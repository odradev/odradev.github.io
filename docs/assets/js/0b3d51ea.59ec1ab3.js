"use strict";(self.webpackChunkodra_website=self.webpackChunkodra_website||[]).push([[58972],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>p});var a=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=a.createContext({}),d=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},u=function(e){var t=d(e.components);return a.createElement(s.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,s=e.parentName,u=r(e,["components","mdxType","originalType","parentName"]),m=d(n),p=o,g=m["".concat(s,".").concat(p)]||m[p]||c[p]||i;return n?a.createElement(g,l(l({ref:t},u),{},{components:n})):a.createElement(g,l({ref:t},u))}));function p(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,l=new Array(i);l[0]=m;var r={};for(var s in t)hasOwnProperty.call(t,s)&&(r[s]=t[s]);r.originalType=e,r.mdxType="string"==typeof e?e:o,l[1]=r;for(var d=2;d<i;d++)l[d]=n[d];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},78205:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>c,frontMatter:()=>i,metadata:()=>r,toc:()=>d});var a=n(87462),o=(n(67294),n(3905));const i={},l="Delegating CSPR to Validators",r={unversionedId:"advanced/delegating-cspr",id:"version-2.4.0/advanced/delegating-cspr",title:"Delegating CSPR to Validators",description:"Casper 2.0 introduced a feature that allows delegating CSPR tokens to validators by contracts.",source:"@site/versioned_docs/version-2.4.0/advanced/08-delegating-cspr.md",sourceDirName:"advanced",slug:"/advanced/delegating-cspr",permalink:"/docs/2.4.0/advanced/delegating-cspr",draft:!1,tags:[],version:"2.4.0",lastUpdatedAt:1765375810,formattedLastUpdatedAt:"Dec 10, 2025",sidebarPosition:8,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Signatures",permalink:"/docs/2.4.0/advanced/signatures"},next:{title:"Backends",permalink:"/docs/2.4.0/category/backends"}},s={},d=[{value:"Sample implementation",id:"sample-implementation",level:2},{value:"Explanation",id:"explanation",level:2},{value:"Testing",id:"testing",level:2},{value:"Implementation details",id:"implementation-details",level:2},{value:"Minimum delegation amount",id:"minimum-delegation-amount",level:3},{value:"Rewards calculation",id:"rewards-calculation",level:3}],u={toc:d};function c(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"delegating-cspr-to-validators"},"Delegating CSPR to Validators"),(0,o.kt)("p",null,"Casper 2.0 introduced a feature that allows delegating CSPR tokens to validators by contracts.\nThis can be useful, especially if you want to implement some kind of liquid staking solution.\nThat's why Odra since v2.0.0 provides a way to delegate CSPR tokens to validators by contracts."),(0,o.kt)("h2",{id:"sample-implementation"},"Sample implementation"),(0,o.kt)("p",null,"The following code shows how to implement a simple contract that allows delegating CSPR tokens to a validator."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust",metastring:"title=examples/src/features/validators.rs",title:"examples/src/features/validators.rs"},"use odra::{\n    casper_types::{PublicKey, U512},\n    prelude::*\n};\n\n#[odra::module]\npub struct ValidatorsContract {\n    /// In this variable we store the validator's public key, this is the only way we can identify the validator\n    validator: Var<PublicKey>\n}\n\n/// Implementation of the TestingContract\n#[odra::module]\nimpl ValidatorsContract {\n    /// Initializes the contract with the validator's public key\n    pub fn init(&mut self, validator: PublicKey) {\n        self.validator.set(validator);\n    }\n\n    /// Stake the amount of tokens\n    #[odra(payable)]\n    pub fn stake(&mut self) {\n        // Get the amount of tokens attached to the call\n        let amount = self.env().attached_value();\n        if amount.is_zero() {\n            self.env().revert(ValError::InsufficientBalance);\n        }\n\n        // Use the ContractEnv's delegate method to delegate the tokens to the validator\n        self.env().delegate(self.validator.get().unwrap(), amount);\n    }\n\n    /// Undelegate the amount from the validator\n    pub fn unstake(&mut self, amount: U512) {\n        self.env().undelegate(self.validator.get().unwrap(), amount);\n    }\n\n    /// Withdraw the amount from the validator\n    pub fn withdraw(&mut self, amount: U512) {\n        self.env().transfer_tokens(&self.env().caller(), &amount);\n    }\n\n    ...\n}\n")),(0,o.kt)("h2",{id:"explanation"},"Explanation"),(0,o.kt)("p",null,"The above example can be a good starting point for implementing a liquid staking solution. The main things to\nremember are the new api methods in ContractEnv:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"pub fn delegate(&self, validator: PublicKey, amount: U512);\npub fn undelegate(&self, validator: PublicKey, amount: U512);\npub fn delegated_amount(&self, validator: PublicKey) -> U512;\n")),(0,o.kt)("p",null,"As you can see, we identify the validator by its public key. Funds delegated to the validator are assigned to the\ncalling contract."),(0,o.kt)("p",null,"Remember, that the delegation and undelegation takes some time, depending on the configuration of the blockchain - it's\nnot instant. For example in the Casper mainnet, the delegation takes 1 era and the undelegation takes 7 eras."),(0,o.kt)("h2",{id:"testing"},"Testing"),(0,o.kt)("p",null,"It is possible to test the delegation and undelegation of tokens in the contract. The following code shows how to do it:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust",metastring:"title=examples/src/features/validators.rs",title:"examples/src/features/validators.rs"},"...\n        let test_env = odra_test::env();\n        let auction_delay = test_env.auction_delay();\n        let unbonding_delay = test_env.unbonding_delay();\n\n        test_env.set_caller(test_env.get_account(0));\n        let mut staking = ValidatorsContract::deploy(\n            &test_env,\n            ValidatorsContractInitArgs {\n                validator: test_env.get_validator(0)\n            }\n        );\n\n        let initial_account_balance = test_env.balance_of(&test_env.get_account(0));\n\n        // Stake some amount\n        let staking_amount = U512::from(1_000_000_000_000u64);\n        staking.with_tokens(staking_amount).stake();\n        assert_eq!(staking.currently_delegated_amount(), staking_amount);\n        assert_eq!(\n            test_env.balance_of(&test_env.get_account(0)),\n            initial_account_balance - staking_amount\n        );\n\n        // Advance time, run auctions and give off rewards\n        test_env.advance_with_auctions(auction_delay * 2);\n\n        // Check that the amount is greater than the staking amount\n        let staking_with_reward = staking.currently_delegated_amount();\n        assert!(staking_with_reward > staking_amount);\n\n...\n")),(0,o.kt)("p",null,"You can see, that we use the new methods from HostEnv, namely:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"    fn advance_with_auctions(&self, time_diff: u64);\n    fn auction_delay(&self) -> u64; \n    fn unbonding_delay(&self) -> u64;\n    fn delegated_amount(&self, delegator: Address, validator: PublicKey) -> U512;\n")),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"advance_with_auctions")," works in a similar way to ",(0,o.kt)("inlineCode",{parentName:"p"},"advance_block_time"),", but it also runs the auctions and gives off\nrewards. The ",(0,o.kt)("inlineCode",{parentName:"p"},"auction_delay")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"unbonding_delay")," methods return the values of the auction and unbonding delays\nspecific to the network or backend."),(0,o.kt)("p",null,"We used ",(0,o.kt)("inlineCode",{parentName:"p"},"currently_delegated_amount")," in the example, it uses ",(0,o.kt)("inlineCode",{parentName:"p"},"delegated_amount")," method from ContractEnv, but it is also\npossible to query this information from the HostEnv using ",(0,o.kt)("inlineCode",{parentName:"p"},"delegated_amount")," method."),(0,o.kt)("h2",{id:"implementation-details"},"Implementation details"),(0,o.kt)("p",null,"To keep the parity of behaviour between Odra VM and Casper VM,\nwe implemented some not-so-obvious behaviours and parameters that\ncan influence your code."),(0,o.kt)("h3",{id:"minimum-delegation-amount"},"Minimum delegation amount"),(0,o.kt)("p",null,"Each validator can define the minimum delegation amount. Delegator\ncannot delegate a smaller amount but can increase the delegation\nin smaller steps."),(0,o.kt)("p",null,"If the delegation amount falls below it, all the delegated\nfunds will be undelegated."),(0,o.kt)("p",null,"By default, the Odra VM and Casper VM are booted up with\n5 validators, each with ",(0,o.kt)("inlineCode",{parentName:"p"},"MINIMUM_DELEGATION_AMOUNT")," set to\n500 CSPR."),(0,o.kt)("h3",{id:"rewards-calculation"},"Rewards calculation"),(0,o.kt)("p",null,"As mentioned above, VMs are started with 5 validators, each\nis delegating ",(0,o.kt)("inlineCode",{parentName:"p"},"DEFAULT_BID_AMOUNT"),", which is set to ",(0,o.kt)("inlineCode",{parentName:"p"},"5_000_000_000_000_000_000u64")," (5 000 000 000 CSPR)."),(0,o.kt)("p",null,"At each auction ",(0,o.kt)("inlineCode",{parentName:"p"},"DEFAULT_REWARD_AMOUNT")," (2500 CSPR) is divided equally between\nall validators and delegators based on their share in the pool."))}c.isMDXComponent=!0}}]);