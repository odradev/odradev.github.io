"use strict";(self.webpackChunkodra_website=self.webpackChunkodra_website||[]).push([[66205],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>m});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},s=Object.keys(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),u=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=u(e.components);return a.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,s=e.originalType,l=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),p=u(n),m=r,h=p["".concat(l,".").concat(m)]||p[m]||d[m]||s;return n?a.createElement(h,i(i({ref:t},c),{},{components:n})):a.createElement(h,i({ref:t},c))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var s=n.length,i=new Array(s);i[0]=p;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o.mdxType="string"==typeof e?e:r,i[1]=o;for(var u=2;u<s;u++)i[u]=n[u];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},85162:(e,t,n)=>{n.d(t,{Z:()=>i});var a=n(67294),r=n(86010);const s="tabItem_Ymn6";function i(e){let{children:t,hidden:n,className:i}=e;return a.createElement("div",{role:"tabpanel",className:(0,r.Z)(s,i),hidden:n},t)}},74866:(e,t,n)=>{n.d(t,{Z:()=>w});var a=n(87462),r=n(67294),s=n(86010),i=n(12466),o=n(16550),l=n(91980),u=n(67392),c=n(50012);function d(e){return function(e){return r.Children.map(e,(e=>{if((0,r.isValidElement)(e)&&"value"in e.props)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))}(e).map((e=>{let{props:{value:t,label:n,attributes:a,default:r}}=e;return{value:t,label:n,attributes:a,default:r}}))}function p(e){const{values:t,children:n}=e;return(0,r.useMemo)((()=>{const e=t??d(n);return function(e){const t=(0,u.l)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,n])}function m(e){let{value:t,tabValues:n}=e;return n.some((e=>e.value===t))}function h(e){let{queryString:t=!1,groupId:n}=e;const a=(0,o.k6)(),s=function(e){let{queryString:t=!1,groupId:n}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:t,groupId:n});return[(0,l._X)(s),(0,r.useCallback)((e=>{if(!s)return;const t=new URLSearchParams(a.location.search);t.set(s,e),a.replace({...a.location,search:t.toString()})}),[s,a])]}function y(e){const{defaultValue:t,queryString:n=!1,groupId:a}=e,s=p(e),[i,o]=(0,r.useState)((()=>function(e){let{defaultValue:t,tabValues:n}=e;if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!m({value:t,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${n.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const a=n.find((e=>e.default))??n[0];if(!a)throw new Error("Unexpected error: 0 tabValues");return a.value}({defaultValue:t,tabValues:s}))),[l,u]=h({queryString:n,groupId:a}),[d,y]=function(e){let{groupId:t}=e;const n=function(e){return e?`docusaurus.tab.${e}`:null}(t),[a,s]=(0,c.Nk)(n);return[a,(0,r.useCallback)((e=>{n&&s.set(e)}),[n,s])]}({groupId:a}),b=(()=>{const e=l??d;return m({value:e,tabValues:s})?e:null})();(0,r.useLayoutEffect)((()=>{b&&o(b)}),[b]);return{selectedValue:i,selectValue:(0,r.useCallback)((e=>{if(!m({value:e,tabValues:s}))throw new Error(`Can't select invalid tab value=${e}`);o(e),u(e),y(e)}),[u,y,s]),tabValues:s}}var b=n(72389);const g="tabList__CuJ",f="tabItem_LNqP";function _(e){let{className:t,block:n,selectedValue:o,selectValue:l,tabValues:u}=e;const c=[],{blockElementScrollPositionUntilNextRender:d}=(0,i.o5)(),p=e=>{const t=e.currentTarget,n=c.indexOf(t),a=u[n].value;a!==o&&(d(t),l(a))},m=e=>{let t=null;switch(e.key){case"Enter":p(e);break;case"ArrowRight":{const n=c.indexOf(e.currentTarget)+1;t=c[n]??c[0];break}case"ArrowLeft":{const n=c.indexOf(e.currentTarget)-1;t=c[n]??c[c.length-1];break}}t?.focus()};return r.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,s.Z)("tabs",{"tabs--block":n},t)},u.map((e=>{let{value:t,label:n,attributes:i}=e;return r.createElement("li",(0,a.Z)({role:"tab",tabIndex:o===t?0:-1,"aria-selected":o===t,key:t,ref:e=>c.push(e),onKeyDown:m,onClick:p},i,{className:(0,s.Z)("tabs__item",f,i?.className,{"tabs__item--active":o===t})}),n??t)})))}function k(e){let{lazy:t,children:n,selectedValue:a}=e;if(n=Array.isArray(n)?n:[n],t){const e=n.find((e=>e.props.value===a));return e?(0,r.cloneElement)(e,{className:"margin-top--md"}):null}return r.createElement("div",{className:"margin-top--md"},n.map(((e,t)=>(0,r.cloneElement)(e,{key:t,hidden:e.props.value!==a}))))}function v(e){const t=y(e);return r.createElement("div",{className:(0,s.Z)("tabs-container",g)},r.createElement(_,(0,a.Z)({},e,t)),r.createElement(k,(0,a.Z)({},e,t)))}function w(e){const t=(0,b.Z)();return r.createElement(v,(0,a.Z)({key:String(t)},e))}},57379:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>l,default:()=>m,frontMatter:()=>o,metadata:()=>u,toc:()=>d});var a=n(87462),r=(n(67294),n(3905)),s=n(74866),i=n(85162);const o={sidebar_position:7},l="Build, Deploy and Read the State of a Contract",u={unversionedId:"tutorials/build-deploy-read",id:"version-2.0.0/tutorials/build-deploy-read",title:"Build, Deploy and Read the State of a Contract",description:"In this guide, we will show the full path from creating a contract, deploying it and reading the state.",source:"@site/versioned_docs/version-2.0.0/tutorials/build-deploy-read.md",sourceDirName:"tutorials",slug:"/tutorials/build-deploy-read",permalink:"/docs/tutorials/build-deploy-read",draft:!1,tags:[],version:"2.0.0",lastUpdatedAt:1748343707,formattedLastUpdatedAt:"May 27, 2025",sidebarPosition:7,frontMatter:{sidebar_position:7},sidebar:"tutorialSidebar",previous:{title:"Ticketing System",permalink:"/docs/tutorials/nft"},next:{title:"Using Proxy Caller",permalink:"/docs/tutorials/using-proxy-caller"}},c={},d=[{value:"Contract",id:"contract",level:3},{value:"Deploying the contract",id:"deploying-the-contract",level:3},{value:"Storage Layout",id:"storage-layout",level:3},{value:"Reading the state",id:"reading-the-state",level:3}],p={toc:d};function m(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"build-deploy-and-read-the-state-of-a-contract"},"Build, Deploy and Read the State of a Contract"),(0,r.kt)("p",null,"In this guide, we will show the full path from creating a contract, deploying it and reading the state."),(0,r.kt)("p",null,"We will use a contract with a complex storage layout and show how to deploy it and then read the state of the contract in Rust and TypeScript."),(0,r.kt)("p",null,"Before you start, make sure you completed the following steps:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Read the ",(0,r.kt)("a",{parentName:"li",href:"../category/getting-started"},"Getting Started")," guide"),(0,r.kt)("li",{parentName:"ul"},"Get familiar with ",(0,r.kt)("a",{parentName:"li",href:"https://docs.casper.network/developers/dapps/setup-nctl/"},"NCTL tutorial")),(0,r.kt)("li",{parentName:"ul"},"Install ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/make-software/casper-nctl-docker"},"NCTL docker")," image"),(0,r.kt)("li",{parentName:"ul"},"Install ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/casper-ecosystem/casper-client-rs"},"casper-client"))),(0,r.kt)("h3",{id:"contract"},"Contract"),(0,r.kt)("p",null,"Let's write a contract with complex storage layout."),(0,r.kt)("p",null,"The contract stores a plain numeric value, a custom nested type and a submodule with another submodule with stores a ",(0,r.kt)("inlineCode",{parentName:"p"},"Mapping"),"."),(0,r.kt)("p",null,"We will expose two methods:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"The constructor ",(0,r.kt)("inlineCode",{parentName:"li"},"init")," which sets the metadata and the version of the contract."),(0,r.kt)("li",{parentName:"ol"},"The method ",(0,r.kt)("inlineCode",{parentName:"li"},"set_data")," which sets the value of the numeric field and the values of the mapping.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:"title=custom_item.rs showLineNumbers",title:"custom_item.rs",showLineNumbers:!0},"use odra::{casper_types::U256, prelude::*};\n\n// A custom type with a vector of another custom type\n#[odra::odra_type]\npub struct Metadata {\n    name: String,\n    description: String,\n    prices: Vec<Price>,\n}\n\n#[odra::odra_type]\npub struct Price {\n    value: U256,\n}\n\n// The main contract with a version, metadata and a submodule\n#[odra::module]\npub struct CustomItem {\n    version: Var<u32>,\n    meta: Var<Metadata>,\n    data: SubModule<Data>\n}\n\n#[odra::module]\nimpl CustomItem {\n    pub fn init(&mut self, name: String, description: String, price_1: U256, price_2: U256) {\n        let meta = Metadata {\n            name,\n            description,\n            prices: vec![\n                Price { value: price_1 },\n                Price { value: price_2 }\n            ]\n        };\n        self.meta.set(meta);\n        self.version.set(self.version.get_or_default() + 1);\n    }\n\n    pub fn set_data(&mut self, value: u32, name: String, name2: String) {\n        self.data.value.set(value);\n        self.data.inner.named_values.set(&name, 10);\n        self.data.inner.named_values.set(&name2, 20);\n    }\n}\n\n// A submodule with a numeric value and another submodule\n#[odra::module]\nstruct Data {\n    value: Var<u32>,\n    inner: SubModule<InnerData>,\n}\n\n// A submodule with a mapping\n#[odra::module]\nstruct InnerData {\n    named_values: Mapping<String, u32>,\n}\n\n")),(0,r.kt)("h3",{id:"deploying-the-contract"},"Deploying the contract"),(0,r.kt)("p",null,"First, we need to setup the chain. We will use the NCTL docker image to run a local network."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"docker run --rm -it --name mynctl -d -p 11101:11101 -p 14101:14101 -p 18101:18101 makesoftware/casper-nctl\n")),(0,r.kt)("p",null,"Next, we need to compile the contract to a Wasm file."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sh"},"cargo odra build -c custom_item \n")),(0,r.kt)("p",null,"Then, we can deploy the contract using the ",(0,r.kt)("inlineCode",{parentName:"p"},"casper-client")," tool."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sh"},"casper-client put-deploy \\\n    --node-address http://localhost:11101 \\\n    --chain-name casper-net-1 \\\n    --secret-key path/to/your/secret_key.pem \\ \n    --session-path [PATH_TO_WASM] \\\n    --payment-amount 100000000000 \\\n    --session-arg \"odra_cfg_package_hash_key_name:string:'test_contract_package_hash'\" \\\n    --session-arg \"odra_cfg_allow_key_override:bool:'true'\" \\\n    --session-arg \"odra_cfg_is_upgradable:bool:'true'\" \\\n    --session-arg \"name:string='My Name'\" \\\n    --session-arg \"description:string='My Description'\" \\ \n    --session-arg \"price_1:u256='101'\" \\\n    --session-arg \"price_2:u256='202'\"\n")),(0,r.kt)("p",null,"Finally, we can call the ",(0,r.kt)("inlineCode",{parentName:"p"},"set_data")," method to set the values of the contract."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sh"},'casper-client put-deploy \\\n    --node-address http://localhost:11101 \\ \n    --chain-name casper-net-1 \\\n    --secret-key ./keys/secret_key.pem \\ \n    --payment-amount 2000000000 \\\n    --session-hash [DEPLOYED_CONTRACT_HASH] \\\n    --session-entry-point "set_data" \\\n    --session-arg "value:u32:\'666\'" \\\n    --session-arg "name:string=\'alice\'" \\ \n    --session-arg "name2:string=\'bob\'"\n')),(0,r.kt)("h3",{id:"storage-layout"},"Storage Layout"),(0,r.kt)("p",null,"To read the state of the contract, we need to understand the storage layout."),(0,r.kt)("p",null,"The first step is to calculate the index of the keys. "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Storage Layout\n\nCustomItem:                 prefix: 0x0..._0000_0000_0000  0\n  version: u32,                     0x0..._0000_0000_0001  1\n  meta: Metadata,                   0x0..._0000_0000_0010  2\n  data: Data:               prefix: 0x0..._0000_0000_0011  3\n    value: u32,                     0x0..._0000_0011_0001  (3 << 4) + 1\n    inner: InnerData:       prefix: 0x0..._0000_0011_0010  (3 << 4) + 2\n      named_values: Mapping         0x0..._0011_0010_0001  ((3 << 4) + 2) << 4 + 1\n")),(0,r.kt)("p",null,"The actual key is obtained as follows:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Convert the index to a big-endian byte array."),(0,r.kt)("li",{parentName:"ol"},"Concatenate the index with the mapping data."),(0,r.kt)("li",{parentName:"ol"},"Hash the concatenated bytes using blake2b."),(0,r.kt)("li",{parentName:"ol"},"Return the hex representation of the hash (the stored key must be utf-8 encoded).")),(0,r.kt)("p",null,"In more detail, the storage layout is described in the ",(0,r.kt)("a",{parentName:"p",href:"/docs/advanced/storage-layout"},"Storage Layout article"),"."),(0,r.kt)("h3",{id:"reading-the-state"},"Reading the state"),(0,r.kt)(s.Z,{mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"rust",label:"Rust",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:"title=main.rs showLineNumbers",title:"main.rs",showLineNumbers:!0},'use casper_client::{rpcs::DictionaryItemIdentifier, types::StoredValue, Verbosity};\nuse casper_types::{\n    bytesrepr::{FromBytes, ToBytes},\n    U256,\n};\n\n// replace with your contract hash\nconst CONTRACT_HASH: &str = "hash-...";\nconst NODE_ADDRESS: &str = "http://localhost:11101/rpc";\nconst RPC_ID: &str = "casper-net-1";\nconst DICTIONARY_NAME: &str = "state";\n\n#[derive(Debug, PartialEq, Eq, Hash)]\npub struct Metadata {\n    name: String,\n    description: String,\n    prices: Vec<Price>,\n}\n\n#[derive(Debug, PartialEq, Eq, Hash)]\npub struct Price {\n    value: U256,\n}\n\nasync fn read_state_key(key: String) -> Vec<u8> {\n    let state_root_hash = casper_client::get_state_root_hash(\n        RPC_ID.to_string().into(),\n        NODE_ADDRESS,\n        Verbosity::Low,\n        None,\n    )\n    .await\n    .unwrap()\n    .result\n    .state_root_hash\n    .unwrap();\n\n    // Read the value from the `state` dictionary.\n    let result = casper_client::get_dictionary_item(\n        RPC_ID.to_string().into(),\n        NODE_ADDRESS,\n        Verbosity::Low,\n        state_root_hash,\n        DictionaryItemIdentifier::ContractNamedKey {\n            key: CONTRACT_HASH.to_string(),\n            dictionary_name: DICTIONARY_NAME.to_string(),\n            dictionary_item_key: key,\n        },\n    )\n    .await\n    .unwrap()\n    .result\n    .stored_value;\n\n    // We expect the value to be a CLValue\n    if let StoredValue::CLValue(cl_value) = result {\n        // Ignore the first 4 bytes, which are the length of the CLType.\n        cl_value.inner_bytes()[4..].to_vec()\n    } else {\n        vec![]\n    }\n}\n\nasync fn metadata() -> Metadata {\n    // The key for the metadata is 2, and it has no mapping data\n    let key = key(2, &[]);\n    let bytes = read_state_key(key).await;\n\n    // Read the name and store the remaining bytes\n    let (name, bytes) = String::from_bytes(&bytes).unwrap();\n    // Read the description and store the remaining bytes\n    let (description, bytes) = String::from_bytes(&bytes).unwrap();\n    // A vector is stored as a u32 size followed by the elements\n    // Read the size of the vector and store the remaining bytes\n    let (size, mut bytes) = u32::from_bytes(&bytes).unwrap();\n\n    let mut prices = vec![];\n    // As we know the size of the vector, we can loop over it\n    for _ in 0..size {\n        // Read the value and store the remaining bytes\n        let (value, rem) = U256::from_bytes(&bytes).unwrap();\n        bytes = rem;\n        prices.push(Price { value });\n    }\n    // Anytime you finish parsing a value, you should check if there are any remaining bytes\n    // if there are, it means you have a bug in your parsing logic.\n    // For simplicity, we will ignore the remaining bytes here.\n    Metadata {\n        name,\n        description,\n        prices\n    }\n}\n\nasync fn value() -> u32 {\n    // The key for the value is (3 << 4) + 1, and it has no mapping data\n    let key = key((3 << 4) + 1, &[]);\n    let bytes = read_state_key(key).await;\n\n    // Read the value and ignore the remaining bytes for simplicity\n    u32::from_bytes(&bytes).unwrap().0\n}\n\nasync fn named_value(name: &str) -> u32 {\n    // The key for the named value is (((3 << 4) + 2) << 4) + 1, and the mapping data is the name as bytes\n    let mapping_data = name.to_bytes().unwrap();\n    let key = key((((3 << 4) + 2) << 4) + 1, &mapping_data);\n    let bytes = read_state_key(key).await;\n\n    // Read the value and ignore the remaining bytes for simplicity\n    u32::from_bytes(&bytes).unwrap().0\n}\n\nfn main() {\n    let runtime = tokio::runtime::Runtime::new().unwrap();\n    dbg!(runtime.block_on(metadata()));\n    dbg!(runtime.block_on(value()));\n    dbg!(runtime.block_on(named_value("alice")));\n    dbg!(runtime.block_on(named_value("bob")));\n}\n\n// The key is a combination of the index and the mapping data\n// The algorithm is as follows:\n// 1. Convert the index to a big-endian byte array\n// 2. Concatenate the index with the mapping data\n// 3. Hash the concatenated bytes using blake2b\n// 4. Return the hex representation of the hash (the stored key must be utf-8 encoded)\nfn key(idx: u32, mapping_data: &[u8]) -> String {\n    let mut key = Vec::new();\n    key.extend_from_slice(idx.to_be_bytes().as_ref());\n    key.extend_from_slice(mapping_data);\n    let hashed_key = blake2b(&key);\n\n    hex::encode(&hashed_key)\n}\n\nfn blake2b(bytes: &[u8]) -> [u8; 32] {\n    let mut result = [0u8; 32];\n    let mut hasher = <blake2::Blake2bVar as blake2::digest::VariableOutput>::new(32)\n        .expect("should create hasher");\n    let _ = std::io::Write::write(&mut hasher, bytes);\n    blake2::digest::VariableOutput::finalize_variable(hasher, &mut result)\n        .expect("should copy hash to the result array");\n    result\n}\n\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sh"},'cargo run\n[src/main.rs:116:5] runtime.block_on(metadata()) = Metadata {\n    name: "My Contract",\n    description: "My Description",\n    prices: [\n        Price {\n            value: 123,\n        },\n        Price {\n            value: 321,\n        },\n    ],\n}\n[src/main.rs:117:5] runtime.block_on(value()) = 666\n[src/main.rs:118:5] runtime.block_on(named_value("alice")) = 20\n[src/main.rs:119:5] runtime.block_on(named_value("bob")) = 10\n'))),(0,r.kt)(i.Z,{value:"ts",label:"TypeScript",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"title=index.ts showLineNumbers",title:"index.ts",showLineNumbers:!0},'\nimport { blake2bHex } from "blakejs";\nimport {\n  CLList,\n  CLListBytesParser,\n  CLStringBytesParser,\n  CLU256BytesParser,\n  CLU32BytesParser,\n  CLU8,\n  CLValueBuilder,\n  CasperClient,\n  CasperServiceByJsonRPC,\n  Contracts,\n  ToBytes,\n} from "casper-js-sdk";\n\nconst LOCAL_NODE_URL = "http://127.0.0.1:11101/rpc";\n// replace with your contract hash\nconst CONTRACT_HASH = "hash-...";\nconst STATE_DICTIONARY_NAME = "state";\nconst U32_SIZE = 4;\n\nclass Price {\n  value: bigint;\n\n  constructor(value: bigint) {\n    this.value = value;\n  }\n}\n\nclass Metadata {\n  name: string;\n  description: string;\n  prices: Price[];\n\n  constructor(name: string, description: string, prices: Price[]) {\n    this.name = name;\n    this.description = description;\n    this.prices = prices;\n  }\n}\n\nexport class Contract {\n  client: CasperClient;\n  service: CasperServiceByJsonRPC;\n  contract: Contracts.Contract;\n\n  private constructor() {\n    this.client = new CasperClient(LOCAL_NODE_URL);\n    this.service = new CasperServiceByJsonRPC(LOCAL_NODE_URL);\n    this.contract = new Contracts.Contract(this.client);\n    this.contract.setContractHash(CONTRACT_HASH);\n  }\n\n  static async load() {\n    return new Contract();\n  }\n\n  async read_state(key: string) {\n    const response = await this.contract.queryContractDictionary(STATE_DICTIONARY_NAME, key);\n    let data: CLList<CLU8 & ToBytes> = CLValueBuilder.list(response.value());\n    let bytes = new CLListBytesParser().toBytes(data).unwrap();\n    // Ignore the first 4 bytes, which are the length of the CLType\n    return bytes.slice(4);\n  }\n\n  async metadata() {\n    // The key for the metadata is 2, and it has no mapping data\n    let bytes: Uint8Array = await this.read_state(key(2));\n\n    // Read the name and store the remaining bytes\n    let name = new CLStringBytesParser().fromBytesWithRemainder(bytes);\n    bytes = name.remainder as Uint8Array;\n\n    // Read the description and store the remaining bytes\n    let description = new CLStringBytesParser().fromBytesWithRemainder(bytes);\n    bytes = description.remainder as Uint8Array;\n\n    let prices: Price[] = [];\n    // A vector is stored as a u32 size followed by the elements\n    // Read the size of the vector and store the remaining bytes\n    let size = new CLU32BytesParser().fromBytesWithRemainder(bytes);\n    bytes = size.remainder as Uint8Array;\n\n    // As we know the size of the vector, we can loop over it\n    for (let i = 0; i < size.result.unwrap().data.toNumber(); i++) {\n      let price = new CLU256BytesParser().fromBytesWithRemainder(bytes);\n      bytes = price.remainder as Uint8Array;\n      prices.push(new Price(price.result.unwrap().data.toBigInt()));\n    }\n\n    // Anytime you finish parsing a value, you should check if there are any remaining bytes\n    // if there are, it means you have a bug in your parsing logic.\n    // For simplicity, we will ignore the remaining bytes here.\n    return new Metadata(\n      name.result.unwrap().data,\n      description.result.unwrap().data,\n      prices\n    );\n  }\n  \n  async value() {\n    // The key for the value is (3 << 4) + 1, and it has no mapping data\n    const bytes = await this.read_state(key((3 << 4) + 1));\n\n    // Read the value and ignore the remaining bytes for simplicity\n    let value = new CLU32BytesParser().fromBytesWithRemainder(bytes);\n    return value.result.unwrap().data.toBigInt();\n  }\n\n  async named_value(name: string) {\n    // The key for the named value is (((3 << 4) + 2) << 4) + 1, and the mapping data is the name as bytes\n    let mapping_data = new CLStringBytesParser()\n      .toBytes(CLValueBuilder.string(name))\n      .unwrap();\n    let bytes: Uint8Array = await this.read_state(\n      key((((3 << 4) + 2) << 4) + 1, mapping_data)\n    );\n\n    // Read the value and ignore the remaining bytes for simplicity\n    let value = new CLU32BytesParser().fromBytesWithRemainder(bytes);\n    return value.result.unwrap().data.toBigInt();\n  }\n}\n\n// The key is a combination of the index and the mapping data\n// The algorithm is as follows:\n// 1. Convert the index to a big-endian byte array\n// 2. Concatenate the index with the mapping data\n// 3. Hash the concatenated bytes using blake2b\n// 4. Return the hex representation of the hash (the stored key must be utf-8 encoded)\nfunction key(idx: number, mapping_data: Uint8Array = new Uint8Array([])) {\n  let key = new Uint8Array(U32_SIZE + mapping_data.length);\n  new DataView(key.buffer).setUint32(0, idx, false); // false for big-endian\n  key.set(mapping_data, U32_SIZE);\n\n  return blake2bHex(key, undefined, 32);\n}\n\nconst contract = Contract.load();\ncontract.then(async (c) => {\n  console.log(await c.value());\n  console.log(await c.metadata());\n  console.log(await c.named_value("alice"));\n  console.log(await c.named_value("bob"));\n});\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sh"},"tsc && node target/index.js \nMetadata {\n  name: 'My Contract',\n  description: 'My Description',\n  prices: [ Price { value: 123n }, Price { value: 321n } ]\n}\n666n\n20n\n10n\n")))))}m.isMDXComponent=!0}}]);