"use strict";(self.webpackChunkodra_website=self.webpackChunkodra_website||[]).push([[66206],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>m});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},s=Object.keys(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=a.createContext({}),i=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=i(e.components);return a.createElement(c.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,s=e.originalType,c=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),u=i(n),m=r,f=u["".concat(c,".").concat(m)]||u[m]||p[m]||s;return n?a.createElement(f,o(o({ref:t},d),{},{components:n})):a.createElement(f,o({ref:t},d))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var s=n.length,o=new Array(s);o[0]=u;var l={};for(var c in t)hasOwnProperty.call(t,c)&&(l[c]=t[c]);l.originalType=e,l.mdxType="string"==typeof e?e:r,o[1]=l;for(var i=2;i<s;i++)o[i]=n[i];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},39252:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>p,frontMatter:()=>s,metadata:()=>l,toc:()=>i});var a=n(87462),r=(n(67294),n(3905));const s={sidebar_position:11,description:"Contracts calling contracts"},o="Cross calls",l={unversionedId:"basics/cross-calls",id:"version-2.3.0/basics/cross-calls",title:"Cross calls",description:"Contracts calling contracts",source:"@site/versioned_docs/version-2.3.0/basics/10-cross-calls.md",sourceDirName:"basics",slug:"/basics/cross-calls",permalink:"/docs/2.3.0/basics/cross-calls",draft:!1,tags:[],version:"2.3.0",lastUpdatedAt:1756362595,formattedLastUpdatedAt:"Aug 28, 2025",sidebarPosition:11,frontMatter:{sidebar_position:11,description:"Contracts calling contracts"},sidebar:"tutorialSidebar",previous:{title:"Casper Contract Schema",permalink:"/docs/2.3.0/basics/casper-contract-schema"},next:{title:"Modules",permalink:"/docs/2.3.0/basics/modules"}},c={},i=[{value:"Contract Ref",id:"contract-ref",level:2},{value:"Loading the contract",id:"loading-the-contract",level:3},{value:"Testing",id:"testing",level:2}],d={toc:i};function p(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"cross-calls"},"Cross calls"),(0,r.kt)("p",null,"To show how to handle calls between contracts, first, let's implement two of them:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="examples/src/features/cross_calls.rs"',title:'"examples/src/features/cross_calls.rs"'},"use odra::prelude::*;\nuse odra::ContractRef;\n\n#[odra::module]\npub struct CrossContract {\n    pub math_engine: External<MathEngineContractRef>\n}\n\n#[odra::module]\nimpl CrossContract {\n    pub fn init(&mut self, math_engine_address: Address) {\n        self.math_engine.set(math_engine_address);\n    }\n\n    pub fn add_using_another(&self) -> u32 {\n        self.math_engine.add(3, 5)\n    }\n}\n\n#[odra::module]\npub struct MathEngine;\n\n#[odra::module]\nimpl MathEngine {\n    pub fn add(&self, n1: u32, n2: u32) -> u32 {\n        n1 + n2\n    }\n}\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"MathEngine")," contract can add two numbers. ",(0,r.kt)("inlineCode",{parentName:"p"},"CrossContract")," takes an ",(0,r.kt)("inlineCode",{parentName:"p"},"Address")," in its ",(0,r.kt)("inlineCode",{parentName:"p"},"init")," function and saves it in\nstorage for later use. If we deploy the ",(0,r.kt)("inlineCode",{parentName:"p"},"MathEngine")," first and take note of its address, we can then deploy\n",(0,r.kt)("inlineCode",{parentName:"p"},"CrossContract")," and use ",(0,r.kt)("inlineCode",{parentName:"p"},"MathEngine")," to perform complicated calculations for us!"),(0,r.kt)("p",null,"To perform a cross-contact call, we use the ",(0,r.kt)("inlineCode",{parentName:"p"},"External")," module component and wrap the ",(0,r.kt)("inlineCode",{parentName:"p"},"{{ModuleName}}ContractRef"),"\nthat was created for us by Odra:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="examples/src/features/cross_calls.rs"',title:'"examples/src/features/cross_calls.rs"'},"pub struct CrossContract {\n    pub math_engine: External<MathEngineContractRef>\n}\n")),(0,r.kt)("p",null,"and then we use the ",(0,r.kt)("inlineCode",{parentName:"p"},"math_engine")," like any other contract/module:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="examples/src/features/cross_calls.rs"',title:'"examples/src/features/cross_calls.rs"'},"self.math_engine.add(3, 5)\n")),(0,r.kt)("p",null,"Alternatively, we could store a raw ",(0,r.kt)("inlineCode",{parentName:"p"},"Address"),", then use the ",(0,r.kt)("inlineCode",{parentName:"p"},"{{ModuleName}}ContractRef")," directly:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="examples/src/features/cross_calls.rs"',title:'"examples/src/features/cross_calls.rs"'},"MathEngineContractRef::new(self.env(), math_engine_address).add(3, 5)\n")),(0,r.kt)("h2",{id:"contract-ref"},"Contract Ref"),(0,r.kt)("p",null,"We mentioned ",(0,r.kt)("inlineCode",{parentName:"p"},"HostRef")," already in our ",(0,r.kt)("a",{parentName:"p",href:"/docs/2.3.0/basics/testing"},"Testing")," article - a host side reference to already deployed contract."),(0,r.kt)("p",null,"In the module context we use a ",(0,r.kt)("inlineCode",{parentName:"p"},"ContractRef")," instead, to call other contracts."),(0,r.kt)("p",null,"Similarly to the ",(0,r.kt)("inlineCode",{parentName:"p"},"HostRef")," trait implemetation for the module, the ",(0,r.kt)("inlineCode",{parentName:"p"},"{{ModuleName}}ContractRef")," is generated automatically,\nby the ",(0,r.kt)("inlineCode",{parentName:"p"},"#[odra::module]")," attribute."),(0,r.kt)("p",null,"The reference implements all the public endpoints to the contract (those marked as ",(0,r.kt)("inlineCode",{parentName:"p"},"pub")," in ",(0,r.kt)("inlineCode",{parentName:"p"},"#[odra::module]"),"\nimpl), and the ",(0,r.kt)("inlineCode",{parentName:"p"},"{{ModuleName}}ContractRef::address()")," function, which returns the address of the contract."),(0,r.kt)("h1",{id:"external-contracts"},"External Contracts"),(0,r.kt)("p",null,"Sometimes in our contract, we would like to interact with a someone else's contract, already deployed onto the blockchain. The only thing we know about the contract is the ABI."),(0,r.kt)("p",null,"For that purpose, we use ",(0,r.kt)("inlineCode",{parentName:"p"},"#[odra:external_contract]")," attribute. This attribute should be applied to a trait. The trait defines the part of the ABI we would like to take advantage of."),(0,r.kt)("p",null,"Let's pretend the ",(0,r.kt)("inlineCode",{parentName:"p"},"MathEngine")," we defined is an external contract. There is a contract with ",(0,r.kt)("inlineCode",{parentName:"p"},"add()")," function that adds two numbers somewhere."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"#[odra::external_contract]\npub trait Adder {\n    fn add(&self, n1: u32, n2: u32) -> u32;\n}\n")),(0,r.kt)("p",null,"Odra automatically creates the ",(0,r.kt)("inlineCode",{parentName:"p"},"AdderContractRef")," struct. Having an address, in the module context we can call:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"struct Contract {\n    adder: External<AdderContractRef>\n}\n// in some function\nself.adder.add(3, 5)\n\n// or\n\nstruct Contract {\n    adder: Var<Address>\n}\n// in some function\nAdderContractRef::new(self.env(), address).add(3, 5)\n")),(0,r.kt)("h3",{id:"loading-the-contract"},"Loading the contract"),(0,r.kt)("p",null,"Sometimes it is useful to load the deployed contract instead of deploying it by ourselves. This is especially useful when we want to test\nour contracts in ",(0,r.kt)("a",{parentName:"p",href:"/docs/2.3.0/backends/livenet"},"Livenet")," backend. We can load the contract using ",(0,r.kt)("inlineCode",{parentName:"p"},"load")," method on the ",(0,r.kt)("inlineCode",{parentName:"p"},"Deployer"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="examples/bin/erc20_on_livenet.rs"',title:'"examples/bin/erc20_on_livenet.rs"'},'fn _load_erc20(env: &HostEnv) -> Erc20HostRef {\n    let address = "hash-d26fcbd2106e37be975d2045c580334a6d7b9d0a241c2358a4db970dfd516945";\n    let address = Address::from_str(address).unwrap();\n    Erc20::load(env, address)\n}\n')),(0,r.kt)("h2",{id:"testing"},"Testing"),(0,r.kt)("p",null,"Let's see how we can test our cross calls using this knowledge:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="examples/src/features/cross_calls.rs"',title:'"examples/src/features/cross_calls.rs"'},"#[cfg(test)]\nmod tests {\n    use super::{CrossContract, CrossContractInitArgs, MathEngineHostRef};\n    use odra::host::{Deployer, NoArgs};\n    use odra::prelude::*;\n\n    #[test]\n    fn test_cross_calls() {\n        let test_env = odra_test::env();\n        let math_engine_contract = MathEngine::deploy(&test_env, NoArgs);\n        let cross_contract = CrossContract::deploy(\n            &test_env,\n            CrossContractInitArgs {\n                math_engine_address: *math_engine_contract.address()\n            }\n        );\n        assert_eq!(cross_contract.add_using_another(), 8);\n    }\n}\n")),(0,r.kt)("p",null,"Each test begins with a clean instance of the blockchain, with no contracts deployed.\nTo test an external contract, we first deploy a ",(0,r.kt)("inlineCode",{parentName:"p"},"MathEngine")," contract, although we won't directly utilize it.\nInstead, we only extract its address.\nLet's continue assuming there is a contract featuring the ",(0,r.kt)("inlineCode",{parentName:"p"},"add()")," function that we intend to utilize."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"#[cfg(test)]\nmod tests {\n    use super::*;\n    use odra::host::{Deployer, NoArgs};\n    use odra::prelude::*;\n    \n    #[test]\n    fn test_ext() {\n        let test_env = odra_test::env();\n        let adder = Adder::new(&test_env, get_adder_address(&test_env)).add(3, 5)\n        assert_eq!(adder.add(1, 2), 3);\n    }\n\n    fn get_adder_address(test_env: &HostEnv) -> Address {\n        let contract = MathEngine::deploy(test_env, NoArgs);\n        contract.address()\n    }\n}\n")))}p.isMDXComponent=!0}}]);