"use strict";(self.webpackChunkodra_website=self.webpackChunkodra_website||[]).push([[41220],{3905:(e,n,t)=>{t.d(n,{Zo:()=>d,kt:()=>m});var a=t(67294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var l=a.createContext({}),u=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},d=function(e){var n=u(e.components);return a.createElement(l.Provider,{value:n},e.children)},c={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},p=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),p=u(t),m=r,f=p["".concat(l,".").concat(m)]||p[m]||c[m]||i;return t?a.createElement(f,o(o({ref:n},d),{},{components:t})):a.createElement(f,o({ref:n},d))}));function m(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,o=new Array(i);o[0]=p;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,o[1]=s;for(var u=2;u<i;u++)o[u]=t[u];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}p.displayName="MDXCreateElement"},85162:(e,n,t)=>{t.d(n,{Z:()=>o});var a=t(67294),r=t(86010);const i="tabItem_Ymn6";function o(e){let{children:n,hidden:t,className:o}=e;return a.createElement("div",{role:"tabpanel",className:(0,r.Z)(i,o),hidden:t},n)}},74866:(e,n,t)=>{t.d(n,{Z:()=>x});var a=t(87462),r=t(67294),i=t(86010),o=t(12466),s=t(16550),l=t(91980),u=t(67392),d=t(50012);function c(e){return function(e){return r.Children.map(e,(e=>{if((0,r.isValidElement)(e)&&"value"in e.props)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))}(e).map((e=>{let{props:{value:n,label:t,attributes:a,default:r}}=e;return{value:n,label:t,attributes:a,default:r}}))}function p(e){const{values:n,children:t}=e;return(0,r.useMemo)((()=>{const e=n??c(t);return function(e){const n=(0,u.l)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,t])}function m(e){let{value:n,tabValues:t}=e;return t.some((e=>e.value===n))}function f(e){let{queryString:n=!1,groupId:t}=e;const a=(0,s.k6)(),i=function(e){let{queryString:n=!1,groupId:t}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return t??null}({queryString:n,groupId:t});return[(0,l._X)(i),(0,r.useCallback)((e=>{if(!i)return;const n=new URLSearchParams(a.location.search);n.set(i,e),a.replace({...a.location,search:n.toString()})}),[i,a])]}function h(e){const{defaultValue:n,queryString:t=!1,groupId:a}=e,i=p(e),[o,s]=(0,r.useState)((()=>function(e){let{defaultValue:n,tabValues:t}=e;if(0===t.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!m({value:n,tabValues:t}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${n}" but none of its children has the corresponding value. Available values are: ${t.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return n}const a=t.find((e=>e.default))??t[0];if(!a)throw new Error("Unexpected error: 0 tabValues");return a.value}({defaultValue:n,tabValues:i}))),[l,u]=f({queryString:t,groupId:a}),[c,h]=function(e){let{groupId:n}=e;const t=function(e){return e?`docusaurus.tab.${e}`:null}(n),[a,i]=(0,d.Nk)(t);return[a,(0,r.useCallback)((e=>{t&&i.set(e)}),[t,i])]}({groupId:a}),b=(()=>{const e=l??c;return m({value:e,tabValues:i})?e:null})();(0,r.useLayoutEffect)((()=>{b&&s(b)}),[b]);return{selectedValue:o,selectValue:(0,r.useCallback)((e=>{if(!m({value:e,tabValues:i}))throw new Error(`Can't select invalid tab value=${e}`);s(e),u(e),h(e)}),[u,h,i]),tabValues:i}}var b=t(72389);const y="tabList__CuJ",g="tabItem_LNqP";function v(e){let{className:n,block:t,selectedValue:s,selectValue:l,tabValues:u}=e;const d=[],{blockElementScrollPositionUntilNextRender:c}=(0,o.o5)(),p=e=>{const n=e.currentTarget,t=d.indexOf(n),a=u[t].value;a!==s&&(c(n),l(a))},m=e=>{let n=null;switch(e.key){case"Enter":p(e);break;case"ArrowRight":{const t=d.indexOf(e.currentTarget)+1;n=d[t]??d[0];break}case"ArrowLeft":{const t=d.indexOf(e.currentTarget)-1;n=d[t]??d[d.length-1];break}}n?.focus()};return r.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.Z)("tabs",{"tabs--block":t},n)},u.map((e=>{let{value:n,label:t,attributes:o}=e;return r.createElement("li",(0,a.Z)({role:"tab",tabIndex:s===n?0:-1,"aria-selected":s===n,key:n,ref:e=>d.push(e),onKeyDown:m,onClick:p},o,{className:(0,i.Z)("tabs__item",g,o?.className,{"tabs__item--active":s===n})}),t??n)})))}function k(e){let{lazy:n,children:t,selectedValue:a}=e;if(t=Array.isArray(t)?t:[t],n){const e=t.find((e=>e.props.value===a));return e?(0,r.cloneElement)(e,{className:"margin-top--md"}):null}return r.createElement("div",{className:"margin-top--md"},t.map(((e,n)=>(0,r.cloneElement)(e,{key:n,hidden:e.props.value!==a}))))}function w(e){const n=h(e);return r.createElement("div",{className:(0,i.Z)("tabs-container",y)},r.createElement(v,(0,a.Z)({},e,n)),r.createElement(k,(0,a.Z)({},e,n)))}function x(e){const n=(0,b.Z)();return r.createElement(w,(0,a.Z)({key:String(n)},e))}},7447:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>m,frontMatter:()=>s,metadata:()=>u,toc:()=>c});var a=t(87462),r=(t(67294),t(3905)),i=t(74866),o=t(85162);const s={sidebar_position:9,slug:"odra-solidity",image:"/img/odra-sol.png",description:"Odra for Solidity developers"},l="Odra for Solidity developers",u={unversionedId:"tutorials/odra-sol",id:"version-1.0.0/tutorials/odra-sol",title:"Odra for Solidity developers",description:"Odra for Solidity developers",source:"@site/versioned_docs/version-1.0.0/tutorials/odra-sol.md",sourceDirName:"tutorials",slug:"/tutorials/odra-solidity",permalink:"/docs/1.0.0/tutorials/odra-solidity",draft:!1,tags:[],version:"1.0.0",lastUpdatedAt:1718109783,formattedLastUpdatedAt:"Jun 11, 2024",sidebarPosition:9,frontMatter:{sidebar_position:9,slug:"odra-solidity",image:"/img/odra-sol.png",description:"Odra for Solidity developers"},sidebar:"tutorialSidebar",previous:{title:"CEP-18",permalink:"/docs/1.0.0/tutorials/cep18"},next:{title:"Deploying a Token on Casper Livenet",permalink:"/docs/1.0.0/tutorials/deploying-on-casper"}},d={},c=[{value:"Introduction",id:"introduction",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Hello World",id:"hello-world",level:2},{value:"Variable Storage and State Management",id:"variable-storage-and-state-management",level:2},{value:"Data Types",id:"data-types",level:3},{value:"Constants and Immutability",id:"constants-and-immutability",level:3},{value:"Variables",id:"variables",level:3},{value:"Arrays and Mappings",id:"arrays-and-mappings",level:3},{value:"Custom types",id:"custom-types",level:3},{value:"Data Location",id:"data-location",level:3},{value:"Functions",id:"functions",level:2},{value:"View and Pure",id:"view-and-pure",level:3},{value:"Modifiers",id:"modifiers",level:3},{value:"Visibility",id:"visibility",level:3},{value:"Payable",id:"payable",level:3},{value:"Selectors",id:"selectors",level:3},{value:"Events and Logging",id:"events-and-logging",level:2},{value:"Error Handling",id:"error-handling",level:2},{value:"Composition vs. Inheritance",id:"composition-vs-inheritance",level:2},{value:"Libraries and Utility",id:"libraries-and-utility",level:2},{value:"Fallback and Receive Functions",id:"fallback-and-receive-functions",level:2},{value:"Miscellaneous",id:"miscellaneous",level:2},{value:"Hashing",id:"hashing",level:3},{value:"Try-catch",id:"try-catch",level:3},{value:"Conclusion",id:"conclusion",level:2}],p={toc:c};function m(e){let{components:n,...t}=e;return(0,r.kt)("wrapper",(0,a.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"odra-for-solidity-developers"},"Odra for Solidity developers"),(0,r.kt)("h2",{id:"introduction"},"Introduction"),(0,r.kt)("p",null,"Hi, stranger Solidity developer! If you are looking to expand your horizons into Rust-based smart contract development, you've come to the right place. Odra is a high-level framework designed to simplify the development of smart contracts for the Casper Network. This tutorial will guide you through the basics of transitioning from Solidity to Odra, highlighting key differences and providing practical examples. Before we delve into the details, we have great news for you. From the very beginning, we have been thinking of you. Our main goal was to design the framework in a way that flattens the learning curve, especially for Solidity developers."),(0,r.kt)("h2",{id:"prerequisites"},"Prerequisites"),(0,r.kt)("p",null,"To follow this guide, you should have:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Knowledge of Solidity."),(0,r.kt)("li",{parentName:"ul"},"Familiarity with Ethereum and smart contract concepts."),(0,r.kt)("li",{parentName:"ul"},"Basic understanding of Rust, as Odra is based on it.")),(0,r.kt)("h2",{id:"hello-world"},"Hello World"),(0,r.kt)("p",null,'Let\'s start with a simple "Hello World" contract in Odra. The following code snippet demonstrates a basic smart contract that stores a greeting message.'),(0,r.kt)(i.Z,{mdxType:"Tabs"},(0,r.kt)(o.Z,{value:"rust",label:"Odra",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:"showLineNumbers",showLineNumbers:!0},"use odra::{prelude::*, Var};\n\n#[odra::module]\npub struct HelloWorld {\n    greet: Var<String>,\n}\n\n#[odra::module]\nimpl HelloWorld {\n    pub fn init(&mut self, message: String) {\n        self.greet.set(message);\n    }\n\n    pub fn get(&self) -> String {\n        self.greet.get_or_default()\n    }\n}\n"))),(0,r.kt)(o.Z,{value:"sol",label:"Solidity",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sol",metastring:"showLineNumbers",showLineNumbers:!0},'// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\ncontract HelloWorld {\n    string public greet = "Hello World!";\n}\n')))),(0,r.kt)("p",null,"As you may have noticed, the Odra code is slightly more verbose than the Solidity code. To define a contract in Odra, you need to create a struct and implement a module for it, both annotated with the ",(0,r.kt)("inlineCode",{parentName:"p"},"odra::module")," attribute. The struct contains the contract's state variables, while the module defines the contract's functions. In this example, the ",(0,r.kt)("inlineCode",{parentName:"p"},"HelloWorld")," struct has a single state variable greet, which stores the greeting message. The module contains two functions: ",(0,r.kt)("inlineCode",{parentName:"p"},"init")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"set")," the greeting message and get to retrieve it.\nTwo key differences are:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Odra does not generate getters for public state variables automatically, so you need to define them explicitly."),(0,r.kt)("li",{parentName:"ol"},"To initialize values, you must do it in the ",(0,r.kt)("inlineCode",{parentName:"li"},"init")," function, which is the contract constructor. You can't assign defaults outside the constructor.")),(0,r.kt)("h2",{id:"variable-storage-and-state-management"},"Variable Storage and State Management"),(0,r.kt)("h3",{id:"data-types"},"Data Types"),(0,r.kt)(i.Z,{mdxType:"Tabs"},(0,r.kt)(o.Z,{value:"rust",label:"Odra",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:"showLineNumbers",showLineNumbers:!0},'use core::str::FromStr;\nuse odra::{\n    casper_types::{bytesrepr::Bytes, U256},\n    module::Module,\n    prelude::*,\n    Address, UnwrapOrRevert, Var,\n};\n\n#[odra::module]\npub struct Primitives {\n    boo: Var<bool>,\n    u: Var<u8>,    // u8 is the smallest unsigned integer type\n    u2: Var<U256>, // U256 is the biggest unsigned integer type\n    i: Var<i32>,   // i32 is the smallest signed integer type\n    i2: Var<i64>,  // i64 is the biggest signed integer type\n    address: Var<Address>,\n    bytes: Var<Bytes>,\n    default_boo: Var<bool>,\n    default_uint: Var<U256>,\n    default_int: Var<i64>,\n    default_addr: Var<Address>,\n}\n\n#[odra::module]\nimpl Primitives {\n    pub fn init(&mut self) {\n        self.boo.set(true);\n        self.u.set(1);\n        self.u2.set(U256::from(456));\n        self.i.set(-1);\n        self.i2.set(456);\n        self.address.set(\n            Address::from_str(\n                "hash-d4b8fa492d55ac7a515c0c6043d72ba43c49cd120e7ba7eec8c0a330dedab3fb",\n            )\n            .unwrap_or_revert(&self.env()),\n        );\n        self.bytes.set(Bytes::from(vec![0xb5]));\n\n        let _min_int = U256::zero();\n        let _max_int = U256::MAX;\n    }\n\n    // For the types that have default values, we can use the get_or_default method\n    pub fn get_default_boo(&self) -> bool {\n        self.default_boo.get_or_default()\n    }\n\n    pub fn get_default_uint(&self) -> U256 {\n        self.default_uint.get_or_default()\n    }\n\n    pub fn get_default_int(&self) -> i64 {\n        self.default_int.get_or_default()\n    }\n\n    // Does not compile - Address does not have the default value\n    pub fn get_default_addr(&self) -> Address {\n        self.default_addr.get_or_default()\n    }\n}\n'))),(0,r.kt)(o.Z,{value:"sol",label:"Solidity",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sol",metastring:'showLineNumbers title="https://solidity-by-example.org/primitives/"',showLineNumbers:!0,title:'"https://solidity-by-example.org/primitives/"'},"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\ncontract Primitives {\n    bool public boo = true;\n\n    uint8 public u8 = 1;\n    uint256 public u256 = 456;\n\n    int8 public i8 = -1;\n    int256 public i256 = 456;\n\n    int256 public minInt = type(int256).min;\n    int256 public maxInt = type(int256).max;\n\n    address public addr = 0xCA35b7d915458EF540aDe6068dFe2F44E8fa733c;\n    bytes1 a = 0xb5; //  [10110101]\n\n    // Default values\n    // Unassigned variables have a default value\n    bool public defaultBoo; // false\n    uint256 public defaultUint; // 0\n    int256 public defaultInt; // 0\n    address public defaultAddr; // 0x0000000000000000000000000000000000000000\n}\n")))),(0,r.kt)("p",null,"The range of integer types in Odra is slightly different from Solidity. Odra provides a wide range of integer types: ",(0,r.kt)("inlineCode",{parentName:"p"},"u8"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"u16"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"u32"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"u64"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"U128"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"U256")," for unsigned integers, and ",(0,r.kt)("inlineCode",{parentName:"p"},"i32")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"i64")," for signed integers."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"Address")," type in Odra is used to represent account and contract addresses. In Odra, there is no default/zero value for the ",(0,r.kt)("inlineCode",{parentName:"p"},"Address")," type; the workaround is to use ",(0,r.kt)("inlineCode",{parentName:"p"},"Option<Address>"),"."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"Bytes")," type is used to store byte arrays."),(0,r.kt)("p",null,"Values are stored in units called ",(0,r.kt)("inlineCode",{parentName:"p"},"Named Keys")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Dictionaries"),". Additionally, local variables are available within the entry points and can be used to perform necessary actions or computations within the scope of each entry point."),(0,r.kt)("h3",{id:"constants-and-immutability"},"Constants and Immutability"),(0,r.kt)(i.Z,{mdxType:"Tabs"},(0,r.kt)(o.Z,{value:"rust",label:"Odra",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:"showLineNumbers",showLineNumbers:!0},"use odra::{casper_types::{account::AccountHash, U256}, Address};\n\n#[odra::module]\npub struct Constants;\n\n#[odra::module]\nimpl Constants {\n    pub const MY_UINT: U256 = U256([123, 0, 0, 0]);\n    pub const MY_ADDRESS: Address = Address::Account(\n        AccountHash([0u8; 32])\n    );\n}\n"))),(0,r.kt)(o.Z,{value:"sol",label:"Solidity",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sol",metastring:'showLineNumbers title="https://solidity-by-example.org/constants/"',showLineNumbers:!0,title:'"https://solidity-by-example.org/constants/"'},"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\ncontract Constants {\n    // coding convention to uppercase constant variables\n    address public constant MY_ADDRESS =\n        0x777788889999AaAAbBbbCcccddDdeeeEfFFfCcCc;\n    uint256 public constant MY_UINT = 123;\n}\n")))),(0,r.kt)("p",null,"In Odra, you can define constants using the ",(0,r.kt)("inlineCode",{parentName:"p"},"const")," keyword. Constants are immutable and can be of any type, including custom types. In addition to constants, Solidity also supports the ",(0,r.kt)("inlineCode",{parentName:"p"},"immutable")," keyword, which is used to set the value of a variable once, in the constructor. Further attempts to alter this value result in a compile error. Odra/Rust does not have an equivalent to Solidity's ",(0,r.kt)("inlineCode",{parentName:"p"},"immutable")," keyword."),(0,r.kt)("h3",{id:"variables"},"Variables"),(0,r.kt)(i.Z,{mdxType:"Tabs"},(0,r.kt)(o.Z,{value:"rust",label:"Odra",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:"showLineNumbers",showLineNumbers:!0},'use odra::{casper_types::U256, prelude::*, Var};\n\n#[odra::module]\npub struct Variables {\n    text: Var<String>,\n    my_uint: Var<U256>,\n}\n\n#[odra::module]\nimpl Variables {\n    pub fn init(&mut self) {\n        self.text.set("Hello".to_string());\n        self.my_uint.set(U256::from(123));\n    }\n\n    pub fn do_something(&self) {\n        // Local variables\n        let i = 456;\n        // Env variables\n        let timestamp = self.env().get_block_time();\n        let sender = self.env().caller();\n    }\n}\n'))),(0,r.kt)(o.Z,{value:"sol",label:"Solidity",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sol",metastring:'showLineNumbers title="https://solidity-by-example.org/variables/"',showLineNumbers:!0,title:'"https://solidity-by-example.org/variables/"'},'// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\ncontract Variables {\n    // State variables are stored on the blockchain.\n    string public text = "Hello";\n    uint256 public num = 123;\n\n    function doSomething() public {\n        // Local variables are not saved to the blockchain.\n        uint256 i = 456;\n\n        // Here are some global variables\n        uint256 timestamp = block.timestamp; // Current block timestamp\n        address sender = msg.sender; // address of the caller\n    }\n}\n')))),(0,r.kt)("p",null,"In Solidity there are three types of variables: state variables, local variables, and global variables. State variables are stored on the blockchain and are accessible by all functions within the contract. Local variables are not stored on the blockchain and are only available within the function in which they are declared. Global variables provide information about the blockchain. Odra uses very similar concepts, but with some differences. In Odra, state variables are a part of a module definition, and local variables are available within the entry points and can be used to perform necessary actions or computations within the scope of each entry point. Global variables are accessed using an instance of ",(0,r.kt)("inlineCode",{parentName:"p"},"ContractEnv")," retrieved using the ",(0,r.kt)("inlineCode",{parentName:"p"},"env()")," function."),(0,r.kt)("h3",{id:"arrays-and-mappings"},"Arrays and Mappings"),(0,r.kt)(i.Z,{mdxType:"Tabs"},(0,r.kt)(o.Z,{value:"rust",label:"Odra",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:"showLineNumbers",showLineNumbers:!0},"use odra::{casper_types::U256, Address, Mapping};\n\n#[odra::module]\npub struct MappingContract {\n    my_map: Mapping<Address, Option<U256>>   \n}\n\n#[odra::module]\nimpl MappingContract {\n    pub fn get(&self, addr: Address) -> U256 {\n        // self.my_map.get(&addr) would return Option<Option<U256>>\n        // so we use get_or_default instead and unwrap the inner Option\n        self.my_map.get_or_default(&addr).unwrap_or_default()\n    }\n\n    pub fn set(&mut self, addr: Address, i: U256) {\n        self.my_map.set(&addr, Some(i));\n    }\n\n    pub fn remove(&mut self, addr: Address) {\n        self.my_map.set(&addr, None);\n    }\n}\n\n#[odra::module]\npub struct NestedMapping {\n    my_map: Mapping<(Address, U256), Option<bool>>   \n}\n\n#[odra::module]\nimpl NestedMapping {\n    pub fn get(&self, addr: Address, i: U256) -> bool {\n        self.my_map.get_or_default(&(addr, i)).unwrap_or_default()\n    }\n\n    pub fn set(&mut self, addr: Address, i: U256, boo: bool) {\n        self.my_map.set(&(addr, i), Some(boo));\n    }\n\n    pub fn remove(&mut self, addr: Address, i: U256) {\n        self.my_map.set(&(addr, i), None);\n    }\n}\n"))),(0,r.kt)(o.Z,{value:"sol",label:"Solidity",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sol",metastring:"showLineNumbers",showLineNumbers:!0},"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\ncontract Mapping {\n    mapping(address => uint256) public myMap;\n\n    function get(address _addr) public view returns (uint256) {\n        return myMap[_addr];\n    }\n\n    function set(address _addr, uint256 _i) public {\n        myMap[_addr] = _i;\n    }\n\n    function remove(address _addr) public {\n        delete myMap[_addr];\n    }\n}\n\ncontract NestedMapping {\n    mapping(address => mapping(uint256 => bool)) public nested;\n\n    function get(address _addr1, uint256 _i) public view returns (bool) {\n        return nested[_addr1][_i];\n    }\n\n    function set(address _addr1, uint256 _i, bool _boo) public {\n        nested[_addr1][_i] = _boo;\n    }\n\n    function remove(address _addr1, uint256 _i) public {\n        delete nested[_addr1][_i];\n    }\n}\n")))),(0,r.kt)(i.Z,{mdxType:"Tabs"},(0,r.kt)(o.Z,{value:"rust",label:"Odra",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:"showLineNumbers",showLineNumbers:!0},"use odra::{prelude::*, Var};\n\n#[odra::module]\npub struct Array {\n    // the size of the array must be known at compile time\n    arr: Var<[u8; 10]>,\n    vec: Var<Vec<u32>>,\n}\n\n#[odra::module]\nimpl Array {\n    pub fn init(&mut self) {\n        self.arr.set([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\n        self.vec.set(vec![1, 2, 3, 4, 5]);\n    }\n\n    pub fn get_arr(&self) -> [u8; 10] {\n        self.arr.get_or_default()\n    }\n\n    pub fn push_vec(&mut self, value: u32) {\n        let mut vec = self.vec.get_or_default();\n        vec.push(value);\n        self.vec.set(vec);\n    }\n\n    pub fn pop_vec(&mut self) {\n        let mut vec = self.vec.get_or_default();\n        vec.pop();\n        self.vec.set(vec);\n    }\n\n    pub fn update_arr(&mut self, index: u8, value: u8) {\n        let mut arr = self.arr.get_or_default();\n        arr[index as usize] = value;\n        self.arr.set(arr);\n    }\n}\n"))),(0,r.kt)(o.Z,{value:"sol",label:"Solidity",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sol",metastring:"showLineNumbers",showLineNumbers:!0},"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\ncontract Array {\n    // Several ways to initialize an array\n    uint256[] public arr;\n    uint256[] public arr2 = [1, 2, 3];\n    // Fixed sized array, all elements initialize to 0\n    uint256[10] public myFixedSizeArr;\n\n    function get(uint256 i) public view returns (uint256) {\n        return arr[i];\n    }\n\n    // Solidity can return the entire array.\n    // But this function should be avoided for\n    // arrays that can grow indefinitely in length.\n    function getArr() public view returns (uint256[] memory) {\n        return arr;\n    }\n\n    function push(uint256 i) public {\n        // Append to array\n        // This will increase the array length by 1.\n        arr.push(i);\n    }\n\n    function pop() public {\n        // Remove last element from array\n        // This will decrease the array length by 1\n        arr.pop();\n    }\n\n    function getLength() public view returns (uint256) {\n        return arr.length;\n    }\n\n    function remove(uint256 index) public {\n        // Delete does not change the array length.\n        // It resets the value at index to it's default value,\n        // in this case 0\n        delete arr[index];\n    }\n\n    function examples() external {\n        // create array in memory, only fixed size can be created\n        uint256[] memory a = new uint256[](5);\n    }\n}\n")))),(0,r.kt)("p",null,"For storing a collection of data as a single unit, Odra uses the Vec type for dynamic arrays and fixed-size arrays, both wrapped with the ",(0,r.kt)("inlineCode",{parentName:"p"},"Var")," container. As in Solidity, you must be aware that reading the entire array in one go can be expensive, so it's better to avoid it for large arrays. In many cases, you can use a ",(0,r.kt)("inlineCode",{parentName:"p"},"Mapping")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"List")," instead of an array or vector to store data."),(0,r.kt)("h3",{id:"custom-types"},"Custom types"),(0,r.kt)(i.Z,{mdxType:"Tabs"},(0,r.kt)(o.Z,{value:"rust",label:"Odra",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:"showLineNumbers",showLineNumbers:!0},"use odra::{prelude::*, Var};\n\n#[odra::odra_type]\n#[derive(Default)]\npub enum Status {\n    #[default]\n    Pending,\n    Shipped,\n    Accepted,\n    Rejected,\n    Canceled,\n}\n\n#[odra::module]\npub struct Enum {\n    status: Var<Status>,\n}\n\n#[odra::module]\nimpl Enum {\n    pub fn get(&self) -> Status {\n        self.status.get_or_default()\n    }\n\n    pub fn set(&mut self, status: Status) {\n        self.status.set(status);\n    }\n\n    pub fn cancel(&mut self) {\n        self.status.set(Status::Canceled);\n    }\n\n    pub fn reset(&mut self) {\n        self.status.set(Default::default());\n    }\n}\n"))),(0,r.kt)(o.Z,{value:"sol",label:"Solidity",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sol",metastring:'showLineNumbers title="https://solidity-by-example.org/enum/"',showLineNumbers:!0,title:'"https://solidity-by-example.org/enum/"'},'// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\ncontract Enum {\n    // Enum representing shipping status\n    enum Status {\n        Pending,\n        Shipped,\n        Accepted,\n        Rejected,\n        Canceled\n    }\n\n    // Default value is the first element listed in\n    // definition of the type, in this case "Pending"\n    Status public status;\n\n    // Returns uint\n    // Pending  - 0\n    // Shipped  - 1\n    // Accepted - 2\n    // Rejected - 3\n    // Canceled - 4\n    function get() public view returns (Status) {\n        return status;\n    }\n\n    function set(Status _status) public {\n        status = _status;\n    }\n\n    function cancel() public {\n        status = Status.Canceled;\n    }\n\n    // delete resets the enum to its first value, 0\n    function reset() public {\n        delete status;\n    }\n}\n')))),(0,r.kt)("p",null,"In Odra, custom types are defined using the ",(0,r.kt)("inlineCode",{parentName:"p"},"#[odra::odra_type]")," attribute. The enum can have a default value specified using the ",(0,r.kt)("inlineCode",{parentName:"p"},"#[default]")," attribute if derived from the Default trait. The enum can be used as a state variable in a contract, and its value can be set and retrieved using the set and get functions. The value cannot be deleted; however, it can be set using the ",(0,r.kt)("inlineCode",{parentName:"p"},"Default::default()")," function."),(0,r.kt)(i.Z,{mdxType:"Tabs"},(0,r.kt)(o.Z,{value:"rust",label:"Odra",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:"showLineNumbers",showLineNumbers:!0},"use odra::{prelude::*, List};\n\n#[odra::odra_type]\npub struct Todo {\n    text: String,\n    completed: bool,\n}\n\n#[odra::module]\npub struct Enum {\n    // You could also use Var<Vec<Todo>> instead of List<Todo>,\n    // but List is more efficient for large arrays,\n    // it loads items lazily.\n    todos: List<Todo>,\n}\n\n#[odra::module]\nimpl Enum {\n    pub fn create(&mut self, text: String) {\n        self.todos.push(Todo {\n            text,\n            completed: false,\n        });\n    }\n\n    pub fn update_text(&mut self, index: u32, text: String) {\n        if let Some(mut todo) = self.todos.get(index) {\n            todo.text = text;\n            self.todos.replace(index, todo);\n        }\n    }\n\n    pub fn toggle_complete(&mut self, index: u32) {\n        if let Some(mut todo) = self.todos.get(index) {\n            todo.completed = !todo.completed;\n            self.todos.replace(index, todo);\n        }\n    }\n\n    // Odra does not create getters by default\n    pub fn get(&self, index: u32) -> Option<Todo> {\n        self.todos.get(index)\n    }\n}\n"))),(0,r.kt)(o.Z,{value:"sol",label:"Solidity",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sol",metastring:'showLineNumbers title="https://solidity-by-example.org/structs/"',showLineNumbers:!0,title:'"https://solidity-by-example.org/structs/"'},"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\ncontract Todos {\n    struct Todo {\n        string text;\n        bool completed;\n    }\n\n    Todo[] public todos;\n\n    function create(string calldata _text) public {\n        todos.push(Todo(_text, false));\n    }\n\n    // Solidity automatically created a getter for 'todos' so\n    // you don't actually need this function.\n    function get(uint256 _index)\n        public\n        view\n        returns (string memory text, bool completed)\n    {\n        Todo storage todo = todos[_index];\n        return (todo.text, todo.completed);\n    }\n\n    function updateText(uint256 _index, string calldata _text) public {\n        Todo storage todo = todos[_index];\n        todo.text = _text;\n    }\n\n    function toggleCompleted(uint256 _index) public {\n        Todo storage todo = todos[_index];\n        todo.completed = !todo.completed;\n    }\n}\n\n")))),(0,r.kt)("p",null,"Similarly to enums, custom structs are defined using the ",(0,r.kt)("inlineCode",{parentName:"p"},"#[odra::odra_type]")," attribute. The struct can be used to define a list of items in a contract. The list can be created using the ",(0,r.kt)("inlineCode",{parentName:"p"},"List")," type, which is more efficient for large arrays as it loads items lazily."),(0,r.kt)("h3",{id:"data-location"},"Data Location"),(0,r.kt)("p",null,"In Solidity, data location is an important concept that determines where the data is stored and how it can be accessed. The data location can be ",(0,r.kt)("inlineCode",{parentName:"p"},"memory"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"storage"),", or ",(0,r.kt)("inlineCode",{parentName:"p"},"calldata"),". In Odra, data location is not explicitly defined, but whenever interacting with storage primitives (e.g., ",(0,r.kt)("inlineCode",{parentName:"p"},"Var"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Mapping"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"List"),"), the data is stored in the contract's storage."),(0,r.kt)("h2",{id:"functions"},"Functions"),(0,r.kt)("p",null,"Odra contracts define their entry point and internal functions within the impl block. Here's an example of a transfer function:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"impl Erc20 {\n    pub fn transfer(&mut self, recipient: &Address, amount: &U256) {\n        self.internal_transfer(&self.env().caller(), recipient, amount);\n        // Transfer logic goes here\n    }\n\n    fn internal_transfer(&mut self, sender: &Address, recipient: &Address, amount: &U256) {\n        // Internal transfer logic goes here\n    }\n}\n")),(0,r.kt)("p",null,"Functions can modify contract state and emit events using the ",(0,r.kt)("a",{parentName:"p",href:"/docs/1.0.0/basics/communicating-with-host"},(0,r.kt)("inlineCode",{parentName:"a"},"ContractEnv"))," function."),(0,r.kt)("h3",{id:"view-and-pure"},"View and Pure"),(0,r.kt)(i.Z,{mdxType:"Tabs"},(0,r.kt)(o.Z,{value:"rust",label:"Odra",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:"showLineNumbers",showLineNumbers:!0},"use odra::Var;\n\n#[odra::module]\npub struct ViewAndPure {\n    x: Var<u32>   \n}\n\n#[odra::module]\nimpl ViewAndPure {\n    pub fn add_to_x(&self, y: u32) -> u32 {\n        self.x.get_or_default() + y\n    }\n}\n\npub fn add(i: u32, j: u32) -> u32 {\n    i + j\n}\n"))),(0,r.kt)(o.Z,{value:"sol",label:"Solidity",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sol",metastring:"showLineNumbers",showLineNumbers:!0},"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\ncontract ViewAndPure {\n    uint256 public x = 1;\n\n    // Promise not to modify the state.\n    function addToX(uint256 y) public view returns (uint256) {\n        return x + y;\n    }\n\n    // Promise not to modify or read from the state.\n    function add(uint256 i, uint256 j) public pure returns (uint256) {\n        return i + j;\n    }\n}\n")))),(0,r.kt)("p",null,"In Odra, you don't need to specify ",(0,r.kt)("inlineCode",{parentName:"p"},"view")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"pure")," functions explicitly. All functions are considered ",(0,r.kt)("inlineCode",{parentName:"p"},"view")," functions by default, meaning they can read contract state but not modify it. To modify the state, the first parameter (called the receiver parameter) should be ",(0,r.kt)("inlineCode",{parentName:"p"},"&mut self"),". If you want to create a pure function that doesn't read or modify state, you can define it as a regular Rust function without any side effects."),(0,r.kt)("h3",{id:"modifiers"},"Modifiers"),(0,r.kt)(i.Z,{mdxType:"Tabs"},(0,r.kt)(o.Z,{value:"rust",label:"Odra",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:"showLineNumbers",showLineNumbers:!0},'use odra::Var;\n\n#[odra::module]\npub struct FunctionModifier {\n    x: Var<u32>,\n    locked: Var<bool>,  \n}\n\n#[odra::module]\nimpl FunctionModifier {\n    pub fn decrement(&mut self, i: u32) -> u32 {\n        self.lock();\n        self.x.set(self.x.get_or_default() - i);\n\n        if i > 1 {\n            self.decrement(i - 1);\n        }\n        self.unlock();\n    }\n\n    #[inline]\n    fn lock(&mut self) {\n        if self.locked.get_or_default() {\n            self.env().revert("No reentrancy");\n        }\n\n        self.locked.set(true);\n    }\n\n    #[inline]\n    fn unlock(&mut self) {\n        self.locked.set(false);\n    }\n}\n\n'))),(0,r.kt)(o.Z,{value:"sol",label:"Solidity",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sol",metastring:"showLineNumbers",showLineNumbers:!0},'// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\ncontract FunctionModifier {\n    uint256 public x = 10;\n    bool public locked;\n\n    modifier noReentrancy() {\n        require(!locked, "No reentrancy");\n\n        locked = true;\n        _;\n        locked = false;\n    }\n\n    function decrement(uint256 i) public noReentrancy {\n        x -= i;\n\n        if (i > 1) {\n            decrement(i - 1);\n        }\n    }\n}\n')))),(0,r.kt)("p",null,"In Odra, there is no direct equivalent to Solidity's function modifiers. Instead, you can define functions that perform certain actions before or after the main function logic. In the example above, the ",(0,r.kt)("inlineCode",{parentName:"p"},"lock")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"unlock")," functions are called before and after the decrement function, respectively, but they must be called explicitly."),(0,r.kt)("p",null,"As often as practicable, developers should inline functions by including the body of the function within their code using the ",(0,r.kt)("inlineCode",{parentName:"p"},"#[inline]")," attribute. In the context of coding for Casper blockchain purposes, this reduces the overhead of executed Wasm and prevents unexpected errors due to exceeding resource tolerances."),(0,r.kt)("h3",{id:"visibility"},"Visibility"),(0,r.kt)("p",null,"Functions and state variables have to declare whether they are accessible by other contracts."),(0,r.kt)("p",null,"Functions can be declared as:"),(0,r.kt)(i.Z,{mdxType:"Tabs"},(0,r.kt)(o.Z,{value:"rust",label:"Odra",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"`pub` inside `#[odra::module]` impl block - any contract/submodule and account can call.\n`pub` inside a regular impl block - any submodule can call.\n`default/no modifier/private` - only inside the contract that defines the function.\n"))),(0,r.kt)(o.Z,{value:"sol",label:"Solidity",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"`public` - any contract and account can call.\n`private` - only inside the contract that defines the function.\n`internal` - only inside contract that inherits an internal function.\n`external` - only other contracts and accounts can call\n\nState variables can be declared as public, private, or internal but not external.\n")))),(0,r.kt)("h3",{id:"payable"},"Payable"),(0,r.kt)(i.Z,{mdxType:"Tabs"},(0,r.kt)(o.Z,{value:"rust",label:"Odra",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:"showLineNumbers",showLineNumbers:!0},"use odra::{casper_types::U512, prelude::*, Address, ExecutionError, Var};\n\n#[odra::module]\npub struct Payable {\n    owner: Var<Address>,\n}\n\n#[odra::module]\nimpl Payable {\n    pub fn init(&mut self) {\n        self.owner.set(self.env().caller());\n    }\n\n    #[odra(payable)]\n    pub fn deposit(&self) {\n    }\n\n    pub fn not_payable(&self) {\n    }\n\n    pub fn withdraw(&self) {\n        let amount = self.env().self_balance();\n        self.env().transfer_tokens(&self.owner.get_or_revert_with(ExecutionError::UnwrapError), &amount);\n    }\n\n    pub fn transfer(&self, to: Address, amount: U512) {\n        self.env().transfer_tokens(&to, &amount);\n    }\n}\n"))),(0,r.kt)(o.Z,{value:"sol",label:"Solidity",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sol",metastring:"showLineNumbers",showLineNumbers:!0},'// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\ncontract Payable {\n    // Payable address can send Ether via transfer or send\n    address payable public owner;\n\n    // Payable constructor can receive Ether\n    constructor() payable {\n        owner = payable(msg.sender);\n    }\n\n    // Function to deposit Ether into this contract.\n    // Call this function along with some Ether.\n    // The balance of this contract will be automatically updated.\n    function deposit() public payable {}\n\n    // Call this function along with some Ether.\n    // The function will throw an error since this function is not payable.\n    function notPayable() public {}\n\n    // Function to withdraw all Ether from this contract.\n    function withdraw() public {\n        // get the amount of Ether stored in this contract\n        uint256 amount = address(this).balance;\n\n        // send all Ether to owner\n        (bool success,) = owner.call{value: amount}("");\n        require(success, "Failed to send Ether");\n    }\n\n    // Function to transfer Ether from this contract to address from input\n    function transfer(address payable _to, uint256 _amount) public {\n        // Note that "to" is declared as payable\n        (bool success,) = _to.call{value: _amount}("");\n        require(success, "Failed to send Ether");\n    }\n}\n')))),(0,r.kt)("p",null,"In Odra, you can define a function with the ",(0,r.kt)("inlineCode",{parentName:"p"},"#[odra(payable)]")," attribute to indicate that the function can receive CSPRs. In Solidity, the payable keyword is used to define functions that can receive Ether."),(0,r.kt)("h3",{id:"selectors"},"Selectors"),(0,r.kt)("p",null,"In Solidity, when a function is called, the first 4 bytes of calldata specify which function to call. This is called a function selector."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sol",metastring:"showLineNumbers",showLineNumbers:!0},'contract_addr.call(\n    abi.encodeWithSignature("transfer(address,uint256)", address, 1234)\n)\n')),(0,r.kt)("p",null,"Odra does not support such a mechanism. You must have access to the contract interface to call a function."),(0,r.kt)("h2",{id:"events-and-logging"},"Events and Logging"),(0,r.kt)(i.Z,{mdxType:"Tabs"},(0,r.kt)(o.Z,{value:"rust",label:"Odra",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:"showLineNumbers",showLineNumbers:!0},'use odra::{prelude::*, Address};\n\n#[odra::event]\npub struct Log {\n    sender: Address,\n    message: String,\n}\n\n#[odra::event]\npub struct AnotherLog {}\n\n#[odra::module]\nstruct Event;\n\n#[odra::module]\nimpl Event {\n    pub fn test(&self) {\n        let env = self.env();\n        env.emit_event(Log {\n            sender: env.caller(),\n            message: "Hello World!".to_string(),\n        });\n        env.emit_event(Log {\n            sender: env.caller(),\n            message: "Hello Casper!".to_string(),\n        });\n        env.emit_event(AnotherLog {});\n    }\n}\n'))),(0,r.kt)(o.Z,{value:"sol",label:"Solidity",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sol",metastring:'showLineNumbers title="https://solidity-by-example.org/events/"',showLineNumbers:!0,title:'"https://solidity-by-example.org/events/"'},'// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\ncontract Event {\n    // Event declaration\n    // Up to 3 parameters can be indexed.\n    // Indexed parameters helps you filter the logs by the indexed parameter\n    event Log(address indexed sender, string message);\n    event AnotherLog();\n\n    function test() public {\n        emit Log(msg.sender, "Hello World!");\n        emit Log(msg.sender, "Hello EVM!");\n        emit AnotherLog();\n    }\n}\n')))),(0,r.kt)("p",null,"In Odra, events are regular structs defined using the ",(0,r.kt)("inlineCode",{parentName:"p"},"#[odra::event]")," attribute. The event struct can contain multiple fields, which can be of any type (primitive or custom Odra type). To emit an event, use the env's ",(0,r.kt)("inlineCode",{parentName:"p"},"emit_event()")," function, passing the event struct as an argument."),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"Events in Solidity are used to emit logs that off-chain services can capture. However, Casper does not support events natively. Odra mimics this feature. Read more about it in the ",(0,r.kt)("a",{parentName:"p",href:"/docs/1.0.0/basics/events"},"Basics")," section.")),(0,r.kt)("h2",{id:"error-handling"},"Error Handling"),(0,r.kt)(i.Z,{mdxType:"Tabs"},(0,r.kt)(o.Z,{value:"rust",label:"Odra",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:"showLineNumbers",showLineNumbers:!0},"use odra::{prelude::*, casper_types::{U256, U512}};\n\n#[odra::odra_error]\npub enum CustomError {\n    InsufficientBalance = 1,\n    InputLowerThanTen = 2,\n}\n\n#[odra::module]\npub struct Error;\n\n#[odra::module]\nimpl Error {\n    pub fn test_require(&mut self, i: U256) {\n        if i <= 10.into() {\n            self.env().revert(CustomError::InputLowerThanTen);\n        }\n    }\n\n    pub fn execute_external_call(&self, withdraw_amount: U512) {\n        let balance = self.env().self_balance();\n        if balance < withdraw_amount {\n            self.env().revert(CustomError::InsufficientBalance);\n        }\n    }\n}\n"))),(0,r.kt)(o.Z,{value:"sol",label:"Solidity",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sol",metastring:'showLineNumbers title="https://solidity-by-example.org/error/"',showLineNumbers:!0,title:'"https://solidity-by-example.org/error/"'},'// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\ncontract Error {\n    function testRequire(uint256 _i) public pure {\n        // Require should be used to validate conditions such as:\n        // - inputs\n        // - conditions before execution\n        // - return values from calls to other functions\n        require(_i > 10, "Input must be greater than 10");\n    }\n\n    function testRevert(uint256 _i) public pure {\n        // Revert is useful when the condition to check is complex.\n        // This code does the exact same thing as the example above\n        if (_i <= 10) {\n            revert("Input must be greater than 10");\n        }\n    }\n\n    uint256 public num;\n\n    function testAssert() public view {\n        // Assert should only be used to test for internal errors,\n        // and to check invariants.\n\n        // Here we assert that num is always equal to 0\n        // since it is impossible to update the value of num\n        assert(num == 0);\n    }\n\n    // custom error\n    error InsufficientBalance(uint256 balance, uint256 withdrawAmount);\n\n    function testCustomError(uint256 _withdrawAmount) public view {\n        uint256 bal = address(this).balance;\n        if (bal < _withdrawAmount) {\n            revert InsufficientBalance({\n                balance: bal,\n                withdrawAmount: _withdrawAmount\n            });\n        }\n    }\n}\n')))),(0,r.kt)("p",null,"In Solidity, there are four ways to handle errors: ",(0,r.kt)("inlineCode",{parentName:"p"},"require"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"revert"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"assert"),", and custom errors. In Odra, there is only one way to revert the execution of a function - by using the ",(0,r.kt)("inlineCode",{parentName:"p"},"env().revert()")," function. The function takes an error type as an argument and stops the execution of the function. You define an error type using the ",(0,r.kt)("inlineCode",{parentName:"p"},"#[odra::odra_error]")," attribute. On Casper, an error is only a number, so you can't pass a message with the error."),(0,r.kt)("h2",{id:"composition-vs-inheritance"},"Composition vs. Inheritance"),(0,r.kt)("p",null,"In Solidity, developers often use inheritance to reuse code and establish relationships between contracts. However, Odra and Rust follow a different paradigm known as composition. Instead of inheriting behavior from parent contracts, Odra encourages the composition of contracts by embedding one contract within another."),(0,r.kt)("p",null,"Let's take a look at the difference between inheritance in Solidity and composition in Odra."),(0,r.kt)(i.Z,{mdxType:"Tabs"},(0,r.kt)(o.Z,{value:"rust",label:"Odra",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:"showLineNumbers",showLineNumbers:!0},'use odra::{prelude::*, SubModule};\n\n#[odra::module]\npub struct A;\n\n#[odra::module]\nimpl A {\n    pub fn foo(&self) -> String {\n        "A".to_string()\n    }\n}\n\n#[odra::module]\npub struct B {\n    a: SubModule<A>\n}\n\n#[odra::module]\nimpl B {\n    pub fn foo(&self) -> String {\n        "B".to_string()\n    }\n}\n\n#[odra::module]\npub struct C {\n    a: SubModule<A>\n}\n\n#[odra::module]\nimpl C {\n    pub fn foo(&self) -> String {\n        "C".to_string()\n    }\n}\n\n#[odra::module]\npub struct D {\n    b: SubModule<B>,\n    c: SubModule<C>\n}\n\n#[odra::module]\nimpl D {\n    pub fn foo(&self) -> String {\n       self.c.foo()\n    }\n}\n\n#[odra::module]\npub struct E {\n    b: SubModule<B>,\n    c: SubModule<C>\n}\n\n#[odra::module]\nimpl E {\n    pub fn foo(&self) -> String {\n       self.b.foo()\n    }\n}\n\n#[odra::module]\npub struct F {\n    a: SubModule<A>,\n    b: SubModule<B>,\n}\n\n#[odra::module]\nimpl F {\n    pub fn foo(&self) -> String {\n       self.a.foo()\n    }\n}\n'))),(0,r.kt)(o.Z,{value:"sol",label:"Solidity",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sol",metastring:'showLineNumbers title="https://solidity-by-example.org/inheritance/"',showLineNumbers:!0,title:'"https://solidity-by-example.org/inheritance/"'},'// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\n/* Graph of inheritance\n    A\n   / \\\n  B   C\n / \\ /\nF  D,E\n*/\n\ncontract A {\n    function foo() public pure virtual returns (string memory) {\n        return "A";\n    }\n}\n\n// Contracts inherit other contracts by using the keyword \'is\'.\ncontract B is A {\n    // Override A.foo()\n    function foo() public pure virtual override returns (string memory) {\n        return "B";\n    }\n}\n\ncontract C is A {\n    // Override A.foo()\n    function foo() public pure virtual override returns (string memory) {\n        return "C";\n    }\n}\n\n// Contracts can inherit from multiple parent contracts.\n// When a function is called that is defined multiple times in\n// different contracts, parent contracts are searched from\n// right to left, and in depth-first manner.\ncontract D is B, C {\n    // D.foo() returns "C"\n    // since C is the right most parent contract with function foo()\n    function foo() public pure override(B, C) returns (string memory) {\n        return super.foo();\n    }\n}\n\ncontract E is C, B {\n    // E.foo() returns "B"\n    // since B is the right most parent contract with function foo()\n    function foo() public pure override(C, B) returns (string memory) {\n        return super.foo();\n    }\n}\n\n// Inheritance must be ordered from \u201cmost base-like\u201d to \u201cmost derived\u201d.\n// Swapping the order of A and B will throw a compilation error.\ncontract F is A, B {\n    function foo() public pure override(A, B) returns (string memory) {\n        return super.foo();\n    }\n}\n')))),(0,r.kt)("p",null,'Solidity supports both single and multiple inheritance. This means a contract can inherit from one or more contracts. Solidity uses a technique called "C3 linearization" to resolve the order in which base contracts are inherited in the case of multiple inheritance. This helps to ensure a consistent method resolution order. However, multiple inheritance can lead to complex code and potential issues, especially for inexperienced developers.'),(0,r.kt)("p",null,"In contrast, Rust does not have a direct equivalent to the inheritance model, but it achieves similar goals through composition. Each contract is defined as a struct, and contracts can be composed by embedding one struct within another. This approach provides a more flexible and modular way to reuse code and establish relationships between contracts."),(0,r.kt)("h2",{id:"libraries-and-utility"},"Libraries and Utility"),(0,r.kt)(i.Z,{mdxType:"Tabs"},(0,r.kt)(o.Z,{value:"rust",label:"Odra",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:"showLineNumbers",showLineNumbers:!0},"use odra::{casper_types::U256, prelude::*, UnwrapOrRevert, Var};\n\nmod math {\n    use odra::casper_types::U256;\n\n    pub fn sqrt(y: U256) -> U256 {\n        let mut z = y;\n        if y > 3.into() {\n            let mut x = y / 2 + 1;\n            while x < z {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if y != U256::zero() {\n            z = U256::one();\n        }\n        z\n    }\n}\n\n#[odra::module]\nstruct TestMath;\n\n#[odra::module]\nimpl TestMath {\n    pub fn test_square_root(&self, x: U256) -> U256 {\n        math::sqrt(x)\n    }\n}\n\n#[odra::odra_error]\nenum Error {\n    EmptyArray = 100,\n}\n\ntrait Removable {\n    fn remove(&mut self, index: usize);\n}\n\nimpl Removable for Var<Vec<U256>> {\n    fn remove(&mut self, index: usize) {\n        let env = self.env();\n        let mut vec = self.get_or_default();\n        if vec.is_empty() {\n            env.revert(Error::EmptyArray);\n        }\n        vec[index] = vec.pop().unwrap_or_revert(&env);\n        self.set(vec);\n    }\n}\n\n#[odra::module]\nstruct TestArray {\n    arr: Var<Vec<U256>>,\n}\n\n#[odra::module]\nimpl TestArray {\n    pub fn test_array_remove(&mut self) {\n        let mut arr = self.arr.get_or_default();\n        for i in 0..3 {\n            arr.push(i.into());\n        }\n        self.arr.set(arr);\n\n        self.arr.remove(1);\n\n        let arr = self.arr.get_or_default();\n        assert_eq!(arr.len(), 2);\n        assert_eq!(arr[0], 0.into());\n        assert_eq!(arr[1], 2.into());\n    }\n}\n"))),(0,r.kt)(o.Z,{value:"sol",label:"Solidity",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sol",metastring:'showLineNumbers title="https://solidity-by-example.org/library/"',showLineNumbers:!0,title:'"https://solidity-by-example.org/library/"'},'// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nlibrary Math {\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\n        if (y > 3) {\n            z = y;\n            uint256 x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n        // else z = 0 (default value)\n    }\n}\n\ncontract TestMath {\n    function testSquareRoot(uint256 x) public pure returns (uint256) {\n        return Math.sqrt(x);\n    }\n}\n\nlibrary Array {\n    function remove(uint256[] storage arr, uint256 index) public {\n        require(arr.length > 0, "Can\'t remove from empty array");\n        arr[index] = arr[arr.length - 1];\n        arr.pop();\n    }\n}\n\ncontract TestArray {\n    using Array for uint256[];\n\n    uint256[] public arr;\n\n    function testArrayRemove() public {\n        for (uint256 i = 0; i < 3; i++) {\n            arr.push(i);\n        }\n\n        arr.remove(1);\n\n        assert(arr.length == 2);\n        assert(arr[0] == 0);\n        assert(arr[1] == 2);\n    }\n}\n')))),(0,r.kt)("p",null,"In Solidity, libraries are similar to contracts but can't declare any state variables and can't receive Ether. In the sample code above, the ",(0,r.kt)("inlineCode",{parentName:"p"},"Math")," library contains a square root function, while the Array library provides a function to remove an element from an array. Both libraries are consumed in different ways: the ",(0,r.kt)("inlineCode",{parentName:"p"},"TestMath")," contract calls the ",(0,r.kt)("inlineCode",{parentName:"p"},"sqrt")," function directly, while the ",(0,r.kt)("inlineCode",{parentName:"p"},"TestArray")," contract uses the using keyword, which extends the type ",(0,r.kt)("inlineCode",{parentName:"p"},"uint256[]")," by adding the ",(0,r.kt)("inlineCode",{parentName:"p"},"remove")," function."),(0,r.kt)("p",null,"In Odra, you use language-level features: modules and traits. The mod keyword defines a module, which is similar to a library in Solidity. Modules can contain functions, types, and other items that can be reused across multiple contracts. Traits are similar to interfaces in other programming languages, defining a set of functions that a type must implement. Implementing the ",(0,r.kt)("inlineCode",{parentName:"p"},"Removable")," trait for the ",(0,r.kt)("inlineCode",{parentName:"p"},"Var<Vec<U256>>")," type allows the ",(0,r.kt)("inlineCode",{parentName:"p"},"remove")," function to be called on a variable that stores a vector of ",(0,r.kt)("inlineCode",{parentName:"p"},"U256")," values."),(0,r.kt)("h2",{id:"fallback-and-receive-functions"},"Fallback and Receive Functions"),(0,r.kt)("p",null,"In Solidity, a contract receiving Ether must implement a ",(0,r.kt)("inlineCode",{parentName:"p"},"receive()")," and/or ",(0,r.kt)("inlineCode",{parentName:"p"},"fallback()")," function. The ",(0,r.kt)("inlineCode",{parentName:"p"},"receive()")," function is called when Ether is sent to the contract with no data, while the ",(0,r.kt)("inlineCode",{parentName:"p"},"fallback()")," function is called when the contract receives Ether with data or when a function that does not exist is called."),(0,r.kt)("p",null,"Odra does not have a direct equivalent to the ",(0,r.kt)("inlineCode",{parentName:"p"},"receive()")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"fallback()")," functions. Instead, you can define a function with the ",(0,r.kt)("inlineCode",{parentName:"p"},"#[odra(payable)]")," attribute to indicate that the function can receive CSPRs."),(0,r.kt)("h2",{id:"miscellaneous"},"Miscellaneous"),(0,r.kt)("h3",{id:"hashing"},"Hashing"),(0,r.kt)(i.Z,{mdxType:"Tabs"},(0,r.kt)(o.Z,{value:"rust",label:"Odra",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:"showLineNumbers",showLineNumbers:!0},"use odra::{\n    casper_types::{bytesrepr::ToBytes, U256},\n    prelude::*,\n    Address, UnwrapOrRevert, Var,\n};\n\n#[odra::module]\npub struct HashFunction;\n\n#[odra::module]\nimpl HashFunction {\n    pub fn hash(&self, text: String, num: U256, addr: Address) -> [u8; 32] {\n        let env = self.env();\n        let mut data = Vec::new();\n        data.extend(text.to_bytes().unwrap_or_revert(&env));\n        data.extend(num.to_bytes().unwrap_or_revert(&env));\n        data.extend(addr.to_bytes().unwrap_or_revert(&env));\n        env.hash(data)\n    }\n}\n\n#[odra::module]\npub struct GuessTheMagicWord {\n    answer: Var<[u8; 32]>,\n}\n\n#[odra::module]\nimpl GuessTheMagicWord {\n    /// Initializes the contract with the magic word hash.\n    pub fn init(&mut self) {\n        self.answer.set([\n            0x86, 0x67, 0x15, 0xbb, 0x0b, 0x96, 0xf1, 0x06, 0xe0, 0x68, 0x07, 0x89, 0x22, 0x84,\n            0x42, 0x81, 0x19, 0x6b, 0x1e, 0x61, 0x45, 0x50, 0xa5, 0x70, 0x4a, 0xb0, 0xa7, 0x55,\n            0xbe, 0xd7, 0x56, 0x08,\n        ]);\n    }\n\n    /// Checks if the `word` is the magic word.\n    pub fn guess(&self, word: String) -> bool {\n        let env = self.env();\n        let hash = env.hash(word.to_bytes().unwrap_or_revert(&env));\n        hash == self.answer.get_or_default()\n    }\n}\n"))),(0,r.kt)(o.Z,{value:"sol",label:"Solidity",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sol",metastring:'showLineNumbers title="https://solidity-by-example.org/hashing/"',showLineNumbers:!0,title:'"https://solidity-by-example.org/hashing/"'},'// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\ncontract HashFunction {\n    function hash(string memory _text, uint256 _num, address _addr)\n        public\n        pure\n        returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(_text, _num, _addr));\n    }\n}\n\ncontract GuessTheMagicWord {\n    bytes32 public answer =\n        0x60298f78cc0b47170ba79c10aa3851d7648bd96f2f8e46a19dbc777c36fb0c00;\n\n    // Magic word is "Solidity"\n    function guess(string memory _word) public view returns (bool) {\n        return keccak256(abi.encodePacked(_word)) == answer;\n    }\n}\n')))),(0,r.kt)("p",null,"The key difference between the two is that in Solidity, the ",(0,r.kt)("inlineCode",{parentName:"p"},"keccak256")," function is used to hash data, while in Odra, the ",(0,r.kt)("inlineCode",{parentName:"p"},"env.hash()")," function is used, which implements the ",(0,r.kt)("inlineCode",{parentName:"p"},"blake2b")," algorithm. Both functions take a byte array as input and return a 32-byte hash."),(0,r.kt)("h3",{id:"try-catch"},"Try-catch"),(0,r.kt)(i.Z,{mdxType:"Tabs"},(0,r.kt)(o.Z,{value:"rust",label:"Odra",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:"showLineNumbers",showLineNumbers:!0},"use odra::{module::Module, Address, ContractRef, Var};\n\n#[odra::module]\npub struct Example {\n    other_contract: Var<Address>,\n}\n\n#[odra::module]\nimpl Example {\n    pub fn init(&mut self, other_contract: Address) {\n        self.other_contract.set(other_contract);\n    }\n\n    pub fn execute_external_call(&self) {\n        if let Some(addr) = self.other_contract.get() {\n            let result = OtherContractContractRef::new(self.env(), addr).some_function();\n            match result {\n                Ok(success) => {\n                    // Code to execute if the external call was successful\n                }\n                Err(reason) => {\n                    // Code to execute if the external call failed\n                }\n            }\n        }\n    }\n}\n\n#[odra::module]\npub struct OtherContract;\n\n#[odra::module]\nimpl OtherContract {\n    pub fn some_function(&self) -> Result<bool, ()> {\n        Ok(true)\n    }\n}\n"))),(0,r.kt)(o.Z,{value:"sol",label:"Solidity",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sol",metastring:'showLineNumbers title="https://solidity-by-example.org/hashing/"',showLineNumbers:!0,title:'"https://solidity-by-example.org/hashing/"'},'// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\ncontract Example {\n    OtherContract otherContract;\n\n    constructor(address _otherContractAddress) public {\n        otherContract = OtherContract(_otherContractAddress);\n    }\n\n    function executeExternalCall() public {\n        try otherContract.someFunction() returns (bool success) {\n            // Code to execute if the external call was successful\n            require(success, "Call failed");\n        } catch Error(string memory reason) {\n            // Code to execute if the external call failed with a revert reason\n            // Optionally handle specific revert reasons\n            emit LogErrorString(reason);\n        } catch (bytes memory lowLevelData) {\n            // Code to execute if the external call failed without a revert reason\n            emit LogErrorBytes(lowLevelData);\n        }\n    }\n\n    event LogErrorString(string reason);\n    event LogErrorBytes(bytes lowLevelData);\n}\n\ncontract OtherContract {\n    function someFunction() public returns (bool) {\n        // Function logic\n    }\n}\n')))),(0,r.kt)("p",null,"In Solidity, ",(0,r.kt)("inlineCode",{parentName:"p"},"try/catch")," is a feature that allows developers to handle exceptions and errors more gracefully. The ",(0,r.kt)("inlineCode",{parentName:"p"},"try/catch")," statement allows developers to catch and handle exceptions that occur during external function calls and contract creation."),(0,r.kt)("p",null,"In Odra, there is no direct equivalent to the ",(0,r.kt)("inlineCode",{parentName:"p"},"try/catch")," statement in Solidity. However, you can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"Result")," type to handle errors in a similar way. The ",(0,r.kt)("inlineCode",{parentName:"p"},"Result")," type is an enum that represents either success (",(0,r.kt)("inlineCode",{parentName:"p"},"Ok"),") or failure (",(0,r.kt)("inlineCode",{parentName:"p"},"Err"),"). You can use the match statement to handle the Result type and execute different code based on the result. However, if an unexpected error occurs on the way, the whole transaction reverts."),(0,r.kt)("h2",{id:"conclusion"},"Conclusion"),(0,r.kt)("p",null,"Congratulations! You've now learned the main differences in writing smart contracts with the Odra Framework. By understanding the structure, initialization, error handling, and the composition pattern in Odra, you can effectively transition from Solidity to Odra for Casper blockchain development."),(0,r.kt)("p",null,"Experiment with the provided code samples, explore more advanced features, and unleash the full potential of the Odra Framework."),(0,r.kt)("p",null,"Read more about the Odra Framework in the ",(0,r.kt)("a",{parentName:"p",href:"../category/basics"},"Basics")," and ",(0,r.kt)("a",{parentName:"p",href:"../category/advanced/"},"Advanced")," sections."),(0,r.kt)("p",null,"Learn by example with our ",(0,r.kt)("a",{parentName:"p",href:"../category/tutorials"},"Tutorial")," series, you will find there a contract you likely familiar with - the ",(0,r.kt)("a",{parentName:"p",href:"/docs/1.0.0/tutorials/erc20"},"Erc20")," standard implementation."),(0,r.kt)("p",null,"If you have any further questions or need clarification on specific topics, feel free to join our ",(0,r.kt)("a",{parentName:"p",href:"https://discord.com/invite/Mm5ABc9P8k"},"Discord"),"!"))}m.isMDXComponent=!0}}]);