"use strict";(self.webpackChunkodra_website=self.webpackChunkodra_website||[]).push([[12450],{3905:(e,n,t)=>{t.d(n,{Zo:()=>d,kt:()=>m});var r=t(67294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function s(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?s(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},s=Object.keys(e);for(r=0;r<s.length;r++)t=s[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(r=0;r<s.length;r++)t=s[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var i=r.createContext({}),u=function(e){var n=r.useContext(i),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},d=function(e){var n=u(e.components);return r.createElement(i.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},c=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,s=e.originalType,i=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),c=u(t),m=a,f=c["".concat(i,".").concat(m)]||c[m]||p[m]||s;return t?r.createElement(f,o(o({ref:n},d),{},{components:t})):r.createElement(f,o({ref:n},d))}));function m(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var s=t.length,o=new Array(s);o[0]=c;var l={};for(var i in n)hasOwnProperty.call(n,i)&&(l[i]=n[i]);l.originalType=e,l.mdxType="string"==typeof e?e:a,o[1]=l;for(var u=2;u<s;u++)o[u]=t[u];return r.createElement.apply(null,o)}return r.createElement.apply(null,t)}c.displayName="MDXCreateElement"},85162:(e,n,t)=>{t.d(n,{Z:()=>o});var r=t(67294),a=t(86010);const s="tabItem_Ymn6";function o(e){let{children:n,hidden:t,className:o}=e;return r.createElement("div",{role:"tabpanel",className:(0,a.Z)(s,o),hidden:t},n)}},74866:(e,n,t)=>{t.d(n,{Z:()=>_});var r=t(87462),a=t(67294),s=t(86010),o=t(12466),l=t(16550),i=t(91980),u=t(67392),d=t(50012);function p(e){return function(e){return a.Children.map(e,(e=>{if((0,a.isValidElement)(e)&&"value"in e.props)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))}(e).map((e=>{let{props:{value:n,label:t,attributes:r,default:a}}=e;return{value:n,label:t,attributes:r,default:a}}))}function c(e){const{values:n,children:t}=e;return(0,a.useMemo)((()=>{const e=n??p(t);return function(e){const n=(0,u.l)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,t])}function m(e){let{value:n,tabValues:t}=e;return t.some((e=>e.value===n))}function f(e){let{queryString:n=!1,groupId:t}=e;const r=(0,l.k6)(),s=function(e){let{queryString:n=!1,groupId:t}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return t??null}({queryString:n,groupId:t});return[(0,i._X)(s),(0,a.useCallback)((e=>{if(!s)return;const n=new URLSearchParams(r.location.search);n.set(s,e),r.replace({...r.location,search:n.toString()})}),[s,r])]}function b(e){const{defaultValue:n,queryString:t=!1,groupId:r}=e,s=c(e),[o,l]=(0,a.useState)((()=>function(e){let{defaultValue:n,tabValues:t}=e;if(0===t.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!m({value:n,tabValues:t}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${n}" but none of its children has the corresponding value. Available values are: ${t.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return n}const r=t.find((e=>e.default))??t[0];if(!r)throw new Error("Unexpected error: 0 tabValues");return r.value}({defaultValue:n,tabValues:s}))),[i,u]=f({queryString:t,groupId:r}),[p,b]=function(e){let{groupId:n}=e;const t=function(e){return e?`docusaurus.tab.${e}`:null}(n),[r,s]=(0,d.Nk)(t);return[r,(0,a.useCallback)((e=>{t&&s.set(e)}),[t,s])]}({groupId:r}),g=(()=>{const e=i??p;return m({value:e,tabValues:s})?e:null})();(0,a.useLayoutEffect)((()=>{g&&l(g)}),[g]);return{selectedValue:o,selectValue:(0,a.useCallback)((e=>{if(!m({value:e,tabValues:s}))throw new Error(`Can't select invalid tab value=${e}`);l(e),u(e),b(e)}),[u,b,s]),tabValues:s}}var g=t(72389);const v="tabList__CuJ",h="tabItem_LNqP";function y(e){let{className:n,block:t,selectedValue:l,selectValue:i,tabValues:u}=e;const d=[],{blockElementScrollPositionUntilNextRender:p}=(0,o.o5)(),c=e=>{const n=e.currentTarget,t=d.indexOf(n),r=u[t].value;r!==l&&(p(n),i(r))},m=e=>{let n=null;switch(e.key){case"Enter":c(e);break;case"ArrowRight":{const t=d.indexOf(e.currentTarget)+1;n=d[t]??d[0];break}case"ArrowLeft":{const t=d.indexOf(e.currentTarget)-1;n=d[t]??d[d.length-1];break}}n?.focus()};return a.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,s.Z)("tabs",{"tabs--block":t},n)},u.map((e=>{let{value:n,label:t,attributes:o}=e;return a.createElement("li",(0,r.Z)({role:"tab",tabIndex:l===n?0:-1,"aria-selected":l===n,key:n,ref:e=>d.push(e),onKeyDown:m,onClick:c},o,{className:(0,s.Z)("tabs__item",h,o?.className,{"tabs__item--active":l===n})}),t??n)})))}function w(e){let{lazy:n,children:t,selectedValue:r}=e;if(t=Array.isArray(t)?t:[t],n){const e=t.find((e=>e.props.value===r));return e?(0,a.cloneElement)(e,{className:"margin-top--md"}):null}return a.createElement("div",{className:"margin-top--md"},t.map(((e,n)=>(0,a.cloneElement)(e,{key:n,hidden:e.props.value!==r}))))}function k(e){const n=b(e);return a.createElement("div",{className:(0,s.Z)("tabs-container",v)},a.createElement(y,(0,r.Z)({},e,n)),a.createElement(w,(0,r.Z)({},e,n)))}function _(e){const n=(0,g.Z)();return a.createElement(k,(0,r.Z)({key:String(n)},e))}},58132:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>i,default:()=>m,frontMatter:()=>l,metadata:()=>u,toc:()=>p});var r=t(87462),a=(t(67294),t(3905)),s=t(74866),o=t(85162);const l={sidebar_position:2,description:"Migration guide to v0.9.0"},i="Migration guide to v0.9.0",u={unversionedId:"migrations/to-0.9.0",id:"version-2.0.1/migrations/to-0.9.0",title:"Migration guide to v0.9.0",description:"Migration guide to v0.9.0",source:"@site/versioned_docs/version-2.0.1/migrations/to-0.9.0.md",sourceDirName:"migrations",slug:"/migrations/to-0.9.0",permalink:"/docs/2.0.1/migrations/to-0.9.0",draft:!1,tags:[],version:"2.0.1",lastUpdatedAt:1752055773,formattedLastUpdatedAt:"Jul 9, 2025",sidebarPosition:2,frontMatter:{sidebar_position:2,description:"Migration guide to v0.9.0"},sidebar:"tutorialSidebar",previous:{title:"Migration guide to v0.8.0",permalink:"/docs/2.0.1/migrations/to-0.8.0"},next:{title:"Migration guide to v1.3.0",permalink:"/docs/2.0.1/migrations/to-1.3.0"}},d={},p=[{value:"<strong>1. Prerequisites</strong>",id:"1-prerequisites",level:2},{value:"1.1. <strong>Update cargo-odra</strong>",id:"11-update-cargo-odra",level:3},{value:"1.2. <strong>Review the Changelog</strong>",id:"12-review-the-changelog",level:3},{value:"<strong>2. Migration Steps</strong>",id:"2-migration-steps",level:2},{value:"2.1 <strong>Update build_schema.rs bin</strong>",id:"21-update-build_schemars-bin",level:3},{value:"2.2 <strong>Update smart contract code</strong>",id:"22-update-smart-contract-code",level:3},{value:"2.2.1. <strong>Update custom types definitions.</strong>",id:"221-update-custom-types-definitions",level:4},{value:"2.2.2. <strong>Update errors definitions.</strong>",id:"222-update-errors-definitions",level:4},{value:"2.2.3. <strong>Update events definitions.</strong>",id:"223-update-events-definitions",level:4},{value:"3. <strong>Code Examples</strong>",id:"3-code-examples",level:2},{value:"4. <strong>Troubleshooting</strong>",id:"4-troubleshooting",level:2},{value:"5. <strong>References</strong>",id:"5-references",level:2}],c={toc:p};function m(e){let{components:n,...t}=e;return(0,a.kt)("wrapper",(0,r.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"migration-guide-to-v090"},"Migration guide to v0.9.0"),(0,a.kt)("p",null,"This guide is intended for developers who have built smart contracts using version 0.8.0 of Odra and need to update their code to be compatible with v0.9.0. For migration from version ",(0,a.kt)("inlineCode",{parentName:"p"},"0.7.1")," and below, start with the ",(0,a.kt)("a",{parentName:"p",href:"./to-0.8.0"},"previous guide"),". It assumes a basic understanding of smart contract development and the Odra framework. If you're new to Odra, we recommend to start your journey with the ",(0,a.kt)("a",{parentName:"p",href:"../category/getting-started/"},"Getting Started"),"."),(0,a.kt)("p",null,"The most significant change in ",(0,a.kt)("inlineCode",{parentName:"p"},"0.9.0")," is the way of defining custom elements namely type, events and errors."),(0,a.kt)("h2",{id:"1-prerequisites"},(0,a.kt)("strong",{parentName:"h2"},"1. Prerequisites")),(0,a.kt)("h3",{id:"11-update-cargo-odra"},"1.1. ",(0,a.kt)("strong",{parentName:"h3"},"Update cargo-odra")),(0,a.kt)("p",null,"Before you begin the migration process, make sure you installed the latest version of the Cargo Odra toolchain. You can install it by running the following command:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"cargo install cargo-odra --force --locked\n")),(0,a.kt)("h3",{id:"12-review-the-changelog"},"1.2. ",(0,a.kt)("strong",{parentName:"h3"},"Review the Changelog")),(0,a.kt)("p",null,"Before you move to changing your code, start by reviewing the ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/odradev/odra/blob/release/0.9.0/CHANGELOG.md"},"Changelog")," to understand the changes introduced in v0.9.0."),(0,a.kt)("h2",{id:"2-migration-steps"},(0,a.kt)("strong",{parentName:"h2"},"2. Migration Steps")),(0,a.kt)("h3",{id:"21-update-build_schemars-bin"},"2.1 ",(0,a.kt)("strong",{parentName:"h3"},"Update build_schema.rs bin")),(0,a.kt)("p",null,"Odra 0.9.0 adds a new standardized way of generating contract schema - ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/odradev/casper-contract-schema"},"Casper Contract Schema"),". You can find the updated ",(0,a.kt)("inlineCode",{parentName:"p"},"build_schema.rs")," file in ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/odradev/odra/blob/release/0.9.0/templates"},"templates")," directory in the Odra main repository. You can choose whatever template you want to use and copy the files to your project. In both files, you should replace ",(0,a.kt)("inlineCode",{parentName:"p"},"{{project-name}}")," with the name of your project."),(0,a.kt)("h3",{id:"22-update-smart-contract-code"},"2.2 ",(0,a.kt)("strong",{parentName:"h3"},"Update smart contract code")),(0,a.kt)("p",null,"The main changes in the smart contract code are related to the way of defining custom types, events and errors. The following sections will guide you through the necessary changes."),(0,a.kt)("h4",{id:"221-update-custom-types-definitions"},"2.2.1. ",(0,a.kt)("strong",{parentName:"h4"},"Update custom types definitions.")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"#[derive(OdraType)]")," attribute has been replace with ",(0,a.kt)("inlineCode",{parentName:"p"},"#[odra::odra_type]")," attribute."),(0,a.kt)(s.Z,{mdxType:"Tabs"},(0,a.kt)(o.Z,{value:"current",label:"0.9.0",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"use odra::Address;\n\n#[odra::odra_type]\npub struct Dog {\n    pub name: String,\n    pub age: u8,\n    pub owner: Option<Address>\n}\n"))),(0,a.kt)(o.Z,{value:"old",label:"0.8.0",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"use odra::{Address, OdraType};\n\n#[derive(OdraType)]\npub struct Dog {\n    pub name: String,\n    pub age: u8,\n    pub owner: Option<Address>\n}\n")))),(0,a.kt)("h4",{id:"222-update-errors-definitions"},"2.2.2. ",(0,a.kt)("strong",{parentName:"h4"},"Update errors definitions.")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"#[derive(OdraError)]")," attribute has been replace with ",(0,a.kt)("inlineCode",{parentName:"p"},"#[odra::odra_error]")," attribute.\nError enum should be passed as a parameter to the ",(0,a.kt)("inlineCode",{parentName:"p"},"#[odra::module]")," attribute."),(0,a.kt)(s.Z,{mdxType:"Tabs"},(0,a.kt)(o.Z,{value:"current",label:"0.9.0",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"#[odra::module(events = [/* events go here */], errors = Error)]\npub struct Erc20 {\n    // fields\n}\n\n#[odra::odra_error]\npub enum Error {\n   InsufficientBalance = 30_000,\n   InsufficientAllowance = 30_001,\n   NameNotSet = 30_002,\n   SymbolNotSet = 30_003,\n   DecimalsNotSet = 30_004\n}\n"))),(0,a.kt)(o.Z,{value:"old",label:"0.8.0",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"#[odra::module(events = [/* events go here */])]\npub struct Erc20 {\n    // fields\n}\n\nuse odra::OdraError;\n\n#[derive(OdraError)]\npub enum Error {\n   InsufficientBalance = 30_000,\n   InsufficientAllowance = 30_001,\n   NameNotSet = 30_002,\n   SymbolNotSet = 30_003,\n   DecimalsNotSet = 30_004\n}\n")))),(0,a.kt)("h4",{id:"223-update-events-definitions"},"2.2.3. ",(0,a.kt)("strong",{parentName:"h4"},"Update events definitions.")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"#[derive(Event)]")," attribute has been replace with ",(0,a.kt)("inlineCode",{parentName:"p"},"#[odra::event]")," attribute."),(0,a.kt)(s.Z,{mdxType:"Tabs"},(0,a.kt)(o.Z,{value:"current",label:"0.9.0",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"use odra::prelude::*;\nuse odra::{Address, casper_types::U256};\n\n#[odra::event]\npub struct Transfer {\n   pub from: Option<Address>,\n   pub to: Option<Address>,\n   pub amount: U256\n}\n"))),(0,a.kt)(o.Z,{value:"old",label:"0.8.0",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"use odra::prelude::*;\nuse odra::{Address, casper_types::U256, Event};\n\n#[derive(Event, Eq, PartialEq, Debug)]\npub struct Transfer {\n   pub from: Option<Address>,\n   pub to: Option<Address>,\n   pub amount: U256\n}\n")))),(0,a.kt)("h2",{id:"3-code-examples"},"3. ",(0,a.kt)("strong",{parentName:"h2"},"Code Examples")),(0,a.kt)("p",null,"Here is a complete example of a smart contract after and before the migration to v0.9.0."),(0,a.kt)(s.Z,{mdxType:"Tabs"},(0,a.kt)(o.Z,{value:"current",label:"0.9.0",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="src/erc20.rs"',title:'"src/erc20.rs"'},"use crate::erc20::errors::Error;\nuse crate::erc20::events::*;\nuse odra::prelude::*;\nuse odra::{casper_types::U256, Address, Mapping, Var};\n\n#[odra::module(events = [Approval, Transfer], errors = Error)]\npub struct Erc20 {\n   decimals: Var<u8>,\n   symbol: Var<String>,\n   name: Var<String>,\n   total_supply: Var<U256>,\n   balances: Mapping<Address, U256>,\n   allowances: Mapping<(Address, Address), U256>\n}\n\n#[odra::module]\nimpl Erc20 {\n   pub fn init(\n      &mut self,\n      symbol: String,\n      name: String,\n      decimals: u8,\n      initial_supply: Option<U256>\n   ) {\n      let caller = self.env().caller();\n      self.symbol.set(symbol);\n      self.name.set(name);\n      self.decimals.set(decimals);\n\n      if let Some(initial_supply) = initial_supply {\n         self.total_supply.set(initial_supply);\n         self.balances.set(&caller, initial_supply);\n\n         if !initial_supply.is_zero() {\n               self.env().emit_event(Transfer {\n                  from: None,\n                  to: Some(caller),\n                  amount: initial_supply\n               });\n         }\n      }\n   }\n\n   pub fn transfer(&mut self, recipient: &Address, amount: &U256) {\n      let caller = self.env().caller();\n      self.raw_transfer(&caller, recipient, amount);\n   }\n\n   pub fn transfer_from(&mut self, owner: &Address, recipient: &Address, amount: &U256) {\n      let spender = self.env().caller();\n\n      self.spend_allowance(owner, &spender, amount);\n      self.raw_transfer(owner, recipient, amount);\n   }\n\n   pub fn approve(&mut self, spender: &Address, amount: &U256) {\n      let owner = self.env().caller();\n\n      self.allowances.set(&(owner, *spender), *amount);\n      self.env().emit_event(Approval {\n         owner,\n         spender: *spender,\n         value: *amount\n      });\n   }\n\n   pub fn name(&self) -> String {\n      self.name.get_or_revert_with(Error::NameNotSet)\n   }\n\n   // Other getter functions...\n\n   pub fn allowance(&self, owner: &Address, spender: &Address) -> U256 {\n      self.allowances.get_or_default(&(*owner, *spender))\n   }\n\n   pub fn mint(&mut self, address: &Address, amount: &U256) {\n      self.total_supply.add(*amount);\n      self.balances.add(address, *amount);\n\n      self.env().emit_event(Transfer {\n         from: None,\n         to: Some(*address),\n         amount: *amount\n      });\n   }\n\n   pub fn burn(&mut self, address: &Address, amount: &U256) {\n      if self.balance_of(address) < *amount {\n         self.env().revert(Error::InsufficientBalance);\n      }\n      self.total_supply.subtract(*amount);\n      self.balances.subtract(address, *amount);\n\n      self.env().emit_event(Transfer {\n         from: Some(*address),\n         to: None,\n         amount: *amount\n      });\n   }\n}\n\nimpl Erc20 {\n   fn raw_transfer(&mut self, owner: &Address, recipient: &Address, amount: &U256) {\n      if *amount > self.balances.get_or_default(owner) {\n         self.env().revert(Error::InsufficientBalance)\n      }\n\n      self.balances.subtract(owner, *amount);\n      self.balances.add(recipient, *amount);\n\n      self.env().emit_event(Transfer {\n         from: Some(*owner),\n         to: Some(*recipient),\n         amount: *amount\n      });\n   }\n\n   fn spend_allowance(&mut self, owner: &Address, spender: &Address, amount: &U256) {\n      let allowance = self.allowances.get_or_default(&(*owner, *spender));\n      if allowance < *amount {\n         self.env().revert(Error::InsufficientAllowance)\n      }\n      self.allowances.subtract(&(*owner, *spender), *amount);\n\n      self.env().emit_event(Approval {\n         owner: *owner,\n         spender: *spender,\n         value: allowance - *amount\n      });\n   }\n}\n\npub mod events {\n   use odra::prelude::*;\n   use odra::{casper_types::U256, Address};\n\n   #[odra::event]\n   pub struct Transfer {\n      pub from: Option<Address>,\n      pub to: Option<Address>,\n      pub amount: U256\n   }\n\n   #[odra::event]\n   pub struct Approval {\n      pub owner: Address,\n      pub spender: Address,\n      pub value: U256\n   }\n}\n\npub mod errors {\n   #[odra::odra_error]\n   pub enum Error {\n      InsufficientBalance = 30_000,\n      InsufficientAllowance = 30_001,\n      NameNotSet = 30_002,\n      SymbolNotSet = 30_003,\n      DecimalsNotSet = 30_004\n   }\n}\n\n#[cfg(test)]\nmod tests {\n    // nothing changed in the tests\n}\n"))),(0,a.kt)(o.Z,{value:"old",label:"Prev",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="src/erc20.rs"',title:'"src/erc20.rs"'},"use crate::erc20::errors::Error::*;\nuse crate::erc20::events::*;\nuse odra::prelude::*;\nuse odra::{casper_types::U256, Address, Mapping, Var};\n\n#[odra::module(events = [Approval, Transfer])]\npub struct Erc20 {\n   decimals: Var<u8>,\n   symbol: Var<String>,\n   name: Var<String>,\n   total_supply: Var<U256>,\n   balances: Mapping<Address, U256>,\n   allowances: Mapping<(Address, Address), U256>\n}\n\n#[odra::module]\nimpl Erc20 {\n   pub fn init(\n      &mut self,\n      symbol: String,\n      name: String,\n      decimals: u8,\n      initial_supply: Option<U256>\n   ) {\n      let caller = self.env().caller();\n      self.symbol.set(symbol);\n      self.name.set(name);\n      self.decimals.set(decimals);\n\n      if let Some(initial_supply) = initial_supply {\n         self.total_supply.set(initial_supply);\n         self.balances.set(&caller, initial_supply);\n\n         if !initial_supply.is_zero() {\n               self.env().emit_event(Transfer {\n                  from: None,\n                  to: Some(caller),\n                  amount: initial_supply\n               });\n         }\n      }\n   }\n\n   pub fn transfer(&mut self, recipient: &Address, amount: &U256) {\n      let caller = self.env().caller();\n      self.raw_transfer(&caller, recipient, amount);\n   }\n\n   pub fn transfer_from(&mut self, owner: &Address, recipient: &Address, amount: &U256) {\n      let spender = self.env().caller();\n\n      self.spend_allowance(owner, &spender, amount);\n      self.raw_transfer(owner, recipient, amount);\n   }\n\n   pub fn approve(&mut self, spender: &Address, amount: &U256) {\n      let owner = self.env().caller();\n\n      self.allowances.set(&(owner, *spender), *amount);\n      self.env().emit_event(Approval {\n         owner,\n         spender: *spender,\n         value: *amount\n      });\n   }\n\n   pub fn name(&self) -> String {\n      self.name.get_or_revert_with(NameNotSet)\n   }\n\n   // Other getter functions...\n\n   pub fn allowance(&self, owner: &Address, spender: &Address) -> U256 {\n      self.allowances.get_or_default(&(*owner, *spender))\n   }\n\n   pub fn mint(&mut self, address: &Address, amount: &U256) {\n      self.total_supply.add(*amount);\n      self.balances.add(address, *amount);\n\n      self.env().emit_event(Transfer {\n         from: None,\n         to: Some(*address),\n         amount: *amount\n      });\n   }\n\n   pub fn burn(&mut self, address: &Address, amount: &U256) {\n      if self.balance_of(address) < *amount {\n         self.env().revert(InsufficientBalance);\n      }\n      self.total_supply.subtract(*amount);\n      self.balances.subtract(address, *amount);\n\n      self.env().emit_event(Transfer {\n         from: Some(*address),\n         to: None,\n         amount: *amount\n      });\n   }\n}\n\nimpl Erc20 {\n   fn raw_transfer(&mut self, owner: &Address, recipient: &Address, amount: &U256) {\n      if *amount > self.balances.get_or_default(owner) {\n         self.env().revert(InsufficientBalance)\n      }\n\n      self.balances.subtract(owner, *amount);\n      self.balances.add(recipient, *amount);\n\n      self.env().emit_event(Transfer {\n         from: Some(*owner),\n         to: Some(*recipient),\n         amount: *amount\n      });\n   }\n\n   fn spend_allowance(&mut self, owner: &Address, spender: &Address, amount: &U256) {\n      let allowance = self.allowances.get_or_default(&(*owner, *spender));\n      if allowance < *amount {\n         self.env().revert(InsufficientAllowance)\n      }\n      self.allowances.subtract(&(*owner, *spender), *amount);\n\n      self.env().emit_event(Approval {\n         owner: *owner,\n         spender: *spender,\n         value: allowance - *amount\n      });\n   }\n}\n\npub mod events {\n   use odra::prelude::*;\n   use odra::{casper_types::U256, Address, Event};\n\n   #[derive(Event, Eq, PartialEq, Debug)]\n   pub struct Transfer {\n      pub from: Option<Address>,\n      pub to: Option<Address>,\n      pub amount: U256\n   }\n\n   #[derive(Event, Eq, PartialEq, Debug)]\n   pub struct Approval {\n      pub owner: Address,\n      pub spender: Address,\n      pub value: U256\n   }\n}\n\npub mod errors {\n   use odra::OdraError;\n\n   #[derive(OdraError)]\n   pub enum Error {\n      InsufficientBalance = 30_000,\n      InsufficientAllowance = 30_001,\n      NameNotSet = 30_002,\n      SymbolNotSet = 30_003,\n      DecimalsNotSet = 30_004\n   }\n}\n\n#[cfg(test)]\nmod tests {\n   // nothing changed in the tests\n}\n")))),(0,a.kt)("h2",{id:"4-troubleshooting"},"4. ",(0,a.kt)("strong",{parentName:"h2"},"Troubleshooting")),(0,a.kt)("p",null,"If you encounter any further issues after completing the migration steps, please don't hesitate to reach out to us on ",(0,a.kt)("a",{parentName:"p",href:"https://discord.com/invite/Mm5ABc9P9k"},"Discord")," or explore the other sections this documentation. You can also refer to the ",(0,a.kt)("a",{parentName:"p",href:"https://docs.rs/odra/0.9.0/odra/index.html"},"technical documentation")," for more detailed information. Additionally, our ",(0,a.kt)("a",{parentName:"p",href:"https:://github.com/odradev/odra/tree/release/0.9.0/examples"},"examples")," repository offers a wide range of examples to assist you in understanding the new features and APIs. Be sure to carefully review any compilation errors and warnings, as they may provide valuable insights into the necessary adjustments."),(0,a.kt)("h2",{id:"5-references"},"5. ",(0,a.kt)("strong",{parentName:"h2"},"References")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/odradev/odra/blob/release/0.9.0/CHANGELOG.md"},"Changelog")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://docs.odra.dev"},"Odra Documentation")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://docs.rs/odra/0.9.0/odra/index.html"},"Docs.rs")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https:://github.com/odradev/odra/tree/release/0.9.0/examples"},"Examples"))))}m.isMDXComponent=!0}}]);