"use strict";(self.webpackChunkodra_website=self.webpackChunkodra_website||[]).push([[5890],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>k});var r=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,i=function(e,t){if(null==e)return{};var n,r,i={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=r.createContext({}),c=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=c(e.components);return r.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,i=e.mdxType,a=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),d=c(n),k=i,f=d["".concat(l,".").concat(k)]||d[k]||p[k]||a;return n?r.createElement(f,o(o({ref:t},u),{},{components:n})):r.createElement(f,o({ref:t},u))}));function k(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=n.length,o=new Array(a);o[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,o[1]=s;for(var c=2;c<a;c++)o[c]=n[c];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},22679:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>p,frontMatter:()=>a,metadata:()=>s,toc:()=>c});var r=n(87462),i=(n(67294),n(3905));const a={sidebar_position:6},o="Ticketing System",s={unversionedId:"tutorials/nft",id:"version-2.0.0/tutorials/nft",title:"Ticketing System",description:"Non-fungible tokens (NFTs) are digital assets that represent ownership of unique items or pieces of content. They are commonly used for digital art, collectibles, in-game items, and other unique assets. In this tutorial, we will create a simple ticketing system based on NFT tokens.",source:"@site/versioned_docs/version-2.0.0/tutorials/nft.md",sourceDirName:"tutorials",slug:"/tutorials/nft",permalink:"/docs/2.0.0/tutorials/nft",draft:!1,tags:[],version:"2.0.0",lastUpdatedAt:1748343707,formattedLastUpdatedAt:"May 27, 2025",sidebarPosition:6,frontMatter:{sidebar_position:6},sidebar:"tutorialSidebar",previous:{title:"Pausable",permalink:"/docs/2.0.0/tutorials/pauseable"},next:{title:"Build, Deploy and Read the State of a Contract",permalink:"/docs/2.0.0/tutorials/build-deploy-read"}},l={},c=[{value:"Ticket Office Contract",id:"ticket-office-contract",level:3},{value:"Setup the project",id:"setup-the-project",level:3},{value:"Contract implementation",id:"contract-implementation",level:3},{value:"Redesign",id:"redesign",level:3},{value:"Ticket Operator Contract",id:"ticket-operator-contract",level:4},{value:"Conclusion",id:"conclusion",level:3}],u={toc:c};function p(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"ticketing-system"},"Ticketing System"),(0,i.kt)("p",null,"Non-fungible tokens (NFTs) are digital assets that represent ownership of unique items or pieces of content. They are commonly used for digital art, collectibles, in-game items, and other unique assets. In this tutorial, we will create a simple ticketing system based on NFT tokens."),(0,i.kt)("p",null,"Our contract will adhere to the CEP-78 standard, which is the standard for NFTs on the Casper blockchain."),(0,i.kt)("p",null,"Learn more about the CEP-78 standard ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/casper-ecosystem/cep-78-enhanced-nft/tree/dev/docs"},"here"),"."),(0,i.kt)("h3",{id:"ticket-office-contract"},"Ticket Office Contract"),(0,i.kt)("p",null,"Our TicketOffice contract will include the following features:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Compliance with the CEP-78 standard."),(0,i.kt)("li",{parentName:"ul"},"Ownership functionality."),(0,i.kt)("li",{parentName:"ul"},"Only the owner can issue new event tickets."),(0,i.kt)("li",{parentName:"ul"},"Users can purchase tickets for events."),(0,i.kt)("li",{parentName:"ul"},"Tickets are limited to a one-time sale."),(0,i.kt)("li",{parentName:"ul"},"Public access to view the total income of the ",(0,i.kt)("inlineCode",{parentName:"li"},"TicketOffice"),".")),(0,i.kt)("h3",{id:"setup-the-project"},"Setup the project"),(0,i.kt)("p",null,"Creating a new NFT token with Odra is straightforward. Use the ",(0,i.kt)("inlineCode",{parentName:"p"},"cargo odra new")," command to create a new project with the CEP-78 template:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"cargo odra new --name ticket-office --template cep78\n")),(0,i.kt)("h3",{id:"contract-implementation"},"Contract implementation"),(0,i.kt)("p",null,"Let's start implementing the ",(0,i.kt)("inlineCode",{parentName:"p"},"TicketOffice")," contract by modify the code generated from the template. "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust",metastring:'showLineNumbers title="src/token.rs"',showLineNumbers:!0,title:'"src/token.rs"'},'use odra::{\n    args::Maybe, casper_types::U512, prelude::*\n};\nuse odra_modules::access::Ownable;\nuse odra_modules::cep78::{\n    modalities::{MetadataMutability, NFTIdentifierMode, NFTKind, NFTMetadataKind, OwnershipMode},\n    token::Cep78,\n};\n\npub type TicketId = u64;\n\n#[odra::odra_type]\npub enum TicketStatus {\n    Available,\n    Sold,\n}\n\n#[odra::odra_type]\npub struct TicketInfo {\n    event_name: String,\n    price: U512,\n    status: TicketStatus,\n}\n\n#[odra::event]\npub struct OnTicketIssue {\n    ticket_id: TicketId,\n    event_name: String,\n    price: U512,\n}\n\n#[odra::event]\npub struct OnTicketSell {\n    ticket_id: TicketId,\n    buyer: Address,\n}\n\n#[odra::odra_error]\npub enum Error {\n    TicketNotAvailableForSale = 200,\n    InsufficientFunds = 201,\n    InvalidTicketId = 202,\n    TicketDoesNotExist = 203,\n}\n\n#[odra::module(\n    events = [OnTicketIssue, OnTicketSell],\n    errors = Error\n)]\npub struct TicketOffice {\n    token: SubModule<Cep78>,\n    ownable: SubModule<Ownable>,\n    tickets: Mapping<TicketId, TicketInfo>,\n}\n\n#[odra::module]\nimpl TicketOffice {\n    pub fn init(&mut self, collection_name: String, collection_symbol: String, total_supply: u64) {\n        self.ownable.init();\n        let receipt_name = format!("cep78_{}", collection_name);\n        self.token.init(\n            collection_name,\n            collection_symbol,\n            total_supply,\n            OwnershipMode::Transferable,\n            NFTKind::Digital,\n            NFTIdentifierMode::Ordinal,\n            NFTMetadataKind::Raw,\n            MetadataMutability::Immutable,\n            receipt_name,\n            // remaining args are optional and can set to Maybe::None\n            ...\n        );\n    }\n\n    pub fn issue_ticket(&mut self, event_name: String, price: U512) {\n        let env = self.env();\n        let caller = env.caller();\n        self.ownable.assert_owner(&caller);\n        // mint a new token\n        let (_, _, token_id) = self.token.mint(caller, "".to_string(), Maybe::None);\n        let ticket_id: u64 = token_id\n            .parse()\n            .map_err(|_| Error::InvalidTicketId)\n            .unwrap_or_revert(&env);\n        // store ticket info\n        self.tickets.set(\n            &ticket_id,\n            TicketInfo {\n                event_name: event_name.clone(),\n                price,\n                status: TicketStatus::Available,\n            },\n        );\n        // emit an event\n        env.emit_event(OnTicketIssue {\n            ticket_id,\n            event_name,\n            price,\n        });\n    }\n\n    #[odra(payable)]\n    pub fn buy_ticket(&mut self, ticket_id: TicketId) {\n        let env = self.env();\n        let owner = self.ownable.get_owner();\n        let buyer = env.caller();\n        let value = env.attached_value();\n        // only tokens owned by the owner can be sold\n        if self.token.owner_of(Maybe::Some(ticket_id), Maybe::None) != owner {\n            env.revert(Error::TicketNotAvailableForSale);\n        }\n        let mut ticket = self\n            .tickets\n            .get(&ticket_id)\n            .unwrap_or_revert_with(&env, Error::TicketDoesNotExist);\n        // only available tickets can be sold\n        if ticket.status != TicketStatus::Available {\n            env.revert(Error::TicketNotAvailableForSale);\n        }\n        // check if the buyer sends enough funds\n        if value < ticket.price {\n            env.revert(Error::InsufficientFunds);\n        }\n        // transfer csprs to the owner\n        env.transfer_tokens(&owner, &value);\n        // transfer the ticket to the buyer\n        self.token\n            .transfer(Maybe::Some(ticket_id), Maybe::None, owner, buyer);\n        ticket.status = TicketStatus::Sold;\n        self.tickets.set(&ticket_id, ticket);\n\n        env.emit_event(OnTicketSell { ticket_id, buyer });\n    }\n\n    pub fn balance_of(&self) -> U512 {\n        self.env().self_balance()\n    }\n}\n')),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"L10-L44")," - We define structures and enums that will be used in our contract. ",(0,i.kt)("inlineCode",{parentName:"li"},"TicketStatus")," enum represents the status of a ticket, ",(0,i.kt)("inlineCode",{parentName:"li"},"TicketInfo")," struct contains information about a ticket that is written to the storage, ",(0,i.kt)("inlineCode",{parentName:"li"},"TicketId")," is a type alias for ",(0,i.kt)("inlineCode",{parentName:"li"},"u64"),". ",(0,i.kt)("inlineCode",{parentName:"li"},"OnTicketIssue")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"OnTicketSell")," are events that will be emitted when a ticket is issued or sold."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"L46-L49")," - Register errors and events that will be used in our contract, required to produce a complete contract schema."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"L51-L53")," - ",(0,i.kt)("inlineCode",{parentName:"li"},"TicketOffice")," module definition. The module contains a ",(0,i.kt)("inlineCode",{parentName:"li"},"Cep78")," token, an ",(0,i.kt)("inlineCode",{parentName:"li"},"Ownable")," module, and a ",(0,i.kt)("inlineCode",{parentName:"li"},"Mapping")," that stores information about tickets."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"L58-L74")," - The ",(0,i.kt)("inlineCode",{parentName:"li"},"init")," function has been generated from the template and there is no need to modify it, except the ",(0,i.kt)("inlineCode",{parentName:"li"},"Ownable")," module initialization."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"L76-L94")," - The ",(0,i.kt)("inlineCode",{parentName:"li"},"issue_ticket")," function allows the owner to issue a new ticket. The function mints a new token, stores information about the ticket, and emits an ",(0,i.kt)("inlineCode",{parentName:"li"},"OnTicketIssue")," event."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"L103")," - The ",(0,i.kt)("inlineCode",{parentName:"li"},"payable")," attribute indicates that the ",(0,i.kt)("inlineCode",{parentName:"li"},"buy_ticket")," function can receive funds."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"L104-L134")," - The ",(0,i.kt)("inlineCode",{parentName:"li"},"buy_ticket")," function checks if the ticket is available for sale, if the buyer sends enough funds, and transfers the ticket to the buyer. Finally, the function updates the ticket status and emits an ",(0,i.kt)("inlineCode",{parentName:"li"},"OnTicketSell")," event.")),(0,i.kt)("p",null,"Lets test the contract. The test scenario will be as follows:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Deploy the contract."),(0,i.kt)("li",{parentName:"ol"},"Issue two tickets."),(0,i.kt)("li",{parentName:"ol"},"Try to buy a ticket with insufficient funds."),(0,i.kt)("li",{parentName:"ol"},"Buy tickets."),(0,i.kt)("li",{parentName:"ol"},"Try to buy the same ticket again."),(0,i.kt)("li",{parentName:"ol"},"Check the balance of the contract.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust",metastring:'showLineNumbers title="src/tests.rs"',showLineNumbers:!0,title:'"src/tests.rs"'},'use odra::{\n    casper_types::U512,\n    host::{Deployer, HostRef},\n};\n\nuse crate::token::{Error, TicketOfficeHostRef, TicketOfficeInitArgs};\n\n#[test]\nfn it_works() {\n    let env = odra_test::env();\n    let init_args = TicketOfficeInitArgs {\n        collection_name: "Ticket".to_string(),\n        collection_symbol: "T".to_string(),\n        total_supply: 100,\n    };  \n    let mut contract = TicketOffice::deploy(&env, init_args);\n    contract.issue_ticket("Ev".to_string(), U512::from(100));\n    contract.issue_ticket("Ev".to_string(), U512::from(50));\n\n    let buyer = env.get_account(1);\n    env.set_caller(buyer);\n\n    assert_eq!(\n        contract\n            .with_tokens(U512::from(50))\n            .try_buy_ticket(0),\n        Err(Error::InsufficientFunds.into())\n    );\n\n    assert_eq!(\n        contract\n            .with_tokens(U512::from(100))\n            .try_buy_ticket(0),\n        Ok(())\n    );\n    assert_eq!(\n        contract\n            .with_tokens(U512::from(50))\n            .try_buy_ticket(1),\n        Ok(())\n    );\n\n    assert_eq!(\n        contract\n            .with_tokens(U512::from(100))\n            .try_buy_ticket(0),\n        Err(Error::TicketNotAvailableForSale.into())\n    );\n}\n')),(0,i.kt)("p",null,"Unfortunately, the test failed. The first assertion succeeds because the buyer sends insufficient funds to buy the ticket. However, the second assertion fails even though the buyer sends enough funds to purchase the ticket. The buy_ticket function reverts with ",(0,i.kt)("inlineCode",{parentName:"p"},"Cep78Error::InvalidTokenOwner")," because the buyer attempts to transfer a token that they do not own, are not approved for, or are not an operator of."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="odra/modules/src/cep78/token78.rs"',title:'"odra/modules/src/cep78/token78.rs"'},"pub fn transfer(\n    &mut self,\n    token_id: Maybe<u64>,\n    token_hash: Maybe<String>,\n    source_key: Address,\n    target_key: Address\n) -> TransferReceipt {\n    ...\n\n    if !is_owner && !is_approved && !is_operator {\n        self.revert(CEP78Error::InvalidTokenOwner);\n    }\n\n    ...\n}\n")),(0,i.kt)("p",null,"Let's fix it by redesigning our little system."),(0,i.kt)("h3",{id:"redesign"},"Redesign"),(0,i.kt)("p",null,"Since a buyer cannot purchase a ticket directly, we need to introduce an intermediary \u2014 an operator who will be responsible for buying tickets on behalf of the buyer. The operator will be approved by the ticket office to transfer tickets."),(0,i.kt)("p",null,"The sequence diagram below illustrates the new flow:"),(0,i.kt)("mermaid",{value:"sequenceDiagram;\n    autonumber\n    actor Owner\n    Owner->>+TicketOffice: Deploy\n    Owner->>+Operator: Deploy\n    actor Buyer\n    Owner->>TicketOffice: call register_operator\n    TicketOffice->>Operator: Register\n    Operator->>TicketOffice: Register\n    Owner->>TicketOffice: call issue_ticket\n    TicketOffice->>Operator: Approve\n    Buyer->>Operator: call buy_ticket\n    Operator->>TicketOffice: call buy_ticket\n    TicketOffice->>Buyer: Transfer ticket"}),(0,i.kt)("h4",{id:"ticket-operator-contract"},"Ticket Operator Contract"),(0,i.kt)("p",null,"As shown in the sequence diagram, a new contract will act as an operator for the ticket office. To create this new contract, use the ",(0,i.kt)("inlineCode",{parentName:"p"},"cargo odra generate")," command."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sh"},"cargo odra generate -c ticket_operator\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust",metastring:'showLineNumbers title="src/ticket_operator.rs"',showLineNumbers:!0,title:'"src/ticket_operator.rs"'},"use crate::token::{TicketId, TicketOfficeContractRef};\nuse odra::{casper_types::U512, prelude::*};\n\n#[odra::odra_error]\npub enum Error {\n    UnknownTicketOffice = 300,\n}\n\n#[odra::module(errors = Error)]\npub struct TicketOperator {\n    ticket_office_address: Var<Address>,\n}\n\n#[odra::module]\nimpl TicketOperator {\n    pub fn register(&mut self, ticket_office_address: Address) {\n        self.ticket_office_address.set(ticket_office_address);\n    }\n\n    // now the operator's `buy_ticket` receives funds.\n    #[odra(payable)]\n    pub fn buy_ticket(&mut self, ticket_id: TicketId) {\n        let env = self.env();\n        let buyer = env.caller();\n        let value = env.attached_value();\n        let center = self\n            .ticket_office_address\n            .get()\n            .unwrap_or_revert_with(&env, Error::UnknownTicketOffice);\n        let mut ticket_contract = TicketOfficeContractRef::new(env, center);\n        // now and approved entity - the operator - buys the ticket on behalf of the buyer\n        ticket_contract.buy_ticket(ticket_id, buyer, value);\n    }\n\n    pub fn balance_of(&self) -> U512 {\n        self.env().self_balance()\n    }\n}\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"L4-L7")," - Define errors that will be used in the contract."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"L9-L13")," - Define the ",(0,i.kt)("inlineCode",{parentName:"li"},"TicketOperator")," module that stores the address of the ticketing office."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"L16-L18")," - The ",(0,i.kt)("inlineCode",{parentName:"li"},"register")," function sets the address of the ticketing office."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"L20-L32")," - The ",(0,i.kt)("inlineCode",{parentName:"li"},"buy_ticket")," function buys a ticket on behalf of the buyer using the ticket office address. The function forwards the call to the ticketing office contract. We simply create a ",(0,i.kt)("inlineCode",{parentName:"li"},"TicketOfficeContractRef")," to interact we the ",(0,i.kt)("inlineCode",{parentName:"li"},"TicketOffice")," contract. Note that, the operator's ",(0,i.kt)("inlineCode",{parentName:"li"},"buy_ticket")," now receives funds.")),(0,i.kt)("p",null,"Now we need to adjust the ",(0,i.kt)("inlineCode",{parentName:"p"},"TicketOffice")," contract to use the ",(0,i.kt)("inlineCode",{parentName:"p"},"TicketOperator")," contract to buy tickets."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust",metastring:'showLineNumbers title="src/token.rs"',showLineNumbers:!0,title:'"src/token.rs"'},"#[odra::odra_error]\npub enum Error {\n    ...\n    MissingOperator = 204,\n    Unauthorized = 205,\n}\n\n#[odra::module]\npub struct TicketOffice {\n    ...\n    operator: Var<Address>,\n}\n\n#[odra::module]\nimpl TicketOffice {\n    ... \n\n    pub fn register_operator(&mut self, operator: Address) {\n        // only the owner can register an operator\n        let caller = self.env().caller();\n        self.ownable.assert_owner(&caller);\n        // store the ticketing center address in the operator contract\n        TicketOperatorContractRef::new(self.env(), operator).register(self.env().self_address());\n        self.operator.set(operator);\n    }\n\n    pub fn issue_ticket(&mut self, event_name: String, price: U512) {\n        // minting logic remains the same...\n        ...\n\n        // approve the operator to transfer the ticket\n        let operator = self.operator();\n        self.token\n            .approve(operator, Maybe::Some(ticket_id), Maybe::None);\n\n        // emit an event\n        ...\n    }\n\n    pub fn buy_ticket(&mut self, ticket_id: TicketId, buyer: Address, value: U512) {\n        let env = self.env();\n        let owner = self.ownable.get_owner();\n        let caller = env.caller();\n        // make sure the caller is the operator\n        if !self.is_operator(caller) {\n            env.revert(Error::Unauthorized);\n        }\n\n        ...\n        // the logic remains the same, except for the csprs transfer\n        // it is now handled by the operator contract.\n        // env.transfer_tokens(&owner, &value);\n    }\n\n    #[inline]\n    fn is_operator(&self, caller: Address) -> bool {\n        Some(caller) == self.operator.get()\n    }\n\n    #[inline]\n    fn operator(&self) -> Address {\n        self.operator\n            .get()\n            .unwrap_or_revert_with(&self.env(), Error::MissingOperator)\n    }\n}\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"L11")," - the contract stores the operator address."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"L18-L25")," - a new function ",(0,i.kt)("inlineCode",{parentName:"li"},"register_operator")," allows the owner to register an operator. Also calls the ",(0,i.kt)("inlineCode",{parentName:"li"},"register")," entry point on the operator contract."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"L32-36")," - modify the ",(0,i.kt)("inlineCode",{parentName:"li"},"issue_ticket")," function: once a new token is minted, approves the operator to transfer the ticket later."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"L40-L53")," - modify the ",(0,i.kt)("inlineCode",{parentName:"li"},"buy_ticket")," function: check if the caller is the operator, do not transfer cspr to the contract - now the operator collect funds."),(0,i.kt)("li",{parentName:"ul"},"We also added two helper functions: ",(0,i.kt)("inlineCode",{parentName:"li"},"is_operator")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"operator")," to check if the caller is the operator and get the operator address. Two new errors were added: ",(0,i.kt)("inlineCode",{parentName:"li"},"MissingOperator")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"Unauthorized"),".")),(0,i.kt)("p",null,"Now we need to update our tests to create a scenario we presented in the sequence diagram."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust",metastring:'showLineNumbers title="src/tests.rs"',showLineNumbers:!0,title:'"src/tests.rs"'},'use odra::{\n    casper_types::U512,\n    host::{Deployer, HostRef, NoArgs},\n    prelude::*\n};\n\nuse crate::{\n    ticket_operator::TicketOperatorHostRef,\n    token::{Error, TicketId, TicketOfficeContractRef, TicketOfficeInitArgs},\n};\n\n#[test]\nfn it_works() {\n    let env = odra_test::env();\n    let init_args = TicketOfficeInitArgs {\n        collection_name: "Ticket".to_string(),\n        collection_symbol: "T".to_string(),\n        total_supply: 100,\n    };\n    let operator = TicketOperator::deploy(&env, NoArgs);\n    let mut ticket_office = TicketOfficeContractRef::deploy(&env, init_args);\n    ticket_office.register_operator(operator.address().clone());\n    ticket_office.issue_ticket("Ev".to_string(), U512::from(100));\n    ticket_office.issue_ticket("Ev".to_string(), U512::from(50));\n\n    let buyer = env.get_account(1);\n    env.set_caller(buyer);\n\n    assert_eq!(\n        buy_ticket(&operator, 0, 50),\n        Err(Error::InsufficientFunds.into())\n    );\n    assert_eq!(buy_ticket(&operator, 0, 100), Ok(()));\n    assert_eq!(buy_ticket(&operator, 1, 50), Ok(()));\n    assert_eq!(\n        buy_ticket(&operator, 0, 100),\n        Err(Error::TicketNotAvailableForSale.into())\n    );\n\n    assert_eq!(operator.balance_of(), U512::from(150));\n}\n\nfn buy_ticket(operator: &TicketOperatorHostRef, id: TicketId, price: u64) -> OdraResult<()> {\n    operator.with_tokens(U512::from(price)).try_buy_ticket(id)\n}\n\n')),(0,i.kt)("h3",{id:"conclusion"},"Conclusion"),(0,i.kt)("p",null,"In this tutorial, we created a simple ticketing system using the CEP-78 standard. This guide demonstrates how to combine various Odra features, including modules, events, errors, payable functions, and cross-contract calls."))}p.isMDXComponent=!0}}]);