"use strict";(self.webpackChunkodra_website=self.webpackChunkodra_website||[]).push([[26482],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>f});var r=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function c(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),s=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):c(c({},t),e)),n},d=function(e){var t=s(e.components);return r.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},p=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,d=i(e,["components","mdxType","originalType","parentName"]),p=s(n),f=a,m=p["".concat(l,".").concat(f)]||p[f]||u[f]||o;return n?r.createElement(m,c(c({ref:t},d),{},{components:n})):r.createElement(m,c({ref:t},d))}));function f(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,c=new Array(o);c[0]=p;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:a,c[1]=i;for(var s=2;s<o;s++)c[s]=n[s];return r.createElement.apply(null,c)}return r.createElement.apply(null,n)}p.displayName="MDXCreateElement"},84219:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>c,default:()=>u,frontMatter:()=>o,metadata:()=>i,toc:()=>s});var r=n(87462),a=(n(67294),n(3905));const o={},c="Factory",i={unversionedId:"advanced/factory",id:"advanced/factory",title:"Factory",description:"The Factory pattern is a design pattern used in smart contracts to create, manage, and keep track of other smart contracts. A factory contract is a contract that deploys other contracts, acting as a centralized registry for all the contracts it has created. This pattern is particularly useful for applications that require standardized, on-demand contract creation, such as deploying new trading pairs for a DEX, launching NFT collections, or creating instances of multi-signature wallets.",source:"@site/docs/advanced/09-factory.md",sourceDirName:"advanced",slug:"/advanced/factory",permalink:"/docs/next/advanced/factory",draft:!1,tags:[],version:"current",lastUpdatedAt:1771419602,formattedLastUpdatedAt:"Feb 18, 2026",sidebarPosition:9,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Delegating CSPR to Validators",permalink:"/docs/next/advanced/delegating-cspr"},next:{title:"Wasm-Client",permalink:"/docs/next/advanced/wasm-client"}},l={},s=[{value:"A Plain Odra Module",id:"a-plain-odra-module",level:2},{value:"Creating a Factory in Odra",id:"creating-a-factory-in-odra",level:2},{value:"Generated Factory Module",id:"generated-factory-module",level:2},{value:"Factory Entry Points",id:"factory-entry-points",level:2},{value:"Testing the Factory",id:"testing-the-factory",level:2},{value:"Upgrading Child Contracts",id:"upgrading-child-contracts",level:2},{value:"Conclusion",id:"conclusion",level:2}],d={toc:s};function u(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,r.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"factory"},"Factory"),(0,a.kt)("p",null,"The Factory pattern is a design pattern used in smart contracts to create, manage, and keep track of other smart contracts. A factory contract is a contract that deploys other contracts, acting as a centralized registry for all the contracts it has created. This pattern is particularly useful for applications that require standardized, on-demand contract creation, such as deploying new trading pairs for a DEX, launching NFT collections, or creating instances of multi-signature wallets."),(0,a.kt)("h2",{id:"a-plain-odra-module"},"A Plain Odra Module"),(0,a.kt)("p",null,"Before we create a factory, let's define the contract we want to produce. Here is a simple ",(0,a.kt)("inlineCode",{parentName:"p"},"Counter")," contract. It's a standard Odra module with a constructor that initializes the counter value, an increment method, and a getter for the current value."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"#[odra::module]\npub struct Counter {\n    value: Var<u32>\n}\n\n#[odra::module]\nimpl Counter {\n    pub fn init(&mut self, value: u32) {\n        self.value.set(value);\n    }\n\n    pub fn increment(&mut self) {\n        self.value.set(self.value.get_or_default() + 1);\n    }\n\n    pub fn value(&self) -> u32 {\n        self.value.get_or_default()\n    }\n}\n")),(0,a.kt)("h2",{id:"creating-a-factory-in-odra"},"Creating a Factory in Odra"),(0,a.kt)("p",null,"Turning our ",(0,a.kt)("inlineCode",{parentName:"p"},"Counter")," contract into a factory is as simple as adding the ",(0,a.kt)("inlineCode",{parentName:"p"},"factory=on")," attribute to both the ",(0,a.kt)("inlineCode",{parentName:"p"},"struct")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"impl")," blocks of the module.\nOdra will use this to automatically generate the factory logic."),(0,a.kt)("p",null,"Let's update our ",(0,a.kt)("inlineCode",{parentName:"p"},"Counter")," contract to be factory-enabled:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"#[odra::module(factory=on)]\npub struct Counter {\n    // ... previous fields remain unchanged ...\n}\n\n#[odra::module(factory=on)]\nimpl Counter {\n   // ... previous methods remain unchanged ...\n}\n")),(0,a.kt)("h2",{id:"generated-factory-module"},"Generated Factory Module"),(0,a.kt)("p",null,"By adding ",(0,a.kt)("inlineCode",{parentName:"p"},"factory=on"),", you instruct the framework to automatically generate a new, dedicated factory module for your\ncontract. For our ",(0,a.kt)("inlineCode",{parentName:"p"},"Counter")," contract, Odra will generate a ",(0,a.kt)("inlineCode",{parentName:"p"},"CounterFactory")," module."),(0,a.kt)("p",null,"This generated factory contract comes with a set of built-in entry points for managing the lifecycle of child contracts.\nYou do not need to write any of this logic yourself. "),(0,a.kt)("admonition",{type:"note"},(0,a.kt)("p",{parentName:"admonition"},"The generated factory contract does not include any public entry points beyond the factory management functions.")),(0,a.kt)("h2",{id:"factory-entry-points"},"Factory Entry Points"),(0,a.kt)("p",null,"The generated factory contract exposes a standardized set of management entry points. It does not have any other public entry points."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"new_contract(contract_name: String, name: String, price: u64) -> (Address, URref)"),": Deploys a new instance of the child contract (",(0,a.kt)("inlineCode",{parentName:"li"},"Product")," in our case). The arguments required by the child's ",(0,a.kt)("inlineCode",{parentName:"li"},"init")," function must be passed along with an unique contract name. It returns the address of the newly created contract and an access URref to it."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"upgrade_child_contract(contract_name: String)"),": Upgrades a single child contract (previously created by this factory) to the latest version of the child contract's Wasm. Except the contract name, it also takes the ",(0,a.kt)("inlineCode",{parentName:"li"},"upgrade")," function arguments of the child contract."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"batch_upgrade_child_contract<T: Into<odra::casper_types::RuntimeArgs>>(args: BTreeMap<String, T>)"),": Upgrades a list of child contracts in a single transaction. This entry point is a more gas-efficient way to upgrade multiple child contracts at once but requires more complex argument handling.")),(0,a.kt)("h2",{id:"testing-the-factory"},"Testing the Factory"),(0,a.kt)("p",null,"With the factory being automatically generated, testing becomes straightforward. "),(0,a.kt)("p",null,"You can still deploy and interact with the ",(0,a.kt)("inlineCode",{parentName:"p"},"Counter")," contract as a standalone module,\nbut now you can also deploy it via the ",(0,a.kt)("inlineCode",{parentName:"p"},"CounterFactory"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'use odra::{\n    host::{Deployer, HostRef, NoArgs},\n    prelude::*,\n};\n\nuse super::{\n    Counter, CounterFactory, CounterFactoryContractDeployed, CounterHostRef, CounterInitArgs\n};\n\n#[test]\nfn test_standalone_module() {\n    let env = odra_test::env();\n    let mut counter_ref = Counter::deploy(&env, CounterInitArgs { value: 1 });\n    assert_eq!(counter_ref.value(), 1);\n    counter_ref.increment();\n    assert_eq!(counter_ref.value(), 2);\n}\n\n#[test]\nfn test_factory() {\n    let env = odra_test::env();\n    // Deploy the factory contract\n    let mut factory_ref = CounterFactory::deploy(&env, NoArgs);\n    // Use the factory to deploy a new Counter contract with initial value 10\n    let (address, _access_uref) = factory_ref.new_contract(String::from("Counter"), 10);\n    assert!(env.emitted_event(\n        &factory_ref,\n        CounterFactoryContractDeployed {\n            contract_address: address,\n            contract_name: String::from("Counter")\n        }\n    ));\n    // Interact with the newly deployed Counter contract\n    let mut counter_ref = CounterHostRef::new(address, env);\n    // Increment the counter\n    counter_ref.increment();\n    // The value should now be 11\n    assert_eq!(counter_ref.value(), 11);\n}\n\n')),(0,a.kt)("admonition",{type:"note"},(0,a.kt)("p",{parentName:"admonition"},"Along with the factory contract, Odra also generates an event struct for contract deployment events. In our case,\nit's ",(0,a.kt)("inlineCode",{parentName:"p"},"CounterFactoryContractDeployed"),", which is emitted every time a new ",(0,a.kt)("inlineCode",{parentName:"p"},"Counter")," contract is created via the factory.")),(0,a.kt)("h2",{id:"upgrading-child-contracts"},"Upgrading Child Contracts"),(0,a.kt)("p",null,"One of the powerful features of the factory pattern is the ability to upgrade child contracts.\nWhen you upgrade the factory contract itself, it can also upgrade all previously deployed child contracts to the new version."),(0,a.kt)("p",null,"To enable this, ensure that your factory contract is deployed with an upgradable configuration.\nWhen you upgrade the factory, you can call the ",(0,a.kt)("inlineCode",{parentName:"p"},"upgrade_child_contract")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"batch_upgrade_child_contract")," methods to upgrade\nindividual or multiple child contracts respectively. Learn more about contract upgrades in the ",(0,a.kt)("a",{parentName:"p",href:"/docs/next/tutorials/upgrades"},"Upgrades")," section."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'#[odra::module(factory=on)]\npub struct CounterV2 {\n    value: Var<u32>\n}\n\n#[odra::module(factory=on)]\nimpl CounterV2 {\n    // ... v1 methods remain unchanged ...\n\n    pub fn upgrade(&mut self, new_value: u32) {\n        self.value.set(new_value);\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use odra::{\n        host::{Deployer, HostRef, InstallConfig, NoArgs},\n        prelude::*,\n        VmError\n    };\n    use super::*;\n\n    #[test]\n    fn test_factory_upgrade_works() {\n        let env = odra_test::env();\n        // Deploy the factory contract\n        let mut factory = CounterFactory::deploy_with_cfg(\n            &env,\n            NoArgs,\n            InstallConfig::upgradable::<CounterFactory>()\n        );\n        let (ten_address, _) = factory.new_contract(String::from("FromTen"), 10);\n        let (two_address, _) = factory.new_contract(String::from("FromTwo"), 2);\n        let (three_address, _) = factory.new_contract(String::from("FromThree"), 3);\n        let (hundred_address, _) = factory.new_contract(String::from("FromHundred"), 100);\n\n        // Upgrade the factory contract\n        let result = CounterV2Factory::try_upgrade(&env, factory.address(), NoArgs);\n        assert!(result.is_ok());\n\n        let mut factory = result.unwrap();\n        // Upgrade individual child contracts\n        factory.upgrade_child_contract(String::from("FromTen"), 122);\n        factory.upgrade_child_contract(String::from("FromTwo"), 11);\n\n        // Verify upgraded values\n        assert_eq!(CounterHostRef::new(ten_address, env.clone()).value(), 122);\n        assert_eq!(CounterHostRef::new(two_address, env.clone()).value(), 11);\n\n        // Batch upgrade child contracts\n        let args = vec![\n            ("FromTwo".to_string(), 42u32),\n            ("FromThree".to_string(), 42u32),\n            ("FromHundred".to_string(), 1000u32),\n        ]\n        .into_iter()\n        .map(|(contract_name, new_value)| (contract_name, CounterV2UpgradeArgs { new_value }))\n        .collect::<BTreeMap<_, _>>();\n        factory.batch_upgrade_child_contract(args);\n\n        // Verify upgraded values\n        assert_eq!(CounterHostRef::new(ten_address, env.clone()).value(), 122);\n        assert_eq!(CounterHostRef::new(two_address, env.clone()).value(), 42);\n        assert_eq!(CounterHostRef::new(three_address, env.clone()).value(), 42);\n        assert_eq!(\n            CounterHostRef::new(hundred_address, env.clone()).value(),\n            1000\n        );\n    }\n}\n')),(0,a.kt)("p",null,"In the above example, we utilized the ",(0,a.kt)("inlineCode",{parentName:"p"},"CounterV2UpgradeArgs")," struct to pass the new initialization parameters during the upgrade process.\nWe can do this becase any ",(0,a.kt)("inlineCode",{parentName:"p"},"UpgradeArgs")," struct implements the ",(0,a.kt)("inlineCode",{parentName:"p"},"Into<RuntimeArgs>")," trait, allowing seamless conversion when upgrading contracts."),(0,a.kt)("h2",{id:"conclusion"},"Conclusion"),(0,a.kt)("p",null,"In this section, we explored how to implement the Factory pattern in Odra by simply adding the ",(0,a.kt)("inlineCode",{parentName:"p"},"factory=on")," attribute to our module.\nThis enables automatic generation of a factory contract that can deploy and manage instances of the child contract.\nWe also discussed how to upgrade child contracts through the factory, leveraging Odra's built-in upgrade mechanisms."))}u.isMDXComponent=!0}}]);