"use strict";(self.webpackChunkodra_website=self.webpackChunkodra_website||[]).push([[9345],{3905:(e,t,r)=>{r.d(t,{Zo:()=>u,kt:()=>m});var n=r(67294);function o(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function a(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?a(Object(r),!0).forEach((function(t){o(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,n,o=function(e,t){if(null==e)return{};var r,n,o={},a=Object.keys(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||(o[r]=e[r]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(o[r]=e[r])}return o}var l=n.createContext({}),p=function(e){var t=n.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},u=function(e){var t=p(e.components);return n.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var r=e.components,o=e.mdxType,a=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),d=p(r),m=o,h=d["".concat(l,".").concat(m)]||d[m]||c[m]||a;return r?n.createElement(h,i(i({ref:t},u),{},{components:r})):n.createElement(h,i({ref:t},u))}));function m(e,t){var r=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=r.length,i=new Array(a);i[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,i[1]=s;for(var p=2;p<a;p++)i[p]=r[p];return n.createElement.apply(null,i)}return n.createElement.apply(null,r)}d.displayName="MDXCreateElement"},53309:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>c,frontMatter:()=>a,metadata:()=>s,toc:()=>p});var n=r(87462),o=(r(67294),r(3905));const a={slug:"casper-zk-risc0",title:"Zero Knowledge on Casper",authors:["zie1ony"],image:"https://github.com/odradev.png"},i=void 0,s={permalink:"/blog/casper-zk-risc0",source:"@site/blog/2022-12-12-casper-zk-risc0.md",title:"Zero Knowledge on Casper",description:"In this post, I present how to verify a zero knowledge proof on Casper.",date:"2022-12-12T00:00:00.000Z",formattedDate:"December 12, 2022",tags:[],readingTime:4.215,hasTruncateMarker:!0,authors:[{name:"Maciej Zieli\u0144ski",title:"CTO",url:"https://github.com/zie1ony",key:"zie1ony"}],frontMatter:{slug:"casper-zk-risc0",title:"Zero Knowledge on Casper",authors:["zie1ony"],image:"https://github.com/odradev.png"},prevItem:{title:"EVM at Risc0",permalink:"/blog/evm-at-risc0"},nextItem:{title:"Odra 0.2.0 Released",permalink:"/blog/release-020"}},l={authorsImageUrls:[void 0]},p=[{value:"Zero Knowledge",id:"zero-knowledge",level:2},{value:"Risc Zero",id:"risc-zero",level:2},{value:"Example",id:"example",level:2},{value:"Guest",id:"guest",level:3},{value:"Prover",id:"prover",level:3},{value:"Verifier",id:"verifier",level:3},{value:"Livenet results",id:"livenet-results",level:3},{value:"What next",id:"what-next",level:2},{value:"Join us",id:"join-us",level:2}],u={toc:p};function c(e){let{components:t,...r}=e;return(0,o.kt)("wrapper",(0,n.Z)({},u,r,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"In this post, I present how to verify a zero knowledge proof on Casper."),(0,o.kt)("h2",{id:"zero-knowledge"},"Zero Knowledge"),(0,o.kt)("p",null,"In my opinion, the ",(0,o.kt)("strong",{parentName:"p"},"zero knowledge")," (ZK) is the largest revolution in\nblockchains, since Ethereum introduced Turing-complete, account-based\nsmart contracts.\nTo put it in simple words, ZK enables two use cases not possible before:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Computation scaling - I can perform expensive computation off-chain\nand put the result on a chain with the proof."),(0,o.kt)("li",{parentName:"ol"},"Anonymity - I can prove to you, I know something without revealing it. ")),(0,o.kt)("h2",{id:"risc-zero"},"Risc Zero"),(0,o.kt)("p",null,"I'd like to introduce you to ",(0,o.kt)("a",{parentName:"p",href:"https://www.risczero.com/"},"Risc Zero"),".\nIt is the general purpose zero-knowledge virtual machine.\nGo ahead and spend time reading their website!\nFor us, the key component is the proof verifier that can be compiled into WASM.\nSooo... we can run it on Casper :)\nYes! We can prove any program, produce proof, and send it to Casper's\nsmart contract for verification."),(0,o.kt)("h2",{id:"example"},"Example"),(0,o.kt)("p",null,"Let's dive into the example to see how it works.\n",(0,o.kt)("a",{parentName:"p",href:"https://github.com/odradev/casper-zk-with-risc0"},"The full example code"),"\nyou can find on our GitHub.\nIt is based on Risc Zero's ",(0,o.kt)("a",{parentName:"p",href:"https://www.risczero.com/docs/examples/hello_multiply"},"Hello, Multiply!"),"\nexample. So make sure you understand it first.\n",(0,o.kt)("a",{parentName:"p",href:"#guest"},"Guest")," and ",(0,o.kt)("a",{parentName:"p",href:"#prover"},"Prover")," sections are taken from this example."),(0,o.kt)("h3",{id:"guest"},"Guest"),(0,o.kt)("p",null,"The program we are proving is called a ",(0,o.kt)("strong",{parentName:"p"},"guest")," in Risc Zero.\nOur goal is to prove we know the factors of an arbitrary number.\nGiven ",(0,o.kt)("inlineCode",{parentName:"p"},"a")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"b")," below guest program computes ",(0,o.kt)("inlineCode",{parentName:"p"},"a * b")," and produces\na proof of computation."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="methods/guest/src/multiply.rs"',title:'"methods/guest/src/multiply.rs"'},'pub fn main() {\n    // Load the first number from the host\n    let a: u64 = env::read();\n    // Load the second number from the host\n    let b: u64 = env::read();\n    // Verify that neither of them are 1 (i.e. nontrivial factors)\n    if a == 1 || b == 1 {\n        panic!("Trivial factors")\n    }\n    // Compute the product while being careful with integer overflow\n    let product = a.checked_mul(b).expect("Integer overflow");\n    env::commit(&product);\n}\n')),(0,o.kt)("h3",{id:"prover"},"Prover"),(0,o.kt)("p",null,"It's time to run the guest program and build the proof for\na specific ",(0,o.kt)("inlineCode",{parentName:"p"},"a")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"b")," values."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="prover/src/main.rs"',title:'"prover/src/main.rs"'},'fn main() {\n    // Pick two numbers.\n    let a: u64 = 17;\n    let b: u64 = 23;\n\n    // First, we make the prover, loading the \'multiply\' method.\n    let multiply_src = std::fs::read(MULTIPLY_PATH)\n        .expect("Method code should be present at the specified path.");\n    let mut prover = Prover::new(&multiply_src, MULTIPLY_ID)\n        .expect("Prover should be constructed.",);\n\n    // Next we send a & b to the guest.\n    prover.add_input_u32_slice(to_vec(&a).unwrap().as_slice());\n    prover.add_input_u32_slice(to_vec(&b).unwrap().as_slice());\n    \n    // Run prover & generate receipt\n    let receipt = prover.run()\n        .expect("Valid code should be provable.");\n\n    // Extract journal of receipt (i.e. output c, where c = a * b)\n    let c: u64 = from_slice(&receipt.journal)\n        .expect("Journal output should deserialize.");\n\n    // Print an assertion\n    println!("I know the factors of {}, and I can prove it!", c);\n\n    // Verify receipt, panic if it\'s wrong.\n    receipt.verify(MULTIPLY_ID).expect(\n        "Code you have proven should successfully verify.",\n    );\n\n    // Convert journal to string and store on disk.\n    let journal = serde_json::to_string(&receipt.journal).unwrap();\n    write_to_file("../data/journal", &journal);\n\n    // Convert seal to string and store on disk.\n    let seal = serde_json::to_string(&receipt.seal).unwrap();\n    write_to_file("../data/seal", &seal);\n\n    // Convert method_id to string and store on disk.\n    let result = serde_json::to_string(MULTIPLY_ID).unwrap();\n    write_to_file("../data/method", &result);\n}\n')),(0,o.kt)("h3",{id:"verifier"},"Verifier"),(0,o.kt)("p",null,"Now the verification step.\nGiven the proof (journal + seal) and the guest program definition (method),\nCasper's smart contract checks its correctness. This one is written\njust for the demonstration, but in general you want ",(0,o.kt)("inlineCode",{parentName:"p"},"METHOD_ID")," to be\nstored in your contract and both ",(0,o.kt)("inlineCode",{parentName:"p"},"SEAL")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"JOURNAL")," to be passed to\nthe contract via arguments from the outside."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="verifier/src/verifier_contract.rs"',title:'"verifier/src/verifier_contract.rs"'},'// Import the proof and the method.\nconst METHOD_ID: &[u8] = &include!("../../data/method");\nconst SEAL: &[u32] = &include!("../../data/seal");\nconst JOURNAL: &[u32] = &include!("../../data/journal");\n\n// Verifier contract holds a result of the zk verification. \n#[odra::module]\npub struct Verifier {\n    result: Variable<String>,\n}\n\n#[odra::module]\nimpl Verifier {\n    // Calling this entry point triggers the zk proof verification.\n    pub fn verify(&mut self) {\n        let result = verify(JOURNAL, SEAL, METHOD_ID);\n        self.result.set(result);\n    }\n\n    // Result getter.\n    pub fn result(&self) -> String {\n        self.result.get().unwrap_or(String::from("Not processed"))\n    }\n}\n\n// The verification method. It constructs new Receipt and verifies it.\nfn verify(journal: &[u32], seal: &[u32], method_id: &[u8]) -> String {\n    let result = Receipt::new(&journal, &seal).verify(method_id);\n\n    match result {\n        Ok(()) => String::from("Ok"),\n        Err(err) => format!("Error: {}", err.to_string())\n    }\n}\n')),(0,o.kt)("h3",{id:"livenet-results"},"Livenet results"),(0,o.kt)("p",null,"I have deployed it to the testnet and called the ",(0,o.kt)("inlineCode",{parentName:"p"},"verify")," method.\nThe ",(0,o.kt)("inlineCode",{parentName:"p"},"result")," was ",(0,o.kt)("inlineCode",{parentName:"p"},"Ok"),". Wow, first-ever ZK proof verification on Casper.\nTrustless bridging, layer 2 here we come :)"),(0,o.kt)("p",null,"The cost of running the ",(0,o.kt)("inlineCode",{parentName:"p"},"verify")," method is ",(0,o.kt)("inlineCode",{parentName:"p"},"2324 CSPR"),". That's a lot, but\nwe have to start somewhere."),(0,o.kt)("h2",{id:"what-next"},"What next"),(0,o.kt)("p",null,"I think it is a good place to outline possible Casper ZK goals for moving\nthis forward. The community should discuss: "),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Building more examples. Risc Zero has a nice battleship game to port over\nto Casper."),(0,o.kt)("li",{parentName:"ol"},"Adding Risc Zero verification method to Casper's FFI."),(0,o.kt)("li",{parentName:"ol"},"Supporting Risc Zero team. We should help develop this awesome\nopen-source project and gain the ZK expertise.")),(0,o.kt)("h2",{id:"join-us"},"Join us"),(0,o.kt)("p",null,"Interested in zero knowledge on Casper?"),(0,o.kt)("p",null,"Join ",(0,o.kt)("a",{parentName:"p",href:"https://discord.gg/Mm5ABc9P8k"},"our Discord"),", ",(0,o.kt)("a",{parentName:"p",href:"https://twitter.com/odradev"},"our Twitter")," or write us\nat ",(0,o.kt)("a",{parentName:"p",href:"mailto:contact@odra.dev"},"contact@odra.dev"),"."))}c.isMDXComponent=!0}}]);