"use strict";(self.webpackChunkodra_website=self.webpackChunkodra_website||[]).push([[3095],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var r=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=r.createContext({}),c=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=c(e.components);return r.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),d=c(n),m=a,f=d["".concat(s,".").concat(m)]||d[m]||p[m]||i;return n?r.createElement(f,o(o({ref:t},u),{},{components:n})):r.createElement(f,o({ref:t},u))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,o[1]=l;for(var c=2;c<i;c++)o[c]=n[c];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},84710:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>p,frontMatter:()=>i,metadata:()=>l,toc:()=>c});var r=n(87462),a=(n(67294),n(3905));const i={slug:"evm-at-risc0",title:"EVM at Risc0",authors:["zie1ony"],image:"https://github.com/odradev.png"},o=void 0,l={permalink:"/blog/evm-at-risc0",source:"@site/blog/2023-02-13-evm-at-risc0.md",title:"EVM at Risc0",description:"Let's run Solidity code inside SputnikVM inside Risc0.",date:"2023-02-13T00:00:00.000Z",formattedDate:"February 13, 2023",tags:[],readingTime:3.97,hasTruncateMarker:!0,authors:[{name:"Maciej Zieli\u0144ski",title:"CTO",url:"https://github.com/zie1ony",key:"zie1ony"}],frontMatter:{slug:"evm-at-risc0",title:"EVM at Risc0",authors:["zie1ony"],image:"https://github.com/odradev.png"},prevItem:{title:"Odra + CosmWasm",permalink:"/blog/odra-cosmwasm"},nextItem:{title:"Zero Knowledge on Casper",permalink:"/blog/casper-zk-risc0"}},s={authorsImageUrls:[void 0]},c=[{value:"Solidity",id:"solidity",level:2},{value:"EVM",id:"evm",level:2},{value:"Risc0",id:"risc0",level:2},{value:"Conclusion",id:"conclusion",level:2},{value:"Join us",id:"join-us",level:2}],u={toc:c};function p(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"Let's run Solidity code inside ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/rust-blockchain/evm/"},"SputnikVM")," inside ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/risc0/risc0"},"Risc0"),"."),(0,a.kt)("p",null,"First make sure you know how Risc0 works.\nMy ",(0,a.kt)("a",{parentName:"p",href:"/blog/casper-zk-risc0"},"previous post")," explains it."),(0,a.kt)("p",null,"If you want to jump directly to the full code example, it's in the ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/odradev/evm-at-risc0"},"repo"),"."),(0,a.kt)("h2",{id:"solidity"},"Solidity"),(0,a.kt)("p",null,"As an example, I have this simple Solidity code.\nIt is a calculator with two functions.\nOne for addition and one for the nth Fibonacci number."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity",metastring:'title="bytecode/Calculator.sol"',title:'"bytecode/Calculator.sol"'},"contract Calculator {\n    function add(uint256 a, uint256 b) public pure returns (uint256) {\n        return a + b;\n    }\n\n    function fibonacci(uint256 n) public returns (uint256) {\n        if (n <= 1) {\n            return n;\n        } else {\n            return fibonacci(n - 1) + fibonacci(n - 2);\n        }\n    }\n}\n")),(0,a.kt)("p",null,"It needs to be compiled into the byte code. ",(0,a.kt)("inlineCode",{parentName:"p"},"solc")," can do this."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"$ solc \\\n    --bin-runtime \\\n    --optimize \\\n    --overwrite \\\n    --evm-version istanbul \\\n    --output-dir bytecode \\\n    bytecode/Calculator.sol  \n")),(0,a.kt)("p",null,"It produces an EVM bytecode in the ",(0,a.kt)("inlineCode",{parentName:"p"},"bytecode")," directory."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"$ ls bytecode/\nCalculator.bin-runtime  Calculator.sol\n")),(0,a.kt)("h2",{id:"evm"},"EVM"),(0,a.kt)("p",null,"The EVM I used is ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/rust-blockchain/evm/"},"SputnikVM"),".\nMost important it is written in pure Rust and even with ",(0,a.kt)("inlineCode",{parentName:"p"},"no_std")," mode.\nThis way I can start an in-memory instance of EVM.\nThen take the bytecode of a contract and install it.\nFinally, call the contract with arguments and obtain the result value.\nFor now, it's just a Rust code. Risc0 comes later."),(0,a.kt)("p",null,"The code is based on Sputnik's ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/rust-blockchain/evm/blob/master/benches/loop.rs"},"benchmark test"),".\nHuge thanks to ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/birchmd"},"Michael Birch")," for helping with Sputnik.\nAlso make sure how EVM's ",(0,a.kt)("a",{parentName:"p",href:"https://solidity-by-example.org/function-selector"},"function selectors")," work."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="evm-runner/src/lib.rs"',title:'"evm-runner/src/lib.rs"'},'\n// Load previously compiled Calculator contract.\npub const CALCULATOR_EVM_PROGRAM: &str = include_str!(\n    "../../bytecode/Calculator.bin-runtime"\n);\n\n// Run Calculator for a given input.\npub fn run_calc_contract(input: &str) -> String {\n    run_evm(CALCULATOR_EVM_PROGRAM, input)\n}\n\n// Run a program (contract) for a given input. \nfn run_evm(program: &str, input: &str) -> String {\n\n    // Define EVM configuration.\n    let config = Config::istanbul();\n    let vicinity = MemoryVicinity {\n        gas_price: U256::zero(),\n        origin: H160::default(),\n        block_hashes: Vec::new(),\n        block_number: Default::default(),\n        block_coinbase: Default::default(),\n        block_timestamp: Default::default(),\n        block_difficulty: Default::default(),\n        block_gas_limit: Default::default(),\n        chain_id: U256::one(),\n        block_base_fee_per_gas: U256::zero(),\n    };\n\n    // Initialized the state of EVM\'s memory.\n    let mut state = BTreeMap::new();\n\n    // Add our contract under the 0x10 address.\n    state.insert(\n        H160::from_str("0x1000000000000000000000000000000000000000")\n            .unwrap(),\n        MemoryAccount {\n            nonce: U256::one(),\n            balance: U256::from(10000000),\n            storage: BTreeMap::new(),\n            code: hex::decode(program).unwrap(),\n        }\n    );\n\n    // Add new user 0xf0 that will be used as the contract caller.\n    state.insert(\n        H160::from_str("0xf000000000000000000000000000000000000000")\n            .unwrap(),\n        MemoryAccount {\n            nonce: U256::one(),\n            balance: U256::from(10000000),\n            storage: BTreeMap::new(),\n            code: Vec::new(),\n        },\n    );\n\n    // Prepare the executor.\n    let backend = MemoryBackend::new(&vicinity, state);\n    let metadata = StackSubstateMetadata::new(u64::MAX, &config);\n    let state = MemoryStackState::new(metadata, &backend);\n    let precompiles = BTreeMap::new();\n    let mut executor \n        = StackExecutor::new_with_precompiles(state, &config, &precompiles);\n\n    // Call the 0x10 contract using the 0xf0 user.\n    // Use the input variable. \n    let (exit_reason, result) = executor.transact_call(\n        H160::from_str("0xf000000000000000000000000000000000000000")\n            .unwrap(),\n        H160::from_str("0x1000000000000000000000000000000000000000")\n            .unwrap(),\n        U256::zero(),\n        hex::decode(input).unwrap(),\n        u64::MAX,\n        Vec::new(),\n    );\n\n    // Make sure the execution succeeded.\n    assert!(exit_reason == ExitReason::Succeed(ExitSucceed::Returned));\n    \n    // Return hex encoded string.\n    hex::encode(result)\n}\n')),(0,a.kt)("p",null,"Let's execute it. In below tests the ",(0,a.kt)("inlineCode",{parentName:"p"},"data")," variable hold two things:\nfunction selector and arguments."),(0,a.kt)("p",null,"For example ",(0,a.kt)("inlineCode",{parentName:"p"},"61047ff4000000000000000000000000000000000000000000000000000000000000000a"),"\nis concatination of the function selector (first 8 chars) and 256-bit long argument.\nIt is just ",(0,a.kt)("inlineCode",{parentName:"p"},"fibonacci(10)"),". ",(0,a.kt)("inlineCode",{parentName:"p"},"a")," is hex of ",(0,a.kt)("inlineCode",{parentName:"p"},"10")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"37")," is hex of ",(0,a.kt)("inlineCode",{parentName:"p"},"52"),". "),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="evm-runner/src/lib.rs"',title:'"evm-runner/src/lib.rs"'},'#[test]\nfn fibonacci_works() {\n    let data = "61047ff4000000000000000000000000000000000000000000000000000000000000000a";\n    let result = run_calc_contract(data);\n    assert_eq!(result, "0000000000000000000000000000000000000000000000000000000000000037");  \n}\n\n#[test]\nfn addition_works() {\n    let data = "771602f700000000000000000000000000000000000000000000000000000000000000070000000000000000000000000000000000000000000000000000000000000002";\n    let result = run_calc_contract(data);\n    assert_eq!(result, "0000000000000000000000000000000000000000000000000000000000000009");\n}\n')),(0,a.kt)("h2",{id:"risc0"},"Risc0"),(0,a.kt)("p",null,"It's time for ",(0,a.kt)("inlineCode",{parentName:"p"},"risc0"),"."),(0,a.kt)("p",null,"First the guest program.\nIt is super simple.\nIt takes a string as an argument,\npasses it to the ",(0,a.kt)("inlineCode",{parentName:"p"},"run_calc_contract"),"\nand returns the result."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust",metastring:"title=methods/guest/src/bin/evm_calc.rs",title:"methods/guest/src/bin/evm_calc.rs"},"#![no_main]\n#![no_std]\n\nextern crate alloc;\n\nuse alloc::{string::String};\nuse risc0_zkvm::guest::{env};\nuse evm_runner::run_calc_contract;\n\nrisc0_zkvm::guest::entry!(main);\n\npub fn main() {\n    let input: String = env::read();\n    let result = run_calc_contract(&input);\n    env::commit(&result);\n}\n")),(0,a.kt)("p",null,"The final step is calling it under ZK."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust",metastring:"title=host/src/main.rs",title:"host/src/main.rs"},'fn main() {\n    println!("Proving Calculator.add(7, 2)");\n    let input = "771602f700000000000000000000000000000000000000000000000000000000000000070000000000000000000000000000000000000000000000000000000000000002";\n    let result = run_prover(input);\n    println!("Proof generated. 7 + 2 = {result}");\n    \n    println!("Proving Calculator.fibonacci(4)");\n    let input = "61047ff40000000000000000000000000000000000000000000000000000000000000004";\n    let result = run_prover(input);\n    println!("Proof generated. fibonacci(4) = {result}");\n}\n\nfn run_prover(input: &str) -> u32 {\n    // Make the prover.\n    let method_code = std::fs::read(EVM_CALC_PATH).unwrap();\n    let mut prover = Prover::new(&method_code, EVM_CALC_ID).unwrap();\n\n    // Push the input as an argument.\n    prover.add_input_u32_slice(to_vec(input).unwrap().as_slice());\n    \n    // Execute the prover.\n    let receipt = prover.run().unwrap();\n    \n    // Verify the proof.\n    assert!(receipt.verify(EVM_CALC_ID).is_ok());\n    \n    // Return result as an u32 value.\n    let result: String = from_slice(receipt.journal.as_slice()).unwrap();\n    u32::from_str_radix(&result, 16).unwrap()\n}\n')),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"$ cargo run --release -p host\nProving Calculator.add(7, 2)\nProof generated. 7 + 2 = 9\nProving Calculator.fibonacci(4)\nProof generated. fibonacci(4) = 3\n")),(0,a.kt)("h2",{id:"conclusion"},"Conclusion"),(0,a.kt)("p",null,"How amazing and mindblowing it is!\nOf course, it's just a proof of concept.\nYet with further development of Risc0 improving its proving time and\nwith more flexible SputnikVM this approach is more than promising."),(0,a.kt)("h2",{id:"join-us"},"Join us"),(0,a.kt)("p",null,"Interested?"),(0,a.kt)("p",null,"Join ",(0,a.kt)("a",{parentName:"p",href:"https://discord.gg/Mm5ABc9P8k"},"our Discord"),", ",(0,a.kt)("a",{parentName:"p",href:"https://twitter.com/odradev"},"our Twitter")," or write us\nat ",(0,a.kt)("a",{parentName:"p",href:"mailto:contact@odra.dev"},"contact@odra.dev"),"."))}p.isMDXComponent=!0}}]);