"use strict";(self.webpackChunkodra_website=self.webpackChunkodra_website||[]).push([[6671],{3905:(e,t,a)=>{a.d(t,{Zo:()=>c,kt:()=>m});var n=a(67294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function s(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?s(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):s(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},s=Object.keys(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var l=n.createContext({}),p=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},c=function(e){var t=p(e.components);return n.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,s=e.originalType,l=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),u=p(a),m=r,g=u["".concat(l,".").concat(m)]||u[m]||d[m]||s;return a?n.createElement(g,i(i({ref:t},c),{},{components:a})):n.createElement(g,i({ref:t},c))}));function m(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var s=a.length,i=new Array(s);i[0]=u;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o.mdxType="string"==typeof e?e:r,i[1]=o;for(var p=2;p<s;p++)i[p]=a[p];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},20210:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>s,metadata:()=>o,toc:()=>p});var n=a(87462),r=(a(67294),a(3905));const s={slug:"Nysa",title:"Nysa",authors:["kpob"],image:"./twitter-card.png"},i=void 0,o={permalink:"/blog/Nysa",source:"@site/blog/2023-08-18-nysa/index.md",title:"Nysa",description:'The Oder River, known as "Odra" in Polish, is one of the major rivers in Poland. It flows for approximately 854 kilometers, originating in the Czech Republic and flowing through southwestern Poland before emptying into the Baltic Sea. The river is a vital transportation route, connecting several Polish cities, including Wroc\u0142aw, Szczecin, and Gda\u0144sk, to international waterways. The Oder also plays a significant role in the region\'s ecology, supporting diverse habitats and species. Its watershed area spans multiple countries, making it a part of various international cooperation initiatives aimed at water management and environmental conservation.',date:"2023-08-18T00:00:00.000Z",formattedDate:"August 18, 2023",tags:[],readingTime:8.47,hasTruncateMarker:!0,authors:[{name:"Krzysztof Pobiar\u017cyn",title:"Lead Developer",url:"https://github.com/kpob",key:"kpob"}],frontMatter:{slug:"Nysa",title:"Nysa",authors:["kpob"],image:"./twitter-card.png"},nextItem:{title:"It's all about the community!",permalink:"/blog/its-all-about-the-community"}},l={image:a(46180).Z,authorsImageUrls:[void 0]},p=[{value:"Odra",id:"odra",level:2},{value:"Nysa",id:"nysa",level:2},{value:"Nysa + Odra",id:"nysa--odra",level:3},{value:"Examples",id:"examples",level:2},{value:"Status message",id:"status-message",level:3},{value:"CappedErc20",id:"cappederc20",level:3},{value:"Conclusion",id:"conclusion",level:2}],c={toc:p};function d(e){let{components:t,...s}=e;return(0,r.kt)("wrapper",(0,n.Z)({},c,s,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,'The Oder River, known as "Odra" in Polish, is one of the major rivers in Poland. It flows for approximately 854 kilometers, originating in the Czech Republic and flowing through southwestern Poland before emptying into the Baltic Sea. The river is a vital transportation route, connecting several Polish cities, including Wroc\u0142aw, Szczecin, and Gda\u0144sk, to international waterways. The Oder also plays a significant role in the region\'s ecology, supporting diverse habitats and species. Its watershed area spans multiple countries, making it a part of various international cooperation initiatives aimed at water management and environmental conservation.'),(0,r.kt)("p",null,"The Nysa K\u0142odzka is a significant river in Poland, flowing through the country's southwestern part. It travels approximately 188 kilometers, originating in the Czech Republic and merging with the Oder River in Poland. The river passes through picturesque landscapes, including the K\u0142odzko Valley, and plays a crucial role in local ecosystems. Its waters are harnessed for various purposes, such as hydroelectric power generation and irrigation."),(0,r.kt)("p",null,"Oh, wait, shouldn't it be a tech blog?"),(0,r.kt)("p",null,"This is a valid question, we will get back to it in a moment."),(0,r.kt)("h2",{id:"odra"},"Odra"),(0,r.kt)("p",null,"A short reminder:"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Odra is a high-level smart contract framework for Rust, which encourages rapid development and clean, pragmatic design ...\nit takes care of much of the hassle of smart contract development, enabling you to focus on writing your dapp without reinventing the wheel. "),(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("a",{parentName:"p",href:"https://odra.dev/docs/"},"Odra"))),(0,r.kt)("p",null,"Understanding that people generally dislike learning new things, we've kept this in mind throughout development. Since day one, we have focused on creating Odra with the largest group of smart contract developers in mind - those familiar with Solidity. The Odra Framework is designed to flatten the learning curve for this group."),(0,r.kt)("p",null,"A Solidity developer will encounter familiar concepts such as:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Constructors"),(0,r.kt)("li",{parentName:"ul"},"Payable functions"),(0,r.kt)("li",{parentName:"ul"},"Mappings"),(0,r.kt)("li",{parentName:"ul"},"Reverts"),(0,r.kt)("li",{parentName:"ul"},"Current caller"),(0,r.kt)("li",{parentName:"ul"},"Current block time"),(0,r.kt)("li",{parentName:"ul"},"A standard module library (similar to OpenZeppelin)"),(0,r.kt)("li",{parentName:"ul"},"And more")),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"It's important to note that the Odra Framework is intentionally blockchain-agnostic. Its design does not target any particular blockchain. "),(0,r.kt)("p",{parentName:"admonition"},"Ultimately, Odra is built to support multiple blockchains, allowing the writing of smart contracts in Rust.")),(0,r.kt)("p",null,"Having so many similarities, why not take the next step and transpile Solidity code into Odra code?"),(0,r.kt)("p",null,"This is where Nysa comes into play."),(0,r.kt)("h2",{id:"nysa"},"Nysa"),(0,r.kt)("p",null,"Solidity and Rust share some syntax similarities despite being designed for different purposes. Both languages emphasize strong typing, pattern matching, and immutability by default."),(0,r.kt)("p",null,"Nysa performs Solidity-to-Rust transpilation through four simple steps."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"nysa-gen",src:a(12112).Z,width:"661",height:"591"})),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Solidity Parser"))),(0,r.kt)("p",null,"Firstly, we need a well-structured Rust representation of Solidity code. Nysa utilizes ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/lalrpop/lalrpop"},"LALRPOP")," - a Rust parser generator framework. In the further steps, this enables us to conduct static analysis of the Solidity code, ranging from contract context down to individual expressions."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:"title=solidity-parser/src/pt.rs",title:"solidity-parser/src/pt.rs"},"// The representation of a Solidity contract\n#[derive(Debug, PartialEq)]\npub struct ContractDefinition {\n    pub doc: Vec<DocComment>,\n    pub loc: Loc,\n    pub ty: ContractTy,\n    pub name: Identifier,\n    pub base: Vec<Base>,\n    pub parts: Vec<ContractPart>,\n}\n")),(0,r.kt)("ol",{start:2},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"C3 Linearization"))),(0,r.kt)("p",null,"One of the most notable distinctions between Rust and Solidity is their approach to inheritance. Rust says ",(0,r.kt)("inlineCode",{parentName:"p"},"No, thx"),", whereas Solidity opts for ",(0,r.kt)("inlineCode",{parentName:"p"},"The more, the better"),". Speaking more technically, Solidity supports multiple inheritance with ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/C3_linearization"},"C3 linearization"),"."),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"The primary purpose of the C3 Linearization Algorithm is to establish a consistent and unambiguous order of method resolution in cases where there might be ambiguity or conflicts due to multiple inheritance. It ensures that the inherited methods are called in a predictable and well-defined sequence based on the class hierarchy and the order in which classes are defined.")),(0,r.kt)("p",null,"For simulating C3 linearization, Nysa utilizes an ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/odradev/c3-lang"},"implementation")," of the C3 linearization in Rust written by ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/zie1ony"},"Maciej Zieli\u0144ski"),", so everything stays in the Odra family."),(0,r.kt)("ol",{start:3},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Nysa Parser"))),(0,r.kt)("p",null,"After that, we step to the essential part, converting Solidity code into Rust code."),(0,r.kt)("p",null,"For example, a Solidity event."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"event Transfer(address indexed from, address indexed to, uint256 value);\n")),(0,r.kt)("p",null,"can easily be represented as an plain Rust struct - the same name, the same fields, similar types. "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"#[derive(PartialEq, Eq, Debug)]\npub struct Transfer {\n    from: Option<Address>,\n    to: Option<Address>,\n    value: U256,\n}\n")),(0,r.kt)("p",null,"The same we do with contracts, interfaces, libraries, errors, variables, functions, statements, etc."),(0,r.kt)("p",null,"Here is a snippet of the expression parser:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:"title=nysa/src/parser/odra/expr/mod.rs",title:"nysa/src/parser/odra/expr/mod.rs"},"pub fn parse<T>(expression: &Expression, ctx: &mut T) -> Result<syn::Expr, ParserError>\nwhere\n    T: StorageInfo + TypeInfo + EventsRegister + ExternalCallsRegister + ContractInfo + FnContext,\n{\n    match expression {\n        Expression::Require { condition, error } => error::revert(Some(condition), error, ctx),\n        Expression::ZeroAddress => Ok(parse_quote!(None)),\n        Expression::Add { left, right } => math::add(left, right, ctx),\n        Expression::Subtract { left, right } => math::sub(left, right, ctx),\n        Expression::Increment { expr } => {\n            let expr = parse(expr, ctx)?;\n            Ok(parse_quote!(#expr += 1))\n        }\n        Expression::ExternalCall {\n            variable,\n            fn_name,\n            args,\n        } => parse_ext_call(variable, fn_name, args, ctx),\n        Expression::Type { ty } => {\n            let ty = ty::parse_plain_type_from_ty(ty, ctx)?;\n            Ok(parse_quote!(#ty))\n        }\n        Expression::BoolLiteral(b) => Ok(parse_quote!(#b)),\n        ...\n    }\n}\n\n")),(0,r.kt)("ol",{start:4},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Printing the code"))),(0,r.kt)("p",null,"The last step is just consuming the resulting C3 AST. Nysa produces a token stream from the AST. Most likely you would write it to a file."),(0,r.kt)("p",null,"And there you are: a Rust smart contract is ready to be compiled!"),(0,r.kt)("h3",{id:"nysa--odra"},"Nysa + Odra"),(0,r.kt)("p",null,"By design, Nysa is a universal tool, so the third step from the pipeline is replaceable. In other words, a Solidity input can be converted to Rust code supporting a framework/SDK of your choice unless you provide a parser implementation."),(0,r.kt)("p",null,"However, the default implementation is ",(0,r.kt)("inlineCode",{parentName:"p"},"OdraParser"),", which takes a contract written in Solidity and splits out an Odra module."),(0,r.kt)("p",null,"I hope you see an analogy to the first two paragraphs at this point. Nysa the river and Nysa the transpiler ",(0,r.kt)("inlineCode",{parentName:"p"},"flow into")," Odra."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"nysa-odra",src:a(42719).Z,width:"661",height:"591"})),(0,r.kt)("h2",{id:"examples"},"Examples"),(0,r.kt)("h3",{id:"status-message"},"Status message"),(0,r.kt)("p",null,"Let's get our hands dirty and create a very simple project. We will write a contract that stores a single mapping of records - an address to a string message."),(0,r.kt)("p",null,"To set up the project, we use ",(0,r.kt)("inlineCode",{parentName:"p"},"cargo odra"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"cargo odra new -n status -t blank\ncd status\n")),(0,r.kt)("p",null,"The first thing is to add Nysa to the project and create a rudimentary ",(0,r.kt)("inlineCode",{parentName:"p"},"build.rs")," where we define the input - a solidity contract and the output - an Odra module generated by Nysa."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-toml",metastring:"title=Cargo.toml",title:"Cargo.toml"},'[build-dependencies]\nnysa = { version = "0.1.0", features = ["builder"] }\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:"title=build.rs",title:"build.rs"},'const DEST_FILE_PATH: &str = "src/status_message.rs";\nconst SOURCE_FILE_PATH: &str = "src/status_message.sol";\n\nfn main() {\n    nysa::builder::generate_file::<&str, nysa::OdraParser>(SOURCE_FILE_PATH, DEST_FILE_PATH);\n}\n')),(0,r.kt)("p",null,"Next, implement the contract. Naturally, a Solidity one."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity",metastring:"title=src/status_message.sol",title:"src/status_message.sol"},"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\ncontract StatusMessage {\n    mapping(address => string) records;\n\n    function setStatus(string memory status) public payable {\n        address accountId = msg.sender;\n        records[accountId] = status;\n    }\n\n    function getStatus(address accountId) public view returns (string memory) {\n        return records[accountId];\n    }\n}\n")),(0,r.kt)("p",null,"The contract has a single mapping ",(0,r.kt)("inlineCode",{parentName:"p"},"records"),"  that stores a message and its owner. Additionally, exposes two entry points: ",(0,r.kt)("inlineCode",{parentName:"p"},"setStatus")," (sets current's sender message) and ",(0,r.kt)("inlineCode",{parentName:"p"},"getStatus"),"."),(0,r.kt)("p",null,"Following, let's define a ",(0,r.kt)("inlineCode",{parentName:"p"},"lib.rs")," file."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:"title=src/lib.rs",title:"src/lib.rs"},"mod status_message;\npub use status_message::{StatusMessage, StatusMessageDeployer, StatusMessageRef};\n\n#[cfg(test)]\nmod test;\n")),(0,r.kt)("p",null,"The file is straightforward: registers a ",(0,r.kt)("inlineCode",{parentName:"p"},"status_message")," rust module, reexports some Odra abstractions, and adds a test module."),(0,r.kt)("p",null,"Lastly, we can test our contract.\nLike the original solidity contract, our Odra contract exposes two entry points: ",(0,r.kt)("inlineCode",{parentName:"p"},"set_message()")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"get_message()"),".\nThe test code looks like ",(0,r.kt)("a",{parentName:"p",href:"https://odra.dev/docs/basics/testing"},"any other")," Odra test: we use ",(0,r.kt)("inlineCode",{parentName:"p"},"StatusMessageDeployer")," to instantiate a contract, which gets us a reference to interact with the contract."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:"title=src/test.rs",title:"src/test.rs"},'use odra::{test_env, types::Address};\nuse super::*;\n\nconst ACCOUNT: fn() -> Address = || odra::test_env::get_account(1);\n\n#[test]\nfn set_get_message() {\n    let mut contract = StatusMessageDeployer::default();\n\n    test_env::set_caller(ACCOUNT());\n    contract.set_status("hello".to_string());\n    assert_eq!("hello".to_string(), contract.get_status(Some(ACCOUNT())));\n}\n\n#[test]\nfn get_nonexistent_message() {\n    let contract = StatusMessageDeployer::default();\n\n    assert_eq!(\n        String::new(),\n        contract.get_status(Some(ACCOUNT()))\n    );\n}\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"cargo odra test # test against MockVM\n# or\ncargo odra test -b casper # build a wasm file and test against CasperVM\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"status-message\n\u251c\u2500\u2500 src\n\u2502   \u251c\u2500\u2500 lib.rs\n\u2502   \u251c\u2500\u2500 status_message.sol\n\u2502   \u2514\u2500\u2500 test.rs\n\u251c\u2500\u2500 build.rs\n\u251c\u2500\u2500 Cargo.toml\n\u2514\u2500\u2500 Odra.toml\n")),(0,r.kt)("p",null,"Full example available ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/odradev/nysa/tree/feature/odra/examples/status-message/nysa"},"here"),"."),(0,r.kt)("h3",{id:"cappederc20"},"CappedErc20"),(0,r.kt)("p",null,"A more complex, real-world example is a ",(0,r.kt)("inlineCode",{parentName:"p"},"CappedErc20")," contract. It is a ERC20 ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol"},"Ownable"),", ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/extensions/ERC20Burnable.sol"},"Burnable")," and ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/extensions/ERC20Capped.sol"},"Capped")," token contract."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity",metastring:"title=plascoin.sol",title:"plascoin.sol"},"// ...\n// rest of the code\n\ncontract Plascoin is ERC20Capped, ERC20Burnable, Ownable {\n    constructor(string memory name_, string memory symbol_, uint256 cap_, address initialOwner) ERC20(name_, symbol_) ERC20Capped(cap_) Ownable(initialOwner) {\n    }\n\n    function mint(address account, uint256 amount) public onlyOwner {\n        _mint(account, amount);\n    }\n\n    function _update(address from, address to, uint256 value) internal override(ERC20, ERC20Capped) {\n        super._update(from, to, value);\n    }\n}\n")),(0,r.kt)("p",null,"You can check out the full source code ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/odradev/nysa/blob/feature/odra/examples/capped-erc20/src/plascoin.sol"},"here"),"."),(0,r.kt)("p",null,"Deployment of such a contract onto the Casper testnet is straightforward. We are just two steps from it. "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sh"},"# to make sure the contract works as expected \n# we execute cargo odra test command to build and run tests\ncargo odra test -b casper\n\n# deploy onto the testnet\ncasper-client put-deploy\n    --node-address {{NODE_ADDRESS}}\n    --chain-name casper-test\n    --secret-key {{SECRET_KEY}} \\\n    --session-path {{CONTRACT_WASM}} \\\n    --payment-amount 130000000000 \\\n    --session-arg \"odra_cfg_package_hash_key_name:string:'{{CONTRACT_PACKAGE_HASH_NAMED_KEY}}'\" \\\n    --session-arg \"odra_cfg_allow_key_override:bool:'true'\" \\\n    --session-arg \"odra_cfg_is_upgradable:bool:'true'\" \\\n    --session-arg \"odra_cfg_constructor:string:'init'\" \\\n    --session-arg \"name:string='{{name}}'\" \\\n    --session-arg \"symbol:string='{{symbol}}'\" \\\n    --session-arg \"cap:u256='{{cap}}'\" \\\n    --session-arg \"initial_owner:opt_key='{{owner}}'\"\n")),(0,r.kt)("p",null,"Literally in 5 minutes I was able to:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Build a wasm file from Solidity source code"),(0,r.kt)("li",{parentName:"ol"},"Successfully ",(0,r.kt)("a",{parentName:"li",href:"https://testnet.cspr.live/deploy/b1dd9628f8a36b7ed24949f88ea97ebb21d0c213e9cc87fc5ee4076074de0c88"},"deploy")," the contract onto Testnet,"),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("a",{parentName:"li",href:"https://testnet.cspr.live/deploy/1def539f806fd39ec1b75687c46946c7510fe3bb15860fcc3420c7bea7e7f10f"},"Mint")," some tokens,"),(0,r.kt)("li",{parentName:"ol"},"And ",(0,r.kt)("a",{parentName:"li",href:"https://testnet.cspr.live/deploy/0e2e0fa490f00783ddaecd06aaf2b43d8c5f6d3224a28a31ad66bfef48ce26e6"},"transfer")," them.")),(0,r.kt)("p",null,"Finally, we compare the costs of Solidity-to-Odra contract and a native CEP-18 implementation. Despite the contracts being different in terms of the internal logic and exposed entry points, such comparison gives us some insight into Nysa's efficiency."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"action"),(0,r.kt)("th",{parentName:"tr",align:null},"CEP-18"),(0,r.kt)("th",{parentName:"tr",align:null},"Nysa"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"deploy"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"https://testnet.cspr.live/deploy/2b5d17ea5d9c093c4252705285f7aeabe58cff37fb48b5837567908e2d91329a"},"143.87")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"https://testnet.cspr.live/deploy/b1dd9628f8a36b7ed24949f88ea97ebb21d0c213e9cc87fc5ee4076074de0c88"},"93.37"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"transfer"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"https://testnet.cspr.live/deploy/3ab866e7cf7b59e081f12aea4103f9552b261b601d91b072ea10ab5be6cf0e45"},"1.29")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"https://testnet.cspr.live/deploy/0e2e0fa490f00783ddaecd06aaf2b43d8c5f6d3224a28a31ad66bfef48ce26e6"},"1.36"))))),(0,r.kt)("h2",{id:"conclusion"},"Conclusion"),(0,r.kt)("p",null,"Nysa is at early stage of development, but already has shown a huge potential. In a few simple steps, you can take advantage of an existing smart contract and convert it into an Odra module. The module can be a standalone contract, or a building block of a bigger contract."))}d.isMDXComponent=!0},12112:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/nysa_generic.drawio-9478454b52585f4bd5c3a825f50917f2.svg"},42719:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/nysa_odra.drawio-e8d8d662f0a2e5e364005985245721fd.svg"},46180:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/twitter-card-941b7cfa84d4da7dd4848d3556845b53.png"}}]);