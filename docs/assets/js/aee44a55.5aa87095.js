"use strict";(self.webpackChunkodra_website=self.webpackChunkodra_website||[]).push([[6704],{3905:(e,n,t)=>{t.d(n,{Zo:()=>c,kt:()=>u});var o=t(67294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function s(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function a(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?s(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,o,r=function(e,n){if(null==e)return{};var t,o,r={},s=Object.keys(e);for(o=0;o<s.length;o++)t=s[o],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(o=0;o<s.length;o++)t=s[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var i=o.createContext({}),m=function(e){var n=o.useContext(i),t=n;return e&&(t="function"==typeof e?e(n):a(a({},n),e)),t},c=function(e){var n=m(e.components);return o.createElement(i.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},d=o.forwardRef((function(e,n){var t=e.components,r=e.mdxType,s=e.originalType,i=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),d=m(t),u=r,h=d["".concat(i,".").concat(u)]||d[u]||p[u]||s;return t?o.createElement(h,a(a({ref:n},c),{},{components:t})):o.createElement(h,a({ref:n},c))}));function u(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var s=t.length,a=new Array(s);a[0]=d;var l={};for(var i in n)hasOwnProperty.call(n,i)&&(l[i]=n[i]);l.originalType=e,l.mdxType="string"==typeof e?e:r,a[1]=l;for(var m=2;m<s;m++)a[m]=t[m];return o.createElement.apply(null,a)}return o.createElement.apply(null,t)}d.displayName="MDXCreateElement"},47953:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>i,contentTitle:()=>a,default:()=>p,frontMatter:()=>s,metadata:()=>l,toc:()=>m});var o=t(87462),r=(t(67294),t(3905));const s={sidebar_position:9},a="CEP-18",l={unversionedId:"tutorials/cep18",id:"version-2.1.0/tutorials/cep18",title:"CEP-18",description:"Not so different from ERC-20, the CEP-18 standard describes a fungible",source:"@site/versioned_docs/version-2.1.0/tutorials/cep18.md",sourceDirName:"tutorials",slug:"/tutorials/cep18",permalink:"/docs/2.1.0/tutorials/cep18",draft:!1,tags:[],version:"2.1.0",lastUpdatedAt:1752056444,formattedLastUpdatedAt:"Jul 9, 2025",sidebarPosition:9,frontMatter:{sidebar_position:9},sidebar:"tutorialSidebar",previous:{title:"Using Proxy Caller",permalink:"/docs/2.1.0/tutorials/using-proxy-caller"},next:{title:"Odra for Solidity developers",permalink:"/docs/2.1.0/tutorials/odra-solidity"}},i={},m=[{value:"Self-governing token",id:"self-governing-token",level:2},{value:"Token implementation",id:"token-implementation",level:2},{value:"Governance implementation",id:"governance-implementation",level:2},{value:"Voting mechanism",id:"voting-mechanism",level:3},{value:"Storage",id:"storage",level:4},{value:"Proposing a new mint",id:"proposing-a-new-mint",level:4},{value:"Voting for the mint",id:"voting-for-the-mint",level:4},{value:"Tallying the votes",id:"tallying-the-votes",level:4},{value:"Testing",id:"testing",level:3},{value:"What&#39;s next",id:"whats-next",level:2},{value:"Complete code",id:"complete-code",level:2}],c={toc:m};function p(e){let{components:n,...t}=e;return(0,r.kt)("wrapper",(0,o.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"cep-18"},"CEP-18"),(0,r.kt)("p",null,"Not so different from ERC-20, the CEP-18 standard describes a fungible\ntoken interface, but for the Casper network.\nThere are some differences, which will be shown in this tutorial.\nThe most visible one however, is the compatibility with the Casper Ecosystem."),(0,r.kt)("p",null,"In our example, we will implement a CEP-18 token with a simple self-governance mechanism.\nWe will also deploy our token on the Casper network, and interact with it."),(0,r.kt)("admonition",{type:"warning"},(0,r.kt)("p",{parentName:"admonition"},"This implementation of the governance in this tutorial is by no means\na complete one, and should not be used in production.")),(0,r.kt)("h2",{id:"self-governing-token"},"Self-governing token"),(0,r.kt)("p",null,"There are many ways to implement a governance mechanism for a token,\neach more complex than the other. In our example, we will use a simple\none, where the community of token holders can vote to mint new tokens."),(0,r.kt)("h2",{id:"token-implementation"},"Token implementation"),(0,r.kt)("p",null,"Let's start by creating a new project, choosing a clever name and using\ncep18 as our starting template:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"cargo odra new --name ourcoin --template cep18\n")),(0,r.kt)("p",null,"Let's glance at our token code:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:'showLineNumbers title="src/token.rs"',showLineNumbers:!0,title:'"src/token.rs"'},"#[odra::module]\npub struct MyToken {\n    token: SubModule<Cep18>,\n}\n\nimpl MyToken {\n    // Delegate all Cep18 functions to the token sub-module.\n    delegate! {\n        to self.token {\n            ...\n            fn name(&self) -> String;\n            fn symbol(&self) -> String;\n            ...\n")),(0,r.kt)("p",null,"As we can see, it indeed uses the ",(0,r.kt)("inlineCode",{parentName:"p"},"Cep18")," module and delegates\nall the methods to it."),(0,r.kt)("p",null,"The only thing to do is to change the name of the struct to more\nappropriate ",(0,r.kt)("inlineCode",{parentName:"p"},"OurToken"),", run the provided tests using ",(0,r.kt)("inlineCode",{parentName:"p"},"cargo odra test"),",\nand continue with the implementation of the governance."),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"Remember to change the name of the struct and its usages as well as\nthe struct name in the ",(0,r.kt)("inlineCode",{parentName:"p"},"Odra.toml")," file!")),(0,r.kt)("h2",{id:"governance-implementation"},"Governance implementation"),(0,r.kt)("p",null,"Let's go through the process of implementing the governance mechanism.\nIf we don't want to, we don't have to hide entrypoints from the public responsible\nfor minting new tokens. By default, minting ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/casper-ecosystem/cep18/tree/dev/cep18#modalities"},"Modality"),"\nis turned off, so any attempt of direct minting will result in an error."),(0,r.kt)("p",null,"We will however implement a voting mechanism, where the token holders can vote\nto mint new tokens."),(0,r.kt)("h3",{id:"voting-mechanism"},"Voting mechanism"),(0,r.kt)("p",null,"Our voting system will be straightforward:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Anyone with the tokens can propose a new mint."),(0,r.kt)("li",{parentName:"ol"},"Anyone with the tokens can vote for the new mint by staking their tokens."),(0,r.kt)("li",{parentName:"ol"},"If the majority of the token holders vote for the mint, it is executed.")),(0,r.kt)("h4",{id:"storage"},"Storage"),(0,r.kt)("p",null,"We will need to store some additional information about the votes, so let's\nadd some fields to our token struct:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:'showLineNumbers title="src/token.rs"',showLineNumbers:!0,title:'"src/token.rs"'},"#[odra::module]\npub struct OurToken {\n    /// A sub-module that implements the CEP-18 token standard.\n    token: SubModule<Cep18>,\n    /// The proposed mint.\n    proposed_mint: Var<(Address, U256)>,\n    /// The list of votes cast in the current vote.\n    votes: List<Ballot>,\n    /// Whether a vote is open.\n    is_vote_open: Var<bool>,\n    /// The time when the vote ends.\n    vote_end_time: Var<u64>,\n}\n\n/// A ballot cast by a voter.\n#[odra::odra_type]\nstruct Ballot {\n    voter: Address,\n    choice: bool,\n    amount: U256,\n}\n")),(0,r.kt)("p",null,"Notice that ",(0,r.kt)("inlineCode",{parentName:"p"},"proposed_mint")," contains a tuple containing the address of\nthe proposer and the amount of tokens to mint. Moreover, we need to keep track if\nthe vote time has ended, but also if it was already tallied, that's why\nwe need both ",(0,r.kt)("inlineCode",{parentName:"p"},"is_vote_open")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"vote_end_time"),"."),(0,r.kt)("p",null,"We will also use the power of the ",(0,r.kt)("a",{parentName:"p",href:"../basics/storage-interaction#list"},"List"),"\ntype to store the ",(0,r.kt)("inlineCode",{parentName:"p"},"Ballots"),"."),(0,r.kt)("h4",{id:"proposing-a-new-mint"},"Proposing a new mint"),(0,r.kt)("p",null,"To implement the endpoint that allows token holders to propose a new mint,\nwe need to add a new function to our token module:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:'showLineNumbers title="src/token.rs"',showLineNumbers:!0,title:'"src/token.rs"'},"/// Proposes a new mint for the contract.\npub fn propose_new_mint(&mut self, account: Address, amount: U256) {\n    // Only allow proposing a new mint if there is no vote in progress.\n    if self.is_vote_open().get_or_default() {\n        self.env().revert(GovernanceError::VoteAlreadyOpen);\n    }\n\n    // Only the token holders can propose a new mint.\n    if self.balance_of(&self.env().caller()) == U256::zero() {\n        self.env().revert(GovernanceError::OnlyTokenHoldersCanPropose);\n    }\n\n    // Set the proposed mint.\n    self.proposed_mint.set((account, amount));\n    // Open a vote.\n    self.is_vote_open.set(true);\n    // Set the vote end time to 10 minutes from now.\n    self.vote_end_time\n        .set(self.env().get_block_time() + 60 * 10 * 1000);\n}\n")),(0,r.kt)("p",null,"As a parameters to the function, we pass the address of the account that should be the receiver of\nthe minted tokens, and the amount."),(0,r.kt)("p",null,"After some validation, we open the vote by setting the ",(0,r.kt)("inlineCode",{parentName:"p"},"is_vote_open")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"true"),",\nand setting the ",(0,r.kt)("inlineCode",{parentName:"p"},"vote_end_time")," to 10 minutes. In real-world scenarios,\nthe time could be configurable, but for the sake of simplicity, we hardcoded it.\nAlso, it should be quite longer than 10 minutes, but it will come in handy\nwhen we test it on Livenet."),(0,r.kt)("h4",{id:"voting-for-the-mint"},"Voting for the mint"),(0,r.kt)("p",null,"Next, we need an endpoint that will allow us to cast a ballot:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:'showLineNumbers title="src/token.rs"',showLineNumbers:!0,title:'"src/token.rs"'},"/// Votes on the proposed mint.\npub fn vote(&mut self, choice: bool, amount: U256) {\n    // Only allow voting if there is a vote in progress.\n    self.assert_vote_in_progress();\n\n    let voter = self.env().caller();\n    let contract = self.env().self_address();\n\n    // Transfer the voting tokens from the voter to the contract.\n    self.token\n        .transfer(&contract, &amount);\n\n    // Add the vote to the list.\n    self.votes.push(Ballot {\n        voter,\n        choice,\n        amount,\n    });\n}\n")),(0,r.kt)("p",null,"The most interesting thing here is that we are using a mechanism of staking,\nwhere we transfer our tokens to the contract, to show that we really mean it."),(0,r.kt)("p",null,"The tokens will be locked until the vote is over, and tallied."),(0,r.kt)("p",null,"Speaking of tallying..."),(0,r.kt)("h4",{id:"tallying-the-votes"},"Tallying the votes"),(0,r.kt)("p",null,"The last step is to tally the votes and mint the tokens if the majority\nof voters agreed to do so:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:'showLineNumbers title="src/token.rs"',showLineNumbers:!0,title:'"src/token.rs"'},"/// Count the votes and perform the action\npub fn tally(&mut self) {\n    // Only allow tallying the votes once.\n    if !self.is_vote_open.get_or_default()\n    {\n        self.env().revert(GovernanceError::NoVoteInProgress);\n    }\n\n    // Only allow tallying the votes after the vote has ended.\n    let finish_time = self\n        .vote_end_time\n        .get_or_revert_with(GovernanceError::NoVoteInProgress);\n    if self.env().get_block_time() < finish_time {\n        self.env().revert(GovernanceError::VoteNotYetEnded);\n    }\n\n    // Count the votes\n    let mut yes_votes = U256::zero();\n    let mut no_votes = U256::zero();\n\n    let contract = self.env().self_address();\n\n    while let Some(vote) = self.votes.pop() {\n        if vote.choice {\n            yes_votes += vote.amount;\n        } else {\n            no_votes += vote.amount;\n        }\n\n        // Transfer back the voting tokens to the voter.\n        self.token.raw_transfer(&contract, &vote.voter, &vote.amount);\n    }\n\n    // Perform the action if the vote has passed.\n    if yes_votes > no_votes {\n        let (account, amount) = self\n            .proposed_mint\n            .get_or_revert_with(GovernanceError::NoVoteInProgress);\n        self.token.raw_mint(&account, &amount);\n    }\n\n    // Close the vote.\n    self.is_vote_open.set(false);\n}\n")),(0,r.kt)("p",null,"Notice how we used ",(0,r.kt)("inlineCode",{parentName:"p"},"raw_transfer")," from the ",(0,r.kt)("inlineCode",{parentName:"p"},"Cep18")," module. We used it\nto set the sender, so the contract's balance will be used, instead of\nthe caller's."),(0,r.kt)("p",null,"Additonally, we used ",(0,r.kt)("inlineCode",{parentName:"p"},"raw_mint")," to mint the tokens, skipping the security\nchecks. We have no modality for minting, but even if we had, we don't\nhave anyone with permissions! The Contract needs to mint the tokens itself."),(0,r.kt)("h3",{id:"testing"},"Testing"),(0,r.kt)("p",null,"Now, we will put our implementation to the test. One unit test, that we can\nrun both on OdraVM and on the CasperVM."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:'showLineNumbers title="src/token.rs"',showLineNumbers:!0,title:'"src/token.rs"'},'#[test]\nfn it_works() {\n    let env = odra_test::env();\n    let init_args = OurTokenInitArgs {\n        name: "OurToken".to_string(),\n        symbol: "OT".to_string(),\n        decimals: 0,\n        initial_supply: U256::from(1_000u64),\n    };\n\n    let mut token = OurToken::deploy(&env, init_args);\n\n    // The deployer, as the only token holder,\n    // starts a new voting to mint 1000 tokens to account 1.\n    // There is only 1 token holder, so there is one Ballot cast.\n    token.propose_new_mint(env.get_account(1), U256::from(2000));\n    token.vote(true, U256::from(1000));\n\n    // The tokens should now be staked.\n    assert_eq!(token.balance_of(&env.get_account(0)), U256::zero());\n\n    // Wait for the vote to end.\n    env.advance_block_time(60 * 11 * 1000);\n\n    // Finish the vote.\n    token.tally();\n\n    // The tokens should now be minted.\n    assert_eq!(token.balance_of(&env.get_account(1)), U256::from(2000));\n    assert_eq!(token.total_supply(), 3000.into());\n\n    // The stake should be returned.\n    assert_eq!(token.balance_of(&env.get_account(0)), U256::from(1000));\n\n    // Now account 1 can mint new tokens with their voting power...\n    env.set_caller(env.get_account(1));\n    token.propose_new_mint(env.get_account(1), U256::from(2000));\n    token.vote(true, U256::from(2000));\n\n    // ...Even if the deployer votes against it.\n    env.set_caller(env.get_account(0));\n    token.vote(false, U256::from(1000));\n\n    env.advance_block_time(60 * 11 * 1000);\n\n    token.tally();\n\n    // The power of community governance!\n    assert_eq!(token.balance_of(&env.get_account(1)), U256::from(4000));\n}\n')),(0,r.kt)("p",null,"We can run the test using both methods:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"cargo odra test\ncargo odra test -b casper\n")),(0,r.kt)("p",null,"It is all nice and green, but it would be really nice to see it in action."),(0,r.kt)("p",null,"How about deploying it on the Casper network?"),(0,r.kt)("h2",{id:"whats-next"},"What's next"),(0,r.kt)("p",null,"We will se our token in action, by ",(0,r.kt)("a",{parentName:"p",href:"deploying-on-casper"},"deploying it on the Casper network"),",\nand using tools from the Casper Ecosystem to interact with it."),(0,r.kt)("h2",{id:"complete-code"},"Complete code"),(0,r.kt)("p",null,"Here is the complete code of the ",(0,r.kt)("inlineCode",{parentName:"p"},"OurToken")," module:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:'showLineNumbers title="src/token.rs"',showLineNumbers:!0,title:'"src/token.rs"'},'use odra::{casper_types::U256, prelude::*};\nuse odra_modules::cep18_token::Cep18;\n\n/// A ballot cast by a voter.\n#[odra::odra_type]\nstruct Ballot {\n    voter: Address,\n    choice: bool,\n    amount: U256,\n}\n\n/// Errors for the governed token.\n#[odra::odra_error]\npub enum GovernanceError {\n    /// The vote is already in progress.\n    VoteAlreadyOpen = 0,\n    /// No vote is in progress.\n    NoVoteInProgress = 1,\n    /// Cannot tally votes yet.\n    VoteNotYetEnded = 2,\n    /// Vote ended\n    VoteEnded = 3,\n    /// Only the token holders can propose a new mint.\n    OnlyTokenHoldersCanPropose = 4,\n}\n\n/// A module definition. Each module struct consists of Vars and Mappings\n/// or/and other modules.\n#[odra::module(errors = GovernanceError)]\npub struct OurToken {\n    /// A submodule that implements the CEP-18 token standard.\n    token: SubModule<Cep18>,\n    /// The proposed mint.\n    proposed_mint: Var<(Address, U256)>,\n    /// The list of votes cast in the current vote.\n    votes: List<Ballot>,\n    /// Whether a vote is open.\n    is_vote_open: Var<bool>,\n    /// The time when the vote ends.\n    vote_end_time: Var<u64>,\n}\n/// Module implementation.\n///\n/// To generate entrypoints,\n/// an implementation block must be marked as #[odra::module].\n#[odra::module]\nimpl OurToken {\n    /// Initializes the contract with the given metadata and initial supply.\n    pub fn init(&mut self, name: String, symbol: String, decimals: u8, initial_supply: U256) {\n        // We put the token address as an admin, so it can govern itself. Self-governing token!\n        self.token.init(symbol, name, decimals, initial_supply);\n    }\n\n    // Delegate all Cep18 functions to the token submodule.\n    delegate! {\n        to self.token {\n            /// Returns the name of the token.\n            fn name(&self) -> String;\n\n            /// Returns the symbol of the token.\n            fn symbol(&self) -> String;\n\n            /// Returns the number of decimals the token uses.\n            fn decimals(&self) -> u8;\n\n            /// Returns the total supply of the token.\n            fn total_supply(&self) -> U256;\n\n            /// Returns the balance of the given address.\n            fn balance_of(&self, address: &Address) -> U256;\n\n            /// Returns the amount of tokens the owner has allowed the spender to spend.\n            fn allowance(&self, owner: &Address, spender: &Address) -> U256;\n\n            /// Approves the spender to spend the given amount of tokens on behalf of the caller.\n            fn approve(&mut self, spender: &Address, amount: &U256);\n\n            /// Decreases the allowance of the spender by the given amount.\n            fn decrease_allowance(&mut self, spender: &Address, decr_by: &U256);\n\n            /// Increases the allowance of the spender by the given amount.\n            fn increase_allowance(&mut self, spender: &Address, inc_by: &U256);\n\n            /// Transfers tokens from the caller to the recipient.\n            fn transfer(&mut self, recipient: &Address, amount: &U256);\n\n            /// Transfers tokens from the owner to the recipient using the spender\'s allowance.\n            fn transfer_from(&mut self, owner: &Address, recipient: &Address, amount: &U256);\n        }\n    }\n\n    /// Burns the given amount of tokens from the given address.\n    pub fn burn(&mut self, owner: &Address, amount: &U256) {\n        self.token.assert_caller(owner);\n\n        // Burn the tokens.\n        self.token.raw_burn(owner, amount);\n    }\n\n    /// Proposes a new mint for the contract.\n    pub fn propose_new_mint(&mut self, account: Address, amount: U256) {\n        // Only allow proposing a new mint if there is no vote in progress.\n        if self.is_vote_open.get_or_default() {\n            self.env().revert(GovernanceError::VoteAlreadyOpen);\n        }\n\n        // Only the token holders can propose a new mint.\n        if self.balance_of(&self.env().caller()) == U256::zero() {\n            self.env()\n                .revert(GovernanceError::OnlyTokenHoldersCanPropose);\n        }\n\n        // Set the proposed mint.\n        self.proposed_mint.set((account, amount));\n        // Open a vote.\n        self.is_vote_open.set(true);\n        // Set the vote end time to 10 minutes from now.\n        self.vote_end_time\n            .set(self.env().get_block_time() + 10 * 60 * 1000);\n    }\n\n    /// Votes on the proposed mint.\n    pub fn vote(&mut self, choice: bool, amount: U256) {\n        // Only allow voting if there is a vote in progress.\n        self.assert_vote_in_progress();\n\n        let voter = self.env().caller();\n        let contract = self.env().self_address();\n\n        // Transfer the voting tokens from the voter to the contract.\n        self.token.transfer(&contract, &amount);\n\n        // Add the vote to the list.\n        self.votes.push(Ballot {\n            voter,\n            choice,\n            amount,\n        });\n    }\n\n    /// Count the votes and perform the action\n    pub fn tally(&mut self) {\n        // Only allow tallying the votes once.\n        if !self.is_vote_open.get_or_default() {\n            self.env().revert(GovernanceError::NoVoteInProgress);\n        }\n\n        // Only allow tallying the votes after the vote has ended.\n        let finish_time = self\n            .vote_end_time\n            .get_or_revert_with(GovernanceError::NoVoteInProgress);\n        if self.env().get_block_time() < finish_time {\n            self.env().revert(GovernanceError::VoteNotYetEnded);\n        }\n\n        // Count the votes\n        let mut yes_votes = U256::zero();\n        let mut no_votes = U256::zero();\n\n        let contract = self.env().self_address();\n\n        while let Some(vote) = self.votes.pop() {\n            if vote.choice {\n                yes_votes += vote.amount;\n            } else {\n                no_votes += vote.amount;\n            }\n\n            // Transfer back the voting tokens to the voter.\n            self.token\n                .raw_transfer(&contract, &vote.voter, &vote.amount);\n        }\n\n        // Perform the action if the vote has passed.\n        if yes_votes > no_votes {\n            let (account, amount) = self\n                .proposed_mint\n                .get_or_revert_with(GovernanceError::NoVoteInProgress);\n            self.token.raw_mint(&account, &amount);\n        }\n\n        // Close the vote.\n        self.is_vote_open.set(false);\n    }\n\n    fn assert_vote_in_progress(&self) {\n        if !self.is_vote_open.get_or_default() {\n            self.env().revert(GovernanceError::NoVoteInProgress);\n        }\n\n        let finish_time = self\n            .vote_end_time\n            .get_or_revert_with(GovernanceError::NoVoteInProgress);\n\n        if self.env().get_block_time() > finish_time {\n            self.env().revert(GovernanceError::VoteEnded);\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use odra::host::Deployer;\n\n    #[test]\n    fn it_works() {\n        let env = odra_test::env();\n        let init_args = OurTokenInitArgs {\n            name: "OurToken".to_string(),\n            symbol: "OT".to_string(),\n            decimals: 0,\n            initial_supply: U256::from(1_000u64),\n        };\n\n        let mut token = OurToken::deploy(&env, init_args);\n\n        // The deployer, as the only token holder,\n        // starts a new voting to mint 1000 tokens to account 1.\n        // There is only 1 token holder, so there is one Ballot cast.\n        token.propose_new_mint(env.get_account(1), U256::from(2000));\n        token.vote(true, U256::from(1000));\n\n        // The tokens should now be staked.\n        assert_eq!(token.balance_of(&env.get_account(0)), U256::zero());\n\n        // Wait for the vote to end.\n        env.advance_block_time(60 * 11 * 1000);\n\n        // Finish the vote.\n        token.tally();\n\n        // The tokens should now be minted.\n        assert_eq!(token.balance_of(&env.get_account(1)), U256::from(2000));\n        assert_eq!(token.total_supply(), 3000.into());\n\n        // The stake should be returned.\n        assert_eq!(token.balance_of(&env.get_account(0)), U256::from(1000));\n\n        // Now account 1 can mint new tokens with their voting power...\n        env.set_caller(env.get_account(1));\n        token.propose_new_mint(env.get_account(1), U256::from(2000));\n        token.vote(true, U256::from(2000));\n\n        // ...Even if the deployer votes against it.\n        env.set_caller(env.get_account(0));\n        token.vote(false, U256::from(1000));\n\n        env.advance_block_time(60 * 11 * 1000);\n\n        token.tally();\n\n        // The power of community governance!\n        assert_eq!(token.balance_of(&env.get_account(1)), U256::from(4000));\n    }\n}\n')))}p.isMDXComponent=!0}}]);