"use strict";(self.webpackChunkodra_website=self.webpackChunkodra_website||[]).push([[1477],{30010:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"Nysa","metadata":{"permalink":"/blog/Nysa","source":"@site/blog/2023-08-18-nysa/index.md","title":"Nysa","description":"The Oder River, known as \\"Odra\\" in Polish, is one of the major rivers in Poland. It flows for approximately 854 kilometers, originating in the Czech Republic and flowing through southwestern Poland before emptying into the Baltic Sea. The river is a vital transportation route, connecting several Polish cities, including Wroc\u0142aw, Szczecin, and Gda\u0144sk, to international waterways. The Oder also plays a significant role in the region\'s ecology, supporting diverse habitats and species. Its watershed area spans multiple countries, making it a part of various international cooperation initiatives aimed at water management and environmental conservation.","date":"2023-08-18T00:00:00.000Z","formattedDate":"August 18, 2023","tags":[],"readingTime":8.47,"hasTruncateMarker":true,"authors":[{"name":"Krzysztof Pobiar\u017cyn","title":"Lead Developer","url":"https://github.com/kpob","key":"kpob"}],"frontMatter":{"slug":"Nysa","title":"Nysa","authors":["kpob"],"image":"./twitter-card.png"},"nextItem":{"title":"It\'s all about the community!","permalink":"/blog/its-all-about-the-community"}},"content":"The Oder River, known as \\"Odra\\" in Polish, is one of the major rivers in Poland. It flows for approximately 854 kilometers, originating in the Czech Republic and flowing through southwestern Poland before emptying into the Baltic Sea. The river is a vital transportation route, connecting several Polish cities, including Wroc\u0142aw, Szczecin, and Gda\u0144sk, to international waterways. The Oder also plays a significant role in the region\'s ecology, supporting diverse habitats and species. Its watershed area spans multiple countries, making it a part of various international cooperation initiatives aimed at water management and environmental conservation.\\n\\nThe Nysa K\u0142odzka is a significant river in Poland, flowing through the country\'s southwestern part. It travels approximately 188 kilometers, originating in the Czech Republic and merging with the Oder River in Poland. The river passes through picturesque landscapes, including the K\u0142odzko Valley, and plays a crucial role in local ecosystems. Its waters are harnessed for various purposes, such as hydroelectric power generation and irrigation.\\n\\nOh, wait, shouldn\'t it be a tech blog?\\n\\nThis is a valid question, we will get back to it in a moment.\\n\\n\x3c!--truncate--\x3e\\n\\n## Odra\\n\\nA short reminder:\\n\\n> Odra is a high-level smart contract framework for Rust, which encourages rapid development and clean, pragmatic design ...\\n> it takes care of much of the hassle of smart contract development, enabling you to focus on writing your dapp without reinventing the wheel. \\n>\\n> [Odra][odra]\\n\\nUnderstanding that people generally dislike learning new things, we\'ve kept this in mind throughout development. Since day one, we have focused on creating Odra with the largest group of smart contract developers in mind - those familiar with Solidity. The Odra Framework is designed to flatten the learning curve for this group.\\n\\nA Solidity developer will encounter familiar concepts such as:\\n\\n* Constructors\\n* Payable functions\\n* Mappings\\n* Reverts\\n* Current caller\\n* Current block time\\n* A standard module library (similar to OpenZeppelin)\\n* And more\\n\\n:::note\\nIt\'s important to note that the Odra Framework is intentionally blockchain-agnostic. Its design does not target any particular blockchain. \\n\\nUltimately, Odra is built to support multiple blockchains, allowing the writing of smart contracts in Rust.\\n:::\\n\\nHaving so many similarities, why not take the next step and transpile Solidity code into Odra code?\\n\\nThis is where Nysa comes into play.\\n\\n## Nysa\\n\\nSolidity and Rust share some syntax similarities despite being designed for different purposes. Both languages emphasize strong typing, pattern matching, and immutability by default.\\n\\nNysa performs Solidity-to-Rust transpilation through four simple steps.\\n\\n![nysa-gen](./nysa_generic.drawio.svg)\\n\\n1. **Solidity Parser**\\n   \\nFirstly, we need a well-structured Rust representation of Solidity code. Nysa utilizes [LALRPOP][lalrpop] - a Rust parser generator framework. In the further steps, this enables us to conduct static analysis of the Solidity code, ranging from contract context down to individual expressions.\\n\\n```rust title=solidity-parser/src/pt.rs\\n// The representation of a Solidity contract\\n#[derive(Debug, PartialEq)]\\npub struct ContractDefinition {\\n    pub doc: Vec<DocComment>,\\n    pub loc: Loc,\\n    pub ty: ContractTy,\\n    pub name: Identifier,\\n    pub base: Vec<Base>,\\n    pub parts: Vec<ContractPart>,\\n}\\n```\\n\\n2. **C3 Linearization**\\n   \\nOne of the most notable distinctions between Rust and Solidity is their approach to inheritance. Rust says `No, thx`, whereas Solidity opts for `The more, the better`. Speaking more technically, Solidity supports multiple inheritance with [C3 linearization][c3].\\n\\n:::info\\nThe primary purpose of the C3 Linearization Algorithm is to establish a consistent and unambiguous order of method resolution in cases where there might be ambiguity or conflicts due to multiple inheritance. It ensures that the inherited methods are called in a predictable and well-defined sequence based on the class hierarchy and the order in which classes are defined.\\n:::\\n\\nFor simulating C3 linearization, Nysa utilizes an [implementation][c3-impl] of the C3 linearization in Rust written by [Maciej Zieli\u0144ski][z1elony], so everything stays in the Odra family.\\n\\n3. **Nysa Parser**\\n\\nAfter that, we step to the essential part, converting Solidity code into Rust code.\\n\\nFor example, a Solidity event.\\n\\n```solidity\\nevent Transfer(address indexed from, address indexed to, uint256 value);\\n```\\ncan easily be represented as an plain Rust struct - the same name, the same fields, similar types. \\n\\n```rust\\n#[derive(PartialEq, Eq, Debug)]\\npub struct Transfer {\\n    from: Option<Address>,\\n    to: Option<Address>,\\n    value: U256,\\n}\\n```\\n\\nThe same we do with contracts, interfaces, libraries, errors, variables, functions, statements, etc.\\n\\nHere is a snippet of the expression parser:\\n\\n```rust title=nysa/src/parser/odra/expr/mod.rs\\npub fn parse<T>(expression: &Expression, ctx: &mut T) -> Result<syn::Expr, ParserError>\\nwhere\\n    T: StorageInfo + TypeInfo + EventsRegister + ExternalCallsRegister + ContractInfo + FnContext,\\n{\\n    match expression {\\n        Expression::Require { condition, error } => error::revert(Some(condition), error, ctx),\\n        Expression::ZeroAddress => Ok(parse_quote!(None)),\\n        Expression::Add { left, right } => math::add(left, right, ctx),\\n        Expression::Subtract { left, right } => math::sub(left, right, ctx),\\n        Expression::Increment { expr } => {\\n            let expr = parse(expr, ctx)?;\\n            Ok(parse_quote!(#expr += 1))\\n        }\\n        Expression::ExternalCall {\\n            variable,\\n            fn_name,\\n            args,\\n        } => parse_ext_call(variable, fn_name, args, ctx),\\n        Expression::Type { ty } => {\\n            let ty = ty::parse_plain_type_from_ty(ty, ctx)?;\\n            Ok(parse_quote!(#ty))\\n        }\\n        Expression::BoolLiteral(b) => Ok(parse_quote!(#b)),\\n        ...\\n    }\\n}\\n\\n```\\n\\n4. **Printing the code**\\n\\nThe last step is just consuming the resulting C3 AST. Nysa produces a token stream from the AST. Most likely you would write it to a file.\\n\\nAnd there you are: a Rust smart contract is ready to be compiled!\\n\\n### Nysa + Odra\\nBy design, Nysa is a universal tool, so the third step from the pipeline is replaceable. In other words, a Solidity input can be converted to Rust code supporting a framework/SDK of your choice unless you provide a parser implementation.\\n\\nHowever, the default implementation is `OdraParser`, which takes a contract written in Solidity and splits out an Odra module.\\n\\nI hope you see an analogy to the first two paragraphs at this point. Nysa the river and Nysa the transpiler `flow into` Odra.\\n\\n![nysa-odra](./nysa_odra.drawio.svg)\\n\\n## Examples\\n\\n### Status message\\n\\nLet\'s get our hands dirty and create a very simple project. We will write a contract that stores a single mapping of records - an address to a string message.\\n\\nTo set up the project, we use `cargo odra`.\\n``` bash\\ncargo odra new -n status -t blank\\ncd status\\n```\\n\\nThe first thing is to add Nysa to the project and create a rudimentary `build.rs` where we define the input - a solidity contract and the output - an Odra module generated by Nysa.\\n\\n```toml title=Cargo.toml\\n[build-dependencies]\\nnysa = { version = \\"0.1.0\\", features = [\\"builder\\"] }\\n```\\n\\n```rust title=build.rs\\nconst DEST_FILE_PATH: &str = \\"src/status_message.rs\\";\\nconst SOURCE_FILE_PATH: &str = \\"src/status_message.sol\\";\\n\\nfn main() {\\n    nysa::builder::generate_file::<&str, nysa::OdraParser>(SOURCE_FILE_PATH, DEST_FILE_PATH);\\n}\\n```\\n\\nNext, implement the contract. Naturally, a Solidity one.\\n\\n```solidity title=src/status_message.sol\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\ncontract StatusMessage {\\n    mapping(address => string) records;\\n\\n    function setStatus(string memory status) public payable {\\n        address accountId = msg.sender;\\n        records[accountId] = status;\\n    }\\n\\n    function getStatus(address accountId) public view returns (string memory) {\\n        return records[accountId];\\n    }\\n}\\n```\\n\\nThe contract has a single mapping `records`  that stores a message and its owner. Additionally, exposes two entry points: `setStatus` (sets current\'s sender message) and `getStatus`.\\n\\nFollowing, let\'s define a `lib.rs` file.\\n\\n```rust title=src/lib.rs\\nmod status_message;\\npub use status_message::{StatusMessage, StatusMessageDeployer, StatusMessageRef};\\n\\n#[cfg(test)]\\nmod test;\\n```\\nThe file is straightforward: registers a `status_message` rust module, reexports some Odra abstractions, and adds a test module.\\n\\nLastly, we can test our contract.\\nLike the original solidity contract, our Odra contract exposes two entry points: `set_message()` and `get_message()`.\\nThe test code looks like [any other][odra-docs-testing] Odra test: we use `StatusMessageDeployer` to instantiate a contract, which gets us a reference to interact with the contract.\\n\\n```rust title=src/test.rs\\nuse odra::{test_env, types::Address};\\nuse super::*;\\n\\nconst ACCOUNT: fn() -> Address = || odra::test_env::get_account(1);\\n\\n#[test]\\nfn set_get_message() {\\n    let mut contract = StatusMessageDeployer::default();\\n\\n    test_env::set_caller(ACCOUNT());\\n    contract.set_status(\\"hello\\".to_string());\\n    assert_eq!(\\"hello\\".to_string(), contract.get_status(Some(ACCOUNT())));\\n}\\n\\n#[test]\\nfn get_nonexistent_message() {\\n    let contract = StatusMessageDeployer::default();\\n\\n    assert_eq!(\\n        String::new(),\\n        contract.get_status(Some(ACCOUNT()))\\n    );\\n}\\n```\\n\\n```bash\\ncargo odra test # test against MockVM\\n# or\\ncargo odra test -b casper # build a wasm file and test against CasperVM\\n```\\n\\n```\\nstatus-message\\n\u251c\u2500\u2500 src\\n\u2502   \u251c\u2500\u2500 lib.rs\\n\u2502   \u251c\u2500\u2500 status_message.sol\\n\u2502   \u2514\u2500\u2500 test.rs\\n\u251c\u2500\u2500 build.rs\\n\u251c\u2500\u2500 Cargo.toml\\n\u2514\u2500\u2500 Odra.toml\\n```\\n\\nFull example available [here][nysa-status-example].\\n\\n### CappedErc20\\n\\nA more complex, real-world example is a `CappedErc20` contract. It is a ERC20 [Ownable][oz-ownable], [Burnable][oz-burnable] and [Capped][oz-capped] token contract.\\n\\n```solidity title=plascoin.sol\\n// ...\\n// rest of the code\\n\\ncontract Plascoin is ERC20Capped, ERC20Burnable, Ownable {\\n    constructor(string memory name_, string memory symbol_, uint256 cap_, address initialOwner) ERC20(name_, symbol_) ERC20Capped(cap_) Ownable(initialOwner) {\\n    }\\n\\n    function mint(address account, uint256 amount) public onlyOwner {\\n        _mint(account, amount);\\n    }\\n\\n    function _update(address from, address to, uint256 value) internal override(ERC20, ERC20Capped) {\\n        super._update(from, to, value);\\n    }\\n}\\n```\\nYou can check out the full source code [here][nysa-capped-erc20-sol].\\n\\nDeployment of such a contract onto the Casper testnet is straightforward. We are just two steps from it. \\n\\n```sh\\n# to make sure the contract works as expected \\n# we execute cargo odra test command to build and run tests\\ncargo odra test -b casper\\n\\n# deploy onto the testnet\\ncasper-client put-deploy\\n    --node-address {{NODE_ADDRESS}}\\n    --chain-name casper-test\\n    --secret-key {{SECRET_KEY}} \\\\\\n    --session-path {{CONTRACT_WASM}} \\\\\\n    --payment-amount 130000000000 \\\\\\n    --session-arg \\"odra_cfg_package_hash_key_name:string:\'{{CONTRACT_PACKAGE_HASH_NAMED_KEY}}\'\\" \\\\\\n    --session-arg \\"odra_cfg_allow_key_override:bool:\'true\'\\" \\\\\\n    --session-arg \\"odra_cfg_is_upgradable:bool:\'true\'\\" \\\\\\n    --session-arg \\"odra_cfg_constructor:string:\'init\'\\" \\\\\\n    --session-arg \\"name:string=\'{{name}}\'\\" \\\\\\n    --session-arg \\"symbol:string=\'{{symbol}}\'\\" \\\\\\n    --session-arg \\"cap:u256=\'{{cap}}\'\\" \\\\\\n    --session-arg \\"initial_owner:opt_key=\'{{owner}}\'\\"\\n```\\n\\nLiterally in 5 minutes I was able to:\\n1. Build a wasm file from Solidity source code\\n2. Successfully [deploy][nysa-deploy] the contract onto Testnet,\\n3. [Mint][nysa-mint] some tokens,\\n4. And [transfer][nysa-transfer] them.\\n   \\nFinally, we compare the costs of Solidity-to-Odra contract and a native CEP-18 implementation. Despite the contracts being different in terms of the internal logic and exposed entry points, such comparison gives us some insight into Nysa\'s efficiency.\\n\\n| action    | CEP-18               | Nysa                  |\\n|-----------|----------------------|-----------------------|\\n| deploy    | [143.87][cep-deploy] | [93.37][nysa-deploy]  |\\n| transfer  | [1.29][cep-transfer] | [1.36][nysa-transfer] |\\n\\n## Conclusion\\n\\nNysa is at early stage of development, but already has shown a huge potential. In a few simple steps, you can take advantage of an existing smart contract and convert it into an Odra module. The module can be a standalone contract, or a building block of a bigger contract.\\n\\n[lalrpop]: https://github.com/lalrpop/lalrpop\\n[c3]: https://en.wikipedia.org/wiki/C3_linearization\\n[c3-impl]: https://github.com/odradev/c3-lang\\n[z1elony]: https://github.com/zie1ony\\n[odra]: https://odra.dev/docs/\\n[odra-discord]: https://discord.gg/Mm5ABc9P8k\\n[odra-twitter]: https://twitter.com/odradev\\n[odra-wiki]: https://en.wikipedia.org/wiki/Oder\\n[nysa-wiki]: https://en.wikipedia.org/wiki/Eastern_Neisse\\n[nysa-capped-erc20-sol]: https://github.com/odradev/nysa/blob/feature/odra/examples/capped-erc20/src/plascoin.sol\\n[nysa-capped-erc20]: https://github.com/odradev/nysa/blob/feature/odra/examples/capped-erc20/\\n[nysa-status-example]: https://github.com/odradev/nysa/tree/feature/odra/examples/status-message/nysa\\n[odra-docs-testing]: https://odra.dev/docs/basics/testing\\n[cep-deploy]: https://testnet.cspr.live/deploy/2b5d17ea5d9c093c4252705285f7aeabe58cff37fb48b5837567908e2d91329a\\n[cep-transfer]: https://testnet.cspr.live/deploy/3ab866e7cf7b59e081f12aea4103f9552b261b601d91b072ea10ab5be6cf0e45\\n[nysa-deploy]: https://testnet.cspr.live/deploy/b1dd9628f8a36b7ed24949f88ea97ebb21d0c213e9cc87fc5ee4076074de0c88\\n[nysa-mint]: https://testnet.cspr.live/deploy/1def539f806fd39ec1b75687c46946c7510fe3bb15860fcc3420c7bea7e7f10f\\n[nysa-transfer]: https://testnet.cspr.live/deploy/0e2e0fa490f00783ddaecd06aaf2b43d8c5f6d3224a28a31ad66bfef48ce26e6\\n[open-zeppelin]: https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/contracts\\n[oz-ownable]: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol\\n[oz-capped]: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/extensions/ERC20Capped.sol\\n[oz-burnable]: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/extensions/ERC20Burnable.sol"},{"id":"its-all-about-the-community","metadata":{"permalink":"/blog/its-all-about-the-community","source":"@site/blog/2023-06-27-we-are-here-to-stay/index.md","title":"It\'s all about the community!","description":"Over the past months,","date":"2023-06-27T00:00:00.000Z","formattedDate":"June 27, 2023","tags":[],"readingTime":2.825,"hasTruncateMarker":true,"authors":[{"name":"Maciej Zieli\u0144ski","title":"CTO","url":"https://github.com/zie1ony","key":"zie1ony"}],"frontMatter":{"slug":"its-all-about-the-community","title":"It\'s all about the community!","authors":["zie1ony"],"image":"./roadmap.png"},"prevItem":{"title":"Nysa","permalink":"/blog/Nysa"},"nextItem":{"title":"OpenAI writes ERC20 in Odra","permalink":"/blog/2023-02-27-openai-writes-erc20-in-odra"}},"content":"Over the past months,\\nwe have been working hard on bringing Odra to the Casper world.\\nWhile we are proud of what we have achieved so far,\\nthe hard part is just beginning.\\nSmart contract developers from outside of our team are starting to use Odra.\\nWe are thrilled about it and here is how we are going to support the community.\\n\\n\x3c!--truncate--\x3e\\n\\n## Hello Odra Community\\n\\nWhether you are a Rust developer, Solidity developer or a Casper enthusiast\\nwe are happy to have you here, reading this blog post.\\n\\nWe have built Odra to make smart contract development on Casper easy.\\nNow we are entering the next phase of the open source journey.\\nWe are going to focus on the community and make sure\\nOdra is the best tool for the job.\\nOur motto (we borrowed from the Django Project) is:\\n\\n> **We bring cutting-edge smart contract development tools to \\nprofessionals with deadlines.**\\n\\nHow will we do it? We are going to focus on four things:\\n- **Quality** - Our code and documentation will be of the highest quality.\\nWe will always have tons of tests and examples.\\n- **Simplicity** - The simplest solution is the best solution.\\nOdra\'s API needs to be simple and easy to use.\\nAlways!\\nWe are not afraid to take a few steps back and rethink our design.\\nWe believe in short feedback loops and fast iterations.\\n- **Reusability** - No one likes to repeat itself.\\nWe see a huge potential in Odra Modules.\\nIn time, it can become a standard library of Casper smart contracts,\\nthat are battle-tested and ready to use.\\n- **Community** - We are here to help you.\\nYou can always reach out to us on [Discord] or [Github].\\n\\n## We will help with your project\\n\\nWhether you are a Rust developer or not, you can start using Odra today.\\nWe have prepared a few [examples and docs] to help you get started.\\nRust knowledge required to use Odra is minimal.\\nThat was always the goal.\\n\\nBut we understand that it is hard to start.\\nWe got your back.\\n\\n> **We offer free consulting + 2 hours of live coding.**\\n\\nAll you have to do is write us an email at **contract@odra.dev**\\nwith a short description of your project.\\nWe will schedule a call and help you get started with Odra.\\nAfter 2 hours of live coding, you will have a working repository with 2 or 3 \\nsmart contracts, that you can use as a starting point for your project.\\n\\n## Roadmap\\n\\nThe feedback we got quite often was:\\n__It\'s nice, but will it last? What\'s the direction of the project?__\\nPoint taken. Now we answer: __We are here to stay.__\\nWe got the support from the Casper Association and some projects of our own\\nto keep us funded. We play the long game.\\n\\nTo systematize our work, we have prepared the [roadmap].\\nAs of now, we maintain plans for at least three future releases.\\nIt is a good balance between predictability and flexibility.\\nWe will release new versions approximately every 1-2 months or as needed.\\nEveryone is encouraged to propose a new Odra feature or enhancement.\\nNew proposals need to be discussed and approved by the core team.\\nWhen the feature is ready, we assign it to one of the future releases.\\n\\n![Odra Roadmap](./roadmap.png)\\n\\n[Discord]: https://discord.gg/Mm5ABc9P8k\\n[Github]: https://github.com/odradev/odra\\n[examples and docs]: https://odra.dev/docs\\n[roadmap]: https://github.com/odradev/odra/milestones"},{"id":"2023-02-27-openai-writes-erc20-in-odra","metadata":{"permalink":"/blog/2023-02-27-openai-writes-erc20-in-odra","source":"@site/blog/2023-02-27-openai-writes-erc20-in-odra/index.md","title":"OpenAI writes ERC20 in Odra","description":"OpenAI can write Odra smart contracts.","date":"2023-02-27T00:00:00.000Z","formattedDate":"February 27, 2023","tags":[],"readingTime":3.785,"hasTruncateMarker":true,"authors":[{"name":"Maciej Zieli\u0144ski","title":"CTO","url":"https://github.com/zie1ony","key":"zie1ony"}],"frontMatter":{"slug":"2023-02-27-openai-writes-erc20-in-odra","title":"OpenAI writes ERC20 in Odra","authors":["zie1ony"],"image":"./twitter-card.png"},"prevItem":{"title":"It\'s all about the community!","permalink":"/blog/its-all-about-the-community"},"nextItem":{"title":"Odra + CosmWasm","permalink":"/blog/odra-cosmwasm"}},"content":"OpenAI can write Odra smart contracts.\\nThis is how.\\n\\n\x3c!--truncate--\x3e\\n\\n## OpenAI\\nOpenAI already proved that AI can code.\\nGithub Copilot is used by more and more developers.\\nMany times it is mind-blowing how accurate it is.\\nIt would be great if one of the OpenAI models could simply work after writing:\\n\\n```\\nQ: Write the ERC20 smart contract.\\n\\nA: use odra::{Mapping, Variable}...\\n```\\n\\nSo far OpenAI hasn\'t indexed Odra. I even asked ChatGPT.\\n\\n```\\nQ: Do you know what is the Odra Framework for writing smart contracts?\\n   Response in one sentence. Use Yoda style.\\n\\nA: Aware of an Odra Framework for writing smart contracts, I am not.\\n```\\n\\nSoon (year or two) it will happen and Odra will be supported out of the box,\\nsimply because it is available on GitHub.\\n\\n## DaVinci Edit\\n\\nOpenAI gives us a great tool called [Edit](https://openai.com/blog/gpt-3-edit-insert/).\\nIt uses the same technology Github Copiled it based on called [Codex](https://openai.com/blog/openai-codex/),\\nOpenAI gives us access to the model `code-davinci-edit-001`.\\nIt allows you to paste in the code and ask for changes.\\nSee more examples like rewriting Fibonacci to a recursive version [here](https://platform.openai.com/docs/guides/code/editing-code). \\n\\nBut it doesn\'t know Odra.\\nLuckily this is not a problem.\\nI have found a nice trick that allows producing the code I want.\\nWe simply have to present all the features of Odra and ask a good question.\\n\\n## ERC20 by AI\\n\\nThe goal is to bend AI to write the ERC20 token using Odra.\\nThe Edit query needs two elements:\\n* source code,\\n* text that describes what should be changed. \\n\\nAs the input source code I wrote the code that uses all the features ERC20 would use.\\nI need `odra::module`, `Variable`, `Mapping`, `caller()`, `Address`,\\nconstructor, and errors.\\n\\n```rust title=flipper.rs\\nuse odra::{Variable, types::Address, contract_env, Mapping, execution_error};\\n\\n#[odra::module]\\npub struct Flipper {\\n    value: Variable<bool>,\\n    flips_count: Variable<u32>,\\n    owner: Variable<Address>,\\n    messages: Mapping<(Address, Address), String>\\n}\\n\\n#[odra::module]\\nimpl Flipper {\\n    #[odra(init)]\\n    pub fn init(&mut self, owner: Address) {\\n        self.value.set(false);\\n        self.owner.set(owner);\\n    }\\n\\n    pub fn set(&mut self, value: bool) {\\n        self.value.set(value);\\n    }\\n\\n    pub fn flip(&mut self) {\\n        self.value.set(!self.get_value());\\n        self.flips_count.set(self.flips_count.get_or_default());\\n    }\\n\\n    pub fn get_value(&self) -> bool {\\n        self.value.get_or_default()\\n    }\\n    \\n    pub fn get_owner(&self) -> Option<Address> {\\n        self.owner.get()\\n    }\\n\\n    pub fn set_message(&mut self, recipient: Address, msg: String) {\\n        let sender = contract_env::caller();\\n        let current_msg = self.messages.get(&(sender, recipient));\\n        match current_msg {\\n            Some(_) => contract_env::revert(Error::MessageAlreadyDefined),\\n            None => self.messages.set(&(sender, recipient), msg)\\n        }\\n    }\\n\\n    pub fn get_message(&self, sender: Address, recipient: Address) -> String {\\n        self.messages.get_or_default(&(sender, recipient))\\n    }\\n}\\n\\nexecution_error! {\\n    pub enum Error {\\n        MessageAlreadyDefined => 1,\\n        NotAnMessageSender => 2,\\n    }\\n}\\n```\\n\\nChatGPT knows what the ERC20 is, so the kind request for changes is simple.\\n\\n```\\nQ: Implement another smart contract called ERC20.\\n   Balances should be of type U256.\\n```\\n\\nThis is the result.\\n\\n```rust title=\\"ERC20 contract in Odra generated by OpenAI\\"\\nuse odra::{Variable, types::Address, contract_env, Mapping, execution_error, U256};\\n\\n#[odra::module]\\npub struct ERC20 {\\n    name: Variable<String>,\\n    symbol: Variable<String>,\\n    decimals: Variable<u8>,\\n    total_supply: Variable<U256>,\\n    balances: Mapping<Address, U256>,\\n    allowed: Mapping<(Address, Address), U256>\\n}\\n\\n#[odra::module]\\nimpl ERC20 {\\n    #[odra(init)]\\n    pub fn init(&mut self, name: String, symbol: String, decimals: u8, total_supply: U256) {\\n        self.name.set(name);\\n        self.symbol.set(symbol);\\n        self.decimals.set(decimals);\\n        self.total_supply.set(total_supply);\\n        self.balances.set(&contract_env::caller(), total_supply);\\n    }\\n\\n    pub fn total_supply(&self) -> U256 {\\n        self.total_supply.get_or_default()\\n    }\\n\\n    pub fn balance_of(&self, owner: Address) -> U256 {\\n        self.balances.get_or_default(&owner)\\n    }\\n\\n    pub fn transfer(&mut self, to: Address, value: U256) {\\n        let from = contract_env::caller();\\n        let from_balance = self.balances.get_or_default(&from);\\n        let to_balance = self.balances.get_or_default(&to);\\n        if from_balance < value {\\n            contract_env::revert(Error::InsufficientBalance);\\n        }\\n        self.balances.set(&from, from_balance - value);\\n        self.balances.set(&to, to_balance + value);\\n    }\\n\\n    pub fn transfer_from(&mut self, from: Address, to: Address, value: U256) {\\n        let caller = contract_env::caller();\\n        let from_balance = self.balances.get_or_default(&from);\\n        let to_balance = self.balances.get_or_default(&to);\\n        let allowed = self.allowed.get_or_default(&(from, caller));\\n        if from_balance < value {\\n            contract_env::revert(Error::InsufficientBalance);\\n        }\\n        if allowed < value {\\n            contract_env::revert(Error::InsufficientAllowance);\\n        }\\n        self.balances.set(&from, from_balance - value);\\n        self.balances.set(&to, to_balance + value);\\n        self.allowed.set(&(from, caller), allowed - value);\\n    }\\n\\n    pub fn approve(&mut self, spender: Address, value: U256) {\\n        let owner = contract_env::caller();\\n        self.allowed.set(&(owner, spender), value);\\n    }\\n\\n    pub fn allowance(&self, owner: Address, spender: Address) -> U256 {\\n        self.allowed.get_or_default(&(owner, spender))\\n    }\\n}\\n\\nexecution_error! {\\n    pub enum Error {\\n        InsufficientBalance => 1,\\n        InsufficientAllowance => 2,\\n    }\\n}\\n```\\n\\nWow!\\n\\n## What is next?\\n\\nAI already understands smart contracts.\\nIt had to read a lot of Solidity code.\\nI checked and it knows Uniswap and Compound source code.\\nMost interesting is that AI was able to implement a concept it already knew\\nfrom another programming language in the unseen Rust framework.\\nAt some point, we will be able to translate all the Solidity code to Odra.\\nOr maybe we will not have to...\\n\\nIt is hard to imagine how good it will be in 2025 and beyond."},{"id":"odra-cosmwasm","metadata":{"permalink":"/blog/odra-cosmwasm","source":"@site/blog/2023-02-15-odra-cosmos.md","title":"Odra + CosmWasm","description":"In November 2022 we released the first version of the Odra Framework. It\'s time for the next big step in our framework development - a new platform integration. Meet Odra + CosmWasm.","date":"2023-02-15T00:00:00.000Z","formattedDate":"February 15, 2023","tags":[],"readingTime":5.96,"hasTruncateMarker":true,"authors":[{"name":"Krzysztof Pobiar\u017cyn","title":"Lead Developer","url":"https://github.com/kpob","key":"kpob"}],"frontMatter":{"slug":"odra-cosmwasm","title":"Odra + CosmWasm","authors":["kpob"],"image":"https://github.com/odradev.png"},"prevItem":{"title":"OpenAI writes ERC20 in Odra","permalink":"/blog/2023-02-27-openai-writes-erc20-in-odra"},"nextItem":{"title":"EVM at Risc0","permalink":"/blog/evm-at-risc0"}},"content":"In November 2022 we released [the first version](../blog/2022-11-30-release-020/index.md) of the Odra Framework. It\'s time for the next big step in our framework development - a new platform integration. Meet Odra + CosmWasm.\\n\\n\x3c!--truncate--\x3e\\n\\n## CosmWasm\\n\\nCosmWasm is a smart contract platform for building dApps on the Cosmos blockchain ecosystem.\\nThe platform is designed as a module that can be integrated into the Cosmos SDK, enabling developers who are already building blockchains with the Cosmos SDK to easily incorporate CosmWasm smart contract functionality without the need to modify their existing code.\\n\\nIt uses the Rust programming language, so is potentially a perfect candidate for an Odra backend.\\nThere are many blockchains like [Osmosis], [Secret Network], [Juno] that utilize CosmWasm.\\n\\n## Show me your code\\n\\nI would like to write a `Counter` smart contract that is CosmWasm compatible.\\nWhat are the requirements?\\n\\n1. It should store a `u32` value. \\n2. The initial value it set by the contract deployer.\\n3. The value can be incremented.\\n4. The value can read from the storage.\\n5. The contract can call another contract and increment its counter.\\n\\nSo let\'s write an Odra module first.\\n\\n```rust title=counter.rs\\nuse odra::{types::{Address, event::OdraEvent}, Variable, contract_env};\\nuse self::events::{Init, ValueUpdated};\\n\\n#[odra::module]\\npub struct Counter {\\n    pub value: Variable<u32>\\n}\\n\\n#[odra::module]\\nimpl Counter {\\n    #[odra(init)]\\n    pub fn init(&mut self, value: u32) {\\n        self.value.set(value);\\n        <Init as OdraEvent>::emit(Init {\\n            value,\\n        });\\n    }\\n\\n    pub fn increment(&mut self) {\\n        let old_value = self.value.get_or_default();\\n        let new_value = old_value + 1;\\n        self.value.set(new_value);\\n        \\n        ValueUpdated {\\n            old_value,\\n            new_value,\\n            operator: contract_env::caller()\\n        }.emit();\\n    }\\n\\n    pub fn cross_increment(&mut self, counter_address: Address) {\\n        CounterRef::at(counter_address).increment();\\n    }\\n\\n    pub fn get_value(&self) -> u32 {\\n        self.value.get_or_default()\\n    }\\n}\\n\\nmod events {\\n    use odra::types::Address;\\n\\n    #[derive(odra::Event)]\\n    pub struct ValueUpdated {\\n        pub old_value: u32,\\n        pub new_value: u32,\\n        pub operator: Address\\n    }\\n    \\n    #[derive(odra::Event)]\\n    pub struct Init {\\n        pub value: u32,\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn deploy() {\\n        let counter = CounterDeployer::init(10);\\n        assert_eq!(10, counter.get_value());\\n    }\\n\\n    #[test]\\n    fn increment() {\\n        let mut counter = CounterDeployer::init(10);\\n        counter.increment();\\n        assert_eq!(11, counter.get_value());\\n    }\\n}\\n```\\nBut wait, I mentioned CosmWasm, did I?\\n\\nHere the beauty of Odra comes into play.\\n\\nLet\'s use `cargo-odra`.\\n```bash\\ncargo odra build -b cosmos\\n```\\nAnd... that\'s it, congratulations! We have just written and build our first CosmWasm contract.\\nAs you see, it is nothing different from building a contract for Casper. No additional code, we only changed the `-b` flag.\\n\\n## Deploy\\nWe have just built a wasm file, but is it really a fully functional contract?\\n\\nAs a battlefield let\'s choose [Juno Network] (if you would like to read more about smart contract development on Juno read this [Quick Start tutorial]). This is an arbitrary choice, each client is built upon a so-called Wasm Zone [wasmd], and its interface is alike.\\n\\nAssuming you already know how to interact with Juno testnet, let\'s move to the fun part.\\n\\nBut before we go, to keep things simple, let\'s prepare a [justfile]. It\'ll make our interactions with the blockchain much easier. See [full version].\\n\\n```justfile title=justfile\\nNODE := \\"--node https://rpc.uni.juno.deuslabs.fi:443\\"\\nCHAIN_ID := \\"--chain-id uni-6\\"\\nQUERY_FLAGS := NODE + \\" \\" + CHAIN_ID\\nTRANSACTION_DEFAULTS := \\"--gas-prices 0.025ujunox --gas auto --gas-adjustment 1.3 --broadcast-mode block\\"\\nEXEC_FLAGS := NODE + \\" \\" + CHAIN_ID + \\" \\" + TRANSACTION_DEFAULTS\\n\\nget-address NAME:\\n    junod keys show {{NAME}} | grep -o juno.*\\n\\nstore-wasm WASM_PATH SENDER:\\n    junod tx wasm store \\\\\\n    {{WASM_PATH}} --from {{SENDER}} {{EXEC_FLAGS}}\\n\\ninit-contract CODE_ID VALUE SENDER CONTRACT_NAME:\\n    junod tx wasm instantiate \\\\\\n    {{CODE_ID}} \\\\\\n    `just run-args-parser \'{\\"name\\": \\"init\\", \\"args\\": [ { \\"value\\" : {{VALUE}} }]}\'` \\\\\\n    --label \'{{CONTRACT_NAME}}\' --from {{SENDER}} \\\\\\n    --admin `just get-address {{SENDER}}` \\\\\\n    {{EXEC_FLAGS}}\\n\\nexec-increment ADDRESS SENDER:\\n    junod tx wasm execute \\\\\\n    {{ADDRESS}} \\\\\\n    `just run-args-parser \'{\\"name\\": \\"increment\\"}\'` \\\\\\n    --from {{SENDER}}  \\\\\\n    {{EXEC_FLAGS}}\\n\\nquery-get-value ADDRESS:\\n    junod q wasm contract-state smart {{ADDRESS}} \\\\\\n    `just run-args-parser \'{\\"name\\": \\"get_value\\"}\'` {{QUERY_FLAGS}}\\n```\\n\\nOk, we are ready to go.\\n\\nFirst, a CosmWasm contract needs to be stored, technically is not a contract yet. Like a larva waiting to morph into a butterfly (sorry for that).\\n\\nThere are three ways to interact with a contract.\\n1. Instantiate - in other words, a constructor call. Once the contract is instantiated, it gets an address.\\n2. Execute - call an entrypoint that modifies the state.\\n3. Query - read the contract\'s state.\\n   \\nNow, let\'s take a look at how to do it using the tools we have just prepared.\\n\\n```bash\\n# args: \\n# the path to a wasm file,\\n# the name under we store the private key.\\njust store-wasm counter.wasm odra\\n\\n...\\nraw_log: \'[{\\"events\\":[{\\"type\\":\\"message\\",\\"attributes\\":[{\\"key\\":\\"action\\",\\"value\\":\\"/cosmwasm.wasm.v1.MsgStoreCode\\"},{\\"key\\":\\"module\\",\\"value\\":\\"wasm\\"},{\\"key\\":\\"sender\\",\\"value\\":\\"juno1le848rjac00nezzq46v5unxujaltdf270vhtfh\\"}]},{\\"type\\":\\"store_code\\",\\"attributes\\":[{\\"key\\":\\"code_checksum\\",\\"value\\":\\"9fb9e7f39170de2628892ed5eecc556e2487267b30bb2c9656f8c7d1cd9f9a59\\"},{\\"key\\":\\"code_id\\",\\"value\\":\\"286\\"}]}]}]\'\\n...\\ntxhash: 1A8BA520E980C5ABCBCFA6F62D68B6BB82E780544605DE4DD5C6B1C5E966441B\\n```\\n\\nGreat, our code is successfully stored. Form the logs we can read now the `code_id` which we will use to initialize the contract.\\n\\n```bash\\n# args: \\n# code id taken from the previous tx, \\n# counter initial value, \\n# named private key,\\n# contract label.\\njust init-contract 286 1 odra \\"My Counter\\"\\n\\n...\\nraw_log: \'[{\\"events\\":[{\\"type\\":\\"instantiate\\",\\"attributes\\":[{\\"key\\":\\"_contract_address\\",\\"value\\":\\"juno10yszsgq4460a57ztuw943h5j3c9l0eyx3algzq080gatl0thecls5ttk7g\\"},{\\"key\\":\\"code_id\\",\\"value\\":\\"286\\"}]},{\\"type\\":\\"message\\",\\"attributes\\":[{\\"key\\":\\"action\\",\\"value\\":\\"/cosmwasm.wasm.v1.MsgInstantiateContract\\"},{\\"key\\":\\"module\\",\\"value\\":\\"wasm\\"},{\\"key\\":\\"sender\\",\\"value\\":\\"juno1le848rjac00nezzq46v5unxujaltdf270vhtfh\\"}]},{\\"type\\":\\"wasm\\",\\"attributes\\":[{\\"key\\":\\"_contract_address\\",\\"value\\":\\"juno10yszsgq4460a57ztuw943h5j3c9l0eyx3algzq080gatl0thecls5ttk7g\\"},{\\"key\\":\\"value\\",\\"value\\":\\"1\\"}]},{\\"type\\":\\"wasm-Init\\",\\"attributes\\":[{\\"key\\":\\"_contract_address\\",\\"value\\":\\"juno10yszsgq4460a57ztuw943h5j3c9l0eyx3algzq080gatl0thecls5ttk7g\\"},{\\"key\\":\\"value\\",\\"value\\":\\"1\\"}]}]}]\'\\n...\\ntxhash: 8DC53F95805349C3763CF4AF9527CAB2AEBEC77B240EFD3801C61231D8748F26\\n```\\n\\nFantastic, the contract has been initialized and we have its address - `juno10yszsgq4460a57ztuw943h5j3c9l0eyx3algzq080gatl0thecls5ttk7g`.\\nIt\'s time to increment the counter.\\n\\n```bash\\n# args:\\n# contract address taken from the previous tx,\\n# named private key\\njust exec-increment juno10yszsgq4460a57ztuw943h5j3c9l0eyx3algzq080gatl0thecls5ttk7g odra\\n\\n...\\nraw_log: \'[{\\"events\\":[{\\"type\\":\\"execute\\",\\"attributes\\":[{\\"key\\":\\"_contract_address\\",\\"value\\":\\"juno10yszsgq4460a57ztuw943h5j3c9l0eyx3algzq080gatl0thecls5ttk7g\\"}]},{\\"type\\":\\"message\\",\\"attributes\\":[{\\"key\\":\\"action\\",\\"value\\":\\"/cosmwasm.wasm.v1.MsgExecuteContract\\"},{\\"key\\":\\"module\\",\\"value\\":\\"wasm\\"},{\\"key\\":\\"sender\\",\\"value\\":\\"juno1le848rjac00nezzq46v5unxujaltdf270vhtfh\\"}]},{\\"type\\":\\"wasm\\",\\"attributes\\":[{\\"key\\":\\"_contract_address\\",\\"value\\":\\"juno10yszsgq4460a57ztuw943h5j3c9l0eyx3algzq080gatl0thecls5ttk7g\\"},{\\"key\\":\\"action\\",\\"value\\":\\"increment\\"}]},{\\"type\\":\\"wasm-ValueUpdated\\",\\"attributes\\":[{\\"key\\":\\"_contract_address\\",\\"value\\":\\"juno10yszsgq4460a57ztuw943h5j3c9l0eyx3algzq080gatl0thecls5ttk7g\\"},{\\"key\\":\\"old_value\\",\\"value\\":\\"1\\"},{\\"key\\":\\"new_value\\",\\"value\\":\\"2\\"},{\\"key\\":\\"operator\\",\\"value\\":\\"juno1le848rjac00nezzq46v5unxujaltdf270vhtfh\\"}]}]}]\'\\n...\\ntxhash: 52141844321B8321DA71D073D4FA0865E73C3940153373CA7EF832D15BC3C2B2\\n```\\n\\nFinally, we expected, the value to be equal to 2 (the initial value was 1 and we incremented it once).\\n\\n``` bash\\n# args:\\n# contract address\\njust query-get-value juno10yszsgq4460a57ztuw943h5j3c9l0eyx3algzq080gatl0thecls5ttk7g\\n\\ndata: 2\\n```\\nIndeed, as expected the current counter value is 2.\\n\\n## Show me your transaction\\nI get it, you don\'t want to do it all by yourself. So let\'s take a closer look at one of my transactions.\\n\\n```bash\\njunod q tx 52141844321B8321DA71D073D4FA0865E73C3940153373CA7EF832D15BC3C2B2 --node https://rpc.uni.juno.deuslabs.fi:443 --chain-id uni-6\\n...\\nlogs:\\n- events:\\n  - attributes:\\n    - key: _contract_address\\n      value: juno10yszsgq4460a57ztuw943h5j3c9l0eyx3algzq080gatl0thecls5ttk7g\\n    type: execute\\n  - attributes:\\n    - key: action\\n      value: /cosmwasm.wasm.v1.MsgExecuteContract\\n    - key: module\\n      value: wasm\\n    - key: sender\\n      value: juno1le848rjac00nezzq46v5unxujaltdf270vhtfh\\n    type: message\\n  - attributes:\\n    - key: _contract_address\\n      value: juno10yszsgq4460a57ztuw943h5j3c9l0eyx3algzq080gatl0thecls5ttk7g\\n    - key: action\\n      value: increment\\n    type: wasm\\n  - attributes:\\n    - key: _contract_address\\n      value: juno10yszsgq4460a57ztuw943h5j3c9l0eyx3algzq080gatl0thecls5ttk7g\\n    - key: old_value\\n      value: \\"1\\"\\n    - key: new_value\\n      value: \\"2\\"\\n    - key: operator\\n      value: juno1le848rjac00nezzq46v5unxujaltdf270vhtfh\\n    type: wasm-ValueUpdated\\n...\\ntxhash: 52141844321B8321DA71D073D4FA0865E73C3940153373CA7EF832D15BC3C2B2\\n```\\n\\nIf you are familiar Cosmos ecosystem, you can see that there is an attribute containing\\nthe performed action (`increment`) (If there were some parameters, they would be included in this attribute).\\nWe can find here also our `ValueUpdated` event with its arguments `old_value`, `new_value` and `operator`.\\n\\nWow, we have it, everything worked as intended!\\n\\n## Conclusion\\nWouldn\'t it be great to replace [Casper Erc20] and [Cosmos Erc20] with a super-simple\\nsingle [Odra Erc20] implementation?\\n\\nThe `Counter` contract is just a POC, and there is still a long road ahead of us.\\nThis simple example shows that features like storage, events, and cross-contract calls\\ncan be unified in a simple readable interface.\\n\\nCosmWasm integration hasn\'t been published yet, but if you want to experiment by yourself, \\ncheck our GitHub (don\'t forget to update cargo-odra as well).\\n\\n## Join us\\nInterested?\\n\\nJoin [our Discord][odra-discord], [our Twitter][odra-twitter] or write us\\nat contact@odra.dev.\\n\\n[odra-discord]: https://discord.gg/Mm5ABc9P8k\\n[odra-twitter]: https://twitter.com/odradev\\n[Secret Network]: https://scrt.network/\\n[Osmosis]: https://docsosmosis.zone/\\n[Juno]: https://www.junonetwork.io/\\n[wasmd]: https://github.com/CosmWasm/wasmd\\n[`cargo-odra`]: https://odra.dev/docs/basics/cargo-odra\\n[Juno Network]: https://www.junonetwork.io/\\n[Quick Start tutorial]: https://medium.com/@NitroBiell/smart-contract-development-quick-start-on-juno-5dabf6fdcad0\\n[justfile]: https://github.com/casey/just\\n[full version]: https://github.com/odradev/odra/blob/feature/cosmos/odra-cosmos/juno-client/justfile\\n[Casper Erc20]: https://github.com/casper-ecosystem/erc20/tree/master/erc20/src\\n[Cosmos Erc20]: https://github.com/CosmWasm/cw-plus/tree/main/contracts/cw20-base/src\\n[Odra Erc20]: https://github.com/odradev/odra/blob/release/0.2.0/examples/src/erc20.rs"},{"id":"evm-at-risc0","metadata":{"permalink":"/blog/evm-at-risc0","source":"@site/blog/2023-02-13-evm-at-risc0.md","title":"EVM at Risc0","description":"Let\'s run Solidity code inside SputnikVM inside Risc0.","date":"2023-02-13T00:00:00.000Z","formattedDate":"February 13, 2023","tags":[],"readingTime":3.97,"hasTruncateMarker":true,"authors":[{"name":"Maciej Zieli\u0144ski","title":"CTO","url":"https://github.com/zie1ony","key":"zie1ony"}],"frontMatter":{"slug":"evm-at-risc0","title":"EVM at Risc0","authors":["zie1ony"],"image":"https://github.com/odradev.png"},"prevItem":{"title":"Odra + CosmWasm","permalink":"/blog/odra-cosmwasm"},"nextItem":{"title":"Zero Knowledge on Casper","permalink":"/blog/casper-zk-risc0"}},"content":"Let\'s run Solidity code inside [SputnikVM](https://github.com/rust-blockchain/evm/) inside [Risc0](https://github.com/risc0/risc0).\\n\\n\x3c!--truncate--\x3e\\nFirst make sure you know how Risc0 works.\\nMy [previous post](2022-12-12-casper-zk-risc0.md) explains it.\\n\\nIf you want to jump directly to the full code example, it\'s in the [repo](https://github.com/odradev/evm-at-risc0).\\n\\n## Solidity\\n\\nAs an example, I have this simple Solidity code.\\nIt is a calculator with two functions.\\nOne for addition and one for the nth Fibonacci number.\\n\\n```solidity title=\\"bytecode/Calculator.sol\\"\\ncontract Calculator {\\n    function add(uint256 a, uint256 b) public pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    function fibonacci(uint256 n) public returns (uint256) {\\n        if (n <= 1) {\\n            return n;\\n        } else {\\n            return fibonacci(n - 1) + fibonacci(n - 2);\\n        }\\n    }\\n}\\n```\\n\\nIt needs to be compiled into the byte code. `solc` can do this.\\n\\n```bash\\n$ solc \\\\\\n    --bin-runtime \\\\\\n    --optimize \\\\\\n    --overwrite \\\\\\n    --evm-version istanbul \\\\\\n    --output-dir bytecode \\\\\\n    bytecode/Calculator.sol  \\n```\\n\\nIt produces an EVM bytecode in the `bytecode` directory.\\n\\n```bash\\n$ ls bytecode/\\nCalculator.bin-runtime  Calculator.sol\\n```\\n\\n## EVM\\n\\nThe EVM I used is [SputnikVM](https://github.com/rust-blockchain/evm/).\\nMost important it is written in pure Rust and even with `no_std` mode.\\nThis way I can start an in-memory instance of EVM.\\nThen take the bytecode of a contract and install it.\\nFinally, call the contract with arguments and obtain the result value.\\nFor now, it\'s just a Rust code. Risc0 comes later.\\n\\nThe code is based on Sputnik\'s [benchmark test](https://github.com/rust-blockchain/evm/blob/master/benches/loop.rs).\\nHuge thanks to [Michael Birch](https://github.com/birchmd) for helping with Sputnik.\\nAlso make sure how EVM\'s [function selectors](https://solidity-by-example.org/function-selector) work.\\n\\n```rust title=\\"evm-runner/src/lib.rs\\"\\n\\n// Load previously compiled Calculator contract.\\npub const CALCULATOR_EVM_PROGRAM: &str = include_str!(\\n    \\"../../bytecode/Calculator.bin-runtime\\"\\n);\\n\\n// Run Calculator for a given input.\\npub fn run_calc_contract(input: &str) -> String {\\n    run_evm(CALCULATOR_EVM_PROGRAM, input)\\n}\\n\\n// Run a program (contract) for a given input. \\nfn run_evm(program: &str, input: &str) -> String {\\n\\n    // Define EVM configuration.\\n    let config = Config::istanbul();\\n\\tlet vicinity = MemoryVicinity {\\n\\t\\tgas_price: U256::zero(),\\n\\t\\torigin: H160::default(),\\n\\t\\tblock_hashes: Vec::new(),\\n\\t\\tblock_number: Default::default(),\\n\\t\\tblock_coinbase: Default::default(),\\n\\t\\tblock_timestamp: Default::default(),\\n\\t\\tblock_difficulty: Default::default(),\\n\\t\\tblock_gas_limit: Default::default(),\\n\\t\\tchain_id: U256::one(),\\n\\t\\tblock_base_fee_per_gas: U256::zero(),\\n\\t};\\n\\n    // Initialized the state of EVM\'s memory.\\n\\tlet mut state = BTreeMap::new();\\n\\n    // Add our contract under the 0x10 address.\\n    state.insert(\\n\\t\\tH160::from_str(\\"0x1000000000000000000000000000000000000000\\")\\n            .unwrap(),\\n\\t\\tMemoryAccount {\\n\\t\\t\\tnonce: U256::one(),\\n\\t\\t\\tbalance: U256::from(10000000),\\n\\t\\t\\tstorage: BTreeMap::new(),\\n\\t\\t\\tcode: hex::decode(program).unwrap(),\\n\\t\\t}\\n\\t);\\n\\n    // Add new user 0xf0 that will be used as the contract caller.\\n    state.insert(\\n\\t\\tH160::from_str(\\"0xf000000000000000000000000000000000000000\\")\\n            .unwrap(),\\n\\t\\tMemoryAccount {\\n\\t\\t\\tnonce: U256::one(),\\n\\t\\t\\tbalance: U256::from(10000000),\\n\\t\\t\\tstorage: BTreeMap::new(),\\n\\t\\t\\tcode: Vec::new(),\\n\\t\\t},\\n\\t);\\n\\n    // Prepare the executor.\\n\\tlet backend = MemoryBackend::new(&vicinity, state);\\n\\tlet metadata = StackSubstateMetadata::new(u64::MAX, &config);\\n\\tlet state = MemoryStackState::new(metadata, &backend);\\n\\tlet precompiles = BTreeMap::new();\\n\\tlet mut executor \\n        = StackExecutor::new_with_precompiles(state, &config, &precompiles);\\n\\n    // Call the 0x10 contract using the 0xf0 user.\\n    // Use the input variable. \\n\\tlet (exit_reason, result) = executor.transact_call(\\n\\t\\tH160::from_str(\\"0xf000000000000000000000000000000000000000\\")\\n            .unwrap(),\\n\\t\\tH160::from_str(\\"0x1000000000000000000000000000000000000000\\")\\n            .unwrap(),\\n\\t\\tU256::zero(),\\n\\t\\thex::decode(input).unwrap(),\\n\\t\\tu64::MAX,\\n\\t\\tVec::new(),\\n\\t);\\n\\n    // Make sure the execution succeeded.\\n    assert!(exit_reason == ExitReason::Succeed(ExitSucceed::Returned));\\n    \\n    // Return hex encoded string.\\n    hex::encode(result)\\n}\\n```\\n\\nLet\'s execute it. In below tests the `data` variable hold two things:\\nfunction selector and arguments.\\n\\nFor example `61047ff4000000000000000000000000000000000000000000000000000000000000000a`\\nis concatination of the function selector (first 8 chars) and 256-bit long argument.\\nIt is just `fibonacci(10)`. `a` is hex of `10` and `37` is hex of `52`. \\n\\n```rust title=\\"evm-runner/src/lib.rs\\"\\n#[test]\\nfn fibonacci_works() {\\n    let data = \\"61047ff4000000000000000000000000000000000000000000000000000000000000000a\\";\\n    let result = run_calc_contract(data);\\n    assert_eq!(result, \\"0000000000000000000000000000000000000000000000000000000000000037\\");  \\n}\\n\\n#[test]\\nfn addition_works() {\\n    let data = \\"771602f700000000000000000000000000000000000000000000000000000000000000070000000000000000000000000000000000000000000000000000000000000002\\";\\n    let result = run_calc_contract(data);\\n    assert_eq!(result, \\"0000000000000000000000000000000000000000000000000000000000000009\\");\\n}\\n```\\n\\n## Risc0\\n\\nIt\'s time for `risc0`.\\n\\nFirst the guest program.\\nIt is super simple.\\nIt takes a string as an argument,\\npasses it to the `run_calc_contract`\\nand returns the result.\\n\\n```rust title=methods/guest/src/bin/evm_calc.rs\\n#![no_main]\\n#![no_std]\\n\\nextern crate alloc;\\n\\nuse alloc::{string::String};\\nuse risc0_zkvm::guest::{env};\\nuse evm_runner::run_calc_contract;\\n\\nrisc0_zkvm::guest::entry!(main);\\n\\npub fn main() {\\n    let input: String = env::read();\\n    let result = run_calc_contract(&input);\\n    env::commit(&result);\\n}\\n```\\n\\nThe final step is calling it under ZK.\\n\\n```rust title=host/src/main.rs\\nfn main() {\\n    println!(\\"Proving Calculator.add(7, 2)\\");\\n    let input = \\"771602f700000000000000000000000000000000000000000000000000000000000000070000000000000000000000000000000000000000000000000000000000000002\\";\\n    let result = run_prover(input);\\n    println!(\\"Proof generated. 7 + 2 = {result}\\");\\n    \\n    println!(\\"Proving Calculator.fibonacci(4)\\");\\n    let input = \\"61047ff40000000000000000000000000000000000000000000000000000000000000004\\";\\n    let result = run_prover(input);\\n    println!(\\"Proof generated. fibonacci(4) = {result}\\");\\n}\\n\\nfn run_prover(input: &str) -> u32 {\\n    // Make the prover.\\n    let method_code = std::fs::read(EVM_CALC_PATH).unwrap();\\n    let mut prover = Prover::new(&method_code, EVM_CALC_ID).unwrap();\\n\\n    // Push the input as an argument.\\n    prover.add_input_u32_slice(to_vec(input).unwrap().as_slice());\\n    \\n    // Execute the prover.\\n    let receipt = prover.run().unwrap();\\n    \\n    // Verify the proof.\\n    assert!(receipt.verify(EVM_CALC_ID).is_ok());\\n    \\n    // Return result as an u32 value.\\n    let result: String = from_slice(receipt.journal.as_slice()).unwrap();\\n    u32::from_str_radix(&result, 16).unwrap()\\n}\\n```\\n\\n```bash\\n$ cargo run --release -p host\\nProving Calculator.add(7, 2)\\nProof generated. 7 + 2 = 9\\nProving Calculator.fibonacci(4)\\nProof generated. fibonacci(4) = 3\\n```\\n\\n## Conclusion\\nHow amazing and mindblowing it is!\\nOf course, it\'s just a proof of concept.\\nYet with further development of Risc0 improving its proving time and\\nwith more flexible SputnikVM this approach is more than promising.\\n\\n## Join us\\nInterested?\\n\\nJoin [our Discord][odra-discord], [our Twitter][odra-twitter] or write us\\nat contact@odra.dev.\\n\\n[odra-discord]: https://discord.gg/Mm5ABc9P8k\\n[odra-twitter]: https://twitter.com/odradev"},{"id":"casper-zk-risc0","metadata":{"permalink":"/blog/casper-zk-risc0","source":"@site/blog/2022-12-12-casper-zk-risc0.md","title":"Zero Knowledge on Casper","description":"In this post, I present how to verify a zero knowledge proof on Casper.","date":"2022-12-12T00:00:00.000Z","formattedDate":"December 12, 2022","tags":[],"readingTime":4.215,"hasTruncateMarker":true,"authors":[{"name":"Maciej Zieli\u0144ski","title":"CTO","url":"https://github.com/zie1ony","key":"zie1ony"}],"frontMatter":{"slug":"casper-zk-risc0","title":"Zero Knowledge on Casper","authors":["zie1ony"],"image":"https://github.com/odradev.png"},"prevItem":{"title":"EVM at Risc0","permalink":"/blog/evm-at-risc0"},"nextItem":{"title":"Odra 0.2.0 Released","permalink":"/blog/release-020"}},"content":"In this post, I present how to verify a zero knowledge proof on Casper.\\n\x3c!--truncate--\x3e\\n\\n## Zero Knowledge\\nIn my opinion, the **zero knowledge** (ZK) is the largest revolution in \\nblockchains, since Ethereum introduced Turing-complete, account-based \\nsmart contracts.\\nTo put it in simple words, ZK enables two use cases not possible before:\\n\\n1. Computation scaling - I can perform expensive computation off-chain\\nand put the result on a chain with the proof.\\n2. Anonymity - I can prove to you, I know something without revealing it. \\n\\n## Risc Zero\\nI\'d like to introduce you to [Risc Zero](https://www.risczero.com/).\\nIt is the general purpose zero-knowledge virtual machine.\\nGo ahead and spend time reading their website!\\nFor us, the key component is the proof verifier that can be compiled into WASM.\\nSooo... we can run it on Casper :)\\nYes! We can prove any program, produce proof, and send it to Casper\'s\\nsmart contract for verification.\\n\\n## Example\\nLet\'s dive into the example to see how it works.\\n[The full example code](https://github.com/odradev/casper-zk-with-risc0)\\nyou can find on our GitHub. \\nIt is based on Risc Zero\'s [Hello, Multiply!](https://www.risczero.com/docs/examples/hello_multiply)\\nexample. So make sure you understand it first.\\n[Guest](#guest) and [Prover](#prover) sections are taken from this example.\\n\\n### Guest\\nThe program we are proving is called a **guest** in Risc Zero.\\nOur goal is to prove we know the factors of an arbitrary number.\\nGiven `a` and `b` below guest program computes `a * b` and produces\\na proof of computation.\\n\\n```rust title=\\"methods/guest/src/multiply.rs\\"\\npub fn main() {\\n    // Load the first number from the host\\n    let a: u64 = env::read();\\n    // Load the second number from the host\\n    let b: u64 = env::read();\\n    // Verify that neither of them are 1 (i.e. nontrivial factors)\\n    if a == 1 || b == 1 {\\n        panic!(\\"Trivial factors\\")\\n    }\\n    // Compute the product while being careful with integer overflow\\n    let product = a.checked_mul(b).expect(\\"Integer overflow\\");\\n    env::commit(&product);\\n}\\n```\\n\\n### Prover\\nIt\'s time to run the guest program and build the proof for \\na specific `a` and `b` values.\\n\\n```rust title=\\"prover/src/main.rs\\"\\nfn main() {\\n    // Pick two numbers.\\n    let a: u64 = 17;\\n    let b: u64 = 23;\\n\\n    // First, we make the prover, loading the \'multiply\' method.\\n    let multiply_src = std::fs::read(MULTIPLY_PATH)\\n        .expect(\\"Method code should be present at the specified path.\\");\\n    let mut prover = Prover::new(&multiply_src, MULTIPLY_ID)\\n        .expect(\\"Prover should be constructed.\\",);\\n\\n    // Next we send a & b to the guest.\\n    prover.add_input_u32_slice(to_vec(&a).unwrap().as_slice());\\n    prover.add_input_u32_slice(to_vec(&b).unwrap().as_slice());\\n    \\n    // Run prover & generate receipt\\n    let receipt = prover.run()\\n        .expect(\\"Valid code should be provable.\\");\\n\\n    // Extract journal of receipt (i.e. output c, where c = a * b)\\n    let c: u64 = from_slice(&receipt.journal)\\n        .expect(\\"Journal output should deserialize.\\");\\n\\n    // Print an assertion\\n    println!(\\"I know the factors of {}, and I can prove it!\\", c);\\n\\n    // Verify receipt, panic if it\'s wrong.\\n    receipt.verify(MULTIPLY_ID).expect(\\n        \\"Code you have proven should successfully verify.\\",\\n    );\\n\\n    // Convert journal to string and store on disk.\\n    let journal = serde_json::to_string(&receipt.journal).unwrap();\\n    write_to_file(\\"../data/journal\\", &journal);\\n\\n    // Convert seal to string and store on disk.\\n    let seal = serde_json::to_string(&receipt.seal).unwrap();\\n    write_to_file(\\"../data/seal\\", &seal);\\n\\n    // Convert method_id to string and store on disk.\\n    let result = serde_json::to_string(MULTIPLY_ID).unwrap();\\n    write_to_file(\\"../data/method\\", &result);\\n}\\n```\\n\\n### Verifier\\nNow the verification step.\\nGiven the proof (journal + seal) and the guest program definition (method),\\nCasper\'s smart contract checks its correctness. This one is written\\njust for the demonstration, but in general you want `METHOD_ID` to be\\nstored in your contract and both `SEAL` and `JOURNAL` to be passed to\\nthe contract via arguments from the outside.\\n\\n```rust title=\\"verifier/src/verifier_contract.rs\\"\\n// Import the proof and the method.\\nconst METHOD_ID: &[u8] = &include!(\\"../../data/method\\");\\nconst SEAL: &[u32] = &include!(\\"../../data/seal\\");\\nconst JOURNAL: &[u32] = &include!(\\"../../data/journal\\");\\n\\n// Verifier contract holds a result of the zk verification. \\n#[odra::module]\\npub struct Verifier {\\n    result: Variable<String>,\\n}\\n\\n#[odra::module]\\nimpl Verifier {\\n    // Calling this entry point triggers the zk proof verification.\\n    pub fn verify(&mut self) {\\n        let result = verify(JOURNAL, SEAL, METHOD_ID);\\n        self.result.set(result);\\n    }\\n\\n    // Result getter.\\n    pub fn result(&self) -> String {\\n        self.result.get().unwrap_or(String::from(\\"Not processed\\"))\\n    }\\n}\\n\\n// The verification method. It constructs new Receipt and verifies it.\\nfn verify(journal: &[u32], seal: &[u32], method_id: &[u8]) -> String {\\n    let result = Receipt::new(&journal, &seal).verify(method_id);\\n\\n    match result {\\n        Ok(()) => String::from(\\"Ok\\"),\\n        Err(err) => format!(\\"Error: {}\\", err.to_string())\\n    }\\n}\\n```\\n\\n### Livenet results\\nI have deployed it to the testnet and called the `verify` method.\\nThe `result` was `Ok`. Wow, first-ever ZK proof verification on Casper.\\nTrustless bridging, layer 2 here we come :)\\n\\nThe cost of running the `verify` method is `2324 CSPR`. That\'s a lot, but\\nwe have to start somewhere.\\n\\n## What next\\nI think it is a good place to outline possible Casper ZK goals for moving\\nthis forward. The community should discuss: \\n1. Building more examples. Risc Zero has a nice battleship game to port over\\nto Casper.\\n2. Adding Risc Zero verification method to Casper\'s FFI.\\n3. Supporting Risc Zero team. We should help develop this awesome\\nopen-source project and gain the ZK expertise.\\n\\n## Join us\\nInterested in zero knowledge on Casper?\\n\\nJoin [our Discord][odra-discord], [our Twitter][odra-twitter] or write us\\nat contact@odra.dev.\\n\\n[odra-discord]:    https://discord.gg/Mm5ABc9P8k\\n[odra-twitter]:    https://twitter.com/odradev"},{"id":"release-020","metadata":{"permalink":"/blog/release-020","source":"@site/blog/2022-11-30-release-020/index.md","title":"Odra 0.2.0 Released","description":"We want to introduce you to the very first public release of the Odra Framework proudly!","date":"2022-11-30T00:00:00.000Z","formattedDate":"November 30, 2022","tags":[],"readingTime":3.07,"hasTruncateMarker":true,"authors":[{"name":"Kuba P\u0142askonka","title":"Lead Developer","url":"https://github.com/kubaplas","key":"kubaplas"},{"name":"Krzysztof Pobiar\u017cyn","title":"Lead Developer","url":"https://github.com/kpob","key":"kpob"},{"name":"Maciej Zieli\u0144ski","title":"CTO","url":"https://github.com/zie1ony","key":"zie1ony"}],"frontMatter":{"slug":"release-020","title":"Odra 0.2.0 Released","authors":["kubaplas","kpob","zie1ony"],"image":"https://github.com/odradev.png"},"prevItem":{"title":"Zero Knowledge on Casper","permalink":"/blog/casper-zk-risc0"}},"content":"We want to introduce you to the very first public release of the Odra Framework proudly!\\n\\n\x3c!--truncate--\x3e\\n\\n## A bit of history\\nMore than a year ago Maciej Zieli\u0144ski resigned from the position of Ecosystem Leader at [CasperLabs][casperlabs].\\nAlong with Krzysztof Pobiar\u017cyn and Kuba P\u0142askonka, we formed an engineering team dedicated to smart contracts.\\n\\nLooking at the blockchain ecosystems from the smart contract developer perspective there are two universes.\\nThe first one is Solidity, which thrives and is at its best now.\\nIt has a ton of well-tested code and security tooling.\\nWhenever an EVM-based blockchain pops out it gets populated by forks of DeFi and DAO protocols.\\nFascinating network effect emerges - code written for one EVM-based blockchain can be run on every other EVM-based blockchain.\\nThe second universe is Rust which compiles to WebAssembly.\\nHere developer communities live in the guarded cities of Polkadot, Cosmos, Solana, Casper, and Near. \\nThe code written for one platform is not portable.\\nThe network effect never had a chance to arise.\\n\\nThe main reason why Odra exists is achieving this cross-chain code reusability.\\nWe could paraphrase a bit and say:\\n\\"One to bring them all and in the code bind them.\\"\\n\\n## Odra for Casper\\nThe very first blockchain we have integrated with Odra is Casper.\\nIn comparison to [casper-contract][casper-contract] API, it greatly cuts development time and offers a much lower entry level.\\nThe Odra interface is developer friendly and people familiar with Solidity, [Ink][ink], or [Near][near-sdk] will feel like at home.\\nWe hope it will unleash the creativity and bring a whole bunch of products onto Casper.\\n\\n## Odra Framework\\n\\nOdra is a high-level smart contract framework for Rust, which encourages rapid development and clean, pragmatic design.\\nBuilt by experienced developers, it takes care of much of the hassle of smart contract development, enabling you to focus on writing your dapp without reinventing the wheel.\\nIt\'s free and open source.\\n\\nOdra\'s goal is to become the go-to smart contract framework for all WebAssembly-based blockchains. \\n\\nA smart contract written using Odra can be executed on all integrated systems.\\nWe can do it by abstracting over core concepts that all the above systems are built around. \\nThese are type system, storage, entry points, execution context, and testing environment.\\nWe believe it will bring standardization to the development of Rust-based smart contracts and enable code reusability we have not yet seen in this ecosystem.\\n\\nLet\u2019s look at a Flipper contract, that holds a boolean value.\\nThe contract has a constructor that sets the initial value, and two entry points: `flip()` and `get()`, to change and query the current value, respectively.\\n\\n```rust\\nuse odra::Variable;\\n\\n#[odra::module]\\npub struct Flipper {\\n    value: Variable<bool>,\\n}\\n\\n#[odra::module]\\nimpl Flipper {\\n\\n    #[odra(init)]\\n    pub fn init(&mut self, value: bool) {\\n        self.value.set(value);\\n    }\\n\\n    pub fn flip(&mut self) {\\n        self.value.set(!self.get());\\n    }\\n\\n    pub fn get(&self) -> bool {\\n        self.value.get_or_default()\\n    }\\n}\\n```\\n\\nIt comes with the CLI tool [cargo-odra][cargo-odra] that makes it easy to use Odra.\\n\\n![cargo-odra](./cargo_odra.gif)\\n\\nNeat and simple, isn\'t it? Do you like it? Start flowing with us!\\n\\n## What next\\n\\nLet\'s be honest, we are just starting.\\nThe codebase is still hot.\\nOn the other hand, we are happy with the interfaces we designed.\\nNow is the time to write documentation and tutorials.\\nWe are also building the modules library inspired by [OpenZeppelin][open-zeppelin].\\nThe security code audit is still ahead of us.\\n\\n## Join us\\n\\nCheck out the [Odra GitHub repository][odra-repo] for more info on how to get the most out of Odra. \\nShould you have questions, join [our Discord][odra-discord], [our Twitter][odra-twitter] or write us at contact@odra.dev.\\n\\n[casperlabs]:      https://casperlabs.io\\n[odra-repo]:       https://github.com/odradev/odra\\n[cargo-odra]:      https://github.com/odradev/cargo-odra\\n[odra-discord]:    https://discord.gg/Mm5ABc9P8k\\n[odra-twitter]:    https://twitter.com/odradev\\n[casper-contract]: https://crates.io/crates/casper-contract\\n[ink]:             https://crates.io/crates/ink_lang\\n[near-sdk]:        https://crates.io/crates/near-sdk\\n[open-zeppelin]:   https://github.com/OpenZeppelin/openzeppelin-contracts/"}]}')}}]);