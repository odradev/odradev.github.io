"use strict";(self.webpackChunkodra_website=self.webpackChunkodra_website||[]).push([[88279],{3905:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>m});var r=t(67294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var i=r.createContext({}),d=function(e){var n=r.useContext(i),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},u=function(e){var n=d(e.components);return r.createElement(i.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},c=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,o=e.originalType,i=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),c=d(t),m=a,f=c["".concat(i,".").concat(m)]||c[m]||p[m]||o;return t?r.createElement(f,s(s({ref:n},u),{},{components:t})):r.createElement(f,s({ref:n},u))}));function m(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=t.length,s=new Array(o);s[0]=c;var l={};for(var i in n)hasOwnProperty.call(n,i)&&(l[i]=n[i]);l.originalType=e,l.mdxType="string"==typeof e?e:a,s[1]=l;for(var d=2;d<o;d++)s[d]=t[d];return r.createElement.apply(null,s)}return r.createElement.apply(null,t)}c.displayName="MDXCreateElement"},85162:(e,n,t)=>{t.d(n,{Z:()=>s});var r=t(67294),a=t(86010);const o="tabItem_Ymn6";function s(e){let{children:n,hidden:t,className:s}=e;return r.createElement("div",{role:"tabpanel",className:(0,a.Z)(o,s),hidden:t},n)}},74866:(e,n,t)=>{t.d(n,{Z:()=>y});var r=t(87462),a=t(67294),o=t(86010),s=t(12466),l=t(16550),i=t(91980),d=t(67392),u=t(50012);function p(e){return function(e){return a.Children.map(e,(e=>{if((0,a.isValidElement)(e)&&"value"in e.props)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))}(e).map((e=>{let{props:{value:n,label:t,attributes:r,default:a}}=e;return{value:n,label:t,attributes:r,default:a}}))}function c(e){const{values:n,children:t}=e;return(0,a.useMemo)((()=>{const e=n??p(t);return function(e){const n=(0,d.l)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,t])}function m(e){let{value:n,tabValues:t}=e;return t.some((e=>e.value===n))}function f(e){let{queryString:n=!1,groupId:t}=e;const r=(0,l.k6)(),o=function(e){let{queryString:n=!1,groupId:t}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return t??null}({queryString:n,groupId:t});return[(0,i._X)(o),(0,a.useCallback)((e=>{if(!o)return;const n=new URLSearchParams(r.location.search);n.set(o,e),r.replace({...r.location,search:n.toString()})}),[o,r])]}function v(e){const{defaultValue:n,queryString:t=!1,groupId:r}=e,o=c(e),[s,l]=(0,a.useState)((()=>function(e){let{defaultValue:n,tabValues:t}=e;if(0===t.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!m({value:n,tabValues:t}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${n}" but none of its children has the corresponding value. Available values are: ${t.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return n}const r=t.find((e=>e.default))??t[0];if(!r)throw new Error("Unexpected error: 0 tabValues");return r.value}({defaultValue:n,tabValues:o}))),[i,d]=f({queryString:t,groupId:r}),[p,v]=function(e){let{groupId:n}=e;const t=function(e){return e?`docusaurus.tab.${e}`:null}(n),[r,o]=(0,u.Nk)(t);return[r,(0,a.useCallback)((e=>{t&&o.set(e)}),[t,o])]}({groupId:r}),g=(()=>{const e=i??p;return m({value:e,tabValues:o})?e:null})();(0,a.useLayoutEffect)((()=>{g&&l(g)}),[g]);return{selectedValue:s,selectValue:(0,a.useCallback)((e=>{if(!m({value:e,tabValues:o}))throw new Error(`Can't select invalid tab value=${e}`);l(e),d(e),v(e)}),[d,v,o]),tabValues:o}}var g=t(72389);const h="tabList__CuJ",k="tabItem_LNqP";function b(e){let{className:n,block:t,selectedValue:l,selectValue:i,tabValues:d}=e;const u=[],{blockElementScrollPositionUntilNextRender:p}=(0,s.o5)(),c=e=>{const n=e.currentTarget,t=u.indexOf(n),r=d[t].value;r!==l&&(p(n),i(r))},m=e=>{let n=null;switch(e.key){case"Enter":c(e);break;case"ArrowRight":{const t=u.indexOf(e.currentTarget)+1;n=u[t]??u[0];break}case"ArrowLeft":{const t=u.indexOf(e.currentTarget)-1;n=u[t]??u[u.length-1];break}}n?.focus()};return a.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,o.Z)("tabs",{"tabs--block":t},n)},d.map((e=>{let{value:n,label:t,attributes:s}=e;return a.createElement("li",(0,r.Z)({role:"tab",tabIndex:l===n?0:-1,"aria-selected":l===n,key:n,ref:e=>u.push(e),onKeyDown:m,onClick:c},s,{className:(0,o.Z)("tabs__item",k,s?.className,{"tabs__item--active":l===n})}),t??n)})))}function _(e){let{lazy:n,children:t,selectedValue:r}=e;if(t=Array.isArray(t)?t:[t],n){const e=t.find((e=>e.props.value===r));return e?(0,a.cloneElement)(e,{className:"margin-top--md"}):null}return a.createElement("div",{className:"margin-top--md"},t.map(((e,n)=>(0,a.cloneElement)(e,{key:n,hidden:e.props.value!==r}))))}function N(e){const n=v(e);return a.createElement("div",{className:(0,o.Z)("tabs-container",h)},a.createElement(b,(0,r.Z)({},e,n)),a.createElement(_,(0,r.Z)({},e,n)))}function y(e){const n=(0,g.Z)();return a.createElement(N,(0,r.Z)({key:String(n)},e))}},68665:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>u,contentTitle:()=>i,default:()=>m,frontMatter:()=>l,metadata:()=>d,toc:()=>p});var r=t(87462),a=(t(67294),t(3905)),o=t(74866),s=t(85162);const l={sidebar_position:1,description:"Migration guide to v0.8.0"},i="Migration guide to v0.8.0",d={unversionedId:"migrations/to-0.8.0",id:"version-2.0.1/migrations/to-0.8.0",title:"Migration guide to v0.8.0",description:"Migration guide to v0.8.0",source:"@site/versioned_docs/version-2.0.1/migrations/to-0.8.0.md",sourceDirName:"migrations",slug:"/migrations/to-0.8.0",permalink:"/docs/2.0.1/migrations/to-0.8.0",draft:!1,tags:[],version:"2.0.1",lastUpdatedAt:1752055773,formattedLastUpdatedAt:"Jul 9, 2025",sidebarPosition:1,frontMatter:{sidebar_position:1,description:"Migration guide to v0.8.0"},sidebar:"tutorialSidebar",previous:{title:"Migrations",permalink:"/docs/2.0.1/category/migrations"},next:{title:"Migration guide to v0.9.0",permalink:"/docs/2.0.1/migrations/to-0.9.0"}},u={},p=[{value:"<strong>1. Prerequisites</strong>",id:"1-prerequisites",level:2},{value:"1.1. <strong>Update cargo-odra</strong>",id:"11-update-cargo-odra",level:3},{value:"1.2. <strong>Review the Changelog</strong>",id:"12-review-the-changelog",level:3},{value:"<strong>2. Migration Steps</strong>",id:"2-migration-steps",level:2},{value:"2.1 <strong>Add bin directory</strong>",id:"21-add-bin-directory",level:3},{value:"2.2. <strong>Update Cargo.toml</strong>",id:"22-update-cargotoml",level:3},{value:"2.2. <strong>Update Odra.toml</strong>",id:"22-update-odratoml",level:3},{value:"2.3. <strong>Update Smart Contracts</strong>",id:"23-update-smart-contracts",level:3},{value:"2.3.1. <strong>Update the <code>use</code> statements to reflect the new module structure.</strong>",id:"231-update-the-use-statements-to-reflect-the-new-module-structure",level:4},{value:"2.3.2. <strong>Some type aliases are no longer in use.</strong>",id:"232-some-type-aliases-are-no-longer-in-use",level:4},{value:"2.3.3. <strong>Consider import <code>odra::prelude::*</code> in your module files.</strong>",id:"233-consider-import-odraprelude-in-your-module-files",level:4},{value:"2.3.4. <strong>Flatten nested <code>Mapping</code>s.</strong>",id:"234-flatten-nested-mappings",level:4},{value:"2.3.5. <strong>Update errors definitions.</strong>",id:"235-update-errors-definitions",level:4},{value:"2.3.6. <strong>Update events definitions.</strong>",id:"236-update-events-definitions",level:4},{value:"2.3.7. <strong>Replace <code>contract_env</code> with <code>self.env()</code> in your modules.</strong>",id:"237-replace-contract_env-with-selfenv-in-your-modules",level:4},{value:"2.3.8. <strong>Wrap submodules of your module with <code>odra::SubModule&lt;T&gt;</code>.</strong>",id:"238-wrap-submodules-of-your-module-with-odrasubmodulet",level:4},{value:"2.3.9. <strong>Update external contract calls.</strong>",id:"239-update-external-contract-calls",level:4},{value:"2.3.10. <strong>Update constructors.</strong>",id:"2310-update-constructors",level:4},{value:"2.3.11. <strong>Update <code>UnwrapOrRevert</code> calls.</strong>",id:"2311-update-unwraporrevert-calls",level:4},{value:"2.3.12. <strong>Remove <code>#[odra(using)]</code> attribute from your module definition.</strong>",id:"2312-remove-odrausing-attribute-from-your-module-definition",level:4},{value:"2.4. <strong>Update Tests</strong>",id:"24-update-tests",level:3},{value:"2.4.1. <strong>Contract deployment.</strong>",id:"241-contract-deployment",level:4},{value:"2.4.2. <strong>Host interactions.</strong>",id:"242-host-interactions",level:4},{value:"2.4.3. <strong>Testing failing scenarios.</strong>",id:"243-testing-failing-scenarios",level:4},{value:"2.4.4. <strong>Testing events.</strong>",id:"244-testing-events",level:4},{value:"3. <strong>Code Examples</strong>",id:"3-code-examples",level:2},{value:"4. <strong>Troubleshooting</strong>",id:"4-troubleshooting",level:2},{value:"5. <strong>References</strong>",id:"5-references",level:2}],c={toc:p};function m(e){let{components:n,...t}=e;return(0,a.kt)("wrapper",(0,r.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"migration-guide-to-v080"},"Migration guide to v0.8.0"),(0,a.kt)("p",null,"Odra v0.8.0 introduces several breaking changes that require users to update their smart contracts and tests. This migration guide provides a detailed overview of the changes, along with step-by-step instructions for migrating existing code to the new version."),(0,a.kt)("p",null,"This guide is intended for developers who have built smart contracts using previous versions of Odra and need to update their code to be compatible with v0.8.0. It assumes a basic understanding of smart contract development and the Odra framework. If you're new to Odra, we recommend to start your journey with the ",(0,a.kt)("a",{parentName:"p",href:"../category/getting-started/"},"Getting Started"),"."),(0,a.kt)("p",null,"The most significant changes in v0.8.0 include:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Odra is not a blockchain-agnostic framework anymore. It is now a Casper smart contract framework only."),(0,a.kt)("li",{parentName:"ul"},"Framework internals redesign.")),(0,a.kt)("h2",{id:"1-prerequisites"},(0,a.kt)("strong",{parentName:"h2"},"1. Prerequisites")),(0,a.kt)("h3",{id:"11-update-cargo-odra"},"1.1. ",(0,a.kt)("strong",{parentName:"h3"},"Update cargo-odra")),(0,a.kt)("p",null,"Before you begin the migration process, make sure you installed the latest version of the Cargo Odra toolchain. You can install it by running the following command:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"cargo install cargo-odra --force --locked\n")),(0,a.kt)("h3",{id:"12-review-the-changelog"},"1.2. ",(0,a.kt)("strong",{parentName:"h3"},"Review the Changelog")),(0,a.kt)("p",null,"Before you move to changing your code, start by reviewing the ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/odradev/odra/blob/release/0.8.0/CHANGELOG.md"},"Changelog")," to understand the changes introduced in v0.8.0."),(0,a.kt)("h2",{id:"2-migration-steps"},(0,a.kt)("strong",{parentName:"h2"},"2. Migration Steps")),(0,a.kt)("h3",{id:"21-add-bin-directory"},"2.1 ",(0,a.kt)("strong",{parentName:"h3"},"Add bin directory")),(0,a.kt)("p",null,"Odra 0.8.0 introduces a new way to build smart contracts. The ",(0,a.kt)("inlineCode",{parentName:"p"},".builder_casper")," directory is no longer used. Instead, you should create a new directory called ",(0,a.kt)("inlineCode",{parentName:"p"},"bin")," in the root of your project and add the ",(0,a.kt)("inlineCode",{parentName:"p"},"build_contract.rs")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"build_schema.rs")," files to the ",(0,a.kt)("inlineCode",{parentName:"p"},"bin")," directory."),(0,a.kt)("p",null,"You can find the ",(0,a.kt)("inlineCode",{parentName:"p"},"build_contract.rs")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"build_schema.rs")," files in ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/odradev/odra/blob/release/0.8.0/templates"},"templates")," directory in the Odra main repository. You can choose whatever template you want to use and copy the files to your project. In both files, you should replace ",(0,a.kt)("inlineCode",{parentName:"p"},"{{project-name}}")," with the name of your project."),(0,a.kt)("h3",{id:"22-update-cargotoml"},"2.2. ",(0,a.kt)("strong",{parentName:"h3"},"Update Cargo.toml")),(0,a.kt)("p",null,"There a bunch of changes in the ",(0,a.kt)("inlineCode",{parentName:"p"},"Cargo.toml")," file."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"You don't have to specify the features anymore - remove the ",(0,a.kt)("inlineCode",{parentName:"li"},"features")," section and ",(0,a.kt)("inlineCode",{parentName:"li"},"default-features")," flag from the ",(0,a.kt)("inlineCode",{parentName:"li"},"odra")," dependency."),(0,a.kt)("li",{parentName:"ul"},"Register bins you added in the previous step."),(0,a.kt)("li",{parentName:"ul"},"Add ",(0,a.kt)("inlineCode",{parentName:"li"},"dev-dependencies")," section with ",(0,a.kt)("inlineCode",{parentName:"li"},"odra-test")," crate."),(0,a.kt)("li",{parentName:"ul"},"Add recommended profiles for ",(0,a.kt)("inlineCode",{parentName:"li"},"release")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"dev")," to optimize the build process.")),(0,a.kt)("p",null,"Below you can compare the ",(0,a.kt)("inlineCode",{parentName:"p"},"Cargo.toml")," file after and before the migration to v0.8.0:"),(0,a.kt)(o.Z,{mdxType:"Tabs"},(0,a.kt)(s.Z,{value:"current",label:"0.8.0",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-toml"},'[package]\nname = "my_project"\nversion = "0.1.0"\nedition = "2021"\n\n[dependencies]\nodra = "0.8.0"\n\n[dev-dependencies]\nodra-test = "0.8.0"\n\n[[bin]]\nname = "my_project_build_contract"\npath = "bin/build_contract.rs"\ntest = false\n\n[[bin]]\nname = "my_project_build_schema"\npath = "bin/build_schema.rs"\ntest = false\n\n[profile.release]\ncodegen-units = 1\nlto = true\n\n[profile.dev.package."*"]\nopt-level = 3\n\n'))),(0,a.kt)(s.Z,{value:"old",label:"Prev",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-toml"},'[package]\nname = "my_project"\nversion = "0.1.0"\nedition = "2021"\n\n[dependencies]\nodra = { version = "0.7.1", default-features = false }\n\n[features]\ndefault = ["mock-vm"]\nmock-vm = ["odra/mock-vm"]\ncasper = ["odra/casper"]\n')))),(0,a.kt)("h3",{id:"22-update-odratoml"},"2.2. ",(0,a.kt)("strong",{parentName:"h3"},"Update Odra.toml")),(0,a.kt)("p",null,"Due to the changes in cargo-odra, the ",(0,a.kt)("inlineCode",{parentName:"p"},"Odra.toml")," file has been simplified. The ",(0,a.kt)("inlineCode",{parentName:"p"},"name")," property is no longer required."),(0,a.kt)(o.Z,{mdxType:"Tabs"},(0,a.kt)(s.Z,{value:"current",label:"0.8.0",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-toml"},'[[contracts]]\nfqn = "my_project::Flipper"\n'))),(0,a.kt)(s.Z,{value:"old",label:"Prev",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-toml"},'[[contracts]]\nname = "flipper"\nfqn = "my_project::Flipper"\n')))),(0,a.kt)("h3",{id:"23-update-smart-contracts"},"2.3. ",(0,a.kt)("strong",{parentName:"h3"},"Update Smart Contracts")),(0,a.kt)("p",null,"The smart contracts themselves will need to be updated to work with the new version of the framework. The changes will depend on the specific features and APIs used in the contracts. Here are some common changes you might need to make:"),(0,a.kt)("h4",{id:"231-update-the-use-statements-to-reflect-the-new-module-structure"},"2.3.1. ",(0,a.kt)("strong",{parentName:"h4"},"Update the ",(0,a.kt)("inlineCode",{parentName:"strong"},"use")," statements to reflect the new module structure.")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Big integer types are now located in the ",(0,a.kt)("inlineCode",{parentName:"li"},"odra::casper_types")," module."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"odra::types::Address")," is now ",(0,a.kt)("inlineCode",{parentName:"li"},"odra::Address"),"."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"Variable")," is now ",(0,a.kt)("inlineCode",{parentName:"li"},"Var"),"."),(0,a.kt)("li",{parentName:"ul"},"Remove ",(0,a.kt)("inlineCode",{parentName:"li"},"odra::contract_env"),"."),(0,a.kt)("li",{parentName:"ul"},"Remove ",(0,a.kt)("inlineCode",{parentName:"li"},"odra::types::event::OdraEvent"),"."),(0,a.kt)("li",{parentName:"ul"},"Remove ",(0,a.kt)("inlineCode",{parentName:"li"},"odra::types::OdraType")," as it is no longer required."),(0,a.kt)("li",{parentName:"ul"},"Change ",(0,a.kt)("inlineCode",{parentName:"li"},"odra::types::casper_types::*;")," to ",(0,a.kt)("inlineCode",{parentName:"li"},"odra::casper_types::*;"),".")),(0,a.kt)("h4",{id:"232-some-type-aliases-are-no-longer-in-use"},"2.3.2. ",(0,a.kt)("strong",{parentName:"h4"},"Some type aliases are no longer in use.")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"Balance")," - use ",(0,a.kt)("inlineCode",{parentName:"li"},"odra::casper_types::U512"),"."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"BlockTime")," - use ",(0,a.kt)("inlineCode",{parentName:"li"},"u64"),"."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"EventData")," - use ",(0,a.kt)("inlineCode",{parentName:"li"},"odra::casper_types::bytesrepr::Bytes"),".")),(0,a.kt)("h4",{id:"233-consider-import-odraprelude-in-your-module-files"},"2.3.3. ",(0,a.kt)("strong",{parentName:"h4"},"Consider import ",(0,a.kt)("inlineCode",{parentName:"strong"},"odra::prelude::*")," in your module files.")),(0,a.kt)("h4",{id:"234-flatten-nested-mappings"},"2.3.4. ",(0,a.kt)("strong",{parentName:"h4"},"Flatten nested ",(0,a.kt)("inlineCode",{parentName:"strong"},"Mapping"),"s.")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"// Before\n#[odra::module(events = [Approval, Transfer])]\npub struct Erc20 {\n   ...\n   allowances: Mapping<Address, Mapping<Address, U256>>\n}\n// After\n#[odra::module(events = [Approval, Transfer])]\npub struct Erc20 {\n   ...\n   allowances: Mapping<(Address, Address), U256>\n}\n")),(0,a.kt)("h4",{id:"235-update-errors-definitions"},"2.3.5. ",(0,a.kt)("strong",{parentName:"h4"},"Update errors definitions.")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"execution_error!")," macro has been replace with ",(0,a.kt)("inlineCode",{parentName:"p"},"OdraError")," derive macro."),(0,a.kt)(o.Z,{mdxType:"Tabs"},(0,a.kt)(s.Z,{value:"current",label:"0.8.0",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"use odra::OdraError;\n\n#[derive(OdraError)]\npub enum Error {\n   InsufficientBalance = 30_000,\n   InsufficientAllowance = 30_001,\n   NameNotSet = 30_002,\n   SymbolNotSet = 30_003,\n   DecimalsNotSet = 30_004\n}\n"))),(0,a.kt)(s.Z,{value:"old",label:"Prev",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"use odra::execution_error;\n\nexecution_error! {\n   pub enum Error {\n      InsufficientBalance => 30_000,\n      InsufficientAllowance => 30_001,\n      NameNotSet => 30_002,\n      SymbolNotSet => 30_003,\n      DecimalsNotSet => 30_004,\n   }\n}\n")))),(0,a.kt)("h4",{id:"236-update-events-definitions"},"2.3.6. ",(0,a.kt)("strong",{parentName:"h4"},"Update events definitions.")),(0,a.kt)(o.Z,{mdxType:"Tabs"},(0,a.kt)(s.Z,{value:"current",label:"0.8.0",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"use odra::prelude::*;\nuse odra::Event;\n\n#[derive(Event, Eq, PartialEq, Debug)]\npub struct Transfer {\n   pub from: Option<Address>,\n   pub to: Option<Address>,\n   pub amount: U256\n}\n\n// Emitting the event\nself.env().emit_event(Transfer {\n   from: None,\n   to: Some(*address),\n   amount: *amount\n});\n"))),(0,a.kt)(s.Z,{value:"old",label:"Prev",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"use odra::Event;\n\n#[derive(Event, Eq, PartialEq, Debug)]\npub struct Transfer {\n   pub from: Option<Address>,\n   pub to: Option<Address>,\n   pub amount: U256\n}\n\n// Emitting the event\nuse odra::types::event::OdraEvent;\n\nTransfer {\n   from: Some(*owner),\n   to: Some(*recipient),\n   amount: *amount\n}.emit();\n")))),(0,a.kt)("h4",{id:"237-replace-contract_env-with-selfenv-in-your-modules"},"2.3.7. ",(0,a.kt)("strong",{parentName:"h4"},"Replace ",(0,a.kt)("inlineCode",{parentName:"strong"},"contract_env")," with ",(0,a.kt)("inlineCode",{parentName:"strong"},"self.env()")," in your modules.")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"self.env()")," is a new way to access the contract environment, returns a reference to ",(0,a.kt)("inlineCode",{parentName:"p"},"ContractEnv"),". The API is similar to the previous ",(0,a.kt)("inlineCode",{parentName:"p"},"contract_env")," but with some changes."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"fn get_var<T: FromBytes>(key: &[u8]) -> Option<T>")," is now ",(0,a.kt)("inlineCode",{parentName:"li"},"fn get_value<T: FromBytes>(&self, key: &[u8]) -> Option<T>"),"."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"fn set_var<T: CLTyped + ToBytes>(key: &[u8], value: T)")," is now ",(0,a.kt)("inlineCode",{parentName:"li"},"fn set_value<T: ToBytes + CLTyped>(&self, key: &[u8], value: T)"),"."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"set_dict_value()")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"get_dict_value()")," has been removed. All the dictionary operations should be performed using ",(0,a.kt)("inlineCode",{parentName:"li"},"Mapping")," type, internally using ",(0,a.kt)("inlineCode",{parentName:"li"},"set_var()")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"get_var()")," functions. "),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"fn hash<T: AsRef<[u8]>>(input: T) -> Vec<u8>")," is now ",(0,a.kt)("inlineCode",{parentName:"li"},"fn hash<T: ToBytes>(&self, value: T) -> [u8; 32]"),"."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"fn revert<E: Into<ExecutionError>>(error: E) -> !")," is now ",(0,a.kt)("inlineCode",{parentName:"li"},"fn revert<E: Into<OdraError>>(&self, error: E) -> !"),"."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"fn emit_event<T: ToBytes + OdraEvent>(event: T)")," is now ",(0,a.kt)("inlineCode",{parentName:"li"},"fn emit_event<T: ToBytes>(&self, event: T)"),"."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"fn call_contract<T: CLTyped + FromBytes>(address: Address, entrypoint: &str, args: &RuntimeArgs, amount: Option<U512>) -> T")," is now ",(0,a.kt)("inlineCode",{parentName:"li"},"fn call_contract<T: FromBytes>(&self, address: Address, call: CallDef) -> T"),"."),(0,a.kt)("li",{parentName:"ul"},"functions ",(0,a.kt)("inlineCode",{parentName:"li"},"native_token_metadata()")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"one_token()")," have been removed.")),(0,a.kt)("h4",{id:"238-wrap-submodules-of-your-module-with-odrasubmodulet"},"2.3.8. ",(0,a.kt)("strong",{parentName:"h4"},"Wrap submodules of your module with ",(0,a.kt)("inlineCode",{parentName:"strong"},"odra::SubModule<T>"),".")),(0,a.kt)(o.Z,{mdxType:"Tabs"},(0,a.kt)(s.Z,{value:"current",label:"0.8.0",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"#[odra::module(events = [Transfer])]\npub struct Erc721Token {\n    core: SubModule<Erc721Base>,\n    metadata: SubModule<Erc721MetadataExtension>,\n    ownable: SubModule<Ownable>\n}\n"))),(0,a.kt)(s.Z,{value:"old",label:"Prev",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"#[odra::module(events = [Transfer])]\npub struct Erc721Token {\n    core: Erc721Base,\n    metadata: Erc721MetadataExtension,\n    ownable: Ownable\n}\n")))),(0,a.kt)("h4",{id:"239-update-external-contract-calls"},"2.3.9. ",(0,a.kt)("strong",{parentName:"h4"},"Update external contract calls.")),(0,a.kt)("p",null,"However the definition of an external contract remains the same, the way you call it has changed. A reference to an external contract is named ",(0,a.kt)("inlineCode",{parentName:"p"},"{{ModuleName}}ContractRef")," (former ",(0,a.kt)("inlineCode",{parentName:"p"},"{{ModuleName}}Ref"),") and you can call it using ",(0,a.kt)("inlineCode",{parentName:"p"},"{{ModuleName}}ContractRef::new(env, address)")," (former ",(0,a.kt)("inlineCode",{parentName:"p"},"{{ModuleName}}Ref::at()"),")."),(0,a.kt)(o.Z,{mdxType:"Tabs"},(0,a.kt)(s.Z,{value:"current",label:"0.8.0",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"#[odra::external_contract]\npub trait Token {\n    fn balance_of(&self, owner: &Address) -> U256;\n}\n\n// Usage\nTokenContractRef::new(env, token).balance_of(account)\n"))),(0,a.kt)(s.Z,{value:"old",label:"Prev",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"#[odra::external_contract]\npub trait Token {\n    fn balance_of(&self, owner: &Address) -> U256;\n}\n\n// Usage\nTokenRef::at(token).balance_of(account)\n")))),(0,a.kt)("h4",{id:"2310-update-constructors"},"2.3.10. ",(0,a.kt)("strong",{parentName:"h4"},"Update constructors.")),(0,a.kt)("p",null,"Remove the ",(0,a.kt)("inlineCode",{parentName:"p"},"#[odra::init]")," attribute from the constructor and ensure that the constructor function is named ",(0,a.kt)("inlineCode",{parentName:"p"},"init"),"."),(0,a.kt)("h4",{id:"2311-update-unwraporrevert-calls"},"2.3.11. ",(0,a.kt)("strong",{parentName:"h4"},"Update ",(0,a.kt)("inlineCode",{parentName:"strong"},"UnwrapOrRevert")," calls.")),(0,a.kt)("p",null,"The functions ",(0,a.kt)("inlineCode",{parentName:"p"},"unwrap_or_revert")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"unwrap_or_revert_with")," now require ",(0,a.kt)("inlineCode",{parentName:"p"},"&HostEnv")," as the first parameter."),(0,a.kt)("h4",{id:"2312-remove-odrausing-attribute-from-your-module-definition"},"2.3.12. ",(0,a.kt)("strong",{parentName:"h4"},"Remove ",(0,a.kt)("inlineCode",{parentName:"strong"},"#[odra(using)]")," attribute from your module definition.")),(0,a.kt)("p",null,"Sharing the same instance of a module is no longer supported. A redesign of the module structure might be required."),(0,a.kt)("h3",{id:"24-update-tests"},"2.4. ",(0,a.kt)("strong",{parentName:"h3"},"Update Tests")),(0,a.kt)("p",null,"Once you've updated your smart contracts, you'll need to update your tests to reflect the changes. The changes will depend on the specific features and APIs used in the tests. Here are some common changes you might need to make:"),(0,a.kt)("h4",{id:"241-contract-deployment"},"2.4.1. ",(0,a.kt)("strong",{parentName:"h4"},"Contract deployment.")),(0,a.kt)("p",null,"The way you deploy a contract has changed:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"You should use ",(0,a.kt)("inlineCode",{parentName:"li"},"{{ModuleName}}HostRef::deploy(&env, args)")," instead of ",(0,a.kt)("inlineCode",{parentName:"li"},"{{ModuleName}}Deployer::init()"),". The ",(0,a.kt)("inlineCode",{parentName:"li"},"{{ModuleName}}HostRef")," implements ",(0,a.kt)("inlineCode",{parentName:"li"},"odra::host::Deployer"),"."),(0,a.kt)("li",{parentName:"ol"},"Instantiate the ",(0,a.kt)("inlineCode",{parentName:"li"},"HostEnv")," using ",(0,a.kt)("inlineCode",{parentName:"li"},"odra_test::env()"),", required by the ",(0,a.kt)("inlineCode",{parentName:"li"},"odra::host::Deployer::deploy()")," function."),(0,a.kt)("li",{parentName:"ol"},"If the contract doesn't have init args, you should use ",(0,a.kt)("inlineCode",{parentName:"li"},"odra::host::NoArgs")," as the second argument of the ",(0,a.kt)("inlineCode",{parentName:"li"},"deploy")," function."),(0,a.kt)("li",{parentName:"ol"},"If the contract has init args, you should pass the autogenerated ",(0,a.kt)("inlineCode",{parentName:"li"},"{{ModuleName}}InitArgs")," as the second argument of the ",(0,a.kt)("inlineCode",{parentName:"li"},"deploy")," function.")),(0,a.kt)(o.Z,{mdxType:"Tabs"},(0,a.kt)(s.Z,{value:"current",label:"0.8.0",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"// A contract without init args\nuse super::OwnableHostRef;\nuse odra::host::{Deployer, HostEnv, HostRef, NoArgs};\n\nlet env: HostEnv = odra_test::env();\nlet ownable = OwnableHostRef::deploy(&env, NoArgs)\n\n// A contract with init args\nuse super::{Erc20HostRef, Erc20InitArgs};\nuse odra::host::{Deployer, HostEnv};\n\nlet env: HostEnv = odra_test::env();\nlet init_args = Erc20InitArgs {\n    symbol: SYMBOL.to_string(),\n    name: NAME.to_string(),\n    decimals: DECIMALS,\n    initial_supply: Some(INITIAL_SUPPLY.into())\n};\nlet erc20 = Erc20HostRef::deploy(&env, init_args);\n"))),(0,a.kt)(s.Z,{value:"old",label:"Prev",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"// A contract without init args\nuse super::OwnableDeployer;\n\nlet ownable = OwnableDeployer::init();\n\n// A contract with init args\nlet erc20 = Erc20Deployer::init(\n   SYMBOL.to_string(),\n   NAME.to_string(),\n   DECIMALS,\n   &Some(INITIAL_SUPPLY.into())\n);\n")))),(0,a.kt)("h4",{id:"242-host-interactions"},"2.4.2. ",(0,a.kt)("strong",{parentName:"h4"},"Host interactions.")),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Replace ",(0,a.kt)("inlineCode",{parentName:"li"},"odra::test_env")," with ",(0,a.kt)("inlineCode",{parentName:"li"},"odra_test::env()"),"."),(0,a.kt)("li",{parentName:"ol"},"The API of ",(0,a.kt)("inlineCode",{parentName:"li"},"odra::test_env")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"odra_test::env()")," are similar, but there are some differences:",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"test_env::advance_block_time_by(BlockTime)")," is now ",(0,a.kt)("inlineCode",{parentName:"li"},"env.advance_block_time(u64)"),"."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"test_env::token_balance(Address)")," is now ",(0,a.kt)("inlineCode",{parentName:"li"},"env.balance_of(&Address)"),"."),(0,a.kt)("li",{parentName:"ul"},"functions ",(0,a.kt)("inlineCode",{parentName:"li"},"test_env::last_call_contract_gas_cost()"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"test_env::last_call_contract_gas_used()"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"test_env::total_gas_used(Address)"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"test_env::gas_report()")," have been removed. You should use ",(0,a.kt)("inlineCode",{parentName:"li"},"HostRef::last_call()")," and extract the data from a ",(0,a.kt)("inlineCode",{parentName:"li"},"odra::ContractCallResult")," instance. ",(0,a.kt)("inlineCode",{parentName:"li"},"HostRef")," is a trait implemented by ",(0,a.kt)("inlineCode",{parentName:"li"},"{{ModuleName}}HostRef"),".")))),(0,a.kt)("h4",{id:"243-testing-failing-scenarios"},"2.4.3. ",(0,a.kt)("strong",{parentName:"h4"},"Testing failing scenarios.")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"test_env::assert_exception()")," has been removed. You should use the ",(0,a.kt)("inlineCode",{parentName:"p"},"try_")," prefix to call the function and then assert the result.\n",(0,a.kt)("inlineCode",{parentName:"p"},"try_")," prefix is a new way to call a function that might fail. It returns a ",(0,a.kt)("a",{parentName:"p",href:"https://docs.rs/odra/0.8.0/odra/type.OdraResult.html"},(0,a.kt)("inlineCode",{parentName:"a"},"OdraResult"))," type, which you can then assert using the standard Rust ",(0,a.kt)("inlineCode",{parentName:"p"},"assert_eq!")," macro."),(0,a.kt)(o.Z,{mdxType:"Tabs"},(0,a.kt)(s.Z,{value:"current",label:"0.8.0",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"#[test]\nfn transfer_from_error() {\n   let (env, mut erc20) = setup();\n\n   let (owner, spender, recipient) =\n      (env.get_account(0), env.get_account(1), env.get_account(2));\n   let amount = 1_000.into();\n   env.set_caller(spender);\n\n   assert_eq!(\n      erc20.try_transfer_from(owner, recipient, amount),\n      Err(Error::InsufficientAllowance.into())\n   );\n}\n"))),(0,a.kt)(s.Z,{value:"old",label:"Prev",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"#[test]\nfn transfer_from_error() {\n   test_env::assert_exception(Error::InsufficientAllowance, || {\n      let mut erc20 = setup();\n\n      let (owner, spender, recipient) = (\n            test_env::get_account(0),\n            test_env::get_account(1),\n            test_env::get_account(2)\n      );\n      let amount = 1_000.into();\n      test_env::set_caller(spender);\n\n      erc20.transfer_from(&owner, &recipient, &amount)\n   });\n}\n")))),(0,a.kt)("h4",{id:"244-testing-events"},"2.4.4. ",(0,a.kt)("strong",{parentName:"h4"},"Testing events.")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"assert_events!")," macro has been removed. You should use ",(0,a.kt)("inlineCode",{parentName:"p"},"HostEnv::emitted_event()")," to assert the emitted events.\nThe new API doesn't allow to assert multiple events at once, but adds alternative ways to assert the emitted events. Check the ",(0,a.kt)("a",{parentName:"p",href:"https://docs.rs/odra/0.8.0/odra/host/struct.HostEnv.html"},(0,a.kt)("inlineCode",{parentName:"a"},"HostEnv"))," documentation to explore the available options."),(0,a.kt)(o.Z,{mdxType:"Tabs"},(0,a.kt)(s.Z,{value:"current",label:"0.8.0",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"let env: HostEnv = odra_test::env();\nlet erc20 = Erc20HostRef::deploy(&env, init_args);\n\n...\n\nassert!(env.emitted_event(\n   erc20.address(),\n   &Approval {\n         owner,\n         spender,\n         value: approved_amount - transfer_amount\n   }\n));\nassert!(env.emitted_event(\n   erc20.address(),\n   &Transfer {\n         from: Some(owner),\n         to: Some(recipient),\n         amount: transfer_amount\n   }\n));\n"))),(0,a.kt)(s.Z,{value:"old",label:"Prev",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"let erc20 = Erc20HostDeployer::init(&env, ...);\n\n...\n\nassert_events!(\n   erc20,\n   Approval {\n         owner,\n         spender,\n         value: approved_amount - transfer_amount\n   },\n   Transfer {\n         from: Some(owner),\n         to: Some(recipient),\n         amount: transfer_amount\n   }\n);\n")))),(0,a.kt)("h2",{id:"3-code-examples"},"3. ",(0,a.kt)("strong",{parentName:"h2"},"Code Examples")),(0,a.kt)("p",null,"Here is a complete example of a smart contract after and before the migration to v0.8.0."),(0,a.kt)(o.Z,{mdxType:"Tabs"},(0,a.kt)(s.Z,{value:"current",label:"0.8.0",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="src/erc20.rs"',title:'"src/erc20.rs"'},'use crate::erc20::errors::Error::*;\nuse crate::erc20::events::*;\nuse odra::prelude::*;\nuse odra::{casper_types::U256, Address, Mapping, Var};\n\n#[odra::module(events = [Approval, Transfer])]\npub struct Erc20 {\n   decimals: Var<u8>,\n   symbol: Var<String>,\n   name: Var<String>,\n   total_supply: Var<U256>,\n   balances: Mapping<Address, U256>,\n   allowances: Mapping<(Address, Address), U256>\n}\n\n#[odra::module]\nimpl Erc20 {\n   pub fn init(\n      &mut self,\n      symbol: String,\n      name: String,\n      decimals: u8,\n      initial_supply: Option<U256>\n   ) {\n      let caller = self.env().caller();\n      self.symbol.set(symbol);\n      self.name.set(name);\n      self.decimals.set(decimals);\n\n      if let Some(initial_supply) = initial_supply {\n         self.total_supply.set(initial_supply);\n         self.balances.set(&caller, initial_supply);\n\n         if !initial_supply.is_zero() {\n               self.env().emit_event(Transfer {\n                  from: None,\n                  to: Some(caller),\n                  amount: initial_supply\n               });\n         }\n      }\n   }\n\n   pub fn transfer(&mut self, recipient: &Address, amount: &U256) {\n      let caller = self.env().caller();\n      self.raw_transfer(&caller, recipient, amount);\n   }\n\n   pub fn transfer_from(&mut self, owner: &Address, recipient: &Address, amount: &U256) {\n      let spender = self.env().caller();\n\n      self.spend_allowance(owner, &spender, amount);\n      self.raw_transfer(owner, recipient, amount);\n   }\n\n   pub fn approve(&mut self, spender: &Address, amount: &U256) {\n      let owner = self.env().caller();\n\n      self.allowances.set(&(owner, *spender), *amount);\n      self.env().emit_event(Approval {\n         owner,\n         spender: *spender,\n         value: *amount\n      });\n   }\n\n   pub fn name(&self) -> String {\n      self.name.get_or_revert_with(NameNotSet)\n   }\n\n   // Other getter functions...\n\n   pub fn allowance(&self, owner: &Address, spender: &Address) -> U256 {\n      self.allowances.get_or_default(&(*owner, *spender))\n   }\n\n   pub fn mint(&mut self, address: &Address, amount: &U256) {\n      self.total_supply.add(*amount);\n      self.balances.add(address, *amount);\n\n      self.env().emit_event(Transfer {\n         from: None,\n         to: Some(*address),\n         amount: *amount\n      });\n   }\n\n   pub fn burn(&mut self, address: &Address, amount: &U256) {\n      if self.balance_of(address) < *amount {\n         self.env().revert(InsufficientBalance);\n      }\n      self.total_supply.subtract(*amount);\n      self.balances.subtract(address, *amount);\n\n      self.env().emit_event(Transfer {\n         from: Some(*address),\n         to: None,\n         amount: *amount\n      });\n   }\n}\n\nimpl Erc20 {\n   fn raw_transfer(&mut self, owner: &Address, recipient: &Address, amount: &U256) {\n      if *amount > self.balances.get_or_default(owner) {\n         self.env().revert(InsufficientBalance)\n      }\n\n      self.balances.subtract(owner, *amount);\n      self.balances.add(recipient, *amount);\n\n      self.env().emit_event(Transfer {\n         from: Some(*owner),\n         to: Some(*recipient),\n         amount: *amount\n      });\n   }\n\n   fn spend_allowance(&mut self, owner: &Address, spender: &Address, amount: &U256) {\n      let allowance = self.allowances.get_or_default(&(*owner, *spender));\n      if allowance < *amount {\n         self.env().revert(InsufficientAllowance)\n      }\n      self.allowances.subtract(&(*owner, *spender), *amount);\n\n      self.env().emit_event(Approval {\n         owner: *owner,\n         spender: *spender,\n         value: allowance - *amount\n      });\n   }\n}\n\npub mod events {\n   use odra::prelude::*;\n   use odra::{casper_types::U256, Address, Event};\n\n   #[derive(Event, Eq, PartialEq, Debug)]\n   pub struct Transfer {\n      pub from: Option<Address>,\n      pub to: Option<Address>,\n      pub amount: U256\n   }\n\n   #[derive(Event, Eq, PartialEq, Debug)]\n   pub struct Approval {\n      pub owner: Address,\n      pub spender: Address,\n      pub value: U256\n   }\n}\n\npub mod errors {\n   use odra::OdraError;\n\n   #[derive(OdraError)]\n   pub enum Error {\n      InsufficientBalance = 30_000,\n      InsufficientAllowance = 30_001,\n      NameNotSet = 30_002,\n      SymbolNotSet = 30_003,\n      DecimalsNotSet = 30_004\n   }\n}\n\n#[cfg(test)]\nmod tests {\n   use super::{\n      errors::Error,\n      events::{Approval, Transfer},\n      Erc20HostRef, Erc20InitArgs\n   };\n   use odra::{\n      casper_types::U256,\n      host::{Deployer, HostEnv, HostRef},\n      prelude::*\n   };\n\n   const NAME: &str = "Plascoin";\n   const SYMBOL: &str = "PLS";\n   const DECIMALS: u8 = 10;\n   const INITIAL_SUPPLY: u32 = 10_000;\n\n   fn setup() -> (HostEnv, Erc20HostRef) {\n      let env = odra_test::env();\n      (\n         env.clone(),\n         Erc20HostRef::deploy(\n               &env,\n               Erc20InitArgs {\n                  symbol: SYMBOL.to_string(),\n                  name: NAME.to_string(),\n                  decimals: DECIMALS,\n                  initial_supply: Some(INITIAL_SUPPLY.into())\n               }\n         )\n      )\n   }\n\n   #[test]\n   fn initialization() {\n      // When deploy a contract with the initial supply.\n      let (env, erc20) = setup();\n\n      // Then the contract has the metadata set.\n      assert_eq!(erc20.symbol(), SYMBOL.to_string());\n      assert_eq!(erc20.name(), NAME.to_string());\n      assert_eq!(erc20.decimals(), DECIMALS);\n\n      // Then the total supply is updated.\n      assert_eq!(erc20.total_supply(), INITIAL_SUPPLY.into());\n\n      // Then a Transfer event was emitted.\n      assert!(env.emitted_event(\n         erc20.address(),\n         &Transfer {\n               from: None,\n               to: Some(env.get_account(0)),\n               amount: INITIAL_SUPPLY.into()\n         }\n      ));\n   }\n\n   #[test]\n   fn transfer_works() {\n      // Given a new contract.\n      let (env, mut erc20) = setup();\n\n      // When transfer tokens to a recipient.\n      let sender = env.get_account(0);\n      let recipient = env.get_account(1);\n      let amount = 1_000.into();\n      erc20.transfer(&recipient, &amount);\n\n      // Then the sender balance is deducted.\n      assert_eq!(\n         erc20.balance_of(&sender),\n         U256::from(INITIAL_SUPPLY) - amount\n      );\n\n      // Then the recipient balance is updated.\n      assert_eq!(erc20.balance_of(&recipient), amount);\n\n      // Then Transfer event was emitted.\n      assert!(env.emitted_event(\n         erc20.address(),\n         &Transfer {\n               from: Some(sender),\n               to: Some(recipient),\n               amount\n         }\n      ));\n   }\n\n   #[test]\n   fn transfer_error() {\n      // Given a new contract.\n      let (env, mut erc20) = setup();\n\n      // When the transfer amount exceeds the sender balance.\n      let recipient = env.get_account(1);\n      let amount = U256::from(INITIAL_SUPPLY) + U256::one();\n\n      // Then an error occurs.\n      assert!(erc20.try_transfer(&recipient, &amount).is_err());\n   }\n\n   // Other tests...\n}\n'))),(0,a.kt)(s.Z,{value:"old",label:"Prev",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="src/erc20.rs"',title:'"src/erc20.rs"'},'use odra::prelude::string::String;\nuse odra::{\n    contract_env,\n    types::{event::OdraEvent, Address, U256},\n    Mapping, UnwrapOrRevert, Variable\n};\n\nuse self::{\n    errors::Error,\n    events::{Approval, Transfer}\n};\n\n#[odra::module(events = [Approval, Transfer])]\npub struct Erc20 {\n    decimals: Variable<u8>,\n    symbol: Variable<String>,\n    name: Variable<String>,\n    total_supply: Variable<U256>,\n    balances: Mapping<Address, U256>,\n    allowances: Mapping<Address, Mapping<Address, U256>>\n}\n\n#[odra::module]\nimpl Erc20 {\n   #[odra(init)]\n   pub fn init(\n      &mut self,\n      symbol: String,\n      name: String,\n      decimals: u8,\n      initial_supply: &Option<U256>\n   ) {\n      let caller = contract_env::caller();\n\n      self.symbol.set(symbol);\n      self.name.set(name);\n      self.decimals.set(decimals);\n\n      if let Some(initial_supply) = *initial_supply {\n         self.total_supply.set(initial_supply);\n         self.balances.set(&caller, initial_supply);\n\n         if !initial_supply.is_zero() {\n               Transfer {\n                  from: None,\n                  to: Some(caller),\n                  amount: initial_supply\n               }\n               .emit();\n         }\n      }\n   }\n\n   pub fn transfer(&mut self, recipient: &Address, amount: &U256) {\n      let caller = contract_env::caller();\n      self.raw_transfer(&caller, recipient, amount);\n   }\n\n   pub fn transfer_from(&mut self, owner: &Address, recipient: &Address, amount: &U256) {\n      let spender = contract_env::caller();\n\n      self.spend_allowance(owner, &spender, amount);\n      self.raw_transfer(owner, recipient, amount);\n   }\n\n   pub fn approve(&mut self, spender: &Address, amount: &U256) {\n      let owner = contract_env::caller();\n\n      self.allowances.get_instance(&owner).set(spender, *amount);\n      Approval {\n         owner,\n         spender: *spender,\n         value: *amount\n      }\n      .emit();\n   }\n\n   pub fn name(&self) -> String {\n      self.name.get().unwrap_or_revert_with(Error::NameNotSet)\n   }\n\n   // Other getter functions...\n\n   pub fn allowance(&self, owner: &Address, spender: &Address) -> U256 {\n      self.allowances.get_instance(owner).get_or_default(spender)\n   }\n\n   pub fn mint(&mut self, address: &Address, amount: &U256) {\n      self.total_supply.add(*amount);\n      self.balances.add(address, *amount);\n\n      Transfer {\n         from: None,\n         to: Some(*address),\n         amount: *amount\n      }\n      .emit();\n   }\n\n   pub fn burn(&mut self, address: &Address, amount: &U256) {\n      if self.balance_of(address) < *amount {\n         contract_env::revert(Error::InsufficientBalance);\n      }\n      self.total_supply.subtract(*amount);\n      self.balances.subtract(address, *amount);\n\n      Transfer {\n         from: Some(*address),\n         to: None,\n         amount: *amount\n      }\n      .emit();\n   }\n}\n\nimpl Erc20 {\n   fn raw_transfer(&mut self, owner: &Address, recipient: &Address, amount: &U256) {\n      if *amount > self.balances.get_or_default(owner) {\n         contract_env::revert(Error::InsufficientBalance)\n      }\n\n      self.balances.subtract(owner, *amount);\n      self.balances.add(recipient, *amount);\n\n      Transfer {\n         from: Some(*owner),\n         to: Some(*recipient),\n         amount: *amount\n      }\n      .emit();\n   }\n\n   fn spend_allowance(&mut self, owner: &Address, spender: &Address, amount: &U256) {\n      let allowance = self.allowances.get_instance(owner).get_or_default(spender);\n      if allowance < *amount {\n         contract_env::revert(Error::InsufficientAllowance)\n      }\n      self.allowances\n         .get_instance(owner)\n         .subtract(spender, *amount);\n      Approval {\n         owner: *owner,\n         spender: *spender,\n         value: allowance - *amount\n      }\n      .emit();\n   }\n}\n\npub mod events {\n   use odra::types::{casper_types::U256, Address};\n   use odra::Event;\n\n   #[derive(Event, Eq, PartialEq, Debug)]\n   pub struct Transfer {\n      pub from: Option<Address>,\n      pub to: Option<Address>,\n      pub amount: U256\n   }\n\n   #[derive(Event, Eq, PartialEq, Debug)]\n   pub struct Approval {\n      pub owner: Address,\n      pub spender: Address,\n      pub value: U256\n   }\n}\n\npub mod errors {\n   use odra::execution_error;\n\n   execution_error! {\n      pub enum Error {\n         InsufficientBalance => 30_000,\n         InsufficientAllowance => 30_001,\n         NameNotSet => 30_002,\n         SymbolNotSet => 30_003,\n         DecimalsNotSet => 30_004,\n      }\n   }\n}\n\n#[cfg(test)]\nmod tests {\n   use super::{\n      errors::Error,\n      events::{Approval, Transfer},\n      Erc20Deployer, Erc20Ref\n   };\n   use odra::prelude::string::ToString;\n   use odra::{assert_events, test_env, types::casper_types::U256};\n\n   const NAME: &str = "Plascoin";\n   const SYMBOL: &str = "PLS";\n   const DECIMALS: u8 = 10;\n   const INITIAL_SUPPLY: u32 = 10_000;\n\n   fn setup() -> Erc20Ref {\n      Erc20Deployer::init(\n         SYMBOL.to_string(),\n         NAME.to_string(),\n         DECIMALS,\n         &Some(INITIAL_SUPPLY.into())\n      )\n   }\n\n   #[test]\n   fn initialization() {\n      // When deploy a contract with the initial supply.\n      let erc20 = setup();\n\n      // Then the contract has the metadata set.\n      assert_eq!(erc20.symbol(), SYMBOL.to_string());\n      assert_eq!(erc20.name(), NAME.to_string());\n      assert_eq!(erc20.decimals(), DECIMALS);\n\n      // Then the total supply is updated.\n      assert_eq!(erc20.total_supply(), INITIAL_SUPPLY.into());\n\n      // Then a Transfer event was emitted.\n      assert_events!(\n         erc20,\n         Transfer {\n               from: None,\n               to: Some(test_env::get_account(0)),\n               amount: INITIAL_SUPPLY.into()\n         }\n      );\n   }\n\n   #[test]\n   fn transfer_works() {\n      // Given a new contract.\n      let mut erc20 = setup();\n\n      // When transfer tokens to a recipient.\n      let sender = test_env::get_account(0);\n      let recipient = test_env::get_account(1);\n      let amount = 1_000.into();\n      erc20.transfer(&recipient, &amount);\n\n      // Then the sender balance is deducted.\n      assert_eq!(\n         erc20.balance_of(&sender),\n         U256::from(INITIAL_SUPPLY) - amount\n      );\n\n      // Then the recipient balance is updated.\n      assert_eq!(erc20.balance_of(&recipient), amount);\n\n      // Then Transfer event was emitted.\n      assert_events!(\n         erc20,\n         Transfer {\n               from: Some(sender),\n               to: Some(recipient),\n               amount\n         }\n      );\n   }\n\n   #[test]\n   fn transfer_error() {\n      test_env::assert_exception(Error::InsufficientBalance, || {\n         // Given a new contract.\n         let mut erc20 = setup();\n\n         // When the transfer amount exceeds the sender balance.\n         let recipient = test_env::get_account(1);\n         let amount = U256::from(INITIAL_SUPPLY) + U256::one();\n\n         // Then an error occurs.\n         erc20.transfer(&recipient, &amount)\n      });\n   }\n\n   // Other tests...\n}\n')))),(0,a.kt)("h2",{id:"4-troubleshooting"},"4. ",(0,a.kt)("strong",{parentName:"h2"},"Troubleshooting")),(0,a.kt)("p",null,"If you encounter any further issues after completing the migration steps, please don't hesitate to reach out to us on ",(0,a.kt)("a",{parentName:"p",href:"https://discord.com/invite/Mm5ABc9P8k"},"Discord")," or explore the other sections this documentation. You can also refer to the ",(0,a.kt)("a",{parentName:"p",href:"https://docs.rs/odra/0.8.0/odra/index.html"},"technical documentation")," for more detailed information. Additionally, our ",(0,a.kt)("a",{parentName:"p",href:"https:://github.com/odradev/odra/tree/release/0.8.0/examples"},"examples")," repository offers a wide range of examples to assist you in understanding the new features and APIs. Be sure to carefully review any compilation errors and warnings, as they may provide valuable insights into the necessary adjustments."),(0,a.kt)("h2",{id:"5-references"},"5. ",(0,a.kt)("strong",{parentName:"h2"},"References")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/odradev/odra/blob/release/0.8.0/CHANGELOG.md"},"Changelog")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://docs.odra.dev"},"Odra Documentation")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://docs.rs/odra/0.8.0/odra/index.html"},"Docs.rs")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https:://github.com/odradev/odra/tree/release/0.8.0/examples"},"Examples"))))}m.isMDXComponent=!0}}]);