"use strict";(self.webpackChunkodra_website=self.webpackChunkodra_website||[]).push([[3925],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>h});var a=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var i=a.createContext({}),c=function(e){var t=a.useContext(i),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},d=function(e){var t=c(e.components);return a.createElement(i.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,i=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),u=c(n),h=o,m=u["".concat(i,".").concat(h)]||u[h]||p[h]||r;return n?a.createElement(m,s(s({ref:t},d),{},{components:n})):a.createElement(m,s({ref:t},d))}));function h(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,s=new Array(r);s[0]=u;var l={};for(var i in t)hasOwnProperty.call(t,i)&&(l[i]=t[i]);l.originalType=e,l.mdxType="string"==typeof e?e:o,s[1]=l;for(var c=2;c<r;c++)s[c]=n[c];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},2785:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>i,contentTitle:()=>s,default:()=>p,frontMatter:()=>r,metadata:()=>l,toc:()=>c});var a=n(87462),o=(n(67294),n(3905));const r={sidebar_position:3},s="Livenet",l={unversionedId:"backends/livenet",id:"version-2.3.1/backends/livenet",title:"Livenet",description:"The Livenet backend lets us deploy and test the contracts on the real blockchain. It can be a local",source:"@site/versioned_docs/version-2.3.1/backends/04-livenet.md",sourceDirName:"backends",slug:"/backends/livenet",permalink:"/docs/2.3.1/backends/livenet",draft:!1,tags:[],version:"2.3.1",lastUpdatedAt:1756365684,formattedLastUpdatedAt:"Aug 28, 2025",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Casper",permalink:"/docs/2.3.1/backends/casper"},next:{title:"Examples",permalink:"/docs/2.3.1/category/examples"}},i={},c=[{value:"Setup",id:"setup",level:2},{value:"Usage",id:"usage",level:2},{value:"How Livenet backend works",id:"how-livenet-backend-works",level:2},{value:"Multiple environments",id:"multiple-environments",level:2}],d={toc:c};function p(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"livenet"},"Livenet"),(0,o.kt)("p",null,"The Livenet backend lets us deploy and test the contracts on the real blockchain. It can be a local\ntest node, a testnet or even the mainnet. It is possible and even recommended using the Livenet backend\nto handle the deployment of your contracts to the real blockchain."),(0,o.kt)("p",null,"Furthermore, it is implemented similarly to Casper or OdraVM,\nhowever, it uses a real blockchain to deploy contracts and store the state.\nThis lets us use Odra to deploy and test contracts on a real blockchain, but\non the other hand, it comes with some limitations on what can be done in the tests."),(0,o.kt)("p",null,"The main differences between Livenet and e.g. CasperVM backend are:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Real CSPR tokens are used to deploy and call contracts. This also means that we need to\npay for each contract deployment and each contract call. Of course, we can use the ",(0,o.kt)("a",{parentName:"li",href:"https://testnet.cspr.live/tools/faucet"},"faucet"),"\nto get some tokens for testing purposes, but we still need to specify the amount needed\nfor each action."),(0,o.kt)("li",{parentName:"ul"},"The contract state is stored on the real blockchain, so we can't just reset the state -\nwe can redeploy the contract, but we can't remove the old one."),(0,o.kt)("li",{parentName:"ul"},"Because of the above, we can load the existing contracts and use them in the tests."),(0,o.kt)("li",{parentName:"ul"},"We have no control over the block time. This means that for example, ",(0,o.kt)("inlineCode",{parentName:"li"},"advance_block_time")," function\nis implemented by waiting for the real time to pass.")),(0,o.kt)("p",null,"This is also a cause for the fact that the Livenet backend cannot be (yet) used for running\nthe regular Odra tests. Instead, we can create integration tests or binaries which will\nuse a slightly different workflow to test the contracts."),(0,o.kt)("h2",{id:"setup"},"Setup"),(0,o.kt)("p",null,"To use Livenet backend, we need to provide Odra with some information - the network address, our private\nkey and the name of the chain we want to use. Optionally, we can add multiple private keys to use\nmore than one account in our tests. Those values are passed using environment variables. We can use .env\nfile to store them - let's take a look at an example .env file, created from the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/odradev/odra/blob/release/2.2.0/examples/.env.sample"},".env.sample")," file from the examples folder:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-env"},'# .env file used by Livenet integration. You can use multiple .env files to manage deploys on multiple chains\n# by naming them casper-test.env, casper-livenet.env, etc. and calling the deploy script with the name of the\n# ennviroment provided in the "ODRA_CASPER_LIVENET_ENV" variable. For example:\n# ODRA_CASPER_LIVENET_ENV=casper-test cargo run --bin livenet_tests --features livenet\n# This will load integration.env file first, and then fill the missing values with the values from casper-test.env.\n\n# Path to the secret key of the account that will be used to deploy the contracts.\n# If you are using the nctl, you can use the following command to extract the secret key from the container:\n#    docker exec mynctl /bin/bash -c "cat /home/casper/casper-nctl/assets/net-1/users/user-1/secret_key.pem" > examples/.node-keys/secret_key.pem\n#   docker exec mynctl /bin/bash -c "cat  /home/casper/casper-nctl/assets/net-1/users/user-2/secret_key.pem" > examples/.node-keys/secret_key_1.pem\nODRA_CASPER_LIVENET_SECRET_KEY_PATH=<path to secret_key.pem>\n\n# RPC address of the node that will be used to deploy the contracts.\n# For CSPR.cloud, you can use the following addresses:\n# - https://node.cspr.cloud\n# - https://node.testnet.cspr.cloud\n# For nctl, default is:\n# - http://localhost:11101\nODRA_CASPER_LIVENET_NODE_ADDRESS=<node address>\n\n# Events url\n# For CSPR.cloud, you can use the following addresses:\n# - https://node.cspr.cloud/events\n# For nctl, default is:\n# - http://localhost:18101/events\nODRA_CASPER_LIVENET_EVENTS_URL=<events url>\n\n# Chain name of the network. The mainnet is "casper" and test net is "casper-test".\n# The integration network uses the "integration-test" chain name.\n# For nctl default is "casper-net-1"\n ODRA_CASPER_LIVENET_CHAIN_NAME=<chain_name>\n\n# Optionally, paths to the secret keys of the additional acccounts. Main secret key will be 0th account.\n# The following will work for nctl if you used the command above to extract the secret keys:\n# ODRA_CASPER_LIVENET_KEY_1=./keys/secret_key_1.pem\n#ODRA_CASPER_LIVENET_KEY_1=<path to secret_key_1.pem>\n\n# If using CSPR.cloud, you can set the auth token here.\n# CSPR_CLOUD_AUTH_TOKEN=\n\n# Optionally, you can set the TTL for the deploys. Default is 5 minutes.\n# ODRA_CASPER_LIVENET_TTL=\n')),(0,o.kt)("admonition",{type:"note"},(0,o.kt)("p",{parentName:"admonition"},"CSPR.cloud is a service that provides mainnet and testnet Casper nodes on demand.")),(0,o.kt)("p",null,"With the proper value in place, we can write our tests or deploy scenarios. In the examples, we can find\na simple binary that deploys a contract and calls it. The test is located in the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/odradev/odra/blob/release/2.2.0/examples/bin/erc20_on_livenet.rs"},"erc20_on_livenet.rs")," file.\nLet's go through the code:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'//! Deploys an ERC20 contract and transfers some tokens to another address.\nuse odra::casper_types::U256;\nuse odra::host::{Deployer, HostEnv, HostRefLoader, InstallConfig};\nuse odra::prelude::*;\nuse odra_modules::erc20::{Erc20, Erc20HostRef, Erc20InitArgs};\nuse std::str::FromStr;\n\nfn main() {\n    let env = odra_casper_livenet_env::env();\n\n    let owner = env.caller();\n    let recipient = "hash-2c4a6ce0da5d175e9638ec0830e01dd6cf5f4b1fbb0724f7d2d9de12b1e0f840";\n    let recipient = Address::from_str(recipient).unwrap();\n\n    // Deploy new contract.\n    let mut token = deploy_erc20(&env);\n    println!("Token address: {}", token.address().to_string());\n\n    // Uncomment to load existing contract.\n    // let mut token = load_erc20(&env);\n\n    println!("Token name: {}", token.name());\n\n    env.set_gas(3_000_000_000u64);\n    token.transfer(&recipient, &U256::from(1000));\n\n    println!("Owner\'s balance: {:?}", token.balance_of(&owner));\n    println!("Recipient\'s balance: {:?}", token.balance_of(&recipient));\n}\n\n/// Loads an ERC20 contract.\nfn _load_erc20(env: &HostEnv) -> Erc20HostRef {\n    let address = "hash-d26fcbd2106e37be975d2045c580334a6d7b9d0a241c2358a4db970dfd516945";\n    let address = Address::from_str(address).unwrap();\n    Erc20::load(env, address)\n}\n\n/// Deploys an ERC20 contract.\npub fn deploy_erc20(env: &HostEnv) -> Erc20HostRef {\n    let name = String::from("Plascoin");\n    let symbol = String::from("PLS");\n    let decimals = 10u8;\n    let initial_supply = Some(U256::from(10_000));\n\n    let init_args = Erc20InitArgs {\n        name,\n        symbol,\n        decimals,\n        initial_supply\n    };\n\n    env.set_gas(450_000_000_000u64);\n    // You may configure a deploy passing `InstallConfig`.\n    // Erc20::deploy_with_cfg(env, init_args, InstallConfig::upgradable::<Erc20>())\n    Erc20::deploy(env, init_args)\n}\n')),(0,o.kt)("admonition",{type:"note"},(0,o.kt)("p",{parentName:"admonition"},"The above example is a rust binary, not a test. Note that it is also added as a section of the\n",(0,o.kt)("inlineCode",{parentName:"p"},"Cargo.toml")," file:"),(0,o.kt)("pre",{parentName:"admonition"},(0,o.kt)("code",{parentName:"pre",className:"language-toml"},'[bin]\nname = "erc20_on_livenet"\npath = "src/bin/erc20_on_livenet.rs"\nrequired-features = ["livenet"]\ntest = false\n'))),(0,o.kt)("h2",{id:"usage"},"Usage"),(0,o.kt)("p",null,"To run the above code, we simply need to run the binary with the ",(0,o.kt)("inlineCode",{parentName:"p"},"livenet")," feature enabled:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"cargo run --bin erc20_on_livenet --features=livenet\n")),(0,o.kt)("admonition",{type:"note"},(0,o.kt)("p",{parentName:"admonition"},"Before executing the binary, make sure you built a wasm file.")),(0,o.kt)("p",null,"A part of a sample output should look like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},'...\n\ud83d\udc81  INFO : Calling "contract-package-b796cf8e527472d7ced8c4f8db5adb30eb577176f4c7ce956675590e0cac4bb8" directly with entrypoint "transfer".\n\ud83d\ude44  WAIT : Waiting 10 for V1(TransactionV1Hash(775913daa0ffbded9aaf2216942217d682f03d1c04e6e2560d1e4b3329ebd2d6)).\n\ud83d\udc81  INFO : Transaction "775913daa0ffbded9aaf2216942217d682f03d1c04e6e2560d1e4b3329ebd2d6" successfully executed.\n\ud83d\udd17  LINK : \nOwner\'s balance: 9000\nRecipient\'s balance: 1000\n')),(0,o.kt)("p",null,"Those logs are a result of the last 4 lines of the above listing.\nEach deployment or a call to the blockchain will be noted and will take some time to execute.\nWe can see that the ",(0,o.kt)("inlineCode",{parentName:"p"},"transfer")," call took over 15 seconds to execute. But calling ",(0,o.kt)("inlineCode",{parentName:"p"},"balance_of")," was nearly instant\nand cost us nothing. How it is possible?"),(0,o.kt)("admonition",{type:"info"},(0,o.kt)("p",{parentName:"admonition"},"You can see the deployment on ",(0,o.kt)("a",{parentName:"p",href:"http://cspr.live/"},"http://cspr.live/")," - the transfer from the example\ncan be seen ",(0,o.kt)("a",{parentName:"p",href:"https://integration.cspr.live/deploy/65b1a5d21174a62c675f89683aba995c453b942c705b404a1f8bbf6f0f6de32a"},"here"),".")),(0,o.kt)("h2",{id:"how-livenet-backend-works"},"How Livenet backend works"),(0,o.kt)("p",null,"All calls of entrypoints executed on a Casper blockchain cost gas - even if they do not change the state.\nIt is possible, however, to query the state of the blockchain for free."),(0,o.kt)("p",null,"This principle is used in the Livenet backend - all calls that do not change the state of the blockchain are really executed offline - the only thing that is requested from the\nnode is the current state. This is why the ",(0,o.kt)("inlineCode",{parentName:"p"},"balance_of")," call was almost instant and free."),(0,o.kt)("p",null,"Basically, if the entrypoint function is not mutable or does not make a call to an unknown external contract\n(see ",(0,o.kt)("a",{parentName:"p",href:"/docs/2.3.1/basics/cross-calls"},"Cross Calls"),"), it is executed offline and\nnode is used for the state query only. However, the Livenet needs to know the connection between the contracts\nand the code, so make sure to deploy or load already deployed contracts"),(0,o.kt)("h2",{id:"multiple-environments"},"Multiple environments"),(0,o.kt)("p",null,"It is possible to have multiple environments for the Livenet backend. This is useful if we want to easily switch between multiple accounts,\nmultiple nodes or even multiple chains."),(0,o.kt)("p",null,"To do this, simply create a new ",(0,o.kt)("inlineCode",{parentName:"p"},".env")," file with a different prefix - for example, ",(0,o.kt)("inlineCode",{parentName:"p"},"integration.env")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"mainnet.env"),".\nThen, pass the ",(0,o.kt)("inlineCode",{parentName:"p"},"ODRA_CASPER_LIVENET_ENV")," variable with value either ",(0,o.kt)("inlineCode",{parentName:"p"},"integration")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"mainnet")," to select which file\nhas to be used first. If your ",(0,o.kt)("inlineCode",{parentName:"p"},"integration.env")," file has a value that IS present in the ",(0,o.kt)("inlineCode",{parentName:"p"},".env")," file, it will\noverride the value from the ",(0,o.kt)("inlineCode",{parentName:"p"},".env")," file."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"ODRA_CASPER_LIVENET_ENV=integration cargo run --bin erc20_on_livenet --features=livenet\n")),(0,o.kt)("p",null,"To sum up - this command will firstly load the ",(0,o.kt)("inlineCode",{parentName:"p"},"integration.env")," file and then load the missing values from ",(0,o.kt)("inlineCode",{parentName:"p"},".env")," file."))}p.isMDXComponent=!0}}]);