{"searchDocs":[{"title":"OpenAI writes ERC20 in Odra","type":0,"sectionRef":"#","url":"/blog/2023-02-27-openai-writes-erc20-in-odra","content":"","keywords":"","version":null},{"title":"OpenAI​","type":1,"pageTitle":"OpenAI writes ERC20 in Odra","url":"/blog/2023-02-27-openai-writes-erc20-in-odra#openai","content":"OpenAI already proved that AI can code. Github Copilot is used by more and more developers. Many times it is mind-blowing how accurate it is. It would be great if one of the OpenAI models could simply work after writing: Q: Write the ERC20 smart contract. A: use odra::{Mapping, Variable}...  So far OpenAI hasn't indexed Odra. I even asked ChatGPT. Q: Do you know what is the Odra Framework for writing smart contracts? Response in one sentence. Use Yoda style. A: Aware of an Odra Framework for writing smart contracts, I am not.  Soon (year or two) it will happen and Odra will be supported out of the box, simply because it is available on GitHub. ","version":null,"tagName":"h2"},{"title":"DaVinci Edit​","type":1,"pageTitle":"OpenAI writes ERC20 in Odra","url":"/blog/2023-02-27-openai-writes-erc20-in-odra#davinci-edit","content":"OpenAI gives us a great tool called Edit. It uses the same technology Github Copiled it based on called Codex, OpenAI gives us access to the model code-davinci-edit-001. It allows you to paste in the code and ask for changes. See more examples like rewriting Fibonacci to a recursive version here. But it doesn't know Odra. Luckily this is not a problem. I have found a nice trick that allows producing the code I want. We simply have to present all the features of Odra and ask a good question. ","version":null,"tagName":"h2"},{"title":"ERC20 by AI​","type":1,"pageTitle":"OpenAI writes ERC20 in Odra","url":"/blog/2023-02-27-openai-writes-erc20-in-odra#erc20-by-ai","content":"The goal is to bend AI to write the ERC20 token using Odra. The Edit query needs two elements: source code,text that describes what should be changed.  As the input source code I wrote the code that uses all the features ERC20 would use. I need odra::module, Variable, Mapping, caller(), Address, constructor, and errors. flipper.rs use odra::{Variable, types::Address, contract_env, Mapping, execution_error}; #[odra::module] pub struct Flipper { value: Variable&lt;bool&gt;, flips_count: Variable&lt;u32&gt;, owner: Variable&lt;Address&gt;, messages: Mapping&lt;(Address, Address), String&gt; } #[odra::module] impl Flipper { #[odra(init)] pub fn init(&amp;mut self, owner: Address) { self.value.set(false); self.owner.set(owner); } pub fn set(&amp;mut self, value: bool) { self.value.set(value); } pub fn flip(&amp;mut self) { self.value.set(!self.get_value()); self.flips_count.set(self.flips_count.get_or_default()); } pub fn get_value(&amp;self) -&gt; bool { self.value.get_or_default() } pub fn get_owner(&amp;self) -&gt; Option&lt;Address&gt; { self.owner.get() } pub fn set_message(&amp;mut self, recipient: Address, msg: String) { let sender = contract_env::caller(); let current_msg = self.messages.get(&amp;(sender, recipient)); match current_msg { Some(_) =&gt; contract_env::revert(Error::MessageAlreadyDefined), None =&gt; self.messages.set(&amp;(sender, recipient), msg) } } pub fn get_message(&amp;self, sender: Address, recipient: Address) -&gt; String { self.messages.get_or_default(&amp;(sender, recipient)) } } execution_error! { pub enum Error { MessageAlreadyDefined =&gt; 1, NotAnMessageSender =&gt; 2, } }  ChatGPT knows what the ERC20 is, so the kind request for changes is simple. Q: Implement another smart contract called ERC20. Balances should be of type U256.  This is the result. ERC20 contract in Odra generated by OpenAI use odra::{Variable, types::Address, contract_env, Mapping, execution_error, U256}; #[odra::module] pub struct ERC20 { name: Variable&lt;String&gt;, symbol: Variable&lt;String&gt;, decimals: Variable&lt;u8&gt;, total_supply: Variable&lt;U256&gt;, balances: Mapping&lt;Address, U256&gt;, allowed: Mapping&lt;(Address, Address), U256&gt; } #[odra::module] impl ERC20 { #[odra(init)] pub fn init(&amp;mut self, name: String, symbol: String, decimals: u8, total_supply: U256) { self.name.set(name); self.symbol.set(symbol); self.decimals.set(decimals); self.total_supply.set(total_supply); self.balances.set(&amp;contract_env::caller(), total_supply); } pub fn total_supply(&amp;self) -&gt; U256 { self.total_supply.get_or_default() } pub fn balance_of(&amp;self, owner: Address) -&gt; U256 { self.balances.get_or_default(&amp;owner) } pub fn transfer(&amp;mut self, to: Address, value: U256) { let from = contract_env::caller(); let from_balance = self.balances.get_or_default(&amp;from); let to_balance = self.balances.get_or_default(&amp;to); if from_balance &lt; value { contract_env::revert(Error::InsufficientBalance); } self.balances.set(&amp;from, from_balance - value); self.balances.set(&amp;to, to_balance + value); } pub fn transfer_from(&amp;mut self, from: Address, to: Address, value: U256) { let caller = contract_env::caller(); let from_balance = self.balances.get_or_default(&amp;from); let to_balance = self.balances.get_or_default(&amp;to); let allowed = self.allowed.get_or_default(&amp;(from, caller)); if from_balance &lt; value { contract_env::revert(Error::InsufficientBalance); } if allowed &lt; value { contract_env::revert(Error::InsufficientAllowance); } self.balances.set(&amp;from, from_balance - value); self.balances.set(&amp;to, to_balance + value); self.allowed.set(&amp;(from, caller), allowed - value); } pub fn approve(&amp;mut self, spender: Address, value: U256) { let owner = contract_env::caller(); self.allowed.set(&amp;(owner, spender), value); } pub fn allowance(&amp;self, owner: Address, spender: Address) -&gt; U256 { self.allowed.get_or_default(&amp;(owner, spender)) } } execution_error! { pub enum Error { InsufficientBalance =&gt; 1, InsufficientAllowance =&gt; 2, } }  Wow! ","version":null,"tagName":"h2"},{"title":"What is next?​","type":1,"pageTitle":"OpenAI writes ERC20 in Odra","url":"/blog/2023-02-27-openai-writes-erc20-in-odra#what-is-next","content":"AI already understands smart contracts. It had to read a lot of Solidity code. I checked and it knows Uniswap and Compound source code. Most interesting is that AI was able to implement a concept it already knew from another programming language in the unseen Rust framework. At some point, we will be able to translate all the Solidity code to Odra. Or maybe we will not have to... It is hard to imagine how good it will be in 2025 and beyond. ","version":null,"tagName":"h2"},{"title":"Zero Knowledge on Casper","type":0,"sectionRef":"#","url":"/blog/casper-zk-risc0","content":"","keywords":"","version":null},{"title":"Zero Knowledge​","type":1,"pageTitle":"Zero Knowledge on Casper","url":"/blog/casper-zk-risc0#zero-knowledge","content":"In my opinion, the zero knowledge (ZK) is the largest revolution in blockchains, since Ethereum introduced Turing-complete, account-based smart contracts. To put it in simple words, ZK enables two use cases not possible before: Computation scaling - I can perform expensive computation off-chain and put the result on a chain with the proof.Anonymity - I can prove to you, I know something without revealing it.  ","version":null,"tagName":"h2"},{"title":"Risc Zero​","type":1,"pageTitle":"Zero Knowledge on Casper","url":"/blog/casper-zk-risc0#risc-zero","content":"I'd like to introduce you to Risc Zero. It is the general purpose zero-knowledge virtual machine. Go ahead and spend time reading their website! For us, the key component is the proof verifier that can be compiled into WASM. Sooo... we can run it on Casper :) Yes! We can prove any program, produce proof, and send it to Casper's smart contract for verification. ","version":null,"tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"Zero Knowledge on Casper","url":"/blog/casper-zk-risc0#example","content":"Let's dive into the example to see how it works.The full example codeyou can find on our GitHub. It is based on Risc Zero's Hello, Multiply!example. So make sure you understand it first.Guest and Prover sections are taken from this example. ","version":null,"tagName":"h2"},{"title":"Guest​","type":1,"pageTitle":"Zero Knowledge on Casper","url":"/blog/casper-zk-risc0#guest","content":"The program we are proving is called a guest in Risc Zero. Our goal is to prove we know the factors of an arbitrary number. Given a and b below guest program computes a * b and produces a proof of computation. methods/guest/src/multiply.rs pub fn main() { // Load the first number from the host let a: u64 = env::read(); // Load the second number from the host let b: u64 = env::read(); // Verify that neither of them are 1 (i.e. nontrivial factors) if a == 1 || b == 1 { panic!(&quot;Trivial factors&quot;) } // Compute the product while being careful with integer overflow let product = a.checked_mul(b).expect(&quot;Integer overflow&quot;); env::commit(&amp;product); }  ","version":null,"tagName":"h3"},{"title":"Prover​","type":1,"pageTitle":"Zero Knowledge on Casper","url":"/blog/casper-zk-risc0#prover","content":"It's time to run the guest program and build the proof for a specific a and b values. prover/src/main.rs fn main() { // Pick two numbers. let a: u64 = 17; let b: u64 = 23; // First, we make the prover, loading the 'multiply' method. let multiply_src = std::fs::read(MULTIPLY_PATH) .expect(&quot;Method code should be present at the specified path.&quot;); let mut prover = Prover::new(&amp;multiply_src, MULTIPLY_ID) .expect(&quot;Prover should be constructed.&quot;,); // Next we send a &amp; b to the guest. prover.add_input_u32_slice(to_vec(&amp;a).unwrap().as_slice()); prover.add_input_u32_slice(to_vec(&amp;b).unwrap().as_slice()); // Run prover &amp; generate receipt let receipt = prover.run() .expect(&quot;Valid code should be provable.&quot;); // Extract journal of receipt (i.e. output c, where c = a * b) let c: u64 = from_slice(&amp;receipt.journal) .expect(&quot;Journal output should deserialize.&quot;); // Print an assertion println!(&quot;I know the factors of {}, and I can prove it!&quot;, c); // Verify receipt, panic if it's wrong. receipt.verify(MULTIPLY_ID).expect( &quot;Code you have proven should successfully verify.&quot;, ); // Convert journal to string and store on disk. let journal = serde_json::to_string(&amp;receipt.journal).unwrap(); write_to_file(&quot;../data/journal&quot;, &amp;journal); // Convert seal to string and store on disk. let seal = serde_json::to_string(&amp;receipt.seal).unwrap(); write_to_file(&quot;../data/seal&quot;, &amp;seal); // Convert method_id to string and store on disk. let result = serde_json::to_string(MULTIPLY_ID).unwrap(); write_to_file(&quot;../data/method&quot;, &amp;result); }  ","version":null,"tagName":"h3"},{"title":"Verifier​","type":1,"pageTitle":"Zero Knowledge on Casper","url":"/blog/casper-zk-risc0#verifier","content":"Now the verification step. Given the proof (journal + seal) and the guest program definition (method), Casper's smart contract checks its correctness. This one is written just for the demonstration, but in general you want METHOD_ID to be stored in your contract and both SEAL and JOURNAL to be passed to the contract via arguments from the outside. verifier/src/verifier_contract.rs // Import the proof and the method. const METHOD_ID: &amp;[u8] = &amp;include!(&quot;../../data/method&quot;); const SEAL: &amp;[u32] = &amp;include!(&quot;../../data/seal&quot;); const JOURNAL: &amp;[u32] = &amp;include!(&quot;../../data/journal&quot;); // Verifier contract holds a result of the zk verification. #[odra::module] pub struct Verifier { result: Variable&lt;String&gt;, } #[odra::module] impl Verifier { // Calling this entry point triggers the zk proof verification. pub fn verify(&amp;mut self) { let result = verify(JOURNAL, SEAL, METHOD_ID); self.result.set(result); } // Result getter. pub fn result(&amp;self) -&gt; String { self.result.get().unwrap_or(String::from(&quot;Not processed&quot;)) } } // The verification method. It constructs new Receipt and verifies it. fn verify(journal: &amp;[u32], seal: &amp;[u32], method_id: &amp;[u8]) -&gt; String { let result = Receipt::new(&amp;journal, &amp;seal).verify(method_id); match result { Ok(()) =&gt; String::from(&quot;Ok&quot;), Err(err) =&gt; format!(&quot;Error: {}&quot;, err.to_string()) } }  ","version":null,"tagName":"h3"},{"title":"Livenet results​","type":1,"pageTitle":"Zero Knowledge on Casper","url":"/blog/casper-zk-risc0#livenet-results","content":"I have deployed it to the testnet and called the verify method. The result was Ok. Wow, first-ever ZK proof verification on Casper. Trustless bridging, layer 2 here we come :) The cost of running the verify method is 2324 CSPR. That's a lot, but we have to start somewhere. ","version":null,"tagName":"h3"},{"title":"What next​","type":1,"pageTitle":"Zero Knowledge on Casper","url":"/blog/casper-zk-risc0#what-next","content":"I think it is a good place to outline possible Casper ZK goals for moving this forward. The community should discuss: Building more examples. Risc Zero has a nice battleship game to port over to Casper.Adding Risc Zero verification method to Casper's FFI.Supporting Risc Zero team. We should help develop this awesome open-source project and gain the ZK expertise. ","version":null,"tagName":"h2"},{"title":"Join us​","type":1,"pageTitle":"Zero Knowledge on Casper","url":"/blog/casper-zk-risc0#join-us","content":"Interested in zero knowledge on Casper? Join our Discord, our Twitter or write us at contact@odra.dev. ","version":null,"tagName":"h2"},{"title":"It's all about the community!","type":0,"sectionRef":"#","url":"/blog/its-all-about-the-community","content":"","keywords":"","version":null},{"title":"Hello Odra Community​","type":1,"pageTitle":"It's all about the community!","url":"/blog/its-all-about-the-community#hello-odra-community","content":"Whether you are a Rust developer, Solidity developer or a Casper enthusiast we are happy to have you here, reading this blog post. We have built Odra to make smart contract development on Casper easy. Now we are entering the next phase of the open source journey. We are going to focus on the community and make sure Odra is the best tool for the job. Our motto (we borrowed from the Django Project) is: We bring cutting-edge smart contract development tools to professionals with deadlines. How will we do it? We are going to focus on four things: Quality - Our code and documentation will be of the highest quality. We will always have tons of tests and examples.Simplicity - The simplest solution is the best solution. Odra's API needs to be simple and easy to use. Always! We are not afraid to take a few steps back and rethink our design. We believe in short feedback loops and fast iterations.Reusability - No one likes to repeat itself. We see a huge potential in Odra Modules. In time, it can become a standard library of Casper smart contracts, that are battle-tested and ready to use.Community - We are here to help you. You can always reach out to us on Discord or Github. ","version":null,"tagName":"h2"},{"title":"We will help with your project​","type":1,"pageTitle":"It's all about the community!","url":"/blog/its-all-about-the-community#we-will-help-with-your-project","content":"Whether you are a Rust developer or not, you can start using Odra today. We have prepared a few examples and docs to help you get started. Rust knowledge required to use Odra is minimal. That was always the goal. But we understand that it is hard to start. We got your back. We offer free consulting + 2 hours of live coding. All you have to do is write us an email at contract@odra.devwith a short description of your project. We will schedule a call and help you get started with Odra. After 2 hours of live coding, you will have a working repository with 2 or 3 smart contracts, that you can use as a starting point for your project. ","version":null,"tagName":"h2"},{"title":"Roadmap​","type":1,"pageTitle":"It's all about the community!","url":"/blog/its-all-about-the-community#roadmap","content":"The feedback we got quite often was:It's nice, but will it last? What's the direction of the project?Point taken. Now we answer: We are here to stay.We got the support from the Casper Association and some projects of our own to keep us funded. We play the long game. To systematize our work, we have prepared the roadmap. As of now, we maintain plans for at least three future releases. It is a good balance between predictability and flexibility. We will release new versions approximately every 1-2 months or as needed. Everyone is encouraged to propose a new Odra feature or enhancement. New proposals need to be discussed and approved by the core team. When the feature is ready, we assign it to one of the future releases.  ","version":null,"tagName":"h2"},{"title":"Odra 0.2.0 Released","type":0,"sectionRef":"#","url":"/blog/release-020","content":"","keywords":"","version":null},{"title":"A bit of history​","type":1,"pageTitle":"Odra 0.2.0 Released","url":"/blog/release-020#a-bit-of-history","content":"More than a year ago Maciej Zieliński resigned from the position of Ecosystem Leader at CasperLabs. Along with Krzysztof Pobiarżyn and Kuba Płaskonka, we formed an engineering team dedicated to smart contracts. Looking at the blockchain ecosystems from the smart contract developer perspective there are two universes. The first one is Solidity, which thrives and is at its best now. It has a ton of well-tested code and security tooling. Whenever an EVM-based blockchain pops out it gets populated by forks of DeFi and DAO protocols. Fascinating network effect emerges - code written for one EVM-based blockchain can be run on every other EVM-based blockchain. The second universe is Rust which compiles to WebAssembly. Here developer communities live in the guarded cities of Polkadot, Cosmos, Solana, Casper, and Near. The code written for one platform is not portable. The network effect never had a chance to arise. The main reason why Odra exists is achieving this cross-chain code reusability. We could paraphrase a bit and say: &quot;One to bring them all and in the code bind them.&quot; ","version":null,"tagName":"h2"},{"title":"Odra for Casper​","type":1,"pageTitle":"Odra 0.2.0 Released","url":"/blog/release-020#odra-for-casper","content":"The very first blockchain we have integrated with Odra is Casper. In comparison to casper-contract API, it greatly cuts development time and offers a much lower entry level. The Odra interface is developer friendly and people familiar with Solidity, Ink, or Near will feel like at home. We hope it will unleash the creativity and bring a whole bunch of products onto Casper. ","version":null,"tagName":"h2"},{"title":"Odra Framework​","type":1,"pageTitle":"Odra 0.2.0 Released","url":"/blog/release-020#odra-framework","content":"Odra is a high-level smart contract framework for Rust, which encourages rapid development and clean, pragmatic design. Built by experienced developers, it takes care of much of the hassle of smart contract development, enabling you to focus on writing your dapp without reinventing the wheel. It's free and open source. Odra's goal is to become the go-to smart contract framework for all WebAssembly-based blockchains. A smart contract written using Odra can be executed on all integrated systems. We can do it by abstracting over core concepts that all the above systems are built around. These are type system, storage, entry points, execution context, and testing environment. We believe it will bring standardization to the development of Rust-based smart contracts and enable code reusability we have not yet seen in this ecosystem. Let’s look at a Flipper contract, that holds a boolean value. The contract has a constructor that sets the initial value, and two entry points: flip() and get(), to change and query the current value, respectively. use odra::Variable; #[odra::module] pub struct Flipper { value: Variable&lt;bool&gt;, } #[odra::module] impl Flipper { #[odra(init)] pub fn init(&amp;mut self, value: bool) { self.value.set(value); } pub fn flip(&amp;mut self) { self.value.set(!self.get()); } pub fn get(&amp;self) -&gt; bool { self.value.get_or_default() } }  It comes with the CLI tool cargo-odra that makes it easy to use Odra.  Neat and simple, isn't it? Do you like it? Start flowing with us! ","version":null,"tagName":"h2"},{"title":"What next​","type":1,"pageTitle":"Odra 0.2.0 Released","url":"/blog/release-020#what-next","content":"Let's be honest, we are just starting. The codebase is still hot. On the other hand, we are happy with the interfaces we designed. Now is the time to write documentation and tutorials. We are also building the modules library inspired by OpenZeppelin. The security code audit is still ahead of us. ","version":null,"tagName":"h2"},{"title":"Join us​","type":1,"pageTitle":"Odra 0.2.0 Released","url":"/blog/release-020#join-us","content":"Check out the Odra GitHub repository for more info on how to get the most out of Odra. Should you have questions, join our Discord, our Twitter or write us at contact@odra.dev. ","version":null,"tagName":"h2"},{"title":"Odra framework","type":0,"sectionRef":"#","url":"/docs/2.0.0/","content":"","keywords":"","version":"2.0.0"},{"title":"What's next​","type":1,"pageTitle":"Odra framework","url":"/docs/2.0.0/#whats-next","content":"See the Installation and our Flipper example to find out how to start your new project with Odra. ","version":"2.0.0","tagName":"h2"},{"title":"Advanced Storage Concepts","type":0,"sectionRef":"#","url":"/docs/2.0.0/advanced/advanced-storage","content":"","keywords":"","version":"2.0.0"},{"title":"Recap and Basic Concepts​","type":1,"pageTitle":"Advanced Storage Concepts","url":"/docs/2.0.0/advanced/advanced-storage#recap-and-basic-concepts","content":"Before we delve into the advanced features, let's recap some basic storage concepts in Odra. In the realm of basic storage interaction, Odra provides several types for interacting with contract storage, including Var, Mapping, and List. These types enable contracts to store and retrieve data in a structured manner. The Var type is used to store a single value, while the List and Mapping types store collections of values. Var: A Var in Odra is a fundamental building block used for storing single values. Each Var is uniquely identified by its name in the contract. Mapping: Mapping in Odra serves as a key-value storage system. It stores an association of unique keys to values, and the value can be retrieved using the key. List: Built on top of the Var and Mapping building blocks, List in Odra allows storing an ordered collection of values that can be iterated over. If you need a refresher on these topics, please refer to our guide on basic storage in Odra. ","version":"2.0.0","tagName":"h2"},{"title":"Advanced Storage Concepts​","type":1,"pageTitle":"Advanced Storage Concepts","url":"/docs/2.0.0/advanced/advanced-storage#advanced-storage-concepts-1","content":"","version":"2.0.0","tagName":"h2"},{"title":"Sequence​","type":1,"pageTitle":"Advanced Storage Concepts","url":"/docs/2.0.0/advanced/advanced-storage#sequence","content":"The Sequence in Odra is a basic module that stores a single value in the storage that can be read or incremented. Internally, holds a Var which keeps track of the current value. pub struct Sequence&lt;T&gt; where T: Num + One + ToBytes + FromBytes + CLTyped { value: Var&lt;T&gt; }  The Sequence module provides functions get_current_value and next_value to get the current value and increment the value respectively. ","version":"2.0.0","tagName":"h3"},{"title":"Advanced Mapping​","type":1,"pageTitle":"Advanced Storage Concepts","url":"/docs/2.0.0/advanced/advanced-storage#advanced-mapping","content":"In Odra, a Mapping is a key-value storage system where the key is associated with a value. In previous examples, the value of the Mapping typically comprised a standard serializable type (such as number, string, or bool) or a custom type marked with the #[odra::odra_type] attribute. However, there are more advanced scenarios where the value of the Mapping represents a module itself. This approach is beneficial when managing a collection of modules, each maintaining its unique state. Let's consider the following example: examples/src/features/storage/mapping.rs use odra::casper_types::U256; use odra::prelude::*; use crate::owned_token::OwnedToken; #[odra::module] pub struct Mappings { strings: Mapping&lt;(String, u32, String), String&gt;, tokens: Mapping&lt;String, OwnedToken&gt; } #[odra::module] impl Mappings { ... pub fn total_supply(&amp;mut self, token_name: String) -&gt; U256 { self.tokens.module(&amp;token_name).total_supply() } pub fn get_string_api( &amp;self, key1: String, key2: u32, key3: String ) -&gt; String { let opt_string = self.strings.get(&amp;(key1, key2, key3)); opt_string.unwrap_or_revert(&amp;self.env()) } }  As you can see, a Mapping key can consist of a tuple of values, not limited to a single value. note Accessing Odra modules differs from accessing regular values such as strings or numbers. Firstly, within a Mapping, you don't encapsulate the module with Submodule. Secondly, rather than utilizing the Mapping::get() function, call Mapping::module(), which returns SubModule&lt;T&gt; and sets the appropriate namespace for nested modules. ","version":"2.0.0","tagName":"h3"},{"title":"AdvancedStorage Contract​","type":1,"pageTitle":"Advanced Storage Concepts","url":"/docs/2.0.0/advanced/advanced-storage#advancedstorage-contract","content":"The given code snippet showcases the AdvancedStorage contract that incorporates these storage concepts. use odra::casper_types::U512; use odra::prelude::*; use crate::modules::Token; #[odra::module] pub struct AdvancedStorage { counter: Sequence&lt;u32&gt;, tokens: Mapping&lt;(String, String), Token&gt;, } impl AdvancedStorage { pub fn current_value(&amp;self) -&gt; u32 { self.counter.get_current_value() } pub fn increment_and_get(&amp;mut self) -&gt; u32 { self.counter.next_value() } pub fn balance_of(&amp;mut self, token_name: String, creator: String, address: Address) -&gt; U512 { let token = self.tokens.module(&amp;(token_name, creator)); token.balance_of(&amp;address) } pub fn mint(&amp;self, token_name: String, creator: String, amount: U512, to: Address) { let mut token = self.tokens.module(&amp;(token_name, creator)); token.mint(amount, to); } }  ","version":"2.0.0","tagName":"h2"},{"title":"Conclusion​","type":1,"pageTitle":"Advanced Storage Concepts","url":"/docs/2.0.0/advanced/advanced-storage#conclusion","content":"Advanced storage features in Odra offer robust options for managing contract state. Two key takeaways from this document are: Odra offers a Sequence module, enabling contracts to store and increment a single value.Mappings support composite keys expressed as tuples and can store modules as values. Understanding these concepts can help developers design and implement more efficient and flexible smart contracts. ","version":"2.0.0","tagName":"h2"},{"title":"Attributes","type":0,"sectionRef":"#","url":"/docs/2.0.0/advanced/attributes","content":"","keywords":"","version":"2.0.0"},{"title":"Payable​","type":1,"pageTitle":"Attributes","url":"/docs/2.0.0/advanced/attributes#payable","content":"When writing a smart contract, you need to make sure that money can be both sent to and extracted from the contract. The 'payable' attribute helps wit this. Any function, except for a constructor, with the #[odra(payable)] attribute can send and take money in the form of native tokens. ","version":"2.0.0","tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"Attributes","url":"/docs/2.0.0/advanced/attributes#example","content":"examples/src/contracts/tlw.rs #[odra(payable)] pub fn deposit(&amp;mut self) { // Extract values let caller: Address = self.env().caller(); let amount: U256 = self.env().attached_value(); let current_block_time: u64 = self.env().get_block_time(); // Multiple lock check if self.balances.get(&amp;caller).is_some() { self.env.revert(Error::CannotLockTwice) } // Update state, emit event self.balances.set(&amp;caller, amount); self.lock_expiration_map .set(&amp;caller, current_block_time + self.lock_duration()); self.env() .emit_event(Deposit { address: caller, amount }); }  If you try to send tokens to a non-payable function, the transaction will be automatically rejected. ","version":"2.0.0","tagName":"h3"},{"title":"Non Reentrant​","type":1,"pageTitle":"Attributes","url":"/docs/2.0.0/advanced/attributes#non-reentrant","content":"Reentrancy attacks in smart contracts exploit the possibility of a function being called multiple times before its initial execution is completed, leading to the repeated unauthorized withdrawal of funds. To prevent such attacks, developers should ensure that all effects on the contract's state and balance checks occur before calling external contracts. They can also use reentrancy guards to block recursive calls to sensitive functions. In Odra you can just apply the #[odra(non_reentrant)] attribute to your function. ","version":"2.0.0","tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"Attributes","url":"/docs/2.0.0/advanced/attributes#example-1","content":"#[odra::module] pub struct NonReentrantCounter { counter: Var&lt;u32&gt; } #[odra::module] impl NonReentrantCounter { #[odra(non_reentrant)] pub fn count_ref_recursive(&amp;mut self, n: u32) { if n &gt; 0 { self.count(); ReentrancyMockRef::new(self.env(), self.env().self_address()).count_ref_recursive(n - 1); } } } impl NonReentrantCounter { fn count(&amp;mut self) { let c = self.counter.get_or_default(); self.counter.set(c + 1); } } #[cfg(test)] mod test { use super::*; use odra::host::{Deployer, NoArgs}; #[test] fn ref_recursion_not_allowed() { let test_env = odra_test::env(); let mut contract = NonReentrantCounter::deploy(&amp;test_env, NoArgs); let result = contract.count_ref_recursive(11); assert_eq!(result, ExecutionError::ReentrantCall.into()); } }  ","version":"2.0.0","tagName":"h3"},{"title":"Mixing attributes​","type":1,"pageTitle":"Attributes","url":"/docs/2.0.0/advanced/attributes#mixing-attributes","content":"A function can accept more than one attribute. The only exclusion is a constructor cannot be payable. To apply multiple attributes, you can write: #[odra(payable, non_reentrant)] fn deposit() { // your logic... }  or #[odra(payable)] #[odra(non_reentrant)] fn deposit() { // your logic... }  In both cases attributes order does not matter. ","version":"2.0.0","tagName":"h2"},{"title":"Odra + CosmWasm","type":0,"sectionRef":"#","url":"/blog/odra-cosmwasm","content":"","keywords":"","version":null},{"title":"CosmWasm​","type":1,"pageTitle":"Odra + CosmWasm","url":"/blog/odra-cosmwasm#cosmwasm","content":"CosmWasm is a smart contract platform for building dApps on the Cosmos blockchain ecosystem. The platform is designed as a module that can be integrated into the Cosmos SDK, enabling developers who are already building blockchains with the Cosmos SDK to easily incorporate CosmWasm smart contract functionality without the need to modify their existing code. It uses the Rust programming language, so is potentially a perfect candidate for an Odra backend. There are many blockchains like Osmosis, Secret Network, Juno that utilize CosmWasm. ","version":null,"tagName":"h2"},{"title":"Show me your code​","type":1,"pageTitle":"Odra + CosmWasm","url":"/blog/odra-cosmwasm#show-me-your-code","content":"I would like to write a Counter smart contract that is CosmWasm compatible. What are the requirements? It should store a u32 value. The initial value it set by the contract deployer.The value can be incremented.The value can read from the storage.The contract can call another contract and increment its counter. So let's write an Odra module first. counter.rs use odra::{types::{Address, event::OdraEvent}, Variable, contract_env}; use self::events::{Init, ValueUpdated}; #[odra::module] pub struct Counter { pub value: Variable&lt;u32&gt; } #[odra::module] impl Counter { #[odra(init)] pub fn init(&amp;mut self, value: u32) { self.value.set(value); &lt;Init as OdraEvent&gt;::emit(Init { value, }); } pub fn increment(&amp;mut self) { let old_value = self.value.get_or_default(); let new_value = old_value + 1; self.value.set(new_value); ValueUpdated { old_value, new_value, operator: contract_env::caller() }.emit(); } pub fn cross_increment(&amp;mut self, counter_address: Address) { CounterRef::at(counter_address).increment(); } pub fn get_value(&amp;self) -&gt; u32 { self.value.get_or_default() } } mod events { use odra::types::Address; #[derive(odra::Event)] pub struct ValueUpdated { pub old_value: u32, pub new_value: u32, pub operator: Address } #[derive(odra::Event)] pub struct Init { pub value: u32, } } #[cfg(test)] mod tests { use super::*; #[test] fn deploy() { let counter = CounterDeployer::init(10); assert_eq!(10, counter.get_value()); } #[test] fn increment() { let mut counter = CounterDeployer::init(10); counter.increment(); assert_eq!(11, counter.get_value()); } }  But wait, I mentioned CosmWasm, did I? Here the beauty of Odra comes into play. Let's use cargo-odra. cargo odra build -b cosmos  And... that's it, congratulations! We have just written and build our first CosmWasm contract. As you see, it is nothing different from building a contract for Casper. No additional code, we only changed the -b flag. ","version":null,"tagName":"h2"},{"title":"Deploy​","type":1,"pageTitle":"Odra + CosmWasm","url":"/blog/odra-cosmwasm#deploy","content":"We have just built a wasm file, but is it really a fully functional contract? As a battlefield let's choose Juno Network (if you would like to read more about smart contract development on Juno read this Quick Start tutorial). This is an arbitrary choice, each client is built upon a so-called Wasm Zone wasmd, and its interface is alike. Assuming you already know how to interact with Juno testnet, let's move to the fun part. But before we go, to keep things simple, let's prepare a justfile. It'll make our interactions with the blockchain much easier. See full version. justfile NODE := &quot;--node https://rpc.uni.juno.deuslabs.fi:443&quot; CHAIN_ID := &quot;--chain-id uni-6&quot; QUERY_FLAGS := NODE + &quot; &quot; + CHAIN_ID TRANSACTION_DEFAULTS := &quot;--gas-prices 0.025ujunox --gas auto --gas-adjustment 1.3 --broadcast-mode block&quot; EXEC_FLAGS := NODE + &quot; &quot; + CHAIN_ID + &quot; &quot; + TRANSACTION_DEFAULTS get-address NAME: junod keys show {{NAME}} | grep -o juno.* store-wasm WASM_PATH SENDER: junod tx wasm store \\ {{WASM_PATH}} --from {{SENDER}} {{EXEC_FLAGS}} init-contract CODE_ID VALUE SENDER CONTRACT_NAME: junod tx wasm instantiate \\ {{CODE_ID}} \\ `just run-args-parser '{&quot;name&quot;: &quot;init&quot;, &quot;args&quot;: [ { &quot;value&quot; : {{VALUE}} }]}'` \\ --label '{{CONTRACT_NAME}}' --from {{SENDER}} \\ --admin `just get-address {{SENDER}}` \\ {{EXEC_FLAGS}} exec-increment ADDRESS SENDER: junod tx wasm execute \\ {{ADDRESS}} \\ `just run-args-parser '{&quot;name&quot;: &quot;increment&quot;}'` \\ --from {{SENDER}} \\ {{EXEC_FLAGS}} query-get-value ADDRESS: junod q wasm contract-state smart {{ADDRESS}} \\ `just run-args-parser '{&quot;name&quot;: &quot;get_value&quot;}'` {{QUERY_FLAGS}}  Ok, we are ready to go. First, a CosmWasm contract needs to be stored, technically is not a contract yet. Like a larva waiting to morph into a butterfly (sorry for that). There are three ways to interact with a contract. Instantiate - in other words, a constructor call. Once the contract is instantiated, it gets an address.Execute - call an entrypoint that modifies the state.Query - read the contract's state. Now, let's take a look at how to do it using the tools we have just prepared. # args: # the path to a wasm file, # the name under we store the private key. just store-wasm counter.wasm odra ... raw_log: '[{&quot;events&quot;:[{&quot;type&quot;:&quot;message&quot;,&quot;attributes&quot;:[{&quot;key&quot;:&quot;action&quot;,&quot;value&quot;:&quot;/cosmwasm.wasm.v1.MsgStoreCode&quot;},{&quot;key&quot;:&quot;module&quot;,&quot;value&quot;:&quot;wasm&quot;},{&quot;key&quot;:&quot;sender&quot;,&quot;value&quot;:&quot;juno1le848rjac00nezzq46v5unxujaltdf270vhtfh&quot;}]},{&quot;type&quot;:&quot;store_code&quot;,&quot;attributes&quot;:[{&quot;key&quot;:&quot;code_checksum&quot;,&quot;value&quot;:&quot;9fb9e7f39170de2628892ed5eecc556e2487267b30bb2c9656f8c7d1cd9f9a59&quot;},{&quot;key&quot;:&quot;code_id&quot;,&quot;value&quot;:&quot;286&quot;}]}]}]' ... txhash: 1A8BA520E980C5ABCBCFA6F62D68B6BB82E780544605DE4DD5C6B1C5E966441B  Great, our code is successfully stored. Form the logs we can read now the code_id which we will use to initialize the contract. # args: # code id taken from the previous tx, # counter initial value, # named private key, # contract label. just init-contract 286 1 odra &quot;My Counter&quot; ... raw_log: '[{&quot;events&quot;:[{&quot;type&quot;:&quot;instantiate&quot;,&quot;attributes&quot;:[{&quot;key&quot;:&quot;_contract_address&quot;,&quot;value&quot;:&quot;juno10yszsgq4460a57ztuw943h5j3c9l0eyx3algzq080gatl0thecls5ttk7g&quot;},{&quot;key&quot;:&quot;code_id&quot;,&quot;value&quot;:&quot;286&quot;}]},{&quot;type&quot;:&quot;message&quot;,&quot;attributes&quot;:[{&quot;key&quot;:&quot;action&quot;,&quot;value&quot;:&quot;/cosmwasm.wasm.v1.MsgInstantiateContract&quot;},{&quot;key&quot;:&quot;module&quot;,&quot;value&quot;:&quot;wasm&quot;},{&quot;key&quot;:&quot;sender&quot;,&quot;value&quot;:&quot;juno1le848rjac00nezzq46v5unxujaltdf270vhtfh&quot;}]},{&quot;type&quot;:&quot;wasm&quot;,&quot;attributes&quot;:[{&quot;key&quot;:&quot;_contract_address&quot;,&quot;value&quot;:&quot;juno10yszsgq4460a57ztuw943h5j3c9l0eyx3algzq080gatl0thecls5ttk7g&quot;},{&quot;key&quot;:&quot;value&quot;,&quot;value&quot;:&quot;1&quot;}]},{&quot;type&quot;:&quot;wasm-Init&quot;,&quot;attributes&quot;:[{&quot;key&quot;:&quot;_contract_address&quot;,&quot;value&quot;:&quot;juno10yszsgq4460a57ztuw943h5j3c9l0eyx3algzq080gatl0thecls5ttk7g&quot;},{&quot;key&quot;:&quot;value&quot;,&quot;value&quot;:&quot;1&quot;}]}]}]' ... txhash: 8DC53F95805349C3763CF4AF9527CAB2AEBEC77B240EFD3801C61231D8748F26  Fantastic, the contract has been initialized and we have its address - juno10yszsgq4460a57ztuw943h5j3c9l0eyx3algzq080gatl0thecls5ttk7g. It's time to increment the counter. # args: # contract address taken from the previous tx, # named private key just exec-increment juno10yszsgq4460a57ztuw943h5j3c9l0eyx3algzq080gatl0thecls5ttk7g odra ... raw_log: '[{&quot;events&quot;:[{&quot;type&quot;:&quot;execute&quot;,&quot;attributes&quot;:[{&quot;key&quot;:&quot;_contract_address&quot;,&quot;value&quot;:&quot;juno10yszsgq4460a57ztuw943h5j3c9l0eyx3algzq080gatl0thecls5ttk7g&quot;}]},{&quot;type&quot;:&quot;message&quot;,&quot;attributes&quot;:[{&quot;key&quot;:&quot;action&quot;,&quot;value&quot;:&quot;/cosmwasm.wasm.v1.MsgExecuteContract&quot;},{&quot;key&quot;:&quot;module&quot;,&quot;value&quot;:&quot;wasm&quot;},{&quot;key&quot;:&quot;sender&quot;,&quot;value&quot;:&quot;juno1le848rjac00nezzq46v5unxujaltdf270vhtfh&quot;}]},{&quot;type&quot;:&quot;wasm&quot;,&quot;attributes&quot;:[{&quot;key&quot;:&quot;_contract_address&quot;,&quot;value&quot;:&quot;juno10yszsgq4460a57ztuw943h5j3c9l0eyx3algzq080gatl0thecls5ttk7g&quot;},{&quot;key&quot;:&quot;action&quot;,&quot;value&quot;:&quot;increment&quot;}]},{&quot;type&quot;:&quot;wasm-ValueUpdated&quot;,&quot;attributes&quot;:[{&quot;key&quot;:&quot;_contract_address&quot;,&quot;value&quot;:&quot;juno10yszsgq4460a57ztuw943h5j3c9l0eyx3algzq080gatl0thecls5ttk7g&quot;},{&quot;key&quot;:&quot;old_value&quot;,&quot;value&quot;:&quot;1&quot;},{&quot;key&quot;:&quot;new_value&quot;,&quot;value&quot;:&quot;2&quot;},{&quot;key&quot;:&quot;operator&quot;,&quot;value&quot;:&quot;juno1le848rjac00nezzq46v5unxujaltdf270vhtfh&quot;}]}]}]' ... txhash: 52141844321B8321DA71D073D4FA0865E73C3940153373CA7EF832D15BC3C2B2  Finally, we expected, the value to be equal to 2 (the initial value was 1 and we incremented it once). # args: # contract address just query-get-value juno10yszsgq4460a57ztuw943h5j3c9l0eyx3algzq080gatl0thecls5ttk7g data: 2  Indeed, as expected the current counter value is 2. ","version":null,"tagName":"h2"},{"title":"Show me your transaction​","type":1,"pageTitle":"Odra + CosmWasm","url":"/blog/odra-cosmwasm#show-me-your-transaction","content":"I get it, you don't want to do it all by yourself. So let's take a closer look at one of my transactions. junod q tx 52141844321B8321DA71D073D4FA0865E73C3940153373CA7EF832D15BC3C2B2 --node https://rpc.uni.juno.deuslabs.fi:443 --chain-id uni-6 ... logs: - events: - attributes: - key: _contract_address value: juno10yszsgq4460a57ztuw943h5j3c9l0eyx3algzq080gatl0thecls5ttk7g type: execute - attributes: - key: action value: /cosmwasm.wasm.v1.MsgExecuteContract - key: module value: wasm - key: sender value: juno1le848rjac00nezzq46v5unxujaltdf270vhtfh type: message - attributes: - key: _contract_address value: juno10yszsgq4460a57ztuw943h5j3c9l0eyx3algzq080gatl0thecls5ttk7g - key: action value: increment type: wasm - attributes: - key: _contract_address value: juno10yszsgq4460a57ztuw943h5j3c9l0eyx3algzq080gatl0thecls5ttk7g - key: old_value value: &quot;1&quot; - key: new_value value: &quot;2&quot; - key: operator value: juno1le848rjac00nezzq46v5unxujaltdf270vhtfh type: wasm-ValueUpdated ... txhash: 52141844321B8321DA71D073D4FA0865E73C3940153373CA7EF832D15BC3C2B2  If you are familiar Cosmos ecosystem, you can see that there is an attribute containing the performed action (increment) (If there were some parameters, they would be included in this attribute). We can find here also our ValueUpdated event with its arguments old_value, new_value and operator. Wow, we have it, everything worked as intended! ","version":null,"tagName":"h2"},{"title":"Conclusion​","type":1,"pageTitle":"Odra + CosmWasm","url":"/blog/odra-cosmwasm#conclusion","content":"Wouldn't it be great to replace Casper Erc20 and Cosmos Erc20 with a super-simple single Odra Erc20 implementation? The Counter contract is just a POC, and there is still a long road ahead of us. This simple example shows that features like storage, events, and cross-contract calls can be unified in a simple readable interface. CosmWasm integration hasn't been published yet, but if you want to experiment by yourself, check our GitHub (don't forget to update cargo-odra as well). ","version":null,"tagName":"h2"},{"title":"Join us​","type":1,"pageTitle":"Odra + CosmWasm","url":"/blog/odra-cosmwasm#join-us","content":"Interested? Join our Discord, our Twitter or write us at contact@odra.dev. ","version":null,"tagName":"h2"},{"title":"EVM at Risc0","type":0,"sectionRef":"#","url":"/blog/evm-at-risc0","content":"","keywords":"","version":null},{"title":"Solidity​","type":1,"pageTitle":"EVM at Risc0","url":"/blog/evm-at-risc0#solidity","content":"As an example, I have this simple Solidity code. It is a calculator with two functions. One for addition and one for the nth Fibonacci number. bytecode/Calculator.sol contract Calculator { function add(uint256 a, uint256 b) public pure returns (uint256) { return a + b; } function fibonacci(uint256 n) public returns (uint256) { if (n &lt;= 1) { return n; } else { return fibonacci(n - 1) + fibonacci(n - 2); } } }  It needs to be compiled into the byte code. solc can do this. $ solc \\ --bin-runtime \\ --optimize \\ --overwrite \\ --evm-version istanbul \\ --output-dir bytecode \\ bytecode/Calculator.sol  It produces an EVM bytecode in the bytecode directory. $ ls bytecode/ Calculator.bin-runtime Calculator.sol  ","version":null,"tagName":"h2"},{"title":"EVM​","type":1,"pageTitle":"EVM at Risc0","url":"/blog/evm-at-risc0#evm","content":"The EVM I used is SputnikVM. Most important it is written in pure Rust and even with no_std mode. This way I can start an in-memory instance of EVM. Then take the bytecode of a contract and install it. Finally, call the contract with arguments and obtain the result value. For now, it's just a Rust code. Risc0 comes later. The code is based on Sputnik's benchmark test. Huge thanks to Michael Birch for helping with Sputnik. Also make sure how EVM's function selectors work. evm-runner/src/lib.rs // Load previously compiled Calculator contract. pub const CALCULATOR_EVM_PROGRAM: &amp;str = include_str!( &quot;../../bytecode/Calculator.bin-runtime&quot; ); // Run Calculator for a given input. pub fn run_calc_contract(input: &amp;str) -&gt; String { run_evm(CALCULATOR_EVM_PROGRAM, input) } // Run a program (contract) for a given input. fn run_evm(program: &amp;str, input: &amp;str) -&gt; String { // Define EVM configuration. let config = Config::istanbul(); let vicinity = MemoryVicinity { gas_price: U256::zero(), origin: H160::default(), block_hashes: Vec::new(), block_number: Default::default(), block_coinbase: Default::default(), block_timestamp: Default::default(), block_difficulty: Default::default(), block_gas_limit: Default::default(), chain_id: U256::one(), block_base_fee_per_gas: U256::zero(), }; // Initialized the state of EVM's memory. let mut state = BTreeMap::new(); // Add our contract under the 0x10 address. state.insert( H160::from_str(&quot;0x1000000000000000000000000000000000000000&quot;) .unwrap(), MemoryAccount { nonce: U256::one(), balance: U256::from(10000000), storage: BTreeMap::new(), code: hex::decode(program).unwrap(), } ); // Add new user 0xf0 that will be used as the contract caller. state.insert( H160::from_str(&quot;0xf000000000000000000000000000000000000000&quot;) .unwrap(), MemoryAccount { nonce: U256::one(), balance: U256::from(10000000), storage: BTreeMap::new(), code: Vec::new(), }, ); // Prepare the executor. let backend = MemoryBackend::new(&amp;vicinity, state); let metadata = StackSubstateMetadata::new(u64::MAX, &amp;config); let state = MemoryStackState::new(metadata, &amp;backend); let precompiles = BTreeMap::new(); let mut executor = StackExecutor::new_with_precompiles(state, &amp;config, &amp;precompiles); // Call the 0x10 contract using the 0xf0 user. // Use the input variable. let (exit_reason, result) = executor.transact_call( H160::from_str(&quot;0xf000000000000000000000000000000000000000&quot;) .unwrap(), H160::from_str(&quot;0x1000000000000000000000000000000000000000&quot;) .unwrap(), U256::zero(), hex::decode(input).unwrap(), u64::MAX, Vec::new(), ); // Make sure the execution succeeded. assert!(exit_reason == ExitReason::Succeed(ExitSucceed::Returned)); // Return hex encoded string. hex::encode(result) }  Let's execute it. In below tests the data variable hold two things: function selector and arguments. For example 61047ff4000000000000000000000000000000000000000000000000000000000000000ais concatination of the function selector (first 8 chars) and 256-bit long argument. It is just fibonacci(10). a is hex of 10 and 37 is hex of 52. evm-runner/src/lib.rs #[test] fn fibonacci_works() { let data = &quot;61047ff4000000000000000000000000000000000000000000000000000000000000000a&quot;; let result = run_calc_contract(data); assert_eq!(result, &quot;0000000000000000000000000000000000000000000000000000000000000037&quot;); } #[test] fn addition_works() { let data = &quot;771602f700000000000000000000000000000000000000000000000000000000000000070000000000000000000000000000000000000000000000000000000000000002&quot;; let result = run_calc_contract(data); assert_eq!(result, &quot;0000000000000000000000000000000000000000000000000000000000000009&quot;); }  ","version":null,"tagName":"h2"},{"title":"Risc0​","type":1,"pageTitle":"EVM at Risc0","url":"/blog/evm-at-risc0#risc0","content":"It's time for risc0. First the guest program. It is super simple. It takes a string as an argument, passes it to the run_calc_contractand returns the result. methods/guest/src/bin/evm_calc.rs #![no_main] #![no_std] extern crate alloc; use alloc::{string::String}; use risc0_zkvm::guest::{env}; use evm_runner::run_calc_contract; risc0_zkvm::guest::entry!(main); pub fn main() { let input: String = env::read(); let result = run_calc_contract(&amp;input); env::commit(&amp;result); }  The final step is calling it under ZK. host/src/main.rs fn main() { println!(&quot;Proving Calculator.add(7, 2)&quot;); let input = &quot;771602f700000000000000000000000000000000000000000000000000000000000000070000000000000000000000000000000000000000000000000000000000000002&quot;; let result = run_prover(input); println!(&quot;Proof generated. 7 + 2 = {result}&quot;); println!(&quot;Proving Calculator.fibonacci(4)&quot;); let input = &quot;61047ff40000000000000000000000000000000000000000000000000000000000000004&quot;; let result = run_prover(input); println!(&quot;Proof generated. fibonacci(4) = {result}&quot;); } fn run_prover(input: &amp;str) -&gt; u32 { // Make the prover. let method_code = std::fs::read(EVM_CALC_PATH).unwrap(); let mut prover = Prover::new(&amp;method_code, EVM_CALC_ID).unwrap(); // Push the input as an argument. prover.add_input_u32_slice(to_vec(input).unwrap().as_slice()); // Execute the prover. let receipt = prover.run().unwrap(); // Verify the proof. assert!(receipt.verify(EVM_CALC_ID).is_ok()); // Return result as an u32 value. let result: String = from_slice(receipt.journal.as_slice()).unwrap(); u32::from_str_radix(&amp;result, 16).unwrap() }  $ cargo run --release -p host Proving Calculator.add(7, 2) Proof generated. 7 + 2 = 9 Proving Calculator.fibonacci(4) Proof generated. fibonacci(4) = 3  ","version":null,"tagName":"h2"},{"title":"Conclusion​","type":1,"pageTitle":"EVM at Risc0","url":"/blog/evm-at-risc0#conclusion","content":"How amazing and mindblowing it is! Of course, it's just a proof of concept. Yet with further development of Risc0 improving its proving time and with more flexible SputnikVM this approach is more than promising. ","version":null,"tagName":"h2"},{"title":"Join us​","type":1,"pageTitle":"EVM at Risc0","url":"/blog/evm-at-risc0#join-us","content":"Interested? Join our Discord, our Twitter or write us at contact@odra.dev. ","version":null,"tagName":"h2"},{"title":"Building contracts manually","type":0,"sectionRef":"#","url":"/docs/2.0.0/advanced/building-manually","content":"","keywords":"","version":"2.0.0"},{"title":"Building the contract manually​","type":1,"pageTitle":"Building contracts manually","url":"/docs/2.0.0/advanced/building-manually#building-the-contract-manually","content":"To build the contract manually, cargo odra uses the following command: ODRA_MODULE=my_contract cargo build --release --target wasm32-unknown-unknown --bin my_project_build_contract  info Odra uses the environment variable ODRA_MODULE to determine which contract to build. Assuming that project's crate is named my_project, this command will build the my_contract contract in release mode and generate the wasm file. The file will be put into the target/wasm32-unknown-unknown/release directory under the name my_project_build_contract.wasm. The Odra Framework expects the contracts to be placed in the wasm directory, and to be named correctly, so the next step would be to move the file: mv target/wasm32-unknown-unknown/release/my_project_build_contract.wasm wasm/my_contract.wasm  ","version":"2.0.0","tagName":"h2"},{"title":"Optimizing the contract​","type":1,"pageTitle":"Building contracts manually","url":"/docs/2.0.0/advanced/building-manually#optimizing-the-contract","content":"To lower the size of the wasm file, cargo odra uses the wasm-strip tool: wasm-strip wasm/my_contract.wasm  To further optimize the wasm file, the wasm-opt tool is also used. wasm-opt --signext-lowering wasm/my_contract.wasm -o wasm/my_contract.wasm  danger This step is required, as the wasm file generated by the Rust compiler is not fully compatible with the Casper execution engine. ","version":"2.0.0","tagName":"h2"},{"title":"Running the tests manually​","type":1,"pageTitle":"Building contracts manually","url":"/docs/2.0.0/advanced/building-manually#running-the-tests-manually","content":"To run the tests manually, Odra needs to know which backend to use. To run tests against Casper backend, the following command needs to be used: ODRA_BACKEND=casper cargo test  ","version":"2.0.0","tagName":"h2"},{"title":"Wrapping up​","type":1,"pageTitle":"Building contracts manually","url":"/docs/2.0.0/advanced/building-manually#wrapping-up","content":"Let's say we want to build the my_contract in debug mode, run the tests against the casper backend and use the my-own-allocator feature from our my_project project. To do that, we can use the following set of commands: ODRA_MODULE=my_contract cargo build --target wasm32-unknown-unknown --bin my_project_build_contract mv target/wasm32-unknown-unknown/debug/my_project_build_contract.wasm wasm/my_contract.wasm wasm-strip wasm/my_contract.wasm wasm-opt --signext-lowering wasm/my_contract.wasm -o wasm/my_contract.wasm ODRA_BACKEND=casper cargo test --features my-own-allocator  ","version":"2.0.0","tagName":"h2"},{"title":"Nysa","type":0,"sectionRef":"#","url":"/blog/Nysa","content":"","keywords":"","version":null},{"title":"Odra​","type":1,"pageTitle":"Nysa","url":"/blog/Nysa#odra","content":"A short reminder: Odra is a high-level smart contract framework for Rust, which encourages rapid development and clean, pragmatic design ... it takes care of much of the hassle of smart contract development, enabling you to focus on writing your dapp without reinventing the wheel. Odra Understanding that people generally dislike learning new things, we've kept this in mind throughout development. Since day one, we have focused on creating Odra with the largest group of smart contract developers in mind - those familiar with Solidity. The Odra Framework is designed to flatten the learning curve for this group. A Solidity developer will encounter familiar concepts such as: ConstructorsPayable functionsMappingsRevertsCurrent callerCurrent block timeA standard module library (similar to OpenZeppelin)And more note It's important to note that the Odra Framework is intentionally blockchain-agnostic. Its design does not target any particular blockchain. Ultimately, Odra is built to support multiple blockchains, allowing the writing of smart contracts in Rust. Having so many similarities, why not take the next step and transpile Solidity code into Odra code? This is where Nysa comes into play. ","version":null,"tagName":"h2"},{"title":"Nysa​","type":1,"pageTitle":"Nysa","url":"/blog/Nysa#nysa","content":"Solidity and Rust share some syntax similarities despite being designed for different purposes. Both languages emphasize strong typing, pattern matching, and immutability by default. Nysa performs Solidity-to-Rust transpilation through four simple steps.  Solidity Parser Firstly, we need a well-structured Rust representation of Solidity code. Nysa utilizes LALRPOP - a Rust parser generator framework. In the further steps, this enables us to conduct static analysis of the Solidity code, ranging from contract context down to individual expressions. solidity-parser/src/pt.rs // The representation of a Solidity contract #[derive(Debug, PartialEq)] pub struct ContractDefinition { pub doc: Vec&lt;DocComment&gt;, pub loc: Loc, pub ty: ContractTy, pub name: Identifier, pub base: Vec&lt;Base&gt;, pub parts: Vec&lt;ContractPart&gt;, }  C3 Linearization One of the most notable distinctions between Rust and Solidity is their approach to inheritance. Rust says No, thx, whereas Solidity opts for The more, the better. Speaking more technically, Solidity supports multiple inheritance with C3 linearization. info The primary purpose of the C3 Linearization Algorithm is to establish a consistent and unambiguous order of method resolution in cases where there might be ambiguity or conflicts due to multiple inheritance. It ensures that the inherited methods are called in a predictable and well-defined sequence based on the class hierarchy and the order in which classes are defined. For simulating C3 linearization, Nysa utilizes an implementation of the C3 linearization in Rust written by Maciej Zieliński, so everything stays in the Odra family. Nysa Parser After that, we step to the essential part, converting Solidity code into Rust code. For example, a Solidity event. event Transfer(address indexed from, address indexed to, uint256 value);  can easily be represented as an plain Rust struct - the same name, the same fields, similar types. #[derive(PartialEq, Eq, Debug)] pub struct Transfer { from: Option&lt;Address&gt;, to: Option&lt;Address&gt;, value: U256, }  The same we do with contracts, interfaces, libraries, errors, variables, functions, statements, etc. Here is a snippet of the expression parser: nysa/src/parser/odra/expr/mod.rs pub fn parse&lt;T&gt;(expression: &amp;Expression, ctx: &amp;mut T) -&gt; Result&lt;syn::Expr, ParserError&gt; where T: StorageInfo + TypeInfo + EventsRegister + ExternalCallsRegister + ContractInfo + FnContext, { match expression { Expression::Require { condition, error } =&gt; error::revert(Some(condition), error, ctx), Expression::ZeroAddress =&gt; Ok(parse_quote!(None)), Expression::Add { left, right } =&gt; math::add(left, right, ctx), Expression::Subtract { left, right } =&gt; math::sub(left, right, ctx), Expression::Increment { expr } =&gt; { let expr = parse(expr, ctx)?; Ok(parse_quote!(#expr += 1)) } Expression::ExternalCall { variable, fn_name, args, } =&gt; parse_ext_call(variable, fn_name, args, ctx), Expression::Type { ty } =&gt; { let ty = ty::parse_plain_type_from_ty(ty, ctx)?; Ok(parse_quote!(#ty)) } Expression::BoolLiteral(b) =&gt; Ok(parse_quote!(#b)), ... } }  Printing the code The last step is just consuming the resulting C3 AST. Nysa produces a token stream from the AST. Most likely you would write it to a file. And there you are: a Rust smart contract is ready to be compiled! ","version":null,"tagName":"h2"},{"title":"Nysa + Odra​","type":1,"pageTitle":"Nysa","url":"/blog/Nysa#nysa--odra","content":"By design, Nysa is a universal tool, so the third step from the pipeline is replaceable. In other words, a Solidity input can be converted to Rust code supporting a framework/SDK of your choice unless you provide a parser implementation. However, the default implementation is OdraParser, which takes a contract written in Solidity and splits out an Odra module. I hope you see an analogy to the first two paragraphs at this point. Nysa the river and Nysa the transpiler flow into Odra.  ","version":null,"tagName":"h3"},{"title":"Examples​","type":1,"pageTitle":"Nysa","url":"/blog/Nysa#examples","content":"","version":null,"tagName":"h2"},{"title":"Status message​","type":1,"pageTitle":"Nysa","url":"/blog/Nysa#status-message","content":"Let's get our hands dirty and create a very simple project. We will write a contract that stores a single mapping of records - an address to a string message. To set up the project, we use cargo odra. cargo odra new -n status -t blank cd status  The first thing is to add Nysa to the project and create a rudimentary build.rs where we define the input - a solidity contract and the output - an Odra module generated by Nysa. Cargo.toml [build-dependencies] nysa = { version = &quot;0.1.0&quot;, features = [&quot;builder&quot;] }  build.rs const DEST_FILE_PATH: &amp;str = &quot;src/status_message.rs&quot;; const SOURCE_FILE_PATH: &amp;str = &quot;src/status_message.sol&quot;; fn main() { nysa::builder::generate_file::&lt;&amp;str, nysa::OdraParser&gt;(SOURCE_FILE_PATH, DEST_FILE_PATH); }  Next, implement the contract. Naturally, a Solidity one. src/status_message.sol // SPDX-License-Identifier: MIT pragma solidity ^0.8.19; contract StatusMessage { mapping(address =&gt; string) records; function setStatus(string memory status) public payable { address accountId = msg.sender; records[accountId] = status; } function getStatus(address accountId) public view returns (string memory) { return records[accountId]; } }  The contract has a single mapping records that stores a message and its owner. Additionally, exposes two entry points: setStatus (sets current's sender message) and getStatus. Following, let's define a lib.rs file. src/lib.rs mod status_message; pub use status_message::{StatusMessage, StatusMessageDeployer, StatusMessageRef}; #[cfg(test)] mod test;  The file is straightforward: registers a status_message rust module, reexports some Odra abstractions, and adds a test module. Lastly, we can test our contract. Like the original solidity contract, our Odra contract exposes two entry points: set_message() and get_message(). The test code looks like any other Odra test: we use StatusMessageDeployer to instantiate a contract, which gets us a reference to interact with the contract. src/test.rs use odra::{test_env, types::Address}; use super::*; const ACCOUNT: fn() -&gt; Address = || odra::test_env::get_account(1); #[test] fn set_get_message() { let mut contract = StatusMessageDeployer::default(); test_env::set_caller(ACCOUNT()); contract.set_status(&quot;hello&quot;.to_string()); assert_eq!(&quot;hello&quot;.to_string(), contract.get_status(Some(ACCOUNT()))); } #[test] fn get_nonexistent_message() { let contract = StatusMessageDeployer::default(); assert_eq!( String::new(), contract.get_status(Some(ACCOUNT())) ); }  cargo odra test # test against MockVM # or cargo odra test -b casper # build a wasm file and test against CasperVM  status-message ├── src │ ├── lib.rs │ ├── status_message.sol │ └── test.rs ├── build.rs ├── Cargo.toml └── Odra.toml  Full example available here. ","version":null,"tagName":"h3"},{"title":"CappedErc20​","type":1,"pageTitle":"Nysa","url":"/blog/Nysa#cappederc20","content":"A more complex, real-world example is a CappedErc20 contract. It is a ERC20 Ownable, Burnable and Capped token contract. plascoin.sol // ... // rest of the code contract Plascoin is ERC20Capped, ERC20Burnable, Ownable { constructor(string memory name_, string memory symbol_, uint256 cap_, address initialOwner) ERC20(name_, symbol_) ERC20Capped(cap_) Ownable(initialOwner) { } function mint(address account, uint256 amount) public onlyOwner { _mint(account, amount); } function _update(address from, address to, uint256 value) internal override(ERC20, ERC20Capped) { super._update(from, to, value); } }  You can check out the full source code here. Deployment of such a contract onto the Casper testnet is straightforward. We are just two steps from it. # to make sure the contract works as expected # we execute cargo odra test command to build and run tests cargo odra test -b casper # deploy onto the testnet casper-client put-deploy --node-address {{NODE_ADDRESS}} --chain-name casper-test --secret-key {{SECRET_KEY}} \\ --session-path {{CONTRACT_WASM}} \\ --payment-amount 130000000000 \\ --session-arg &quot;odra_cfg_package_hash_key_name:string:'{{CONTRACT_PACKAGE_HASH_NAMED_KEY}}'&quot; \\ --session-arg &quot;odra_cfg_allow_key_override:bool:'true'&quot; \\ --session-arg &quot;odra_cfg_is_upgradable:bool:'true'&quot; \\ --session-arg &quot;odra_cfg_constructor:string:'init'&quot; \\ --session-arg &quot;name:string='{{name}}'&quot; \\ --session-arg &quot;symbol:string='{{symbol}}'&quot; \\ --session-arg &quot;cap:u256='{{cap}}'&quot; \\ --session-arg &quot;initial_owner:opt_key='{{owner}}'&quot;  Literally in 5 minutes I was able to: Build a wasm file from Solidity source codeSuccessfully deploy the contract onto Testnet,Mint some tokens,And transfer them. Finally, we compare the costs of Solidity-to-Odra contract and a native CEP-18 implementation. Despite the contracts being different in terms of the internal logic and exposed entry points, such comparison gives us some insight into Nysa's efficiency. action\tCEP-18\tNysadeploy\t143.87\t93.37 transfer\t1.29\t1.36 ","version":null,"tagName":"h3"},{"title":"Conclusion​","type":1,"pageTitle":"Nysa","url":"/blog/Nysa#conclusion","content":"Nysa is at early stage of development, but already has shown a huge potential. In a few simple steps, you can take advantage of an existing smart contract and convert it into an Odra module. The module can be a standalone contract, or a building block of a bigger contract. ","version":null,"tagName":"h2"},{"title":"Storage Layout","type":0,"sectionRef":"#","url":"/docs/2.0.0/advanced/storage-layout","content":"","keywords":"","version":"2.0.0"},{"title":"Casper VM Perspective​","type":1,"pageTitle":"Storage Layout","url":"/docs/2.0.0/advanced/storage-layout#casper-vm-perspective","content":"The Casper Execution Engine (VM) enables the storage of data in named keys or dictionaries. However, a smart contract has a limited number of named keys, making it unsuitable for storing substantial data volumes. Odra resolves this issue by storing all user-generated data in a dictionary called state. This dictionary operates as a key-value store, where keys are strings with a maximum length of 64 characters, and values are arbitrary byte arrays. Here is an example of what the interface for reading and writing data could look like: pub trait CasperStorage { fn read(key: &amp;str) -&gt; Option&lt;Vec&lt;u8&gt;&gt;; fn write(key: &amp;str, value: Vec&lt;u8&gt;); }  ","version":"2.0.0","tagName":"h2"},{"title":"Odra Perspective​","type":1,"pageTitle":"Storage Layout","url":"/docs/2.0.0/advanced/storage-layout#odra-perspective","content":"Odra was conceived with modularity and code reusability in mind. Additionally, we aimed to streamline storage definition through the struct object. Consider this straightforward storage definition: #[odra::module] pub struct Token { name: Var&lt;String&gt;, balances: Mapping&lt;Address, U256&gt; }  The Token structure contains two fields: name of type String andbalances, which functions as a key-value store with Address as keys andU256 as values. The Token module can be reused in another module, as demonstrated in a more complex example: #[odra::module] pub struct Loans { lenders: SubModule&lt;Token&gt;, borrowers: SubModule&lt;Token&gt;, }  The Loans module has two fields: lenders and borrowers, both of which have the same storage layout as defined by the Token module. Odra guarantees thatlenders and borrowers are stored under distinct keys within the storage dictionary. Both Token and Loans serve as examples to show how Odra's storage layout operates. ","version":"2.0.0","tagName":"h2"},{"title":"Key generation.​","type":1,"pageTitle":"Storage Layout","url":"/docs/2.0.0/advanced/storage-layout#key-generation","content":"Every element of a module (struct) with N elements is associated with an index ranging from 0 to N-1, represented as a u8 with a maximum of 256 elements. If an element of a module is another module (SubModule&lt;...&gt;), the associated index serves as a prefix for the indexes of the inner module. While this may initially appear complex, it is easily understood through an example. In the example, indexes are presented as bytes, reflecting the actual implementation. Loans { lenders: Token { // prefix: 0x0001 name: 1, // key: 0x0001_0001 balances: 2 // key: 0x0001_0010 }, borrowers: Token { // prefix: 0x0010 name: 1, // key: 0x0010_0001 balances: 2 // key: 0x0010_0010 } }  Additionally, it's worth mentioning how Mapping's keys are used in thestorage. They are simply concatenated with the index of the module, as demonstrated in the example. For instance, triggering borrowers.balances.get(0x1234abcd) would result in a key: 0x0001_0001_1234_abcd  Finally, the key must be hashed to fit within the 64-character limit and then encoded in hexadecimal format. ","version":"2.0.0","tagName":"h2"},{"title":"Value serialization​","type":1,"pageTitle":"Storage Layout","url":"/docs/2.0.0/advanced/storage-layout#value-serialization","content":"Before being stored in the storage, each value is serialized into bytes using the CLType serialization method and subsequently encapsulated with Casper'sBytes types. ","version":"2.0.0","tagName":"h2"},{"title":"Memory allocators","type":0,"sectionRef":"#","url":"/docs/2.0.0/advanced/using-different-allocator","content":"","keywords":"","version":"2.0.0"},{"title":"Using a different allocator​","type":1,"pageTitle":"Memory allocators","url":"/docs/2.0.0/advanced/using-different-allocator#using-a-different-allocator","content":"If the default allocator does not suit your needs, or you use a crate that already provides an allocator, you can disable the default allocator by enabling the disable-allocator feature in the odra dependency in your project: [dependencies] odra = { path = &quot;../odra&quot;, features = [&quot;disable-allocator&quot;] }  If you want to have a better control over the features that are enabled during the building and tests, see the next article on building manually. ","version":"2.0.0","tagName":"h2"},{"title":"Signatures","type":0,"sectionRef":"#","url":"/docs/2.0.0/advanced/signatures","content":"","keywords":"","version":"2.0.0"},{"title":"Signature verification​","type":1,"pageTitle":"Signatures","url":"/docs/2.0.0/advanced/signatures#signature-verification","content":"Signature verification is conducted by a function in contract's env(): pub fn verify_signature(message: &amp;Bytes, signature: &amp;Bytes, public_key: &amp;PublicKey) -&gt; bool;  Here's the simplest example of this function used in a contract: examples/src/features/signature_verifier.rs #[odra::module] impl SignatureVerifier { pub fn verify_signature( &amp;self, message: &amp;Bytes, signature: &amp;Bytes, public_key: &amp;PublicKey ) -&gt; bool { self.env().verify_signature(message, signature, public_key) } }  ","version":"2.0.0","tagName":"h2"},{"title":"Testing​","type":1,"pageTitle":"Signatures","url":"/docs/2.0.0/advanced/signatures#testing","content":"Besides the above function in the contract context, Odra provides corresponding functions in the HostEnv: pub fn sign_message(message: &amp;Bytes, address: &amp;Address) -&gt; Bytes; pub fn public_key(address: &amp;Address) -&gt; PublicKey;  sign_message will return a signed message. The signing itself will be performed using a private key of an account behind the address. public_key returns the PublicKey of an address account. Here's a complete example of how to test the signature verification in the contract: examples/src/features/signature_verifier.rs #[test] fn signature_verification_works() { let test_env = odra_test::env(); let message = &quot;Message to be signed&quot;; let message_bytes = Bytes::from(message.as_bytes()); let account = test_env.get_account(0); let signature = test_env.sign_message(&amp;message_bytes, &amp;account); let public_key = test_env.public_key(&amp;account); let signature_verifier = SignatureVerifier::deploy(&amp;test_env, NoArgs); assert!(signature_verifier.verify_signature(&amp;message_bytes, &amp;signature, &amp;public_key)); }  If you want, you can also test signatures created outside Odra: examples/src/features/signature_verifier.rs #[test] fn verify_signature_casper_wallet() { // Casper Wallet for the message &quot;Ahoj przygodo!&quot; signed using SECP256K1 key // produces the following signature: // 1e87e186238fa1df9c222b387a79910388c6ef56285924c7e4f6d7e77ed1d6c61815312cf66a5318db204c693b79e020b1d392dafe8c1b3841e1f6b4c41ca0fa // Casper Wallet adds &quot;Casper Message:\\n&quot; prefix to the message: let message = &quot;Casper Message:\\nAhoj przygodo!&quot;; let message_bytes = Bytes::from(message.as_bytes()); // Depending on the type of the key, we need to prefix the signature with a tag: // 0x01 for ED25519 // 0x02 for SECP256K1 let signature_hex = &quot;021e87e186238fa1df9c222b387a79910388c6ef56285924c7e4f6d7e77ed1d6c61815312cf66a5318db204c693b79e020b1d392dafe8c1b3841e1f6b4c41ca0fa&quot;; let signature: [u8; 65] = hex::decode(signature_hex).unwrap().try_into().unwrap(); let signature_bytes = Bytes::from(signature.as_slice()); // Similar to the above, the public key is tagged: let public_key_hex = &quot;02036d9b880e44254afaf34330e57703a63aec53b5918d4470059b67a4a906350105&quot;; let public_key_decoded = hex::decode(public_key_hex).unwrap(); let (public_key, _) = PublicKey::from_bytes(public_key_decoded.as_slice()).unwrap(); let signature_verifier = SignatureVerifier::deploy(&amp;odra_test::env(), NoArgs); assert!(signature_verifier.verify_signature(&amp;message_bytes, &amp;signature_bytes, &amp;public_key)); }  ","version":"2.0.0","tagName":"h2"},{"title":"Delegating CSPR to Validators","type":0,"sectionRef":"#","url":"/docs/2.0.0/advanced/delegating-cspr","content":"","keywords":"","version":"2.0.0"},{"title":"Sample implementation​","type":1,"pageTitle":"Delegating CSPR to Validators","url":"/docs/2.0.0/advanced/delegating-cspr#sample-implementation","content":"The following code shows how to implement a simple contract that allows delegating CSPR tokens to a validator. examples/src/features/validators.rs use odra::{ casper_types::{PublicKey, U512}, prelude::* }; #[odra::module] pub struct ValidatorsContract { /// In this variable we store the validator's public key, this is the only way we can identify the validator validator: Var&lt;PublicKey&gt; } /// Implementation of the TestingContract #[odra::module] impl ValidatorsContract { /// Initializes the contract with the validator's public key pub fn init(&amp;mut self, validator: PublicKey) { self.validator.set(validator); } /// Stake the amount of tokens #[odra(payable)] pub fn stake(&amp;mut self) { // Get the amount of tokens attached to the call let amount = self.env().attached_value(); if amount.is_zero() { self.env().revert(ValError::InsufficientBalance); } // Use the ContractEnv's delegate method to delegate the tokens to the validator self.env().delegate(self.validator.get().unwrap(), amount); } /// Undelegate the amount from the validator pub fn unstake(&amp;mut self, amount: U512) { self.env().undelegate(self.validator.get().unwrap(), amount); } /// Withdraw the amount from the validator pub fn withdraw(&amp;mut self, amount: U512) { self.env().transfer_tokens(&amp;self.env().caller(), &amp;amount); } ... }  ","version":"2.0.0","tagName":"h2"},{"title":"Explanation​","type":1,"pageTitle":"Delegating CSPR to Validators","url":"/docs/2.0.0/advanced/delegating-cspr#explanation","content":"The above example can be a good starting point for implementing a liquid staking solution. The main things to remember are the new api methods in ContractEnv: pub fn delegate(&amp;self, validator: PublicKey, amount: U512); pub fn undelegate(&amp;self, validator: PublicKey, amount: U512); pub fn delegated_amount(&amp;self, validator: PublicKey) -&gt; U512;  As you can see, we identify the validator by its public key. Funds delegated to the validator are assigned to the calling contract. Remember, that the delegation and undelegation takes some time, depending on the configuration of the blockchain - it's not instant. For example in the Casper mainnet, the delegation takes 1 era and the undelegation takes 7 eras. ","version":"2.0.0","tagName":"h2"},{"title":"Testing​","type":1,"pageTitle":"Delegating CSPR to Validators","url":"/docs/2.0.0/advanced/delegating-cspr#testing","content":"It is possible to test the delegation and undelegation of tokens in the contract. The following code shows how to do it: examples/src/features/validators.rs ... let test_env = odra_test::env(); let auction_delay = test_env.auction_delay(); let unbonding_delay = test_env.unbonding_delay(); test_env.set_caller(test_env.get_account(0)); let mut staking = ValidatorsContract::deploy( &amp;test_env, ValidatorsContractInitArgs { validator: test_env.get_validator(0) } ); let initial_account_balance = test_env.balance_of(&amp;test_env.get_account(0)); // Stake some amount let staking_amount = U512::from(1_000_000_000_000u64); staking.with_tokens(staking_amount).stake(); assert_eq!(staking.currently_delegated_amount(), staking_amount); assert_eq!( test_env.balance_of(&amp;test_env.get_account(0)), initial_account_balance - staking_amount ); // Advance time, run auctions and give off rewards test_env.advance_with_auctions(auction_delay * 2); // Check that the amount is greater than the staking amount let staking_with_reward = staking.currently_delegated_amount(); assert!(staking_with_reward &gt; staking_amount); ...  You can see, that we use the new methods from HostEnv, namely:  fn advance_with_auctions(&amp;self, time_diff: u64); fn auction_delay(&amp;self) -&gt; u64; fn unbonding_delay(&amp;self) -&gt; u64; fn delegated_amount(&amp;self, delegator: Address, validator: PublicKey) -&gt; U512;  advance_with_auctions works in a similar way to advance_block_time, but it also runs the auctions and gives off rewards. The auction_delay and unbonding_delay methods return the values of the auction and unbonding delays specific to the network or backend. We used currently_delegated_amount in the example, it uses delegated_amount method from ContractEnv, but it is also possible to query this information from the HostEnv using delegated_amount method. ","version":"2.0.0","tagName":"h2"},{"title":"OdraVM","type":0,"sectionRef":"#","url":"/docs/2.0.0/backends/odra-vm","content":"","keywords":"","version":"2.0.0"},{"title":"Usage​","type":1,"pageTitle":"OdraVM","url":"/docs/2.0.0/backends/odra-vm#usage","content":"The OdraVM is the default backend for Odra framework, so each time you run cargo odra test  You are running your code against it. ","version":"2.0.0","tagName":"h2"},{"title":"Architecture​","type":1,"pageTitle":"OdraVM","url":"/docs/2.0.0/backends/odra-vm#architecture","content":"OdraVM consists of two main parts: the Contract Register and the State. The Contract Register is a list of contracts deployed onto the OdraVM, identified by an Address. Contracts and Test Env functions can modify the State of the OdraVM. Contrary to the &quot;real&quot; backend, which holds the whole history of the blockchain, the OdraVM State holds only the current state of the OdraVM. Thanks to this and the fact that we do not need the blockchain itself, OdraVM starts instantly and runs the tests in the native speed. ","version":"2.0.0","tagName":"h2"},{"title":"Execution​","type":1,"pageTitle":"OdraVM","url":"/docs/2.0.0/backends/odra-vm#execution","content":"When the OdraVM backend is enabled, the #[odra::module] attribute is responsible for converting your pub functions into a list of Entrypoints, which are put into a Contract Container. When the contract is deployed, its Container registered into a Registry under an address. During the contract call, OdraVM finds an Entrypoint and executes the code. ","version":"2.0.0","tagName":"h2"},{"title":"Casper","type":0,"sectionRef":"#","url":"/docs/2.0.0/backends/casper","content":"","keywords":"","version":"2.0.0"},{"title":"Contract Env​","type":1,"pageTitle":"Casper","url":"/docs/2.0.0/backends/casper#contract-env","content":"As with any other backend, Casper Backend must implement the same features, but some do not have native support. Let's take a closer look at how Odra overcomes these hindrances. ","version":"2.0.0","tagName":"h2"},{"title":"Events​","type":1,"pageTitle":"Casper","url":"/docs/2.0.0/backends/casper#events","content":"An event is not a first-class citizen in Casper like in Ethereum, so Odra mimics it. As you've already learned from the events article, in Odra you emit an event, similarly, you would do it in Solidity. Under the hood, Odra integrates with Casper Event Standard and creates a few URefs in the global state when a contract is being installed: __events - a dictionary that stores events' data.__events_length - the evens count.__events_ces_version - the version of Casper Event Standard. __events_schema - a dictionary that stores event schemas. Besides that, all the events the contract emits are registered - events schemas are written to the storage under the __events_schema key. So, Events are nothing different from any other data stored by a contract. A struct to be an event must implement traits defined by Casper Event Standard, thankfully you can derive them using #[odra::event]. note Don't forget to expose events in the module using #[odra::module(events = [...])]. ","version":"2.0.0","tagName":"h3"},{"title":"Payable​","type":1,"pageTitle":"Casper","url":"/docs/2.0.0/backends/casper#payable","content":"The first Odra idiom is a Contract Main Purse. It is a purse associated with a contract. The purse is created lazily - when the first transfer to the contract occurs, a proper URef and a purse are created and stored under the __contract_main_purse key. Casper does not allow direct transfers from an account to a contract, so Odra comes up with the second idiom - a Cargo Purse. It is a one-time-use purse proxy between an account and a contract. First, motes go from the account to the cargo purse and then to the contract's main purse. Behind the scenes, Odra handles an account-contract transfer via a cargo purse when a function is marked as payable. If under the way something goes wrong with the transfer, the contract reverts. The transferred amount can be read inside the contract by calling self.env().attached_value(). note Odra expects the cargo_purse runtime argument to be attached to a contract call. In case of its absence, the contract_env::attached_value() returns zero. ","version":"2.0.0","tagName":"h3"},{"title":"Revert​","type":1,"pageTitle":"Casper","url":"/docs/2.0.0/backends/casper#revert","content":"In Casper, we can stop the execution pretty straightforwardly - call the runtime::revert(). Odra adds an extra abstraction layer - in a contract ExecutionErrors are defined, which ultimately are transformed into Casper's ApiError::User. ","version":"2.0.0","tagName":"h3"},{"title":"Context​","type":1,"pageTitle":"Casper","url":"/docs/2.0.0/backends/casper#context","content":"Casper equips developers with very low-level tooling, which can be cumbersome for newcomers. If you want to check who called the contract or its address, you can not do it off-hand - you must analyze the call stack. The self.env().self_address() function takes the first element of the callstack (runtime::get_call_stack()) and casts it to Address. The self.env().caller() function takes the second element of the call stack (runtime::get_call_stack()) and casts it to Address. As mentioned in the [Payable] section, to store CSPR, each contract creates its purse. To read the contract balance, you call self.env().self_balance(), which checks the balance of the purse stored under __contract_main_purse. ","version":"2.0.0","tagName":"h3"},{"title":"Test Env​","type":1,"pageTitle":"Casper","url":"/docs/2.0.0/backends/casper#test-env","content":"Test environment allows you to test wasm contracts before you deploy them onto the testnet or livenet. It is built on top of the Casper Execution Engine. In your test, you can freely switch execution context by setting as a caller (test_env::set_caller()) one of the 20 predefined accounts. Each account possesses the default amount of Motes (100_000_000_000_000_000). The Test Env internally keeps track of the current block time, error and attached value. Each test is executed on a fresh instance of the Test Env. ","version":"2.0.0","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"Casper","url":"/docs/2.0.0/backends/casper#usage","content":"Name of the Casper backend in Odra is casper, so to run the tests against it, simply pass it as a -bparameter: cargo odra test -b casper  If you want to just generate a wasm file, simply run: cargo odra build -b casper  ","version":"2.0.0","tagName":"h2"},{"title":"Deploying a contract to Casper network​","type":1,"pageTitle":"Casper","url":"/docs/2.0.0/backends/casper#deploying-a-contract-to-casper-network","content":"There would be no point in writing a contract if you couldn't deploy it to the blockchain. You can do it in two ways: provided by the Casper itself: using the casper-client tool or using the Odra's Livenet integration. Let's explore the first option to better understand the process. note If you wish, you can skip the following section and jump to the Livenet integration. ","version":"2.0.0","tagName":"h2"},{"title":"WASM arguments​","type":1,"pageTitle":"Casper","url":"/docs/2.0.0/backends/casper#wasm-arguments","content":"When deploying a new contract you can pass some arguments to it. Every contract written in Odra expects those arguments to be set: odra_cfg_package_hash_key_name - String type. The key under which the package hash of the contract will be stored.odra_cfg_allow_key_override - Bool type. If true and the key specified in odra_cfg_package_hash_key_name already exists, it will be overwritten.odra_cfg_is_upgradable - Bool type. If true, the contract will be deployed as upgradable. Additionally, if required by the contract, you can pass constructor arguments. When working with the test env via cargo odra or when usingLivenet integration this is handled automatically. However, if you rather usecasper-client directly, you have to pass them manually: ","version":"2.0.0","tagName":"h3"},{"title":"Example: Deploy Counter​","type":1,"pageTitle":"Casper","url":"/docs/2.0.0/backends/casper#example-deploy-counter","content":"To deploy your contract with a constructor using casper-client, you need to pass the above arguments. Additionally, you need to pass the value argument, which sets the arbitrary initial value for the counter. casper-client put-deploy \\ --node-address [NODE_ADDRESS] \\ --chain-name casper-test \\ --secret-key [PATH_TO_YOUR_KEY]/secret_key.pem \\ --payment-amount 5000000000000 \\ --session-path ./wasm/counter.wasm \\ --session-arg &quot;odra_cfg_package_hash_key_name:string:'counter_package_hash'&quot; \\ --session-arg &quot;odra_cfg_allow_key_override:bool:'true'&quot; \\ --session-arg &quot;odra_cfg_is_upgradable:bool:'true'&quot; \\ --session-arg &quot;value:u32:42&quot;  For a more in-depth tutorial, please refer to the Casper's 'Writing On-Chain Code'. ","version":"2.0.0","tagName":"h3"},{"title":"Example: Deploy ERC721​","type":1,"pageTitle":"Casper","url":"/docs/2.0.0/backends/casper#example-deploy-erc721","content":"Odra comes with a standard ERC721 token implementation. Clone the main Odra repo and navigate to the modules directory. Firstly contract needs to be compiled. cargo odra build -b casper -c erc721_token  It produces the erc721_token.wasm file in the wasm directory. Now it's time to deploy the contract. casper-client put-deploy \\ --node-address [NODE_ADDRESS] \\ --chain-name casper-test \\ --secret-key [PATH_TO_YOUR_KEY]/secret_key.pem \\ --payment-amount 300000000000 \\ --session-path ./wasm/erc721_token.wasm \\ --session-arg &quot;odra_cfg_package_hash_key_name:string:'my_nft'&quot; \\ --session-arg &quot;odra_cfg_allow_key_override:bool:'false'&quot; \\ --session-arg &quot;odra_cfg_is_upgradable:bool:'true'&quot; \\ --session-arg &quot;name:string:'MyNFT'&quot; \\ --session-arg &quot;symbol:string:'NFT'&quot; \\ --session-arg &quot;base_uri:string:'https://example.com/'&quot;  It's done. The contract is deployed and ready to use. Your account is the owner of the contract and you can mint and burn tokens. For more details see the code of the ERC721 module. To obtain the package hash of the contract search for my_nft key in your account's named keys. ","version":"2.0.0","tagName":"h3"},{"title":"Example: Deploy ERC1155​","type":1,"pageTitle":"Casper","url":"/docs/2.0.0/backends/casper#example-deploy-erc1155","content":"The process is similar to the one described in the previous section. Contract compilation: cargo odra build -b casper -c erc1155_token  Contract deployment: casper-client put-deploy \\ --node-address [NODE_ADDRESS] \\ --chain-name casper-test \\ --secret-key [PATH_TO_YOUR_KEY]/secret_key.pem \\ --payment-amount 300000000000 \\ --session-path ./wasm/erc1155_token.wasm \\ --session-arg &quot;odra_cfg_package_hash_key_name:string:'my_tokens'&quot; \\ --session-arg &quot;odra_cfg_allow_key_override:bool:'false'&quot; \\ --session-arg &quot;odra_cfg_is_upgradable:bool:'true'&quot; \\ --session-arg &quot;odra_cfg_constructor:string:'init'&quot; \\  As previously, your account is the owner and can mint and burn tokens. For more details see the code of the ERC1155 module. ","version":"2.0.0","tagName":"h3"},{"title":"Sending CSPR to a contract​","type":1,"pageTitle":"Casper","url":"/docs/2.0.0/backends/casper#sending-cspr-to-a-contract","content":"Defining payable entry points is described in Native Token section. What is happening under the hood is that Odra creates a new cargo_purse argument for each payable entry point. The cargo_purse needs to be top-upped with CSPR before calling the contract. When a contract adds CSPR to another contract call, Odra handles it for you. The problem arises when you want to call an entry point and attach CSPR as an account. The only way of doing that is by executing code in the sessions context, that top-ups the cargo_purse and then calls the contract. Odra provides a generic proxy_caller.wasm that does exactly that. You can build it by yourself from the main Odra repository, or use the proxy_caller.wasmwe maintain. ","version":"2.0.0","tagName":"h2"},{"title":"Using proxy_caller.wasm​","type":1,"pageTitle":"Casper","url":"/docs/2.0.0/backends/casper#using-proxy_callerwasm","content":"To use the proxy_caller.wasm you need to attach the following arguments: contract_package_hash - BytesArray(32) type. The package hash of the contract you want to call. Result of to_bytes on CasperPackageHash.entry_point - String type. The name of the entry point you want to call.args - Bytes type. It is a serialized RuntimeArgs with the arguments you want to pass to the entry point. To be specific it is the result of to_bytes method wrapped with Bytes type.attached_value. U512 type. The amount of CSPR you want to attach to the call.amount. U512 type. Should be the same value as attached_value if not None. It is a special Casper argument that enables the access to account's main purse. Currently casper-client doesn't allow building such arguments. You have to build it using your SDK. See an example in the Tutorial section. ","version":"2.0.0","tagName":"h3"},{"title":"Execution​","type":1,"pageTitle":"Casper","url":"/docs/2.0.0/backends/casper#execution","content":"First thing Odra does with your code, is similar to the one used in OdraVM - a list of entrypoints is generated, thanks to the #[odra::module] attribute. ","version":"2.0.0","tagName":"h2"},{"title":"Delegate","type":0,"sectionRef":"#","url":"/docs/2.0.0/advanced/delegate","content":"","keywords":"","version":"2.0.0"},{"title":"Overview​","type":1,"pageTitle":"Delegate","url":"/docs/2.0.0/advanced/delegate#overview","content":"To utilize the delegate feature in your contract, use the delegate! macro provided by Odra. This macro allows you to list the functions you wish to delegate to the child modules. By using the delegate! macro, your parent module remains clean and easy to understand. You can delegate functions to as many child modules as you like. The functions will be available as if they were implemented in the parent module itself. ","version":"2.0.0","tagName":"h2"},{"title":"Code Examples​","type":1,"pageTitle":"Delegate","url":"/docs/2.0.0/advanced/delegate#code-examples","content":"Consider the following basic example for better understanding: use crate::{erc20::Erc20, ownable::Ownable}; use odra::{casper_types::U256, prelude::*}; #[odra::module] pub struct OwnedToken { ownable: SubModule&lt;Ownable&gt;, erc20: SubModule&lt;Erc20&gt; } #[odra::module] impl OwnedToken { pub fn init(&amp;mut self, name: String, symbol: String, decimals: u8, initial_supply: U256) { let deployer = self.env().caller(); self.ownable.init(deployer); self.erc20.init(name, symbol, decimals, initial_supply); } delegate! { to self.erc20 { fn transfer(&amp;mut self, recipient: Address, amount: U256); fn transfer_from(&amp;mut self, owner: Address, recipient: Address, amount: U256); fn approve(&amp;mut self, spender: Address, amount: U256); fn name(&amp;self) -&gt; String; fn symbol(&amp;self) -&gt; String; fn decimals(&amp;self) -&gt; u8; fn total_supply(&amp;self) -&gt; U256; fn balance_of(&amp;self, owner: Address) -&gt; U256; fn allowance(&amp;self, owner: Address, spender: Address) -&gt; U256; } to self.ownable { fn get_owner(&amp;self) -&gt; Address; fn change_ownership(&amp;mut self, new_owner: Address); } } pub fn mint(&amp;mut self, address: Address, amount: U256) { self.ownable.ensure_ownership(self.env().caller()); self.erc20.mint(address, amount); } }  This OwnedToken contract includes two modules: Erc20 and Ownable. We delegate various functions from both modules using the delegate! macro. As a result, the contract retains its succinctness without compromising on functionality. The above example basically merges the functionalities of modules and adds some control over the minting process. But you can use delegation to build more complex contracts, cherry-picking just a few module functionalities. Let's take a look at another example. use crate::{erc20::Erc20, ownable::Ownable, exchange::Exchange}; use odra::{casper_types::U256, prelude::*}; #[odra::module] pub struct DeFiPlatform { ownable: SubModule&lt;Ownable&gt;, erc20: SubModule&lt;Erc20&gt;, exchange: SubModule&lt;Exchange&gt; } #[odra::module] impl DeFiPlatform { pub fn init(&amp;mut self, name: String, symbol: String, decimals: u8, initial_supply: U256, exchange_rate: u64) { let deployer = self.env().caller(); self.ownable.init(deployer); self.erc20.init(name, symbol, decimals, initial_supply); self.exchange.init(exchange_rate); } delegate! { to self.erc20 { fn transfer(&amp;mut self, recipient: Address, amount: U256); fn balance_of(&amp;self, owner: Address) -&gt; U256; } to self.ownable { fn get_owner(&amp;self) -&gt; Address; } to self.exchange { fn swap(&amp;mut self, sender: Address, recipient: Address); fn set_exchange_rate(&amp;mut self, new_rate: u64); } } pub fn mint(&amp;mut self, address: Address, amount: U256) { self.ownable.ensure_ownership(self.env().caller()); self.erc20.mint(address, amount); } }  In this DeFiPlatform contract, we include Erc20, Ownable, and Exchange modules. By delegating functions from these modules, the parent contract becomes a powerhouse of functionality while retaining its readability and structure. Remember, the possibilities are endless with Odra's. By leveraging this feature, you can write cleaner, more efficient, and modular smart contracts. ","version":"2.0.0","tagName":"h2"},{"title":"What is a backend?","type":0,"sectionRef":"#","url":"/docs/2.0.0/backends/what-is-a-backend","content":"","keywords":"","version":"2.0.0"},{"title":"Contract Env​","type":1,"pageTitle":"What is a backend?","url":"/docs/2.0.0/backends/what-is-a-backend#contract-env","content":"The Contract Env is a simple interface that each backend needs to implement, exposing features of the blockchain from the perspective of the contract. It gives Odra a set of functions, which allows implementing more complex concepts - for example, to implement Mapping, Odra requires some kind of storage integration. The exact implementation of those functions is a responsibility of a backend, making Odra and its user free to implement the contract logic, instead of messing with the blockchain internals. Other functions from Contract Env include handling transfers, addresses, block time, errors and events. ","version":"2.0.0","tagName":"h2"},{"title":"Host Env​","type":1,"pageTitle":"What is a backend?","url":"/docs/2.0.0/backends/what-is-a-backend#host-env","content":"Similarly to the Contract Env, the Host Env exposes a set of functions that allows the communication with the backend from the outside world - really useful for implementing tests. This ranges from interacting with the blockchain - like deploying new, loading existing and calling the contracts, to the more test-oriented - handling errors, forwarding the block time, etc. ","version":"2.0.0","tagName":"h2"},{"title":"What's next​","type":1,"pageTitle":"What is a backend?","url":"/docs/2.0.0/backends/what-is-a-backend#whats-next","content":"We will take a look at backends Odra implements in more detail. ","version":"2.0.0","tagName":"h2"},{"title":"Livenet","type":0,"sectionRef":"#","url":"/docs/2.0.0/backends/livenet","content":"","keywords":"","version":"2.0.0"},{"title":"Setup​","type":1,"pageTitle":"Livenet","url":"/docs/2.0.0/backends/livenet#setup","content":"To use Livenet backend, we need to provide Odra with some information - the network address, our private key and the name of the chain we want to use. Optionally, we can add multiple private keys to use more than one account in our tests. Those values are passed using environment variables. We can use .env file to store them - let's take a look at an example .env file, created from the .env.sample file from the examples folder: # Path to the secret key of the account that will be used # to deploy the contracts. # We're using .keys folder so we don't accidentally commit # the secret key to the repository. ODRA_CASPER_LIVENET_SECRET_KEY_PATH=.keys/secret_key.pem # RPC address of the node that will be used to deploy the contracts. ODRA_CASPER_LIVENET_NODE_ADDRESS=localhost:7777 # Chain name of the network. Known values: # - integration-test ODRA_CASPER_LIVENET_CHAIN_NAME=integration-test # Paths to the secret keys of the additional accounts. # Main secret key will be 0th account. ODRA_CASPER_LIVENET_KEY_1=.keys/secret_key_1.pem ODRA_CASPER_LIVENET_KEY_2=.keys/secret_key_2.pem # If using CSPR.cloud, you can set the auth token here. # CSPR_CLOUD_AUTH_TOKEN=  note CSPR.cloud is a service that provides mainnet and testnet Casper nodes on demand. With the proper value in place, we can write our tests or deploy scenarios. In the examples, we can find a simple binary that deploys a contract and calls it. The test is located in the erc20_on_livenet.rs file. Let's go through the code: fn main() { // Similar to the OdraVM backend, we need to initialize // the environment: let env = odra_casper_livenet_env::env(); // Most of the host env works the same as in the // OdraVM backend. let owner = env.caller(); // Addresses are the real addresses on the blockchain, // so we need to provide them // if we did not import their secret keys. let recipient = &quot;hash-2c4a6ce0da5d175e9638ec0830e01dd6cf5f4b1fbb0724f7d2d9de12b1e0f840&quot;; let recipient = Address::from_str(recipient).unwrap(); // Arguments for the contract init method. let name = String::from(&quot;Plascoin&quot;); let symbol = String::from(&quot;PLS&quot;); let decimals = 10u8; let initial_supply: U256 = U256::from(10_000); // The main difference between other backends - we need to specify // the gas limit for each action. // The limit will be used for every consecutive action // until we change it. env.set_gas(100_000_000_000u64); // Deploy the contract. The API is the same as in the OdraVM backend. let init_args = Erc20InitArgs { name, symbol, decimals, initial_supply: Some(initial_supply) }; let mut token = Erc20::deploy(env, init_args); // We can now use the contract as we would in the OdraVM backend. println!(&quot;Token address: {}&quot;, token.address().to_string()); // Uncomment to load existing contract. // let address = &quot;hash-d26fcbd2106e37be975d2045c580334a6d7b9d0a241c2358a4db970dfd516945&quot;; // let address = Address::from_str(address).unwrap(); // We use the Livenet-specific `load` method to load the contract // that is already deployed. // let mut token = Erc20Deployer::load(env, address); // Non-mutable calls are free! Neat, huh? More on that later. println!(&quot;Token name: {}&quot;, token.name()); // The next call is mutable, but the cost is lower than the deployment, // so we change the amount of gas env.set_gas(3_000_000_000u64); token.transfer(recipient, U256::from(1000)); println!(&quot;Owner's balance: {:?}&quot;, token.balance_of(owner)); println!(&quot;Recipient's balance: {:?}&quot;, token.balance_of(recipient)); }  note The above example is a rust binary, not a test. Note that it is also added as a section of theCargo.toml file: [bin] name = &quot;erc20_on_livenet&quot; path = &quot;src/bin/erc20_on_livenet.rs&quot; required-features = [&quot;livenet&quot;] test = false  ","version":"2.0.0","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"Livenet","url":"/docs/2.0.0/backends/livenet#usage","content":"To run the above code, we simply need to run the binary with the livenet feature enabled: cargo run --bin erc20_on_livenet --features=livenet  note Before executing the binary, make sure you built a wasm file. A part of a sample output should look like this: ... 💁 INFO : Calling &quot;hash-d26fcbd210...&quot; with entrypoint &quot;transfer&quot;. 🙄 WAIT : Waiting 15s for &quot;65b1a5d21...&quot;. 🙄 WAIT : Waiting 15s for &quot;65b1a5d21...&quot;. 💁 INFO : Deploy &quot;65b1a5d21...&quot; successfully executed. Owner's balance: 4004 Recipient's balance: 4000  Those logs are a result of the last 4 lines of the above listing. Each deployment or a call to the blockchain will be noted and will take some time to execute. We can see that the transfer call took over 15 seconds to execute. But calling balance_of was nearly instant and cost us nothing. How it is possible? info You can see the deployment on http://cspr.live/ - the transfer from the example can be seen here. ","version":"2.0.0","tagName":"h2"},{"title":"How Livenet backend works​","type":1,"pageTitle":"Livenet","url":"/docs/2.0.0/backends/livenet#how-livenet-backend-works","content":"All calls of entrypoints executed on a Casper blockchain cost gas - even if they do not change the state. It is possible, however, to query the state of the blockchain for free. This principle is used in the Livenet backend - all calls that do not change the state of the blockchain are really executed offline - the only thing that is requested from the node is the current state. This is why the balance_of call was almost instant and free. Basically, if the entrypoint function is not mutable or does not make a call to an unknown external contract (see Cross Calls), it is executed offline and node is used for the state query only. However, the Livenet needs to know the connection between the contracts and the code, so make sure to deploy or load already deployed contracts ","version":"2.0.0","tagName":"h2"},{"title":"Multiple environments​","type":1,"pageTitle":"Livenet","url":"/docs/2.0.0/backends/livenet#multiple-environments","content":"It is possible to have multiple environments for the Livenet backend. This is useful if we want to easily switch between multiple accounts, multiple nodes or even multiple chains. To do this, simply create a new .env file with a different prefix - for example, integration.env and mainnet.env. Then, pass the ODRA_CASPER_LIVENET_ENV variable with value either integration or mainnet to select which file has to be used first. If your integration.env file has a value that IS present in the .env file, it will override the value from the .env file. ODRA_CASPER_LIVENET_ENV=integration cargo run --bin erc20_on_livenet --features=livenet  To sum up - this command will firstly load the integration.env file and then load the missing values from .env file. ","version":"2.0.0","tagName":"h2"},{"title":"Host Communication","type":0,"sectionRef":"#","url":"/docs/2.0.0/basics/communicating-with-host","content":"","keywords":"","version":"2.0.0"},{"title":"What's next​","type":1,"pageTitle":"Host Communication","url":"/docs/2.0.0/basics/communicating-with-host#whats-next","content":"In the next article, we'll dive into testing your contracts with Odra, so you can check that the code we presented in fact works! ","version":"2.0.0","tagName":"h2"},{"title":"Cargo Odra","type":0,"sectionRef":"#","url":"/docs/2.0.0/basics/cargo-odra","content":"","keywords":"","version":"2.0.0"},{"title":"Managing projects​","type":1,"pageTitle":"Cargo Odra","url":"/docs/2.0.0/basics/cargo-odra#managing-projects","content":"Two commands help you create a new project. The first one is cargo odra new. You need to pass one parameter, namely --name {PROJECT_NAME}: cargo odra new --name my-project  This creates a new project in the my_project folder and name it my_project. You can see it for yourself, for example by taking a look into a Cargo.toml file created in your project's folder: [package] name = &quot;my_project&quot; version = &quot;0.1.0&quot; edition = &quot;2021&quot;  The project is created using the template located in Odra's main repository. By default it uses full template, if you want, you can use minimalistic blank by running: cargo odra new -t blank --name my-project  The third available template is workspace, which creates a workspace with two projects, similar to the one created with the full template. There are also two templates which create a project with a sample tokens native to Casper Network: cep18 and cep78. By default, the latest release of Odra will be used for the template and as a dependency. You can pass a source of Odra you want to use, by using -s parameter: cargo odra new -n my-project -s ../odra # will use local folder of odra cargo odra new -n my-project -s release/0.9.0 # will use github branch, e.g. if you want to test new release cargo odra new -n my-project -s 1.1.0 # will use a version released on crates.io  The second way of creating a project is by using init command: cargo odra init --name my-project  It works in the same way as new, but instead of creating a new folder, it creates a project in the current, empty directory. ","version":"2.0.0","tagName":"h2"},{"title":"Generating code​","type":1,"pageTitle":"Cargo Odra","url":"/docs/2.0.0/basics/cargo-odra#generating-code","content":"If you want to quickly create a new contract code, you can use the generate command: cargo odra generate -c counter  This creates a new file src/counter.rs with sample code, add appropriate use and mod sections to src/lib.rs and update the Odra.toml file accordingly. To learn more about Odra.toml file, visit Odra.toml. ","version":"2.0.0","tagName":"h2"},{"title":"Testing​","type":1,"pageTitle":"Cargo Odra","url":"/docs/2.0.0/basics/cargo-odra#testing","content":"The most used command during the development of your project should be this one: cargo odra test  It runs your tests against Odra's MockVM. It is substantially faster than CasperVMand implements all the features Odra uses. When you want to run tests against a &quot;real&quot; VM, just provide the name of the backend using -boption: cargo odra test -b casper  In the example above, Cargo Odra builds the project, generates the wasm files, spin up CasperVM instance, deploys the contracts onto it and runs the tests against it. Pretty neat. Keep in mind that this is a lot slower than OdraVM and you cannot use the debugger. This is why OdraVM was created and should be your first choice when developing contracts. Of course, testing all of your code against a blockchain VM is a must in the end. If you want to run only some of the tests, you can pass arguments to the cargo test command (which is run in the background obviously): cargo odra test -- this-will-be-passed-to-cargo-test  If you want to run tests which names contain the word two, you can execute: cargo odra test -- two  Of course, you can do the same when using the backend: cargo odra test -b casper -- two  ","version":"2.0.0","tagName":"h2"},{"title":"Building code​","type":1,"pageTitle":"Cargo Odra","url":"/docs/2.0.0/basics/cargo-odra#building-code","content":"You can also build the code itself and generate the output contracts without running the tests. To do so, simply run: cargo odra build  If the build process finishes successfully, wasm files will be located in wasm folder. Notice, that this command does not require the -b option. If you want to build specific contract, you can use -c option: cargo odra build -c counter # you pass many comma separated contracts  ","version":"2.0.0","tagName":"h2"},{"title":"Skipping building​","type":1,"pageTitle":"Cargo Odra","url":"/docs/2.0.0/basics/cargo-odra#skipping-building","content":"As building wasm files can take a long time, especially if you have a lot of contracts. If you did not change anything in your contracts and you just want to rerun the tests for the casper backend, use the -s option: cargo odra test -b casper -s  ","version":"2.0.0","tagName":"h2"},{"title":"Generating contract schema​","type":1,"pageTitle":"Cargo Odra","url":"/docs/2.0.0/basics/cargo-odra#generating-contract-schema","content":"If you want to generate a schema (including the name, entrypoints, events, etc.) for your contract, you can use the schema command: cargo odra schema  This generates a schema file in JSON format for all your contracts and places them in the resources folder. If the resources folder does not exist, it creates the folder for you. Like with the build command, you can use the -c option to generate a schema for a specific contract. ","version":"2.0.0","tagName":"h2"},{"title":"What's next​","type":1,"pageTitle":"Cargo Odra","url":"/docs/2.0.0/basics/cargo-odra#whats-next","content":"In the next section, we will take a look at all the files and directories that cargo odra created for us and explain their purpose. ","version":"2.0.0","tagName":"h2"},{"title":"Directory structure","type":0,"sectionRef":"#","url":"/docs/2.0.0/basics/directory-structure","content":"","keywords":"","version":"2.0.0"},{"title":"Cargo.toml​","type":1,"pageTitle":"Directory structure","url":"/docs/2.0.0/basics/directory-structure#cargotoml","content":"Let's first take a look at Cargo.toml file: [package] name = &quot;sample&quot; version = &quot;0.1.0&quot; edition = &quot;2021&quot; [dependencies] odra = &quot;2.0.0&quot; [dev-dependencies] odra-test = &quot;2.0.0&quot; [build-dependencies] odra-build = &quot;2.0.0&quot; [[bin]] name = &quot;sample_build_contract&quot; path = &quot;bin/build_contract.rs&quot; test = false [[bin]] name = &quot;sample_build_schema&quot; path = &quot;bin/build_schema.rs&quot; test = false [profile.release] codegen-units = 1 lto = true [profile.dev.package.&quot;*&quot;] opt-level = 3  By default, your project will use the latest odra version available at crates.io. For testing purposes, odra-test is also added as a dev dependency. ","version":"2.0.0","tagName":"h2"},{"title":"Odra.toml​","type":1,"pageTitle":"Directory structure","url":"/docs/2.0.0/basics/directory-structure#odratoml","content":"This is the file that holds information about contracts that will be generated when running cargo odra build andcargo odra test: [[contracts]] fqn = &quot;sample::Flipper&quot;  As we can see, we have a single contract, its fqn (Fully Qualified Name) corresponds to the contract is located in src/flipper.rs. More contracts can be added here by hand, or by using cargo odra generate command. ","version":"2.0.0","tagName":"h2"},{"title":"src/​","type":1,"pageTitle":"Directory structure","url":"/docs/2.0.0/basics/directory-structure#src","content":"This is the folder where your smart contract files live. ","version":"2.0.0","tagName":"h2"},{"title":"bin/​","type":1,"pageTitle":"Directory structure","url":"/docs/2.0.0/basics/directory-structure#bin","content":"This is the folder where scripts that will be used to generate code or schemas live. You don't need to modify those files, they are generated by cargo odra new command and are used by cargo odra build, cargo odra test and cargo odra schema commands. ","version":"2.0.0","tagName":"h2"},{"title":"target/​","type":1,"pageTitle":"Directory structure","url":"/docs/2.0.0/basics/directory-structure#target","content":"Files generated by cargo during the build process are put here. ","version":"2.0.0","tagName":"h2"},{"title":"wasm/​","type":1,"pageTitle":"Directory structure","url":"/docs/2.0.0/basics/directory-structure#wasm","content":"WASM files generated by cargo odra build and cargo odra test are put here. You can grab those WASM files and deploy them on the blockchain. What's next Now, let's take a look at one of the files mentioned above in more detail, namely the Odra.toml file. ","version":"2.0.0","tagName":"h2"},{"title":"Cross calls","type":0,"sectionRef":"#","url":"/docs/2.0.0/basics/cross-calls","content":"","keywords":"","version":"2.0.0"},{"title":"Contract Ref​","type":1,"pageTitle":"Cross calls","url":"/docs/2.0.0/basics/cross-calls#contract-ref","content":"We mentioned HostRef already in our Testing article - a host side reference to already deployed contract. In the module context we use a ContractRef instead, to call other contracts. Similarly to the HostRef trait implemetation for the module, the {{ModuleName}}ContractRef is generated automatically, by the #[odra::module] attribute. The reference implements all the public endpoints to the contract (those marked as pub in #[odra::module]impl), and the {{ModuleName}}ContractRef::address() function, which returns the address of the contract. External Contracts Sometimes in our contract, we would like to interact with a someone else's contract, already deployed onto the blockchain. The only thing we know about the contract is the ABI. For that purpose, we use #[odra:external_contract] attribute. This attribute should be applied to a trait. The trait defines the part of the ABI we would like to take advantage of. Let's pretend the MathEngine we defined is an external contract. There is a contract with add() function that adds two numbers somewhere. #[odra::external_contract] pub trait Adder { fn add(&amp;self, n1: u32, n2: u32) -&gt; u32; }  Odra automatically creates the AdderContractRef struct. Having an address, in the module context we can call: struct Contract { adder: External&lt;AdderContractRef&gt; } // in some function self.adder.add(3, 5) // or struct Contract { adder: Var&lt;Address&gt; } // in some function AdderContractRef::new(self.env(), address).add(3, 5)  ","version":"2.0.0","tagName":"h2"},{"title":"Loading the contract​","type":1,"pageTitle":"Cross calls","url":"/docs/2.0.0/basics/cross-calls#loading-the-contract","content":"Sometimes it is useful to load the deployed contract instead of deploying it by ourselves. This is especially useful when we want to test our contracts in Livenet backend. We can load the contract using load method on the Deployer: examples/bin/erc20_on_livenet.rs fn _load_erc20(env: &amp;HostEnv) -&gt; Erc20HostRef { let address = &quot;hash-d26fcbd2106e37be975d2045c580334a6d7b9d0a241c2358a4db970dfd516945&quot;; let address = Address::from_str(address).unwrap(); Erc20::load(env, address) }  ","version":"2.0.0","tagName":"h3"},{"title":"Testing​","type":1,"pageTitle":"Cross calls","url":"/docs/2.0.0/basics/cross-calls#testing","content":"Let's see how we can test our cross calls using this knowledge: examples/src/features/cross_calls.rs #[cfg(test)] mod tests { use super::{CrossContract, CrossContractInitArgs, MathEngineHostRef}; use odra::host::{Deployer, HostRef, NoArgs}; #[test] fn test_cross_calls() { let test_env = odra_test::env(); let math_engine_contract = MathEngine::deploy(&amp;test_env, NoArgs); let cross_contract = CrossContract::deploy( &amp;test_env, CrossContractInitArgs { math_engine_address: *math_engine_contract.address() } ); assert_eq!(cross_contract.add_using_another(), 8); } }  Each test begins with a clean instance of the blockchain, with no contracts deployed. To test an external contract, we first deploy a MathEngine contract, although we won't directly utilize it. Instead, we only extract its address. Let's continue assuming there is a contract featuring the add() function that we intend to utilize. #[cfg(test)] mod tests { use super::*; use odra::{host::{Deployer, HostRef, NoArgs}}; #[test] fn test_ext() { let test_env = odra_test::env(); let adder = Adder::new(&amp;test_env, get_adder_address(&amp;test_env)).add(3, 5) assert_eq!(adder.add(1, 2), 3); } fn get_adder_address(test_env: &amp;HostEnv) -&gt; Address { let contract = MathEngine::deploy(test_env, NoArgs); *contract.address() } }  ","version":"2.0.0","tagName":"h2"},{"title":"Errors","type":0,"sectionRef":"#","url":"/docs/2.0.0/basics/errors","content":"","keywords":"","version":"2.0.0"},{"title":"Testing errors​","type":1,"pageTitle":"Errors","url":"/docs/2.0.0/basics/errors#testing-errors","content":"Okay, but how about testing it? Let's write a test that will check if the error is thrown when the caller is not an owner: examples/src/features/handling_errors.rs #[cfg(test)] mod tests { use super::{Error, OwnedContract, OwnedContractInitArgs}; use odra::{host::Deployer, prelude::*}; #[test] fn test_owner_error() { let test_env = odra_test::env(); let owner = test_env.get_account(0); let not_an_owner = test_env.get_account(1); test_env.set_caller(owner); let init_args = OwnedContractInitArgs { name: &quot;OwnedContract&quot;.to_string() }; let mut owned_contract = OwnedContract::deploy(&amp;test_env, init_args); test_env.set_caller(not_an_owner); assert_eq!( owned_contract.try_change_name(&quot;NewName&quot;.to_string()), Err(Error::NotAnOwner.into()) ); } }  Each deployed contract is of {{ModuleName}}HostRef type and has try_{{entry_point_name}} functions that return an OdraResult.OwnedContractHostRef implements regular entrypoints: name, owner, change_name, and and safe its safe version: try_name, try_owner, try_change_name. In our example, we are calling try_change_name and expecting an error to be thrown. For assertions, we are using a standard assert_eq! macro. As the contract call returns an OdraError, we need to convert our custom error to OdraError using Into::into(). ","version":"2.0.0","tagName":"h2"},{"title":"What's next​","type":1,"pageTitle":"Errors","url":"/docs/2.0.0/basics/errors#whats-next","content":"We will learn how to emit and test events using Odra. ","version":"2.0.0","tagName":"h2"},{"title":"Events","type":0,"sectionRef":"#","url":"/docs/2.0.0/basics/events","content":"","keywords":"","version":"2.0.0"},{"title":"Testing events​","type":1,"pageTitle":"Events","url":"/docs/2.0.0/basics/events#testing-events","content":"Odra's HostEnv comes with a few functions which lets you easily test the events that a given contract has emitted: examples/src/features/events.rs use super::{PartyContract, PartyStarted}; use odra::host::{Deployer, HostEnv, NoArgs}; #[test] fn test_party() { let test_env: HostEnv = odra_test::env(); let party_contract = PartyContract::deploy(&amp;test_env, NoArgs); assert!(test_env.emitted_event( &amp;party_contract, &amp;PartyStarted { caller: test_env.get_account(0), block_time: 0 } )); assert!(test_env.emitted_native_event( &amp;party_contract, &amp;NativePartyStarted { caller: test_env.get_account(0), block_time: 0 } )); // If you do not want to check the exact event, you can use `emitted` function assert!(test_env.emitted(&amp;party_contract, &quot;PartyStarted&quot;)); // Or `emitted_native` for the native events assert!(test_env.emitted_native(&amp;party_contract, &quot;NativePartyStarted&quot;)); // You can also check how many events were emitted: assert_eq!(test_env.events_count(&amp;party_contract), 1); assert_eq!(test_env.native_events_count(&amp;party_contract), 1); }  To explore more event testing functions, check the HostEnv documentation. ","version":"2.0.0","tagName":"h2"},{"title":"What's next​","type":1,"pageTitle":"Events","url":"/docs/2.0.0/basics/events#whats-next","content":"Read the next article to learn how to call other contracts from the contract context. ","version":"2.0.0","tagName":"h2"},{"title":"Flipper Internals","type":0,"sectionRef":"#","url":"/docs/2.0.0/basics/flipper-internals","content":"","keywords":"","version":"2.0.0"},{"title":"Header​","type":1,"pageTitle":"Flipper Internals","url":"/docs/2.0.0/basics/flipper-internals#header","content":"flipper.rs use odra::prelude::*;  The first line of the file imports the odra crate. The prelude module contains all the necessary types and traits that you will need to write your contract. It is a good practice to import theodra::prelude::* module in every file that contains Odra code. This way, you will not have to import each type or trait separately. ","version":"2.0.0","tagName":"h2"},{"title":"Struct​","type":1,"pageTitle":"Flipper Internals","url":"/docs/2.0.0/basics/flipper-internals#struct","content":"flipper.rs /// A module definition. Each module struct consists of Vars and Mappings /// or/and other modules. #[odra::module] pub struct Flipper { /// The module itself does not store the value, /// it's a proxy that writes/reads value to/from the host. value: Var&lt;bool&gt;, }  In Odra, all contracts are also modules, which can be reused between contracts. That's why we need to mark the struct with the #[odra::module] attribute. In the struct definition itself, we state all the fields of the contract. Those fields can be regular Rust data types, however - those will not be persisted on the blockchain. They can also be Odra modules - defined in your project or coming from Odra itself. Finally, to make the data persistent on the blockchain, you can use something likeVar&lt;T&gt; showed above. To learn more about storage interaction, take a look at thenext article. ","version":"2.0.0","tagName":"h2"},{"title":"Impl​","type":1,"pageTitle":"Flipper Internals","url":"/docs/2.0.0/basics/flipper-internals#impl","content":"flipper.rs /// Module implementation. /// /// To generate entrypoints, /// an implementation block must be marked as #[odra::module]. #[odra::module] impl Flipper { /// Odra constructor. /// /// Initializes the contract with the value of value. pub fn init(&amp;mut self) { self.value.set(false); } ...  Similarly to the struct, we mark the impl section with the #[odra::module] attribute. Odra will take allpub functions from this section and create contract endpoints from them. So, if you wish to have functions that are not available for calling outside the contract, do not make them public. Alternatively, you can create a separate impl section without the attribute - all functions defined there, even marked with pub will be not callable. The function named init is the constructor of the contract. This function will be limited only to a single call, all further calls to it will result in an error. The init function is optional, if your contract does not need any initialization, you can skip it. flipper.rs ... /// Replaces the current value with the passed argument. pub fn set(&amp;mut self, value: bool) { self.value.set(value); } /// Replaces the current value with the opposite value. pub fn flip(&amp;mut self) { self.value.set(!self.get()); } ...  The endpoints above show you how to interact with the simplest type of storage - Var&lt;T&gt;. The data saved there using set function will be persisted in the blockchain. ","version":"2.0.0","tagName":"h2"},{"title":"Tests​","type":1,"pageTitle":"Flipper Internals","url":"/docs/2.0.0/basics/flipper-internals#tests","content":"flipper.rs #[cfg(test)] mod tests { use crate::flipper::Flipper; use odra::host::{Deployer, NoArgs}; #[test] fn flipping() { let env = odra_test::env(); // To test a module we need to deploy it. `Flipper` implements `Deployer` trait, // so we can use it to deploy the module. let mut contract = Flipper::deploy(&amp;env, NoArgs); assert!(!contract.get()); contract.flip(); assert!(contract.get()); } ...  You can write tests in any way you prefer and know in Rust. In the example above we are deploying the contract using Deployer::deploy function called on Flipper - a piece of code generated by the #[odra::module]. Because the module implements the constructor but does not accept any arguments, as the second argument of the deploy function, we pass NoArgs - one of the implementations of the InitArgs trait provided with the framework. The contract will be deployed on the VM you chose while running cargo odra test. ","version":"2.0.0","tagName":"h2"},{"title":"What's next​","type":1,"pageTitle":"Flipper Internals","url":"/docs/2.0.0/basics/flipper-internals#whats-next","content":"Now let's take a look at the different types of storage that Odra provides and how to use them. ","version":"2.0.0","tagName":"h2"},{"title":"Modules","type":0,"sectionRef":"#","url":"/docs/2.0.0/basics/modules","content":"","keywords":"","version":"2.0.0"},{"title":"Testing​","type":1,"pageTitle":"Modules","url":"/docs/2.0.0/basics/modules#testing","content":"As we don't need to hold addresses, the test is really simple: examples/src/features/modules.rs #[cfg(test)] mod tests { use super::ModulesContract; use odra::host::{Deployer, NoArgs}; #[test] fn test_modules() { let test_env = odra_test::env(); let modules_contract = ModulesContract::deploy(&amp;test_env, NoArgs); assert_eq!(modules_contract.add_using_module(), 8); } }  ","version":"2.0.0","tagName":"h2"},{"title":"What's next​","type":1,"pageTitle":"Modules","url":"/docs/2.0.0/basics/modules#whats-next","content":"We will see how to handle native token transfers. ","version":"2.0.0","tagName":"h2"},{"title":"Casper Contract Schema","type":0,"sectionRef":"#","url":"/docs/2.0.0/basics/casper-contract-schema","content":"","keywords":"","version":"2.0.0"},{"title":"Odra and CCS​","type":1,"pageTitle":"Casper Contract Schema","url":"/docs/2.0.0/basics/casper-contract-schema#odra-and-ccs","content":"There is almost nothing you need to do to use CCS in your Odra project. The only thing to be taken care of is using odra attributes namely: module, event, odra_error and odra_type. The schema will be generated for you and available in the resources directory. note If you forget to register events and errors in the module attribute, the definition remains valid; however, the errors and events will not be incorporated into the schema. src/contract.rs use odra::prelude::*; #[odra::module( // the name of the contract, default is the module name name = &quot;MyContract&quot;, // the version of the contract, default is the version of the crate version = &quot;0.1.0&quot;, // events that the contract can emit, collected recursively if submodules are used events = [ Created, Updated ], // the error enum the contract can revert with, collected recursively if submodules are used errors = MyErrors )] pub struct MyContract { name: Var&lt;String&gt;, owner: Var&lt;Address&gt;, } #[odra::module] impl MyContract { /// Initializes the contract, sets the name and owner and emits an event pub fn init(&amp;mut self, name: String, owner: Address) { self.name.set(name.clone()); self.owner.set(owner.clone()); self.env().emit_event(Created { name }); } /// Updates the name of the contract and emits an event pub fn update(&amp;mut self, name: String) { self.name.set(name.clone()); self.env().emit_event(Updated { name }); } /// Returns the data of the contract pub fn get_data(&amp;self) -&gt; Data { Data { name: self.name.get_or_default(), owner: self.owner.get_or_revert_with(MyErrors::InvalidOwner), } } } // The struct will we visible in the schema in the types section #[odra::odra_type] pub struct Data { name: String, owner: Address, } // The enum variants will we visible in the schema in the errors section #[odra::odra_error] pub enum MyErrors { /// The owner is invalid InvalidOwner, /// The name is invalid InvalidName, } // The struct will we visible in the schema in the types and events section #[odra::event] pub struct Updated { name: String, } // The struct will we visible in the schema in the types section and events section #[odra::event] pub struct Created { name: String, }  ","version":"2.0.0","tagName":"h2"},{"title":"Generating the Schema​","type":1,"pageTitle":"Casper Contract Schema","url":"/docs/2.0.0/basics/casper-contract-schema#generating-the-schema","content":"To generate the schema run the following cargo-odra command: cargo odra schema # or pass -c flag to generate the schema for a specific contract  ","version":"2.0.0","tagName":"h2"},{"title":"Schema Output​","type":1,"pageTitle":"Casper Contract Schema","url":"/docs/2.0.0/basics/casper-contract-schema#schema-output","content":"The generated schema will be available in the resources directory. The schema is a JSON file that contains all the information about the contract. Here is an example of the generated schema: resources/my_contract_schema.json { &quot;casper_contract_schema_version&quot;: 1, &quot;toolchain&quot;: &quot;rustc 1.77.0-nightly (5bd5d214e 2024-01-25)&quot;, &quot;authors&quot;: [], &quot;repository&quot;: null, &quot;homepage&quot;: null, &quot;contract_name&quot;: &quot;MyContract&quot;, &quot;contract_version&quot;: &quot;0.1.0&quot;, &quot;types&quot;: [ { &quot;struct&quot;: { &quot;name&quot;: &quot;Created&quot;, &quot;description&quot;: null, &quot;members&quot;: [ { &quot;name&quot;: &quot;name&quot;, &quot;description&quot;: null, &quot;ty&quot;: &quot;String&quot; } ] } }, { &quot;struct&quot;: { &quot;name&quot;: &quot;Data&quot;, &quot;description&quot;: null, &quot;members&quot;: [ { &quot;name&quot;: &quot;name&quot;, &quot;description&quot;: null, &quot;ty&quot;: &quot;String&quot; }, { &quot;name&quot;: &quot;owner&quot;, &quot;description&quot;: null, &quot;ty&quot;: &quot;Key&quot; } ] } }, { &quot;struct&quot;: { &quot;name&quot;: &quot;Updated&quot;, &quot;description&quot;: null, &quot;members&quot;: [ { &quot;name&quot;: &quot;name&quot;, &quot;description&quot;: null, &quot;ty&quot;: &quot;String&quot; } ] } } ], &quot;errors&quot;: [ { &quot;name&quot;: &quot;InvalidName&quot;, &quot;description&quot;: &quot;The name is invalid&quot;, &quot;discriminant&quot;: 1 }, { &quot;name&quot;: &quot;InvalidOwner&quot;, &quot;description&quot;: &quot;The owner is invalid&quot;, &quot;discriminant&quot;: 0 } ], &quot;entry_points&quot;: [ { &quot;name&quot;: &quot;update&quot;, &quot;description&quot;: &quot;Updates the name of the contract and emits an event&quot;, &quot;is_mutable&quot;: true, &quot;arguments&quot;: [ { &quot;name&quot;: &quot;name&quot;, &quot;description&quot;: null, &quot;ty&quot;: &quot;String&quot;, &quot;optional&quot;: false } ], &quot;return_ty&quot;: &quot;Unit&quot;, &quot;is_contract_context&quot;: true, &quot;access&quot;: &quot;public&quot; }, { &quot;name&quot;: &quot;get_data&quot;, &quot;description&quot;: &quot;Returns the data of the contract&quot;, &quot;is_mutable&quot;: false, &quot;arguments&quot;: [], &quot;return_ty&quot;: &quot;Data&quot;, &quot;is_contract_context&quot;: true, &quot;access&quot;: &quot;public&quot; } ], &quot;events&quot;: [ { &quot;name&quot;: &quot;Created&quot;, &quot;ty&quot;: &quot;Created&quot; }, { &quot;name&quot;: &quot;Updated&quot;, &quot;ty&quot;: &quot;Updated&quot; } ], &quot;call&quot;: { &quot;wasm_file_name&quot;: &quot;MyContract.wasm&quot;, &quot;description&quot;: &quot;Initializes the contract, sets the name and owner and emits an event&quot;, &quot;arguments&quot;: [ { &quot;name&quot;: &quot;odra_cfg_package_hash_key_name&quot;, &quot;description&quot;: &quot;The arg name for the package hash key name.&quot;, &quot;ty&quot;: &quot;String&quot;, &quot;optional&quot;: false }, { &quot;name&quot;: &quot;odra_cfg_allow_key_override&quot;, &quot;description&quot;: &quot;The arg name for the allow key override.&quot;, &quot;ty&quot;: &quot;Bool&quot;, &quot;optional&quot;: false }, { &quot;name&quot;: &quot;odra_cfg_is_upgradable&quot;, &quot;description&quot;: &quot;The arg name for the contract upgradeability setting.&quot;, &quot;ty&quot;: &quot;Bool&quot;, &quot;optional&quot;: false }, { &quot;name&quot;: &quot;name&quot;, &quot;description&quot;: null, &quot;ty&quot;: &quot;String&quot;, &quot;optional&quot;: false }, { &quot;name&quot;: &quot;owner&quot;, &quot;description&quot;: null, &quot;ty&quot;: &quot;Key&quot;, &quot;optional&quot;: false } ] } }  ","version":"2.0.0","tagName":"h2"},{"title":"Schema Fields​","type":1,"pageTitle":"Casper Contract Schema","url":"/docs/2.0.0/basics/casper-contract-schema#schema-fields","content":"casper_contract_schema_version is the version of the schema.toolchain is the version of the Rust compiler used to compile the contract.Fields authors, repository, and homepage are optional and can be set in the Cargo.toml file.contract_name is the name of the contract - by default is the module name, may be overriden by the module attribute.contract_version denotes the version of the contract, defaulting to the version specified in the Cargo.toml file, but can be overridden by the module attribute.types comprises a list of custom structs and enums defined within the contract. Each struct or enum includes a name, description (not currently supported, with the value set to null), and a list of members.errors is a list of error enums defined within the contract. Each error includes a name, description (the first line of the variant documentation), and a discriminant.entry_points is a list of contract functions that can be called from the outside. Each entry point includes a name, description (not currently supported, with the value set to null), whether the function is mutable, a list of arguments, the return type, whether the function is called in the contract context, and the access level.events is a list of events that the contract can emit. Each event includes a name and the type (earlier defined in types) of the event.The call section provides details regarding the contract's call function, which executes upon contract deployment. It includes the name of the Wasm file, a description (reflecting the constructor's description, typically the init function), and a list of arguments. These arguments are a combination of Odra configuration arguments and constructor arguments. ","version":"2.0.0","tagName":"h2"},{"title":"Native token","type":0,"sectionRef":"#","url":"/docs/2.0.0/basics/native-token","content":"","keywords":"","version":"2.0.0"},{"title":"Testing​","type":1,"pageTitle":"Native token","url":"/docs/2.0.0/basics/native-token#testing","content":"To be able to test how many tokens a contract (or any address) has, HostEnv comes with a function -balance_of: examples/src/features/native_token.rs #[cfg(test)] mod tests { use super::PublicWallet; use odra::{casper_types::U512, host::{Deployer, HostRef, NoArgs}}; #[test] fn test_modules() { let test_env = odra_test::env(); let mut my_contract = PublicWallet::deploy(&amp;test_env, NoArgs); assert_eq!(test_env.balance_of(my_contract.address()), U512::zero()); my_contract.with_tokens(U512::from(100)).deposit(); assert_eq!(test_env.balance_of(my_contract.address()), U512::from(100)); my_contract.withdraw(U512::from(25)); assert_eq!(test_env.balance_of(my_contract.address()), U512::from(75)); } }  ","version":"2.0.0","tagName":"h2"},{"title":"HostEnv​","type":1,"pageTitle":"Native token","url":"/docs/2.0.0/basics/native-token#hostenv","content":"In a broader context of the host environment (test, livenet), you can also transfer CSPR tokens between accounts: let env = odra_casper_livenet_env::env(); //let env = odra_test::env(); let (alice, bob) = (env.get_account(0), env.get_account(1)); env.set_caller(alice); let result = env.transfer_tokens(bob, odra::casper_types::U512::from(100));  ","version":"2.0.0","tagName":"h2"},{"title":"Odra.toml","type":0,"sectionRef":"#","url":"/docs/2.0.0/basics/odra-toml","content":"","keywords":"","version":"2.0.0"},{"title":"Adding a new contract manually​","type":1,"pageTitle":"Odra.toml","url":"/docs/2.0.0/basics/odra-toml#adding-a-new-contract-manually","content":"Besides using the cargo odra generate command, you can add a new contract to be compiled by hand. To do this, add another [[contracts]] element, name it and make sure that the fqn is set correctly. For example, if you want to create a new contract called counter, your Odra.toml file should finally look like this: [[contracts]] fqn = &quot;sample::Flipper&quot; [[contracts]] fqn = &quot;sample::Counter&quot;  ","version":"2.0.0","tagName":"h2"},{"title":"What's next​","type":1,"pageTitle":"Odra.toml","url":"/docs/2.0.0/basics/odra-toml#whats-next","content":"In the next section, we'll take a closer look at the code that was generated by Odra by default - the famousFlipper contract. ","version":"2.0.0","tagName":"h2"},{"title":"Testing","type":0,"sectionRef":"#","url":"/docs/2.0.0/basics/testing","content":"","keywords":"","version":"2.0.0"},{"title":"HostEnv​","type":1,"pageTitle":"Testing","url":"/docs/2.0.0/basics/testing#hostenv","content":"Odra gives us some additional functions that we can use to communicate with the host (outside the contract context) and to configure how the contracts are deployed and called. Let's revisit the example from the previous article about host communication and implement the tests that prove it works: examples/src/features/testing.rs #[cfg(test)] mod tests { use crate::features::testing::{TestingContract, TestingContractInitArgs}; use odra::{host::{Deployer, HostEnv}, prelude::*}; #[test] fn env() { let test_env: HostEnv = odra_test::env(); test_env.set_caller(test_env.get_account(0)); let init_args = TestingContractInitArgs { name: &quot;MyContract&quot;.to_string() }; let testing_contract = TestingContract::deploy(&amp;test_env, init_args); let creator = testing_contract.created_by(); test_env.set_caller(test_env.get_account(1)); let init_args = TestingContractInitArgs { name: &quot;MyContract2&quot;.to_string() }; let testing_contract2 = TestingContract::deploy(&amp;test_env, init_args); let creator2 = testing_contract2.created_by(); assert_ne!(creator, creator2); } }  In the code above, at the beginning of the test, we are obtaining a HostEnv instance using odra_test::env(). Next, we are deploying two instances of the same contract, but we're using HostEnv::set_callerto change the caller - so the Address which is deploying the contract. This changes the result of the odra::ContractEnv::caller()the function we are calling inside the contract. HostEnv comes with a set of functions that will let you write better tests: fn set_caller(&amp;self, address: Address) - you've seen it in action just nowfn balance_of(&amp;self, address: &amp;Address) -&gt; U512 - returns the balance of the account associated with the given addressfn advance_block_time(&amp;self, time_diff: u64) - increases the current value of block_timefn get_account(&amp;self, n: usize) -&gt; Address - returns an n-th address that was prepared for you by Odra in advance; by default, you start with the 0-th accountfn emitted_event&lt;T: ToBytes + EventInstance, R: Addressable&gt;(&amp;self, contract_address: &amp;R, event: &amp;T) -&gt; bool - verifies if the event was emitted by the contract Full list of functions can be found in the HostEnv documentation. ","version":"2.0.0","tagName":"h2"},{"title":"What's next​","type":1,"pageTitle":"Testing","url":"/docs/2.0.0/basics/testing#whats-next","content":"We take a look at how Odra handles errors! ","version":"2.0.0","tagName":"h2"},{"title":"odra-examples","type":0,"sectionRef":"#","url":"/docs/2.0.0/examples/odra-examples","content":"","keywords":"","version":"2.0.0"},{"title":"What's next​","type":1,"pageTitle":"odra-examples","url":"/docs/2.0.0/examples/odra-examples#whats-next","content":"Read the next article to learn about reusable Odra components encapsulated in odra-modules. ","version":"2.0.0","tagName":"h2"},{"title":"Storage interaction","type":0,"sectionRef":"#","url":"/docs/2.0.0/basics/storage-interaction","content":"","keywords":"","version":"2.0.0"},{"title":"Var​","type":1,"pageTitle":"Storage interaction","url":"/docs/2.0.0/basics/storage-interaction#var","content":"The Var is the simplest storage type available in the Odra framework. It serializes the data and stores it under a single key in the blockchain storage. To use it, just wrap your variable in the Var type. Let's look at a &quot;real world&quot; example of a contract that represents a dog: examples/src/features/storage/variable.rs use odra::prelude::*; #[odra::module] pub struct DogContract { barks: Var&lt;bool&gt;, weight: Var&lt;u32&gt;, name: Var&lt;String&gt;, walks: Var&lt;Vec&lt;u32&gt;&gt;, }  You can see the Var wrapping the data. Even complex types like Vec can be wrapped (with some caveats)! Let's make this contract usable, by providing a constructor and some getter functions: examples/src/features/storage/variable.rs #[odra::module] impl DogContract { pub fn init(&amp;mut self, barks: bool, weight: u32, name: String) { self.barks.set(barks); self.weight.set(weight); self.name.set(name); self.walks.set(Vec::&lt;u32&gt;::default()); } pub fn barks(&amp;self) -&gt; bool { self.barks.get_or_default() } pub fn weight(&amp;self) -&gt; u32 { self.weight.get_or_default() } pub fn name(&amp;self) -&gt; String { self.name.get_or_default() } pub fn walks_amount(&amp;self) -&gt; u32 { let walks = self.walks.get_or_default(); walks.len() as u32 } pub fn walks_total_length(&amp;self) -&gt; u32 { let walks = self.walks.get_or_default(); walks.iter().sum() } }  As you can see, you can access the data, by using get_or_default function: examples/src/features/storage/variable.rs ... self.barks.get_or_default() ...  note Keep in mind that using get() will result in an Option that you'll need to unwrap - the variable doesn't have to be initialized! To modify the data, use the set() function: examples/src/features/storage/variable.rs self.barks.set(barks);  A Var is easy to use and efficient for simple data types. One of its downsides is that it serializes the data as a whole, so when you're using complex types like Vec or HashMap, each time you get or set the whole data is read and written to the blockchain storage. In the example above, if we want to see how many walks our dog had, we would use the function: examples/src/features/storage/variable.rs pub fn walks_amount(&amp;self) -&gt; usize { let walks = self.walks.get_or_default(); walks.len() }  But to do so, we need to extract the whole serialized vector from the storage, which would inefficient, especially for larger sets of data. To tackle this issue following two types were created. ","version":"2.0.0","tagName":"h2"},{"title":"Mapping​","type":1,"pageTitle":"Storage interaction","url":"/docs/2.0.0/basics/storage-interaction#mapping","content":"The Mapping is used to store and access data as key-value pairs. To define a Mapping, you need to pass two values - the key type and the value type. Let's look at the variation of the Dog contract, that uses Mapping to store information about our dog's friends and how many times they visited: examples/src/features/storage/mapping.rs use odra::prelude::*; #[odra::module] pub struct DogContract2 { name: Var&lt;String&gt;, friends: Mapping&lt;String, u32&gt;, }  In the example above, our key is a String (it is a name of the friend) and we are storing u32 values (amount of visits). To read and write values from and into a Mapping we use a similar approach to the one shown in the Vars section with one difference - we need to pass a key: examples/src/features/storage/mapping.rs pub fn visit(&amp;mut self, friend_name: String) { let visits = self.visits(friend_name.clone()); self.friends.set(&amp;friend_name, visits + 1); } pub fn visits(&amp;self, friend_name: String) -&gt; u32 { self.friends.get_or_default(&amp;friend_name) }  The biggest improvement over a Var is that we can model functionality of a HashMap using Mapping. The amount of data written to and read from the storage is minimal. However, we cannot iterate over Mapping. We could implement such behavior by using a numeric type key and saving the length of the set in a separate variable. Thankfully Odra comes with a prepared solution - the List type. note If you take a look into List implementation in Odra, you'll see that in fact it is just a Mapping with a Var working together: core/src/list.rs use odra::prelude::*; pub struct List&lt;T&gt; { values: Mapping&lt;u32, T&gt;, index: Var&lt;u32&gt; }  ","version":"2.0.0","tagName":"h2"},{"title":"List​","type":1,"pageTitle":"Storage interaction","url":"/docs/2.0.0/basics/storage-interaction#list","content":"Going back to our DogContract example - let's revisit the walk case. This time, instead of Vec, we'll use the list: examples/src/features/storage/list.rs use odra::prelude::*; #[odra::module] pub struct DogContract3 { name: Var&lt;String&gt;, walks: List&lt;u32&gt;, }  As you can see, the notation is very similar to the Vec. To understand the usage, take a look at the reimplementation of the functions with an additional function that takes our dog for a walk (it writes the data to the storage): examples/src/features/storage/list.rs #[odra::module] impl DogContract3 { pub fn init(&amp;mut self, name: String) { self.name.set(name); } pub fn name(&amp;self) -&gt; String { self.name.get_or_default() } pub fn walks_amount(&amp;self) -&gt; u32 { self.walks.len() } pub fn walks_total_length(&amp;self) -&gt; u32 { self.walks.iter().sum() } pub fn walk_the_dog(&amp;mut self, length: u32) { self.walks.push(length); } }  Now, we can know how many walks our dog had without loading the whole vector from the storage. We need to do this to sum the length of all the walks, but the Odra framework cannot (yet) handle all the cases for you. info All of the above examples, alongside the tests, are available in the Odra repository in the examples/src/features/ folder. ","version":"2.0.0","tagName":"h2"},{"title":"Custom Types​","type":1,"pageTitle":"Storage interaction","url":"/docs/2.0.0/basics/storage-interaction#custom-types","content":"By default you can store only built-in types like numbers, Options, Results, Strings, Vectors. Implementing custom types is straightforward, your type must add #[odra::odra_type] attribute. Let's see how to implement a Dog type: use odra::prelude::*; #[odra::odra_type] pub struct Dog { pub name: String, pub age: u8, pub owner: Option&lt;Address&gt; }  #[odra_type] is applicable to named field structs and enums. It generates serialization, deserialization and schema code for your type.CLType of a custom type is CLType::Any, except for an unit-only enum, which is CLType::U8. unit_only_enum.rs enum Enum { Foo = 3, Bar = 2, Baz = 1, }  note Each custom typed field of your struct must be marked with the #[odra::odra_type] attribute . ","version":"2.0.0","tagName":"h2"},{"title":"What's next​","type":1,"pageTitle":"Storage interaction","url":"/docs/2.0.0/basics/storage-interaction#whats-next","content":"In the next article, we'll see how to query the host for information about the world and our contract. ","version":"2.0.0","tagName":"h2"},{"title":"Using odra-modules","type":0,"sectionRef":"#","url":"/docs/2.0.0/examples/using-odra-modules","content":"","keywords":"","version":"2.0.0"},{"title":"Available modules​","type":1,"pageTitle":"Using odra-modules","url":"/docs/2.0.0/examples/using-odra-modules#available-modules","content":"Odra modules comes with couple of ready-to-use modules and reusable extensions. ","version":"2.0.0","tagName":"h2"},{"title":"Tokens​","type":1,"pageTitle":"Using odra-modules","url":"/docs/2.0.0/examples/using-odra-modules#tokens","content":"CEP-18​ Casper Ecosystem Proposal 18 (CEP-18) is a standard interface for the CSPR and the custom made tokens. Inspired by the ERC20 standard. Read more about the CEP-18 here. CEP-78​ Casper Ecosystem Proposal 78 (CEP-78) is an enhanced NFT standard focused on ease of use and installation. Inspired by the ERC721 standard. Read more about the CEP-78 here. Erc20​ The Erc20 module implements the ERC20 standard. Erc721​ The Erc721Base module implements the ERC721 standard, adjusted for the Odra framework. The Erc721Token module implements the ERC721Base and additionally uses the Erc721Metadata and Ownable extensions. The Erc721Receiver trait lets you implement your own logic for receiving NFTs. The OwnedErc721WithMetadata trait is a combination of Erc721Token, Erc721Metadata and Ownable modules. Erc1155​ The Erc1155Base module implements the ERC1155 standard, adjusted for the Odra framework. The Erc1155Token module implements the ERC1155Base and additionally uses the Ownable extension. The OwnedErc1155 trait is a combination of Erc1155Token and Ownable modules. Wrapped native token​ The WrappedNativeToken module implements the Wrapper for the native token, it was inspired by the WETH. ","version":"2.0.0","tagName":"h3"},{"title":"Access​","type":1,"pageTitle":"Using odra-modules","url":"/docs/2.0.0/examples/using-odra-modules#access","content":"AccessControl​ This module enables the implementation of role-based access control mechanisms for children modules. Roles are identified by their 32-bytes identifier, which should be unique and exposed in the external API. Ownable​ This module provides a straightforward access control feature that enables exclusive access to particular functions by an account, known as the owner. The account that initiates the module is automatically assigned as the owner. However, ownership can be transferred later by using thetransfer_ownership() function. Ownable2Step​ An extension of the Ownable module. Ownership can be transferred in a two-step process by using transfer_ownership() and accept_ownership() functions. ","version":"2.0.0","tagName":"h3"},{"title":"Security​","type":1,"pageTitle":"Using odra-modules","url":"/docs/2.0.0/examples/using-odra-modules#security","content":"Pausable​ A module allowing to implement an emergency stop mechanism that can be triggered by any account. ","version":"2.0.0","tagName":"h3"},{"title":"Installation","type":0,"sectionRef":"#","url":"/docs/2.0.0/getting-started/installation","content":"","keywords":"","version":"2.0.0"},{"title":"Prerequisites​","type":1,"pageTitle":"Installation","url":"/docs/2.0.0/getting-started/installation#prerequisites","content":"To start working with Odra, you need to have the following installed on your machine: Rust toolchain installed (see rustup.rs)wasmstrip tool installed (see wabt)wasm-opt tool installed (see binaryen) We do not provide exact commands for installing these tools, as they are different for different operating systems. Please refer to the documentation of the tools themselves. With Rust toolchain ready, you can add a new target: rustup target add wasm32-unknown-unknown  note wasm32-unknown-unknown is a target that will be used by Odra to compile your smart contracts to WASM files. ","version":"2.0.0","tagName":"h2"},{"title":"Installing Cargo Odra​","type":1,"pageTitle":"Installation","url":"/docs/2.0.0/getting-started/installation#installing-cargo-odra","content":"Cargo Odra is a helpful tool that will help you to build and test your smart contracts. It is not required to use Odra, but the documentation will assume that you have it installed. To install it, simply execute the following command: cargo install cargo-odra --locked  To check if it was installed correctly and see available commands, type: cargo odra --help  If everything went fine, we can proceed to the next step. ","version":"2.0.0","tagName":"h2"},{"title":"Creating a new Odra project​","type":1,"pageTitle":"Installation","url":"/docs/2.0.0/getting-started/installation#creating-a-new-odra-project","content":"To create a new project, simply execute: cargo odra new --name my-project &amp;&amp; cd my_project  This will create a new folder called my_project and initialize Odra there. Cargo Odra will create a sample contract for you in src directory. You can run the tests of this contract by executing: cargo odra test  This will run tests using Odra's internal OdraVM. You can run those tests against a real backend, let's use CasperVM: cargo odra test -b casper  Congratulations! Now you are ready to create contracts using Odra framework! If you had any problems during the installation process, feel free to ask for help on our Discord. ","version":"2.0.0","tagName":"h2"},{"title":"What's next?​","type":1,"pageTitle":"Installation","url":"/docs/2.0.0/getting-started/installation#whats-next","content":"If you want to see the code that you just tested, continue to the description of Flipper example. ","version":"2.0.0","tagName":"h2"},{"title":"Flipper example","type":0,"sectionRef":"#","url":"/docs/2.0.0/getting-started/flipper","content":"","keywords":"","version":"2.0.0"},{"title":"Let's flip​","type":1,"pageTitle":"Flipper example","url":"/docs/2.0.0/getting-started/flipper#lets-flip","content":"flipper.rs use odra::prelude::*; /// A module definition. Each module struct consists Vars and Mappings /// or/and another modules. #[odra::module] pub struct Flipper { /// The module itself does not store the value, /// it's a proxy that writes/reads value to/from the host. value: Var&lt;bool&gt;, } /// Module implementation. /// /// To generate entrypoints, /// an implementation block must be marked as #[odra::module]. #[odra::module] impl Flipper { /// Odra constructor. /// /// Initializes the contract. pub fn init(&amp;mut self) { self.value.set(false); } /// Replaces the current value with the passed argument. pub fn set(&amp;mut self, value: bool) { self.value.set(value); } /// Replaces the current value with the opposite value. pub fn flip(&amp;mut self) { self.value.set(!self.get()); } /// Retrieves value from the storage. /// If the value has never been set, the default value is returned. pub fn get(&amp;self) -&gt; bool { self.value.get_or_default() } } #[cfg(test)] mod tests { use crate::flipper::Flipper; use odra::host::{Deployer, NoArgs}; #[test] fn flipping() { let env = odra_test::env(); // To test a module we need to deploy it. `Flipper` implements `Deployer` trait, // so we can use it to deploy the module. let mut contract = Flipper::deploy(&amp;env, NoArgs); assert!(!contract.get()); contract.flip(); assert!(contract.get()); } }  ","version":"2.0.0","tagName":"h2"},{"title":"Testing​","type":1,"pageTitle":"Flipper example","url":"/docs/2.0.0/getting-started/flipper#testing","content":"To run the tests, execute the following command: cargo odra test # or add the `-b casper` flag to run tests on the CasperVM  ","version":"2.0.0","tagName":"h2"},{"title":"What's next​","type":1,"pageTitle":"Flipper example","url":"/docs/2.0.0/getting-started/flipper#whats-next","content":"In the next category of articles, we will go through basic concepts of Odra. ","version":"2.0.0","tagName":"h2"},{"title":"Migration guide to v1.3.0","type":0,"sectionRef":"#","url":"/docs/2.0.0/migrations/to-1.3.0","content":"","keywords":"","version":"2.0.0"},{"title":"Migrating to Odra v1.3.0​","type":1,"pageTitle":"Migration guide to v1.3.0","url":"/docs/2.0.0/migrations/to-1.3.0#migrating-to-odra-v130","content":"To migrate your smart contracts to Odra v1.3.0, remove the use the deploy method from the module instead of the {{ModuleName}}HostRef struct: before.rs let token = TokenHostRef::deploy(env, init_args); let another_token = AnotherTokenHostRef::load(env, address);  after.rs let token = Token::deploy(env, init_args); let another_token = AnotherToken::load(env, address);  ","version":"2.0.0","tagName":"h2"},{"title":"Migration guide to v2.0.0 from 1.*","type":0,"sectionRef":"#","url":"/docs/2.0.0/migrations/to-2.0.0","content":"","keywords":"","version":"2.0.0"},{"title":"Updating rustc version​","type":1,"pageTitle":"Migration guide to v2.0.0 from 1.*","url":"/docs/2.0.0/migrations/to-2.0.0#updating-rustc-version","content":"Update rust-toolchain file in your project: nightly-2024-07-31  ","version":"2.0.0","tagName":"h2"},{"title":"Access Control","type":0,"sectionRef":"#","url":"/docs/2.0.0/tutorials/access-control","content":"","keywords":"","version":"2.0.0"},{"title":"Code​","type":1,"pageTitle":"Access Control","url":"/docs/2.0.0/tutorials/access-control#code","content":"Before we start writing code, we list the functionalities of our access control layer. A Role type is used across the module.A Role can be assigned to many Addresses.Each Role may have a corresponding admin role.Only an admin can grant/revoke a Role.A Role can be renounced.A Role cannot be renounced on someone's behalf.Each action triggers an event.Unauthorized access stops contract execution. ","version":"2.0.0","tagName":"h2"},{"title":"Project Structure​","type":1,"pageTitle":"Access Control","url":"/docs/2.0.0/tutorials/access-control#project-structure","content":"access-control ├── src │ ├── access │ │ ├── access_control.rs │ │ ├── events.rs │ │ └── errors.rs │ └── lib.rs |── build.rs |── Cargo.toml └── Odra.toml  ","version":"2.0.0","tagName":"h3"},{"title":"Events and Errors​","type":1,"pageTitle":"Access Control","url":"/docs/2.0.0/tutorials/access-control#events-and-errors","content":"There are three actions that can be performed concerning a Role: granting, revoking, and altering the admin role. Let us establish standard Odra events for each of these actions. events.rs use odra::prelude::*; use super::access_control::Role; #[odra::event] pub struct RoleGranted { pub role: Role, pub address: Address, pub sender: Address } #[odra::event] pub struct RoleRevoked { pub role: Role, pub address: Address, pub sender: Address } #[odra::event] pub struct RoleAdminChanged { pub role: Role, pub previous_admin_role: Role, pub new_admin_role: Role }  L4-L16 - to describe the grant or revoke actions, our events specify the Role, and Addresses indicating who receives or loses access and who provides or withdraws it.L18-L23 - the event describing the admin role change, requires the subject Role, the previous and the current admin Role. errors.rs #[odra::odra_error] pub enum Error { MissingRole = 20_000, RoleRenounceForAnotherAddress = 20_001, }  Errors definition is straightforward - there are only two invalid states: An action is triggered by an unauthorized actor.The caller is attempting to resign the Role on someone's behalf.  ","version":"2.0.0","tagName":"h3"},{"title":"Module​","type":1,"pageTitle":"Access Control","url":"/docs/2.0.0/tutorials/access-control#module","content":"Now, we are stepping into the most interesting part: the module definition and implementation. access_control.rs use super::events::*; use super::errors::Error; use odra::prelude::*; pub type Role = [u8; 32]; pub const DEFAULT_ADMIN_ROLE: Role = [0u8; 32]; #[odra::module(events = [RoleAdminChanged, RoleGranted, RoleRevoked])] pub struct AccessControl { roles: Mapping&lt;(Role, Address), bool&gt;, role_admin: Mapping&lt;Role, Role&gt; } #[odra::module] impl AccessControl { pub fn has_role(&amp;self, role: &amp;Role, address: &amp;Address) -&gt; bool { self.roles.get_or_default(&amp;(*role, *address)) } pub fn get_role_admin(&amp;self, role: &amp;Role) -&gt; Role { let admin_role = self.role_admin.get(role); if let Some(admin) = admin_role { admin } else { DEFAULT_ADMIN_ROLE } } pub fn grant_role(&amp;mut self, role: &amp;Role, address: &amp;Address) { self.check_role(&amp;self.get_role_admin(role), &amp;self.env().caller()); self.unchecked_grant_role(role, address); } pub fn revoke_role(&amp;mut self, role: &amp;Role, address: &amp;Address) { self.check_role(&amp;self.get_role_admin(role), &amp;self.env().caller()); self.unchecked_revoke_role(role, address); } pub fn renounce_role(&amp;mut self, role: &amp;Role, address: &amp;Address) { if address != &amp;self.env().caller() { self.env().revert(Error::RoleRenounceForAnotherAddress); } self.unchecked_revoke_role(role, address); } } impl AccessControl { pub fn check_role(&amp;self, role: &amp;Role, address: &amp;Address) { if !self.has_role(role, address) { self.env().revert(Error::MissingRole); } } pub fn set_admin_role(&amp;mut self, role: &amp;Role, admin_role: &amp;Role) { let previous_admin_role = self.get_role_admin(role); self.role_admin.set(role, *admin_role); self.env().emit_event(RoleAdminChanged { role: *role, previous_admin_role, new_admin_role: *admin_role }); } pub fn unchecked_grant_role(&amp;mut self, role: &amp;Role, address: &amp;Address) { if !self.has_role(role, address) { self.roles.set(&amp;(*role, *address), true); self.env().emit_event(RoleGranted { role: *role, address: *address, sender: self.env().caller() }); } } pub fn unchecked_revoke_role(&amp;mut self, role: &amp;Role, address: &amp;Address) { if self.has_role(role, address) { self.roles.set(&amp;(*role, *address), false); self.env().emit_event(RoleRevoked { role: *role, address: *address, sender: self.env().caller() }); } } }  L5 - Firstly, we need the Role type. It is simply an alias for a 32-byte array.L7 - The default role is an array filled with zeros.L10-L13 - The storage consists of two mappings: roles - a nested mapping that stores information about whether a certain Role is granted to a given Address.role_admin - each Role can have a single admin Role. L17-L19 - This is a simple check to determine if a Role has been granted to a given Address. It is an exposed entry point and an important building block widely used throughout the entire module.L48 - This is a non-exported block containing helper functions.L49-L53 - The check_role() function serves as a guard function. Before a Role is granted or revoked, we must ensure that the caller is allowed to do so. For this purpose, the function reads the roles mapping. If the role has not been granted to the address, the contract reverts with Error::MissingRole.L55-L63 - The set_admin_role() function simply updates the role_admin mapping and emits the RoleAdminChanged event.L65-L85 - The unchecked_grant_role() and unchecked_revoke_role() functions are mirror functions that update the roles mapping and post RoleGranted or RoleRevoked events. If the role is already granted, unchecked_grant_role() has no effect (the opposite check is made in the case of revoking a role).L21-L28 - The get_role_admin() entry point reads the role_admin. If there is no admin role for a given role, it returns the default role.L30-L45 - This is a combination of check_role() and unchecked_*_role(). Entry points fail on unauthorized access. ","version":"2.0.0","tagName":"h3"},{"title":"Migration guide to v0.9.0","type":0,"sectionRef":"#","url":"/docs/2.0.0/migrations/to-0.9.0","content":"","keywords":"","version":"2.0.0"},{"title":"1. Prerequisites​","type":1,"pageTitle":"Migration guide to v0.9.0","url":"/docs/2.0.0/migrations/to-0.9.0#1-prerequisites","content":"","version":"2.0.0","tagName":"h2"},{"title":"1.1. Update cargo-odra​","type":1,"pageTitle":"Migration guide to v0.9.0","url":"/docs/2.0.0/migrations/to-0.9.0#11-update-cargo-odra","content":"Before you begin the migration process, make sure you installed the latest version of the Cargo Odra toolchain. You can install it by running the following command: cargo install cargo-odra --force --locked  ","version":"2.0.0","tagName":"h3"},{"title":"1.2. Review the Changelog​","type":1,"pageTitle":"Migration guide to v0.9.0","url":"/docs/2.0.0/migrations/to-0.9.0#12-review-the-changelog","content":"Before you move to changing your code, start by reviewing the Changelog to understand the changes introduced in v0.9.0. ","version":"2.0.0","tagName":"h3"},{"title":"2. Migration Steps​","type":1,"pageTitle":"Migration guide to v0.9.0","url":"/docs/2.0.0/migrations/to-0.9.0#2-migration-steps","content":"","version":"2.0.0","tagName":"h2"},{"title":"2.1 Update build_schema.rs bin​","type":1,"pageTitle":"Migration guide to v0.9.0","url":"/docs/2.0.0/migrations/to-0.9.0#21-update-build_schemars-bin","content":"Odra 0.9.0 adds a new standardized way of generating contract schema - Casper Contract Schema. You can find the updated build_schema.rs file in templates directory in the Odra main repository. You can choose whatever template you want to use and copy the files to your project. In both files, you should replace {{project-name}} with the name of your project. ","version":"2.0.0","tagName":"h3"},{"title":"2.2 Update smart contract code​","type":1,"pageTitle":"Migration guide to v0.9.0","url":"/docs/2.0.0/migrations/to-0.9.0#22-update-smart-contract-code","content":"The main changes in the smart contract code are related to the way of defining custom types, events and errors. The following sections will guide you through the necessary changes. 2.2.1. Update custom types definitions.​ #[derive(OdraType)] attribute has been replace with #[odra::odra_type] attribute. 0.9.00.8.0 use odra::Address; #[odra::odra_type] pub struct Dog { pub name: String, pub age: u8, pub owner: Option&lt;Address&gt; }  2.2.2. Update errors definitions.​ #[derive(OdraError)] attribute has been replace with #[odra::odra_error] attribute. Error enum should be passed as a parameter to the #[odra::module] attribute. 0.9.00.8.0 #[odra::module(events = [/* events go here */], errors = Error)] pub struct Erc20 { // fields } #[odra::odra_error] pub enum Error { InsufficientBalance = 30_000, InsufficientAllowance = 30_001, NameNotSet = 30_002, SymbolNotSet = 30_003, DecimalsNotSet = 30_004 }  2.2.3. Update events definitions.​ #[derive(Event)] attribute has been replace with #[odra::event] attribute. 0.9.00.8.0 use odra::prelude::*; use odra::{Address, casper_types::U256}; #[odra::event] pub struct Transfer { pub from: Option&lt;Address&gt;, pub to: Option&lt;Address&gt;, pub amount: U256 }  ","version":"2.0.0","tagName":"h3"},{"title":"3. Code Examples​","type":1,"pageTitle":"Migration guide to v0.9.0","url":"/docs/2.0.0/migrations/to-0.9.0#3-code-examples","content":"Here is a complete example of a smart contract after and before the migration to v0.9.0. 0.9.0Prev src/erc20.rs use crate::erc20::errors::Error; use crate::erc20::events::*; use odra::prelude::*; use odra::{casper_types::U256, Address, Mapping, Var}; #[odra::module(events = [Approval, Transfer], errors = Error)] pub struct Erc20 { decimals: Var&lt;u8&gt;, symbol: Var&lt;String&gt;, name: Var&lt;String&gt;, total_supply: Var&lt;U256&gt;, balances: Mapping&lt;Address, U256&gt;, allowances: Mapping&lt;(Address, Address), U256&gt; } #[odra::module] impl Erc20 { pub fn init( &amp;mut self, symbol: String, name: String, decimals: u8, initial_supply: Option&lt;U256&gt; ) { let caller = self.env().caller(); self.symbol.set(symbol); self.name.set(name); self.decimals.set(decimals); if let Some(initial_supply) = initial_supply { self.total_supply.set(initial_supply); self.balances.set(&amp;caller, initial_supply); if !initial_supply.is_zero() { self.env().emit_event(Transfer { from: None, to: Some(caller), amount: initial_supply }); } } } pub fn transfer(&amp;mut self, recipient: &amp;Address, amount: &amp;U256) { let caller = self.env().caller(); self.raw_transfer(&amp;caller, recipient, amount); } pub fn transfer_from(&amp;mut self, owner: &amp;Address, recipient: &amp;Address, amount: &amp;U256) { let spender = self.env().caller(); self.spend_allowance(owner, &amp;spender, amount); self.raw_transfer(owner, recipient, amount); } pub fn approve(&amp;mut self, spender: &amp;Address, amount: &amp;U256) { let owner = self.env().caller(); self.allowances.set(&amp;(owner, *spender), *amount); self.env().emit_event(Approval { owner, spender: *spender, value: *amount }); } pub fn name(&amp;self) -&gt; String { self.name.get_or_revert_with(Error::NameNotSet) } // Other getter functions... pub fn allowance(&amp;self, owner: &amp;Address, spender: &amp;Address) -&gt; U256 { self.allowances.get_or_default(&amp;(*owner, *spender)) } pub fn mint(&amp;mut self, address: &amp;Address, amount: &amp;U256) { self.total_supply.add(*amount); self.balances.add(address, *amount); self.env().emit_event(Transfer { from: None, to: Some(*address), amount: *amount }); } pub fn burn(&amp;mut self, address: &amp;Address, amount: &amp;U256) { if self.balance_of(address) &lt; *amount { self.env().revert(Error::InsufficientBalance); } self.total_supply.subtract(*amount); self.balances.subtract(address, *amount); self.env().emit_event(Transfer { from: Some(*address), to: None, amount: *amount }); } } impl Erc20 { fn raw_transfer(&amp;mut self, owner: &amp;Address, recipient: &amp;Address, amount: &amp;U256) { if *amount &gt; self.balances.get_or_default(owner) { self.env().revert(Error::InsufficientBalance) } self.balances.subtract(owner, *amount); self.balances.add(recipient, *amount); self.env().emit_event(Transfer { from: Some(*owner), to: Some(*recipient), amount: *amount }); } fn spend_allowance(&amp;mut self, owner: &amp;Address, spender: &amp;Address, amount: &amp;U256) { let allowance = self.allowances.get_or_default(&amp;(*owner, *spender)); if allowance &lt; *amount { self.env().revert(Error::InsufficientAllowance) } self.allowances.subtract(&amp;(*owner, *spender), *amount); self.env().emit_event(Approval { owner: *owner, spender: *spender, value: allowance - *amount }); } } pub mod events { use odra::prelude::*; use odra::{casper_types::U256, Address}; #[odra::event] pub struct Transfer { pub from: Option&lt;Address&gt;, pub to: Option&lt;Address&gt;, pub amount: U256 } #[odra::event] pub struct Approval { pub owner: Address, pub spender: Address, pub value: U256 } } pub mod errors { #[odra::odra_error] pub enum Error { InsufficientBalance = 30_000, InsufficientAllowance = 30_001, NameNotSet = 30_002, SymbolNotSet = 30_003, DecimalsNotSet = 30_004 } } #[cfg(test)] mod tests { // nothing changed in the tests }  ","version":"2.0.0","tagName":"h2"},{"title":"4. Troubleshooting​","type":1,"pageTitle":"Migration guide to v0.9.0","url":"/docs/2.0.0/migrations/to-0.9.0#4-troubleshooting","content":"If you encounter any further issues after completing the migration steps, please don't hesitate to reach out to us on Discord or explore the other sections this documentation. You can also refer to the technical documentation for more detailed information. Additionally, our examples repository offers a wide range of examples to assist you in understanding the new features and APIs. Be sure to carefully review any compilation errors and warnings, as they may provide valuable insights into the necessary adjustments. ","version":"2.0.0","tagName":"h2"},{"title":"5. References​","type":1,"pageTitle":"Migration guide to v0.9.0","url":"/docs/2.0.0/migrations/to-0.9.0#5-references","content":"ChangelogOdra DocumentationDocs.rsExamples ","version":"2.0.0","tagName":"h2"},{"title":"Build, Deploy and Read the State of a Contract","type":0,"sectionRef":"#","url":"/docs/2.0.0/tutorials/build-deploy-read","content":"","keywords":"","version":"2.0.0"},{"title":"Contract​","type":1,"pageTitle":"Build, Deploy and Read the State of a Contract","url":"/docs/2.0.0/tutorials/build-deploy-read#contract","content":"Let's write a contract with complex storage layout. The contract stores a plain numeric value, a custom nested type and a submodule with another submodule with stores a Mapping. We will expose two methods: The constructor init which sets the metadata and the version of the contract.The method set_data which sets the value of the numeric field and the values of the mapping. custom_item.rs use odra::{casper_types::U256, prelude::*}; // A custom type with a vector of another custom type #[odra::odra_type] pub struct Metadata { name: String, description: String, prices: Vec&lt;Price&gt;, } #[odra::odra_type] pub struct Price { value: U256, } // The main contract with a version, metadata and a submodule #[odra::module] pub struct CustomItem { version: Var&lt;u32&gt;, meta: Var&lt;Metadata&gt;, data: SubModule&lt;Data&gt; } #[odra::module] impl CustomItem { pub fn init(&amp;mut self, name: String, description: String, price_1: U256, price_2: U256) { let meta = Metadata { name, description, prices: vec![ Price { value: price_1 }, Price { value: price_2 } ] }; self.meta.set(meta); self.version.set(self.version.get_or_default() + 1); } pub fn set_data(&amp;mut self, value: u32, name: String, name2: String) { self.data.value.set(value); self.data.inner.named_values.set(&amp;name, 10); self.data.inner.named_values.set(&amp;name2, 20); } } // A submodule with a numeric value and another submodule #[odra::module] struct Data { value: Var&lt;u32&gt;, inner: SubModule&lt;InnerData&gt;, } // A submodule with a mapping #[odra::module] struct InnerData { named_values: Mapping&lt;String, u32&gt;, }  ","version":"2.0.0","tagName":"h3"},{"title":"Deploying the contract​","type":1,"pageTitle":"Build, Deploy and Read the State of a Contract","url":"/docs/2.0.0/tutorials/build-deploy-read#deploying-the-contract","content":"First, we need to setup the chain. We will use the NCTL docker image to run a local network. docker run --rm -it --name mynctl -d -p 11101:11101 -p 14101:14101 -p 18101:18101 makesoftware/casper-nctl  Next, we need to compile the contract to a Wasm file. cargo odra build -c custom_item  Then, we can deploy the contract using the casper-client tool. casper-client put-deploy \\ --node-address http://localhost:11101 \\ --chain-name casper-net-1 \\ --secret-key path/to/your/secret_key.pem \\ --session-path [PATH_TO_WASM] \\ --payment-amount 100000000000 \\ --session-arg &quot;odra_cfg_package_hash_key_name:string:'test_contract_package_hash'&quot; \\ --session-arg &quot;odra_cfg_allow_key_override:bool:'true'&quot; \\ --session-arg &quot;odra_cfg_is_upgradable:bool:'true'&quot; \\ --session-arg &quot;name:string='My Name'&quot; \\ --session-arg &quot;description:string='My Description'&quot; \\ --session-arg &quot;price_1:u256='101'&quot; \\ --session-arg &quot;price_2:u256='202'&quot;  Finally, we can call the set_data method to set the values of the contract. casper-client put-deploy \\ --node-address http://localhost:11101 \\ --chain-name casper-net-1 \\ --secret-key ./keys/secret_key.pem \\ --payment-amount 2000000000 \\ --session-hash [DEPLOYED_CONTRACT_HASH] \\ --session-entry-point &quot;set_data&quot; \\ --session-arg &quot;value:u32:'666'&quot; \\ --session-arg &quot;name:string='alice'&quot; \\ --session-arg &quot;name2:string='bob'&quot;  ","version":"2.0.0","tagName":"h3"},{"title":"Storage Layout​","type":1,"pageTitle":"Build, Deploy and Read the State of a Contract","url":"/docs/2.0.0/tutorials/build-deploy-read#storage-layout","content":"To read the state of the contract, we need to understand the storage layout. The first step is to calculate the index of the keys. Storage Layout CustomItem: prefix: 0x0..._0000_0000_0000 0 version: u32, 0x0..._0000_0000_0001 1 meta: Metadata, 0x0..._0000_0000_0010 2 data: Data: prefix: 0x0..._0000_0000_0011 3 value: u32, 0x0..._0000_0011_0001 (3 &lt;&lt; 4) + 1 inner: InnerData: prefix: 0x0..._0000_0011_0010 (3 &lt;&lt; 4) + 2 named_values: Mapping 0x0..._0011_0010_0001 ((3 &lt;&lt; 4) + 2) &lt;&lt; 4 + 1  The actual key is obtained as follows: Convert the index to a big-endian byte array.Concatenate the index with the mapping data.Hash the concatenated bytes using blake2b.Return the hex representation of the hash (the stored key must be utf-8 encoded). In more detail, the storage layout is described in the Storage Layout article. ","version":"2.0.0","tagName":"h3"},{"title":"Reading the state​","type":1,"pageTitle":"Build, Deploy and Read the State of a Contract","url":"/docs/2.0.0/tutorials/build-deploy-read#reading-the-state","content":"RustTypeScript main.rs use casper_client::{rpcs::DictionaryItemIdentifier, types::StoredValue, Verbosity}; use casper_types::{ bytesrepr::{FromBytes, ToBytes}, U256, }; // replace with your contract hash const CONTRACT_HASH: &amp;str = &quot;hash-...&quot;; const NODE_ADDRESS: &amp;str = &quot;http://localhost:11101/rpc&quot;; const RPC_ID: &amp;str = &quot;casper-net-1&quot;; const DICTIONARY_NAME: &amp;str = &quot;state&quot;; #[derive(Debug, PartialEq, Eq, Hash)] pub struct Metadata { name: String, description: String, prices: Vec&lt;Price&gt;, } #[derive(Debug, PartialEq, Eq, Hash)] pub struct Price { value: U256, } async fn read_state_key(key: String) -&gt; Vec&lt;u8&gt; { let state_root_hash = casper_client::get_state_root_hash( RPC_ID.to_string().into(), NODE_ADDRESS, Verbosity::Low, None, ) .await .unwrap() .result .state_root_hash .unwrap(); // Read the value from the `state` dictionary. let result = casper_client::get_dictionary_item( RPC_ID.to_string().into(), NODE_ADDRESS, Verbosity::Low, state_root_hash, DictionaryItemIdentifier::ContractNamedKey { key: CONTRACT_HASH.to_string(), dictionary_name: DICTIONARY_NAME.to_string(), dictionary_item_key: key, }, ) .await .unwrap() .result .stored_value; // We expect the value to be a CLValue if let StoredValue::CLValue(cl_value) = result { // Ignore the first 4 bytes, which are the length of the CLType. cl_value.inner_bytes()[4..].to_vec() } else { vec![] } } async fn metadata() -&gt; Metadata { // The key for the metadata is 2, and it has no mapping data let key = key(2, &amp;[]); let bytes = read_state_key(key).await; // Read the name and store the remaining bytes let (name, bytes) = String::from_bytes(&amp;bytes).unwrap(); // Read the description and store the remaining bytes let (description, bytes) = String::from_bytes(&amp;bytes).unwrap(); // A vector is stored as a u32 size followed by the elements // Read the size of the vector and store the remaining bytes let (size, mut bytes) = u32::from_bytes(&amp;bytes).unwrap(); let mut prices = vec![]; // As we know the size of the vector, we can loop over it for _ in 0..size { // Read the value and store the remaining bytes let (value, rem) = U256::from_bytes(&amp;bytes).unwrap(); bytes = rem; prices.push(Price { value }); } // Anytime you finish parsing a value, you should check if there are any remaining bytes // if there are, it means you have a bug in your parsing logic. // For simplicity, we will ignore the remaining bytes here. Metadata { name, description, prices } } async fn value() -&gt; u32 { // The key for the value is (3 &lt;&lt; 4) + 1, and it has no mapping data let key = key((3 &lt;&lt; 4) + 1, &amp;[]); let bytes = read_state_key(key).await; // Read the value and ignore the remaining bytes for simplicity u32::from_bytes(&amp;bytes).unwrap().0 } async fn named_value(name: &amp;str) -&gt; u32 { // The key for the named value is (((3 &lt;&lt; 4) + 2) &lt;&lt; 4) + 1, and the mapping data is the name as bytes let mapping_data = name.to_bytes().unwrap(); let key = key((((3 &lt;&lt; 4) + 2) &lt;&lt; 4) + 1, &amp;mapping_data); let bytes = read_state_key(key).await; // Read the value and ignore the remaining bytes for simplicity u32::from_bytes(&amp;bytes).unwrap().0 } fn main() { let runtime = tokio::runtime::Runtime::new().unwrap(); dbg!(runtime.block_on(metadata())); dbg!(runtime.block_on(value())); dbg!(runtime.block_on(named_value(&quot;alice&quot;))); dbg!(runtime.block_on(named_value(&quot;bob&quot;))); } // The key is a combination of the index and the mapping data // The algorithm is as follows: // 1. Convert the index to a big-endian byte array // 2. Concatenate the index with the mapping data // 3. Hash the concatenated bytes using blake2b // 4. Return the hex representation of the hash (the stored key must be utf-8 encoded) fn key(idx: u32, mapping_data: &amp;[u8]) -&gt; String { let mut key = Vec::new(); key.extend_from_slice(idx.to_be_bytes().as_ref()); key.extend_from_slice(mapping_data); let hashed_key = blake2b(&amp;key); hex::encode(&amp;hashed_key) } fn blake2b(bytes: &amp;[u8]) -&gt; [u8; 32] { let mut result = [0u8; 32]; let mut hasher = &lt;blake2::Blake2bVar as blake2::digest::VariableOutput&gt;::new(32) .expect(&quot;should create hasher&quot;); let _ = std::io::Write::write(&amp;mut hasher, bytes); blake2::digest::VariableOutput::finalize_variable(hasher, &amp;mut result) .expect(&quot;should copy hash to the result array&quot;); result } cargo run [src/main.rs:116:5] runtime.block_on(metadata()) = Metadata { name: &quot;My Contract&quot;, description: &quot;My Description&quot;, prices: [ Price { value: 123, }, Price { value: 321, }, ], } [src/main.rs:117:5] runtime.block_on(value()) = 666 [src/main.rs:118:5] runtime.block_on(named_value(&quot;alice&quot;)) = 20 [src/main.rs:119:5] runtime.block_on(named_value(&quot;bob&quot;)) = 10  ","version":"2.0.0","tagName":"h3"},{"title":"Deploying a Token on Casper Livenet","type":0,"sectionRef":"#","url":"/docs/2.0.0/tutorials/deploying-on-casper","content":"","keywords":"","version":"2.0.0"},{"title":"Casper Wallet​","type":1,"pageTitle":"Deploying a Token on Casper Livenet","url":"/docs/2.0.0/tutorials/deploying-on-casper#casper-wallet","content":"We will be using Casper Wallet to do some tasks in this tutorial. To install it, please follow the instructions on theofficial website. After setting up the wallet, extract the private key of the account you want to use for our testing. You can do this by clicking on the Menu &gt; Download account keys. danger You are solely responsible for the security of your private keys. We recommend creating a new account for the testing purposes. Why do we need the private key? We will use it in Odra to deploy our contract to the Casper network using Livenet backend. ","version":"2.0.0","tagName":"h2"},{"title":"Getting tokens​","type":1,"pageTitle":"Deploying a Token on Casper Livenet","url":"/docs/2.0.0/tutorials/deploying-on-casper#getting-tokens","content":"To deploy the contract on the Livenet, we need to have some CSPR. The easiest way to get them is to use the faucet, which will send us 1000 CSPR for free. Unfortunately, only on the Testnet. To use the faucet, go to the Casper Testnet Faucet. Log in using your Casper Wallet account and click on the &quot;Request Tokens&quot; button. note One account can request tokens only once. If you run out of tokens, you can either ask someone in the Casper community to send you some, or simply create a new account in the wallet. Now, when we have the tokens, we can deploy the contract. Let's do it using Odra! ","version":"2.0.0","tagName":"h2"},{"title":"Odra Livenet​","type":1,"pageTitle":"Deploying a Token on Casper Livenet","url":"/docs/2.0.0/tutorials/deploying-on-casper#odra-livenet","content":"Odra Livenet is described in detail in thebackends section of this documentation. We will then briefly describe how to use set it up in this tutorial. In your contract code, create a new file in the bin folder: bin/our_token_livenet.rs //! Deploys a new OurToken contract on the Casper livenet and mints some tokens for the tutorial //! creator. use std::str::FromStr; use odra::casper_types::U256; use odra::host::{Deployer, HostEnv, HostRef, HostRefLoader}; use odra::prelude::Address; use ourcoin::token::{OurToken, OurToken, OurTokenInitArgs}; fn main() { // Load the Casper livenet environment. let env = odra_casper_livenet_env::env(); // Caller is the deployer and the owner of the private key. let owner = env.caller(); // Just some random address... let recipient = &quot;hash-48bd92253a1370d1d913c56800296145547a243d13ff4f059ba4b985b1e94c26&quot;; let recipient = Address::from_str(recipient).unwrap(); // Deploy new contract. let mut token = deploy_our_token(&amp;env); println!(&quot;Token address: {}&quot;, token.address().to_string()); // Propose minting new tokens. env.set_gas(1_000_000_000u64); token.propose_new_mint(recipient, U256::from(1_000)); // Vote, we are the only voter. env.set_gas(1_000_000_000u64); token.vote(true, U256::from(1_000)); // Let's advance the block time by 11 minutes, as // we set the voting time to 10 minutes. // OH NO! It is the Livenet, so we need to wait real time... // Hopefully you are not in a hurry. env.advance_block_time(11 * 60 * 1000); // Tally the votes. env.set_gas(1_500_000_000u64); token.tally(); // Check the balances. println!(&quot;Owner's balance: {:?}&quot;, token.balance_of(&amp;owner)); println!( &quot;Tutorial creator's balance: {:?}&quot;, token.balance_of(&amp;recipient) ); } /// Deploys a contract. pub fn deploy_our_token(env: &amp;HostEnv) -&gt; OurTokenHostRef { let name = String::from(&quot;OurToken&quot;); let symbol = String::from(&quot;OT&quot;); let decimals = 0; let initial_supply = U256::from(1_000); let init_args = OurTokenInitArgs { name, symbol, decimals, initial_supply, }; env.set_gas(300_000_000_000u64); OurToken::deploy(env, init_args) } /// Loads a contract. Just in case you need to load an existing contract later... fn _load_our_token(env: &amp;HostEnv) -&gt; OurTokenHostRef { let address = &quot;hash-XXXXX&quot;; let address = Address::from_str(address).unwrap(); OurToken::load(env, address) }  In your Cargo.toml file, we need to add a new dependency, a feature and register the new binary. In the end, it should look like this: Cargo.toml [package] name = &quot;ourcoin&quot; version = &quot;0.1.0&quot; edition = &quot;2021&quot; [dependencies] odra = { version = &quot;1.4.0&quot;, features = [], default-features = false } odra-modules = { version = &quot;1.4.0&quot;, features = [], default-features = false } odra-casper-livenet-env = { version = &quot;1.4.0&quot;, optional = true } [dev-dependencies] odra-test = { version = &quot;1.4.0&quot;, features = [], default-features = false } [build-dependencies] odra-build = { version = &quot;1.4.0&quot;, features = [], default-features = false } [features] default = [] livenet = [&quot;odra-casper-livenet-env&quot;] [[bin]] name = &quot;ourcoin_build_contract&quot; path = &quot;bin/build_contract.rs&quot; test = false [[bin]] name = &quot;ourcoin_build_schema&quot; path = &quot;bin/build_schema.rs&quot; test = false [[bin]] name = &quot;our_token_livenet&quot; path = &quot;bin/our_token_livenet.rs&quot; required-features = [&quot;livenet&quot;] [profile.release] codegen-units = 1 lto = true [profile.dev.package.&quot;*&quot;] opt-level = 3  Finally, add the .env file with the following content: .env # Path to the secret key of the account that will be used to deploy the contracts. ODRA_CASPER_LIVENET_SECRET_KEY_PATH=folder_with_your_secret_key/secret_key_file.pem # RPC address of the node that will be used to deploy the contracts. ODRA_CASPER_LIVENET_NODE_ADDRESS=http://138.201.80.141:7777 # Chain name of the network. ODRA_CASPER_LIVENET_CHAIN_NAME=casper-test  Of course, you need to replace the secret key's path with the path to the secret key file you downloaded from the Casper Wallet. note One of the problems you may encounter is that the node you are using will be down or will not accept your calls. In this case, you will have to find and use another node IP address. Now, we will run our code: cargo run --bin our_token_livenet --features livenet  If everything is set up correctly, you should see the output similar to this:  Running `target/debug/our_token_livenet` 💁 INFO : Deploying &quot;OurToken&quot;. 💁 INFO : Found wasm under &quot;wasm/OurToken.wasm&quot;. 🙄 WAIT : Waiting 15s for &quot;e6b34772ebc3682702674102db87c633b0544242eafd5944e680371be4ea1227&quot;. 🙄 WAIT : Waiting 15s for &quot;e6b34772ebc3682702674102db87c633b0544242eafd5944e680371be4ea1227&quot;. 💁 INFO : Deploy &quot;e6b34772ebc3682702674102db87c633b0544242eafd5944e680371be4ea1227&quot; successfully executed. 💁 INFO : Contract &quot;hash-565bd0bde39c8c3dd79e49c037e05eac8add2b2193e86a91a6bac068e0de7857&quot; deployed. Token address: hash-565bd0bde39c8c3dd79e49c037e05eac8add2b2193e86a91a6bac068e0de7857 💁 INFO : Calling &quot;hash-565bd0bde39c8c3dd79e49c037e05eac8add2b2193e86a91a6bac068e0de7857&quot; with entrypoint &quot;propose_new_mint&quot;. 🙄 WAIT : Waiting 15s for &quot;2f89cc96b6f8f05b88f8e75bef3a2f0ba39e9ab761693afff49e4112aa9d7361&quot;. 🙄 WAIT : Waiting 15s for &quot;2f89cc96b6f8f05b88f8e75bef3a2f0ba39e9ab761693afff49e4112aa9d7361&quot;. 💁 INFO : Deploy &quot;2f89cc96b6f8f05b88f8e75bef3a2f0ba39e9ab761693afff49e4112aa9d7361&quot; successfully executed. 💁 INFO : Calling &quot;hash-565bd0bde39c8c3dd79e49c037e05eac8add2b2193e86a91a6bac068e0de7857&quot; with entrypoint &quot;vote&quot;. 🙄 WAIT : Waiting 15s for &quot;aca9ae847cfcb97c81b4c64992515ff14d6f63a60f7c141558463f5b752058a5&quot;. 🙄 WAIT : Waiting 15s for &quot;aca9ae847cfcb97c81b4c64992515ff14d6f63a60f7c141558463f5b752058a5&quot;. 💁 INFO : Deploy &quot;aca9ae847cfcb97c81b4c64992515ff14d6f63a60f7c141558463f5b752058a5&quot; successfully executed. 💁 INFO : advance_block_time called - Waiting for 660000 ms 💁 INFO : Calling &quot;hash-565bd0bde39c8c3dd79e49c037e05eac8add2b2193e86a91a6bac068e0de7857&quot; with entrypoint &quot;tally&quot;. 🙄 WAIT : Waiting 15s for &quot;223b135edbeadd88425183abaec0b0afb7d7770ffc57eba9054e3ea60e9e9cef&quot;. 🙄 WAIT : Waiting 15s for &quot;223b135edbeadd88425183abaec0b0afb7d7770ffc57eba9054e3ea60e9e9cef&quot;. 💁 INFO : Deploy &quot;223b135edbeadd88425183abaec0b0afb7d7770ffc57eba9054e3ea60e9e9cef&quot; successfully executed. Owner's balance: 1000 Tutorial creator's balance: 1000  Congratulations, your contract is now deployed on the Casper network! Before we move on, note the address of the token! We will use it in the next section to interact with the token. In our case it ishash-565bd0bde39c8c3dd79e49c037e05eac8add2b2193e86a91a6bac068e0de7857. ","version":"2.0.0","tagName":"h2"},{"title":"Cspr.live​","type":1,"pageTitle":"Deploying a Token on Casper Livenet","url":"/docs/2.0.0/tutorials/deploying-on-casper#csprlive","content":"The first thing we will do is to explore Casper's network block explorer,cspr.live. We can put the address of our token in the search bar to find it. note If you deployed your contract on the Testnet, remember to make sure that the Testnet network is selected in the dropdown menu in the top right corner. If everything is set up correctly, you should see the contract package's details. Besides the owner, keys etc., you can also see the contract's metdata, if it was developed using a standard that cspr.live supports. Indeed, we can see that it detected that our contract is a CEP-18 token! We see the name, symbol and total supply. All the mentions of the contract on the website will use the token name instead of the contract address.  Additionally, on the Token Txs tab, we can see the transactions that happened with the token. We can see the minting transaction we did in the previous section and transfers done during the voting process.  If we click on one of the accounts that recieved the tokens, we will go to the account page. Here, on the Tokens tab, we can see all the tokens that the account has - and OurToken is one of them! If you wish, you can check the status of the contract deployed during the development of this tutorial here. ","version":"2.0.0","tagName":"h2"},{"title":"Transferring Tokens using Casper Wallet​","type":1,"pageTitle":"Deploying a Token on Casper Livenet","url":"/docs/2.0.0/tutorials/deploying-on-casper#transferring-tokens-using-casper-wallet","content":"Casper wallet can do much more than just logging in to the faucet, exporting the private keys and transferring CSPR. It can also interact with the contracts deployed on the network. If you deployed the contract and left some OT tokens to yourself, you should see them in the Casper Wallet window. You should also be able to transfer them to another account!  ","version":"2.0.0","tagName":"h2"},{"title":"Conclusion​","type":1,"pageTitle":"Deploying a Token on Casper Livenet","url":"/docs/2.0.0/tutorials/deploying-on-casper#conclusion","content":"We've successfully deployed a token on the Casper network and interacted with it using the Odra backend and Casper Wallet. We've also learned how to use the cspr.live block explorer to check the status of your contract. Odra, Cspr.live and Casper Wallet are just a few of the tools that the Casper ecosystem provides. Feel free to explore them on casperecosystem.io. ","version":"2.0.0","tagName":"h2"},{"title":"CEP-18","type":0,"sectionRef":"#","url":"/docs/2.0.0/tutorials/cep18","content":"","keywords":"","version":"2.0.0"},{"title":"Self-governing token​","type":1,"pageTitle":"CEP-18","url":"/docs/2.0.0/tutorials/cep18#self-governing-token","content":"There are many ways to implement a governance mechanism for a token, each more complex than the other. In our example, we will use a simple one, where the community of token holders can vote to mint new tokens. ","version":"2.0.0","tagName":"h2"},{"title":"Token implementation​","type":1,"pageTitle":"CEP-18","url":"/docs/2.0.0/tutorials/cep18#token-implementation","content":"Let's start by creating a new project, choosing a clever name and using cep18 as our starting template: cargo odra new --name ourcoin --template cep18  Let's glance at our token code: src/token.rs #[odra::module] pub struct MyToken { token: SubModule&lt;Cep18&gt;, } impl MyToken { // Delegate all Cep18 functions to the token sub-module. delegate! { to self.token { ... fn name(&amp;self) -&gt; String; fn symbol(&amp;self) -&gt; String; ...  As we can see, it indeed uses the Cep18 module and delegates all the methods to it. The only thing to do is to change the name of the struct to more appropriate OurToken, run the provided tests using cargo odra test, and continue with the implementation of the governance. note Remember to change the name of the struct and its usages as well as the struct name in the Odra.toml file! ","version":"2.0.0","tagName":"h2"},{"title":"Governance implementation​","type":1,"pageTitle":"CEP-18","url":"/docs/2.0.0/tutorials/cep18#governance-implementation","content":"Let's go through the process of implementing the governance mechanism. If we don't want to, we don't have to hide entrypoints from the public responsible for minting new tokens. By default, minting Modalityis turned off, so any attempt of direct minting will result in an error. We will however implement a voting mechanism, where the token holders can vote to mint new tokens. ","version":"2.0.0","tagName":"h2"},{"title":"Voting mechanism​","type":1,"pageTitle":"CEP-18","url":"/docs/2.0.0/tutorials/cep18#voting-mechanism","content":"Our voting system will be straightforward: Anyone with the tokens can propose a new mint.Anyone with the tokens can vote for the new mint by staking their tokens.If the majority of the token holders vote for the mint, it is executed. Storage​ We will need to store some additional information about the votes, so let's add some fields to our token struct: src/token.rs #[odra::module] pub struct OurToken { /// A sub-module that implements the CEP-18 token standard. token: SubModule&lt;Cep18&gt;, /// The proposed mint. proposed_mint: Var&lt;(Address, U256)&gt;, /// The list of votes cast in the current vote. votes: List&lt;Ballot&gt;, /// Whether a vote is open. is_vote_open: Var&lt;bool&gt;, /// The time when the vote ends. vote_end_time: Var&lt;u64&gt;, } /// A ballot cast by a voter. #[odra::odra_type] struct Ballot { voter: Address, choice: bool, amount: U256, }  Notice that proposed_mint contains a tuple containing the address of the proposer and the amount of tokens to mint. Moreover, we need to keep track if the vote time has ended, but also if it was already tallied, that's why we need both is_vote_open and vote_end_time. We will also use the power of the Listtype to store the Ballots. Proposing a new mint​ To implement the endpoint that allows token holders to propose a new mint, we need to add a new function to our token module: src/token.rs /// Proposes a new mint for the contract. pub fn propose_new_mint(&amp;mut self, account: Address, amount: U256) { // Only allow proposing a new mint if there is no vote in progress. if self.is_vote_open().get_or_default() { self.env().revert(GovernanceError::VoteAlreadyOpen); } // Only the token holders can propose a new mint. if self.balance_of(&amp;self.env().caller()) == U256::zero() { self.env().revert(GovernanceError::OnlyTokenHoldersCanPropose); } // Set the proposed mint. self.proposed_mint.set((account, amount)); // Open a vote. self.is_vote_open.set(true); // Set the vote end time to 10 minutes from now. self.vote_end_time .set(self.env().get_block_time() + 60 * 10 * 1000); }  As a parameters to the function, we pass the address of the account that should be the receiver of the minted tokens, and the amount. After some validation, we open the vote by setting the is_vote_open to true, and setting the vote_end_time to 10 minutes. In real-world scenarios, the time could be configurable, but for the sake of simplicity, we hardcoded it. Also, it should be quite longer than 10 minutes, but it will come in handy when we test it on Livenet. Voting for the mint​ Next, we need an endpoint that will allow us to cast a ballot: src/token.rs /// Votes on the proposed mint. pub fn vote(&amp;mut self, choice: bool, amount: U256) { // Only allow voting if there is a vote in progress. self.assert_vote_in_progress(); let voter = self.env().caller(); let contract = self.env().self_address(); // Transfer the voting tokens from the voter to the contract. self.token .transfer(&amp;contract, &amp;amount); // Add the vote to the list. self.votes.push(Ballot { voter, choice, amount, }); }  The most interesting thing here is that we are using a mechanism of staking, where we transfer our tokens to the contract, to show that we really mean it. The tokens will be locked until the vote is over, and tallied. Speaking of tallying... Tallying the votes​ The last step is to tally the votes and mint the tokens if the majority of voters agreed to do so: src/token.rs /// Count the votes and perform the action pub fn tally(&amp;mut self) { // Only allow tallying the votes once. if !self.is_vote_open.get_or_default() { self.env().revert(GovernanceError::NoVoteInProgress); } // Only allow tallying the votes after the vote has ended. let finish_time = self .vote_end_time .get_or_revert_with(GovernanceError::NoVoteInProgress); if self.env().get_block_time() &lt; finish_time { self.env().revert(GovernanceError::VoteNotYetEnded); } // Count the votes let mut yes_votes = U256::zero(); let mut no_votes = U256::zero(); let contract = self.env().self_address(); while let Some(vote) = self.votes.pop() { if vote.choice { yes_votes += vote.amount; } else { no_votes += vote.amount; } // Transfer back the voting tokens to the voter. self.token.raw_transfer(&amp;contract, &amp;vote.voter, &amp;vote.amount); } // Perform the action if the vote has passed. if yes_votes &gt; no_votes { let (account, amount) = self .proposed_mint .get_or_revert_with(GovernanceError::NoVoteInProgress); self.token.raw_mint(&amp;account, &amp;amount); } // Close the vote. self.is_vote_open.set(false); }  Notice how we used raw_transfer from the Cep18 module. We used it to set the sender, so the contract's balance will be used, instead of the caller's. Additonally, we used raw_mint to mint the tokens, skipping the security checks. We have no modality for minting, but even if we had, we don't have anyone with permissions! The Contract needs to mint the tokens itself. ","version":"2.0.0","tagName":"h3"},{"title":"Testing​","type":1,"pageTitle":"CEP-18","url":"/docs/2.0.0/tutorials/cep18#testing","content":"Now, we will put our implementation to the test. One unit test, that we can run both on OdraVM and on the CasperVM. src/token.rs #[test] fn it_works() { let env = odra_test::env(); let init_args = OurTokenInitArgs { name: &quot;OurToken&quot;.to_string(), symbol: &quot;OT&quot;.to_string(), decimals: 0, initial_supply: U256::from(1_000u64), }; let mut token = OurToken::deploy(&amp;env, init_args); // The deployer, as the only token holder, // starts a new voting to mint 1000 tokens to account 1. // There is only 1 token holder, so there is one Ballot cast. token.propose_new_mint(env.get_account(1), U256::from(2000)); token.vote(true, U256::from(1000)); // The tokens should now be staked. assert_eq!(token.balance_of(&amp;env.get_account(0)), U256::zero()); // Wait for the vote to end. env.advance_block_time(60 * 11 * 1000); // Finish the vote. token.tally(); // The tokens should now be minted. assert_eq!(token.balance_of(&amp;env.get_account(1)), U256::from(2000)); assert_eq!(token.total_supply(), 3000.into()); // The stake should be returned. assert_eq!(token.balance_of(&amp;env.get_account(0)), U256::from(1000)); // Now account 1 can mint new tokens with their voting power... env.set_caller(env.get_account(1)); token.propose_new_mint(env.get_account(1), U256::from(2000)); token.vote(true, U256::from(2000)); // ...Even if the deployer votes against it. env.set_caller(env.get_account(0)); token.vote(false, U256::from(1000)); env.advance_block_time(60 * 11 * 1000); token.tally(); // The power of community governance! assert_eq!(token.balance_of(&amp;env.get_account(1)), U256::from(4000)); }  We can run the test using both methods: cargo odra test cargo odra test -b casper  It is all nice and green, but it would be really nice to see it in action. How about deploying it on the Casper network? ","version":"2.0.0","tagName":"h3"},{"title":"What's next​","type":1,"pageTitle":"CEP-18","url":"/docs/2.0.0/tutorials/cep18#whats-next","content":"We will se our token in action, by deploying it on the Casper network, and using tools from the Casper Ecosystem to interact with it. ","version":"2.0.0","tagName":"h2"},{"title":"Complete code​","type":1,"pageTitle":"CEP-18","url":"/docs/2.0.0/tutorials/cep18#complete-code","content":"Here is the complete code of the OurToken module: src/token.rs use odra::{casper_types::U256, prelude::*}; use odra_modules::cep18_token::Cep18; /// A ballot cast by a voter. #[odra::odra_type] struct Ballot { voter: Address, choice: bool, amount: U256, } /// Errors for the governed token. #[odra::odra_error] pub enum GovernanceError { /// The vote is already in progress. VoteAlreadyOpen = 0, /// No vote is in progress. NoVoteInProgress = 1, /// Cannot tally votes yet. VoteNotYetEnded = 2, /// Vote ended VoteEnded = 3, /// Only the token holders can propose a new mint. OnlyTokenHoldersCanPropose = 4, } /// A module definition. Each module struct consists of Vars and Mappings /// or/and other modules. #[odra::module] pub struct OurToken { /// A submodule that implements the CEP-18 token standard. token: SubModule&lt;Cep18&gt;, /// The proposed mint. proposed_mint: Var&lt;(Address, U256)&gt;, /// The list of votes cast in the current vote. votes: List&lt;Ballot&gt;, /// Whether a vote is open. is_vote_open: Var&lt;bool&gt;, /// The time when the vote ends. vote_end_time: Var&lt;u64&gt;, } /// Module implementation. /// /// To generate entrypoints, /// an implementation block must be marked as #[odra::module]. #[odra::module] impl OurToken { /// Initializes the contract with the given metadata and initial supply. pub fn init(&amp;mut self, name: String, symbol: String, decimals: u8, initial_supply: U256) { // We put the token address as an admin, so it can govern itself. Self-governing token! self.token .init(symbol, name, decimals, initial_supply, vec![], vec![], None); } // Delegate all Cep18 functions to the token submodule. delegate! { to self.token { /// Admin EntryPoint to manipulate the security access granted to users. /// One user can only possess one access group badge. /// Change strength: None &gt; Admin &gt; Minter /// Change strength meaning by example: If a user is added to both Minter and Admin, they will be an /// Admin, also if a user is added to Admin and None then they will be removed from having rights. /// Beware: do not remove the last Admin because that will lock out all admin functionality. fn change_security( &amp;mut self, admin_list: Vec&lt;Address&gt;, minter_list: Vec&lt;Address&gt;, none_list: Vec&lt;Address&gt; ); /// Returns the name of the token. fn name(&amp;self) -&gt; String; /// Returns the symbol of the token. fn symbol(&amp;self) -&gt; String; /// Returns the number of decimals the token uses. fn decimals(&amp;self) -&gt; u8; /// Returns the total supply of the token. fn total_supply(&amp;self) -&gt; U256; /// Returns the balance of the given address. fn balance_of(&amp;self, address: &amp;Address) -&gt; U256; /// Returns the amount of tokens the owner has allowed the spender to spend. fn allowance(&amp;self, owner: &amp;Address, spender: &amp;Address) -&gt; U256; /// Approves the spender to spend the given amount of tokens on behalf of the caller. fn approve(&amp;mut self, spender: &amp;Address, amount: &amp;U256); /// Decreases the allowance of the spender by the given amount. fn decrease_allowance(&amp;mut self, spender: &amp;Address, decr_by: &amp;U256); /// Increases the allowance of the spender by the given amount. fn increase_allowance(&amp;mut self, spender: &amp;Address, inc_by: &amp;U256); /// Transfers tokens from the caller to the recipient. fn transfer(&amp;mut self, recipient: &amp;Address, amount: &amp;U256); /// Transfers tokens from the owner to the recipient using the spender's allowance. fn transfer_from(&amp;mut self, owner: &amp;Address, recipient: &amp;Address, amount: &amp;U256); /// Mints new tokens and assigns them to the given address. fn mint(&amp;mut self, owner: &amp;Address, amount: &amp;U256); /// Burns the given amount of tokens from the given address. fn burn(&amp;mut self, owner: &amp;Address, amount: &amp;U256); } } /// Proposes a new mint for the contract. pub fn propose_new_mint(&amp;mut self, account: Address, amount: U256) { // Only allow proposing a new mint if there is no vote in progress. if self.is_vote_open.get_or_default() { self.env().revert(GovernanceError::VoteAlreadyOpen); } // Only the token holders can propose a new mint. if self.balance_of(&amp;self.env().caller()) == U256::zero() { self.env() .revert(GovernanceError::OnlyTokenHoldersCanPropose); } // Set the proposed mint. self.proposed_mint.set((account, amount)); // Open a vote. self.is_vote_open.set(true); // Set the vote end time to 10 minutes from now. self.vote_end_time .set(self.env().get_block_time() + 10 * 60 * 1000); } /// Votes on the proposed mint. pub fn vote(&amp;mut self, choice: bool, amount: U256) { // Only allow voting if there is a vote in progress. self.assert_vote_in_progress(); let voter = self.env().caller(); let contract = self.env().self_address(); // Transfer the voting tokens from the voter to the contract. self.token.transfer(&amp;contract, &amp;amount); // Add the vote to the list. self.votes.push(Ballot { voter, choice, amount, }); } /// Count the votes and perform the action pub fn tally(&amp;mut self) { // Only allow tallying the votes once. if !self.is_vote_open.get_or_default() { self.env().revert(GovernanceError::NoVoteInProgress); } // Only allow tallying the votes after the vote has ended. let finish_time = self .vote_end_time .get_or_revert_with(GovernanceError::NoVoteInProgress); if self.env().get_block_time() &lt; finish_time { self.env().revert(GovernanceError::VoteNotYetEnded); } // Count the votes let mut yes_votes = U256::zero(); let mut no_votes = U256::zero(); let contract = self.env().self_address(); while let Some(vote) = self.votes.pop() { if vote.choice { yes_votes += vote.amount; } else { no_votes += vote.amount; } // Transfer back the voting tokens to the voter. self.token .raw_transfer(&amp;contract, &amp;vote.voter, &amp;vote.amount); } // Perform the action if the vote has passed. if yes_votes &gt; no_votes { let (account, amount) = self .proposed_mint .get_or_revert_with(GovernanceError::NoVoteInProgress); self.token.raw_mint(&amp;account, &amp;amount); } // Close the vote. self.is_vote_open.set(false); } fn assert_vote_in_progress(&amp;self) { if !self.is_vote_open.get_or_default() { self.env().revert(GovernanceError::NoVoteInProgress); } let finish_time = self .vote_end_time .get_or_revert_with(GovernanceError::NoVoteInProgress); if self.env().get_block_time() &gt; finish_time { self.env().revert(GovernanceError::VoteEnded); } } } #[cfg(test)] mod tests { use super::*; use odra::host::Deployer; #[test] fn it_works() { let env = odra_test::env(); let init_args = OurTokenInitArgs { name: &quot;OurToken&quot;.to_string(), symbol: &quot;OT&quot;.to_string(), decimals: 0, initial_supply: U256::from(1_000u64), }; let mut token = OurToken::deploy(&amp;env, init_args); // The deployer, as the only token holder, // starts a new voting to mint 1000 tokens to account 1. // There is only 1 token holder, so there is one Ballot cast. token.propose_new_mint(env.get_account(1), U256::from(2000)); token.vote(true, U256::from(1000)); // The tokens should now be staked. assert_eq!(token.balance_of(&amp;env.get_account(0)), U256::zero()); // Wait for the vote to end. env.advance_block_time(60 * 11 * 1000); // Finish the vote. token.tally(); // The tokens should now be minted. assert_eq!(token.balance_of(&amp;env.get_account(1)), U256::from(2000)); assert_eq!(token.total_supply(), 3000.into()); // The stake should be returned. assert_eq!(token.balance_of(&amp;env.get_account(0)), U256::from(1000)); // Now account 1 can mint new tokens with their voting power... env.set_caller(env.get_account(1)); token.propose_new_mint(env.get_account(1), U256::from(2000)); token.vote(true, U256::from(2000)); // ...Even if the deployer votes against it. env.set_caller(env.get_account(0)); token.vote(false, U256::from(1000)); env.advance_block_time(60 * 11 * 1000); token.tally(); // The power of community governance! assert_eq!(token.balance_of(&amp;env.get_account(1)), U256::from(4000)); } }  ","version":"2.0.0","tagName":"h2"},{"title":"Migration guide to v0.8.0","type":0,"sectionRef":"#","url":"/docs/2.0.0/migrations/to-0.8.0","content":"","keywords":"","version":"2.0.0"},{"title":"1. Prerequisites​","type":1,"pageTitle":"Migration guide to v0.8.0","url":"/docs/2.0.0/migrations/to-0.8.0#1-prerequisites","content":"","version":"2.0.0","tagName":"h2"},{"title":"1.1. Update cargo-odra​","type":1,"pageTitle":"Migration guide to v0.8.0","url":"/docs/2.0.0/migrations/to-0.8.0#11-update-cargo-odra","content":"Before you begin the migration process, make sure you installed the latest version of the Cargo Odra toolchain. You can install it by running the following command: cargo install cargo-odra --force --locked  ","version":"2.0.0","tagName":"h3"},{"title":"1.2. Review the Changelog​","type":1,"pageTitle":"Migration guide to v0.8.0","url":"/docs/2.0.0/migrations/to-0.8.0#12-review-the-changelog","content":"Before you move to changing your code, start by reviewing the Changelog to understand the changes introduced in v0.8.0. ","version":"2.0.0","tagName":"h3"},{"title":"2. Migration Steps​","type":1,"pageTitle":"Migration guide to v0.8.0","url":"/docs/2.0.0/migrations/to-0.8.0#2-migration-steps","content":"","version":"2.0.0","tagName":"h2"},{"title":"2.1 Add bin directory​","type":1,"pageTitle":"Migration guide to v0.8.0","url":"/docs/2.0.0/migrations/to-0.8.0#21-add-bin-directory","content":"Odra 0.8.0 introduces a new way to build smart contracts. The .builder_casper directory is no longer used. Instead, you should create a new directory called bin in the root of your project and add the build_contract.rs and build_schema.rs files to the bin directory. You can find the build_contract.rs and build_schema.rs files in templates directory in the Odra main repository. You can choose whatever template you want to use and copy the files to your project. In both files, you should replace {{project-name}} with the name of your project. ","version":"2.0.0","tagName":"h3"},{"title":"2.2. Update Cargo.toml​","type":1,"pageTitle":"Migration guide to v0.8.0","url":"/docs/2.0.0/migrations/to-0.8.0#22-update-cargotoml","content":"There a bunch of changes in the Cargo.toml file. You don't have to specify the features anymore - remove the features section and default-features flag from the odra dependency.Register bins you added in the previous step.Add dev-dependencies section with odra-test crate.Add recommended profiles for release and dev to optimize the build process. Below you can compare the Cargo.toml file after and before the migration to v0.8.0: 0.8.0Prev [package] name = &quot;my_project&quot; version = &quot;0.1.0&quot; edition = &quot;2021&quot; [dependencies] odra = &quot;0.8.0&quot; [dev-dependencies] odra-test = &quot;0.8.0&quot; [[bin]] name = &quot;my_project_build_contract&quot; path = &quot;bin/build_contract.rs&quot; test = false [[bin]] name = &quot;my_project_build_schema&quot; path = &quot;bin/build_schema.rs&quot; test = false [profile.release] codegen-units = 1 lto = true [profile.dev.package.&quot;*&quot;] opt-level = 3  ","version":"2.0.0","tagName":"h3"},{"title":"2.2. Update Odra.toml​","type":1,"pageTitle":"Migration guide to v0.8.0","url":"/docs/2.0.0/migrations/to-0.8.0#22-update-odratoml","content":"Due to the changes in cargo-odra, the Odra.toml file has been simplified. The name property is no longer required. 0.8.0Prev [[contracts]] fqn = &quot;my_project::Flipper&quot;  ","version":"2.0.0","tagName":"h3"},{"title":"2.3. Update Smart Contracts​","type":1,"pageTitle":"Migration guide to v0.8.0","url":"/docs/2.0.0/migrations/to-0.8.0#23-update-smart-contracts","content":"The smart contracts themselves will need to be updated to work with the new version of the framework. The changes will depend on the specific features and APIs used in the contracts. Here are some common changes you might need to make: 2.3.1. Update the use statements to reflect the new module structure.​ Big integer types are now located in the odra::casper_types module.odra::types::Address is now odra::Address.Variable is now Var.Remove odra::contract_env.Remove odra::types::event::OdraEvent.Remove odra::types::OdraType as it is no longer required.Change odra::types::casper_types::*; to odra::casper_types::*;. 2.3.2. Some type aliases are no longer in use.​ Balance - use odra::casper_types::U512.BlockTime - use u64.EventData - use odra::casper_types::bytesrepr::Bytes. 2.3.3. Consider import odra::prelude::* in your module files.​ 2.3.4. Flatten nested Mappings.​ // Before #[odra::module(events = [Approval, Transfer])] pub struct Erc20 { ... allowances: Mapping&lt;Address, Mapping&lt;Address, U256&gt;&gt; } // After #[odra::module(events = [Approval, Transfer])] pub struct Erc20 { ... allowances: Mapping&lt;(Address, Address), U256&gt; }  2.3.5. Update errors definitions.​ execution_error! macro has been replace with OdraError derive macro. 0.8.0Prev use odra::OdraError; #[derive(OdraError)] pub enum Error { InsufficientBalance = 30_000, InsufficientAllowance = 30_001, NameNotSet = 30_002, SymbolNotSet = 30_003, DecimalsNotSet = 30_004 }  2.3.6. Update events definitions.​ 0.8.0Prev use odra::prelude::*; use odra::Event; #[derive(Event, Eq, PartialEq, Debug)] pub struct Transfer { pub from: Option&lt;Address&gt;, pub to: Option&lt;Address&gt;, pub amount: U256 } // Emitting the event self.env().emit_event(Transfer { from: None, to: Some(*address), amount: *amount });  2.3.7. Replace contract_env with self.env() in your modules.​ self.env() is a new way to access the contract environment, returns a reference to ContractEnv. The API is similar to the previous contract_env but with some changes. fn get_var&lt;T: FromBytes&gt;(key: &amp;[u8]) -&gt; Option&lt;T&gt; is now fn get_value&lt;T: FromBytes&gt;(&amp;self, key: &amp;[u8]) -&gt; Option&lt;T&gt;.fn set_var&lt;T: CLTyped + ToBytes&gt;(key: &amp;[u8], value: T) is now fn set_value&lt;T: ToBytes + CLTyped&gt;(&amp;self, key: &amp;[u8], value: T).set_dict_value() and get_dict_value() has been removed. All the dictionary operations should be performed using Mapping type, internally using set_var() and get_var() functions. fn hash&lt;T: AsRef&lt;[u8]&gt;&gt;(input: T) -&gt; Vec&lt;u8&gt; is now fn hash&lt;T: ToBytes&gt;(&amp;self, value: T) -&gt; [u8; 32].fn revert&lt;E: Into&lt;ExecutionError&gt;&gt;(error: E) -&gt; ! is now fn revert&lt;E: Into&lt;OdraError&gt;&gt;(&amp;self, error: E) -&gt; !.fn emit_event&lt;T: ToBytes + OdraEvent&gt;(event: T) is now fn emit_event&lt;T: ToBytes&gt;(&amp;self, event: T).fn call_contract&lt;T: CLTyped + FromBytes&gt;(address: Address, entrypoint: &amp;str, args: &amp;RuntimeArgs, amount: Option&lt;U512&gt;) -&gt; T is now fn call_contract&lt;T: FromBytes&gt;(&amp;self, address: Address, call: CallDef) -&gt; T.functions native_token_metadata() and one_token() have been removed. 2.3.8. Wrap submodules of your module with odra::SubModule&lt;T&gt;.​ 0.8.0Prev #[odra::module(events = [Transfer])] pub struct Erc721Token { core: SubModule&lt;Erc721Base&gt;, metadata: SubModule&lt;Erc721MetadataExtension&gt;, ownable: SubModule&lt;Ownable&gt; }  2.3.9. Update external contract calls.​ However the definition of an external contract remains the same, the way you call it has changed. A reference to an external contract is named {{ModuleName}}ContractRef (former {{ModuleName}}Ref) and you can call it using {{ModuleName}}ContractRef::new(env, address) (former {{ModuleName}}Ref::at()). 0.8.0Prev #[odra::external_contract] pub trait Token { fn balance_of(&amp;self, owner: &amp;Address) -&gt; U256; } // Usage TokenContractRef::new(env, token).balance_of(account)  2.3.10. Update constructors.​ Remove the #[odra::init] attribute from the constructor and ensure that the constructor function is named init. 2.3.11. Update UnwrapOrRevert calls.​ The functions unwrap_or_revert and unwrap_or_revert_with now require &amp;HostEnv as the first parameter. 2.3.12. Remove #[odra(using)] attribute from your module definition.​ Sharing the same instance of a module is no longer supported. A redesign of the module structure might be required. ","version":"2.0.0","tagName":"h3"},{"title":"2.4. Update Tests​","type":1,"pageTitle":"Migration guide to v0.8.0","url":"/docs/2.0.0/migrations/to-0.8.0#24-update-tests","content":"Once you've updated your smart contracts, you'll need to update your tests to reflect the changes. The changes will depend on the specific features and APIs used in the tests. Here are some common changes you might need to make: 2.4.1. Contract deployment.​ The way you deploy a contract has changed: You should use {{ModuleName}}HostRef::deploy(&amp;env, args) instead of {{ModuleName}}Deployer::init(). The {{ModuleName}}HostRef implements odra::host::Deployer.Instantiate the HostEnv using odra_test::env(), required by the odra::host::Deployer::deploy() function.If the contract doesn't have init args, you should use odra::host::NoArgs as the second argument of the deploy function.If the contract has init args, you should pass the autogenerated {{ModuleName}}InitArgs as the second argument of the deploy function. 0.8.0Prev // A contract without init args use super::OwnableHostRef; use odra::host::{Deployer, HostEnv, HostRef, NoArgs}; let env: HostEnv = odra_test::env(); let ownable = OwnableHostRef::deploy(&amp;env, NoArgs) // A contract with init args use super::{Erc20HostRef, Erc20InitArgs}; use odra::host::{Deployer, HostEnv}; let env: HostEnv = odra_test::env(); let init_args = Erc20InitArgs { symbol: SYMBOL.to_string(), name: NAME.to_string(), decimals: DECIMALS, initial_supply: Some(INITIAL_SUPPLY.into()) }; let erc20 = Erc20HostRef::deploy(&amp;env, init_args);  2.4.2. Host interactions.​ Replace odra::test_env with odra_test::env().The API of odra::test_env and odra_test::env() are similar, but there are some differences: test_env::advance_block_time_by(BlockTime) is now env.advance_block_time(u64).test_env::token_balance(Address) is now env.balance_of(&amp;Address).functions test_env::last_call_contract_gas_cost(), test_env::last_call_contract_gas_used(), test_env::total_gas_used(Address), test_env::gas_report() have been removed. You should use HostRef::last_call() and extract the data from a odra::ContractCallResult instance. HostRef is a trait implemented by {{ModuleName}}HostRef. 2.4.3. Testing failing scenarios.​ test_env::assert_exception() has been removed. You should use the try_ prefix to call the function and then assert the result.try_ prefix is a new way to call a function that might fail. It returns a OdraResult type, which you can then assert using the standard Rust assert_eq! macro. 0.8.0Prev #[test] fn transfer_from_error() { let (env, mut erc20) = setup(); let (owner, spender, recipient) = (env.get_account(0), env.get_account(1), env.get_account(2)); let amount = 1_000.into(); env.set_caller(spender); assert_eq!( erc20.try_transfer_from(owner, recipient, amount), Err(Error::InsufficientAllowance.into()) ); }  2.4.4. Testing events.​ assert_events! macro has been removed. You should use HostEnv::emitted_event() to assert the emitted events. The new API doesn't allow to assert multiple events at once, but adds alternative ways to assert the emitted events. Check the HostEnv documentation to explore the available options. 0.8.0Prev let env: HostEnv = odra_test::env(); let erc20 = Erc20HostRef::deploy(&amp;env, init_args); ... assert!(env.emitted_event( erc20.address(), &amp;Approval { owner, spender, value: approved_amount - transfer_amount } )); assert!(env.emitted_event( erc20.address(), &amp;Transfer { from: Some(owner), to: Some(recipient), amount: transfer_amount } ));  ","version":"2.0.0","tagName":"h3"},{"title":"3. Code Examples​","type":1,"pageTitle":"Migration guide to v0.8.0","url":"/docs/2.0.0/migrations/to-0.8.0#3-code-examples","content":"Here is a complete example of a smart contract after and before the migration to v0.8.0. 0.8.0Prev src/erc20.rs use crate::erc20::errors::Error::*; use crate::erc20::events::*; use odra::prelude::*; use odra::{casper_types::U256, Address, Mapping, Var}; #[odra::module(events = [Approval, Transfer])] pub struct Erc20 { decimals: Var&lt;u8&gt;, symbol: Var&lt;String&gt;, name: Var&lt;String&gt;, total_supply: Var&lt;U256&gt;, balances: Mapping&lt;Address, U256&gt;, allowances: Mapping&lt;(Address, Address), U256&gt; } #[odra::module] impl Erc20 { pub fn init( &amp;mut self, symbol: String, name: String, decimals: u8, initial_supply: Option&lt;U256&gt; ) { let caller = self.env().caller(); self.symbol.set(symbol); self.name.set(name); self.decimals.set(decimals); if let Some(initial_supply) = initial_supply { self.total_supply.set(initial_supply); self.balances.set(&amp;caller, initial_supply); if !initial_supply.is_zero() { self.env().emit_event(Transfer { from: None, to: Some(caller), amount: initial_supply }); } } } pub fn transfer(&amp;mut self, recipient: &amp;Address, amount: &amp;U256) { let caller = self.env().caller(); self.raw_transfer(&amp;caller, recipient, amount); } pub fn transfer_from(&amp;mut self, owner: &amp;Address, recipient: &amp;Address, amount: &amp;U256) { let spender = self.env().caller(); self.spend_allowance(owner, &amp;spender, amount); self.raw_transfer(owner, recipient, amount); } pub fn approve(&amp;mut self, spender: &amp;Address, amount: &amp;U256) { let owner = self.env().caller(); self.allowances.set(&amp;(owner, *spender), *amount); self.env().emit_event(Approval { owner, spender: *spender, value: *amount }); } pub fn name(&amp;self) -&gt; String { self.name.get_or_revert_with(NameNotSet) } // Other getter functions... pub fn allowance(&amp;self, owner: &amp;Address, spender: &amp;Address) -&gt; U256 { self.allowances.get_or_default(&amp;(*owner, *spender)) } pub fn mint(&amp;mut self, address: &amp;Address, amount: &amp;U256) { self.total_supply.add(*amount); self.balances.add(address, *amount); self.env().emit_event(Transfer { from: None, to: Some(*address), amount: *amount }); } pub fn burn(&amp;mut self, address: &amp;Address, amount: &amp;U256) { if self.balance_of(address) &lt; *amount { self.env().revert(InsufficientBalance); } self.total_supply.subtract(*amount); self.balances.subtract(address, *amount); self.env().emit_event(Transfer { from: Some(*address), to: None, amount: *amount }); } } impl Erc20 { fn raw_transfer(&amp;mut self, owner: &amp;Address, recipient: &amp;Address, amount: &amp;U256) { if *amount &gt; self.balances.get_or_default(owner) { self.env().revert(InsufficientBalance) } self.balances.subtract(owner, *amount); self.balances.add(recipient, *amount); self.env().emit_event(Transfer { from: Some(*owner), to: Some(*recipient), amount: *amount }); } fn spend_allowance(&amp;mut self, owner: &amp;Address, spender: &amp;Address, amount: &amp;U256) { let allowance = self.allowances.get_or_default(&amp;(*owner, *spender)); if allowance &lt; *amount { self.env().revert(InsufficientAllowance) } self.allowances.subtract(&amp;(*owner, *spender), *amount); self.env().emit_event(Approval { owner: *owner, spender: *spender, value: allowance - *amount }); } } pub mod events { use odra::prelude::*; use odra::{casper_types::U256, Address, Event}; #[derive(Event, Eq, PartialEq, Debug)] pub struct Transfer { pub from: Option&lt;Address&gt;, pub to: Option&lt;Address&gt;, pub amount: U256 } #[derive(Event, Eq, PartialEq, Debug)] pub struct Approval { pub owner: Address, pub spender: Address, pub value: U256 } } pub mod errors { use odra::OdraError; #[derive(OdraError)] pub enum Error { InsufficientBalance = 30_000, InsufficientAllowance = 30_001, NameNotSet = 30_002, SymbolNotSet = 30_003, DecimalsNotSet = 30_004 } } #[cfg(test)] mod tests { use super::{ errors::Error, events::{Approval, Transfer}, Erc20HostRef, Erc20InitArgs }; use odra::{ casper_types::U256, host::{Deployer, HostEnv, HostRef}, prelude::* }; const NAME: &amp;str = &quot;Plascoin&quot;; const SYMBOL: &amp;str = &quot;PLS&quot;; const DECIMALS: u8 = 10; const INITIAL_SUPPLY: u32 = 10_000; fn setup() -&gt; (HostEnv, Erc20HostRef) { let env = odra_test::env(); ( env.clone(), Erc20HostRef::deploy( &amp;env, Erc20InitArgs { symbol: SYMBOL.to_string(), name: NAME.to_string(), decimals: DECIMALS, initial_supply: Some(INITIAL_SUPPLY.into()) } ) ) } #[test] fn initialization() { // When deploy a contract with the initial supply. let (env, erc20) = setup(); // Then the contract has the metadata set. assert_eq!(erc20.symbol(), SYMBOL.to_string()); assert_eq!(erc20.name(), NAME.to_string()); assert_eq!(erc20.decimals(), DECIMALS); // Then the total supply is updated. assert_eq!(erc20.total_supply(), INITIAL_SUPPLY.into()); // Then a Transfer event was emitted. assert!(env.emitted_event( erc20.address(), &amp;Transfer { from: None, to: Some(env.get_account(0)), amount: INITIAL_SUPPLY.into() } )); } #[test] fn transfer_works() { // Given a new contract. let (env, mut erc20) = setup(); // When transfer tokens to a recipient. let sender = env.get_account(0); let recipient = env.get_account(1); let amount = 1_000.into(); erc20.transfer(&amp;recipient, &amp;amount); // Then the sender balance is deducted. assert_eq!( erc20.balance_of(&amp;sender), U256::from(INITIAL_SUPPLY) - amount ); // Then the recipient balance is updated. assert_eq!(erc20.balance_of(&amp;recipient), amount); // Then Transfer event was emitted. assert!(env.emitted_event( erc20.address(), &amp;Transfer { from: Some(sender), to: Some(recipient), amount } )); } #[test] fn transfer_error() { // Given a new contract. let (env, mut erc20) = setup(); // When the transfer amount exceeds the sender balance. let recipient = env.get_account(1); let amount = U256::from(INITIAL_SUPPLY) + U256::one(); // Then an error occurs. assert!(erc20.try_transfer(&amp;recipient, &amp;amount).is_err()); } // Other tests... }  ","version":"2.0.0","tagName":"h2"},{"title":"4. Troubleshooting​","type":1,"pageTitle":"Migration guide to v0.8.0","url":"/docs/2.0.0/migrations/to-0.8.0#4-troubleshooting","content":"If you encounter any further issues after completing the migration steps, please don't hesitate to reach out to us on Discord or explore the other sections this documentation. You can also refer to the technical documentation for more detailed information. Additionally, our examples repository offers a wide range of examples to assist you in understanding the new features and APIs. Be sure to carefully review any compilation errors and warnings, as they may provide valuable insights into the necessary adjustments. ","version":"2.0.0","tagName":"h2"},{"title":"5. References​","type":1,"pageTitle":"Migration guide to v0.8.0","url":"/docs/2.0.0/migrations/to-0.8.0#5-references","content":"ChangelogOdra DocumentationDocs.rsExamples ","version":"2.0.0","tagName":"h2"},{"title":"ERC-20","type":0,"sectionRef":"#","url":"/docs/2.0.0/tutorials/erc20","content":"","keywords":"","version":"2.0.0"},{"title":"Framework features​","type":1,"pageTitle":"ERC-20","url":"/docs/2.0.0/tutorials/erc20#framework-features","content":"A module we will write in a minute, will help you master a few Odra features: Advanced storage using key-value pairs,Odra types such as Address,Advanced event assertion. ","version":"2.0.0","tagName":"h2"},{"title":"Code​","type":1,"pageTitle":"ERC-20","url":"/docs/2.0.0/tutorials/erc20#code","content":"Our module features a considerably more complex storage layout compared to the previous example. It is designed to store the following data: Immutable metadata - name, symbol, and decimals.Total supply.Balances of individual users.Allowances, essentially indicating who is permitted to spend tokens on behalf of another user. ","version":"2.0.0","tagName":"h2"},{"title":"Module definition​","type":1,"pageTitle":"ERC-20","url":"/docs/2.0.0/tutorials/erc20#module-definition","content":"erc20.rs use odra::prelude::*; use odra::casper_types::U256; #[odra::module(events = [Transfer, Approval])] pub struct Erc20 { decimals: Var&lt;u8&gt;, symbol: Var&lt;String&gt;, name: Var&lt;String&gt;, total_supply: Var&lt;U256&gt;, balances: Mapping&lt;Address, U256&gt;, allowances: Mapping&lt;(Address, Address), U256&gt; }  L10 - For the first time, we need to store key-value pairs. In order to do that, we use Mapping. The name is taken after Solidity's native type mapping.L11 - Odra does not allows nested Mappings as Solidity does. Instead, you can create a compound key using a tuple of keys. ","version":"2.0.0","tagName":"h2"},{"title":"Metadata​","type":1,"pageTitle":"ERC-20","url":"/docs/2.0.0/tutorials/erc20#metadata","content":"erc20.rs #[odra::module] impl Erc20 { pub fn init(&amp;mut self, name: String, symbol: String, decimals: u8, initial_supply: U256) { let caller = self.env().caller(); self.name.set(name); self.symbol.set(symbol); self.decimals.set(decimals); self.mint(&amp;caller, &amp;initial_supply); } pub fn name(&amp;self) -&gt; String { self.name.get_or_default() } pub fn symbol(&amp;self) -&gt; String { self.symbol.get_or_default() } pub fn decimals(&amp;self) -&gt; u8 { self.decimals.get_or_default() } pub fn total_supply(&amp;self) -&gt; U256 { self.total_supply.get_or_default() } } impl Erc20 { pub fn mint(&amp;mut self, address: &amp;Address, amount: &amp;U256) { self.balances.add(address, *amount); self.total_supply.add(*amount); self.env().emit_event(Transfer { from: None, to: Some(*address), amount: *amount }); } } #[odra::event] pub struct Transfer { pub from: Option&lt;Address&gt;, pub to: Option&lt;Address&gt;, pub amount: U256 }  L1 - The first impl block, marked as a module, contains functions defined in the ERC-20 standard.L3-L9 - A constructor sets the token metadata and mints the initial supply.L28 - The second impl is not an Odra module; in other words, these functions will not be part of the contract's public interface.L29-L38 - The mint function is public, so, like in regular Rust code, it will be accessible from the outside. mint() uses the notation self.balances.add(address, *amount);, which is syntactic sugar for: let current_balance = self.balances.get(address).unwrap_or_default(); let new_balance = &lt;U256 as OverflowingAdd&gt;::overflowing_add(current_balance, current_balance).unwrap_or_revert(&amp;self.env()); self.balances.set(address, new_balance);  ","version":"2.0.0","tagName":"h3"},{"title":"Core​","type":1,"pageTitle":"ERC-20","url":"/docs/2.0.0/tutorials/erc20#core","content":"To ensure comprehensive functionality, let's implement the remaining features such as transfer, transfer_from, and approve. Since they do not introduce any new concepts, we will present them without additional remarks. erc20.rs #[odra::module] impl Erc20 { ... pub fn transfer(&amp;mut self, recipient: &amp;Address, amount: &amp;U256) { let caller = self.env().caller(); self.raw_transfer(&amp;caller, recipient, amount); } pub fn transfer_from(&amp;mut self, owner: &amp;Address, recipient: &amp;Address, amount: &amp;U256) { let spender = self.env().caller(); self.spend_allowance(owner, &amp;spender, amount); self.raw_transfer(owner, recipient, amount); } pub fn approve(&amp;mut self, spender: &amp;Address, amount: &amp;U256) { let owner = self.env().caller(); self.allowances.set(&amp;(owner, *spender), *amount); self.env().emit_event(Approval { owner, spender: *spender, value: *amount }); } pub fn balance_of(&amp;self, address: &amp;Address) -&gt; U256 { self.balances.get_or_default(&amp;address) } pub fn allowance(&amp;self, owner: &amp;Address, spender: &amp;Address) -&gt; U256 { self.allowances.get_or_default(&amp;(*owner, *spender)) } } impl Erc20 { ... fn raw_transfer(&amp;mut self, owner: &amp;Address, recipient: &amp;Address, amount: &amp;U256) { let owner_balance = self.balances.get_or_default(&amp;owner); if *amount &gt; owner_balance { self.env().revert(Error::InsufficientBalance) } self.balances.set(owner, owner_balance - *amount); self.balances.add(recipient, *amount); self.env().emit_event(Transfer { from: Some(*owner), to: Some(*recipient), amount: *amount }); } fn spend_allowance(&amp;mut self, owner: &amp;Address, spender: &amp;Address, amount: &amp;U256) { let allowance = self.allowance(owner, spender); if allowance &lt; *amount { self.env().revert(Error::InsufficientAllowance) } let new_allowance = allowance - *amount; self.allowances .set(&amp;(*owner, *spender), new_allowance); self.env().emit_event(Approval { owner: *owner, spender: *spender, value: allowance - *amount }); } } #[odra::event] pub struct Approval { pub owner: Address, pub spender: Address, pub value: U256 } #[odra::odra_error] pub enum Error { InsufficientBalance = 1, InsufficientAllowance = 2, }  Now, compare the code we have written, with Open Zeppelin code. Out of 10, how Solidity-ish is our implementation? ","version":"2.0.0","tagName":"h3"},{"title":"Test​","type":1,"pageTitle":"ERC-20","url":"/docs/2.0.0/tutorials/erc20#test","content":"erc20.rs #[cfg(test)] pub mod tests { use super::*; use odra::{casper_types::U256, host::{Deployer, HostEnv, HostRef}}; const NAME: &amp;str = &quot;Plascoin&quot;; const SYMBOL: &amp;str = &quot;PLS&quot;; const DECIMALS: u8 = 10; const INITIAL_SUPPLY: u32 = 10_000; fn setup() -&gt; (HostEnv, Erc20HostRef) { let env = odra_test::env(); ( env.clone(), Erc20::deploy( &amp;env, Erc20InitArgs { symbol: SYMBOL.to_string(), name: NAME.to_string(), decimals: DECIMALS, initial_supply: INITIAL_SUPPLY.into() } ) ) } #[test] fn initialization() { // When deploy a contract with the initial supply. let (env, erc20) = setup(); // Then the contract has the metadata set. assert_eq!(erc20.symbol(), SYMBOL.to_string()); assert_eq!(erc20.name(), NAME.to_string()); assert_eq!(erc20.decimals(), DECIMALS); // Then the total supply is updated. assert_eq!(erc20.total_supply(), INITIAL_SUPPLY.into()); // Then a Transfer event was emitted. assert!(env.emitted_event( &amp;erc20, &amp;Transfer { from: None, to: Some(env.get_account(0)), amount: INITIAL_SUPPLY.into() } )); } #[test] fn transfer_works() { // Given a new contract. let (env, mut erc20) = setup(); // When transfer tokens to a recipient. let sender = env.get_account(0); let recipient = env.get_account(1); let amount = 1_000.into(); erc20.transfer(&amp;recipient, &amp;amount); // Then the sender balance is deducted. assert_eq!( erc20.balance_of(&amp;sender), U256::from(INITIAL_SUPPLY) - amount ); // Then the recipient balance is updated. assert_eq!(erc20.balance_of(&amp;recipient), amount); // Then Transfer event was emitted. assert!(env.emitted_event( &amp;erc20, &amp;Transfer { from: Some(sender), to: Some(recipient), amount } )); } #[test] fn transfer_error() { // Given a new contract. let (env, mut erc20) = setup(); // When the transfer amount exceeds the sender balance. let recipient = env.get_account(1); let amount = U256::from(INITIAL_SUPPLY) + U256::one(); // Then an error occurs. assert!(erc20.try_transfer(&amp;recipient, &amp;amount).is_err()); } #[test] fn transfer_from_and_approval_work() { let (env, mut erc20) = setup(); let (owner, recipient, spender) = (env.get_account(0), env.get_account(1), env.get_account(2)); let approved_amount = 3_000.into(); let transfer_amount = 1_000.into(); assert_eq!(erc20.balance_of(&amp;owner), U256::from(INITIAL_SUPPLY)); // Owner approves Spender. erc20.approve(&amp;spender, &amp;approved_amount); // Allowance was recorded. assert_eq!(erc20.allowance(&amp;owner, &amp;spender), approved_amount); assert!(env.emitted_event( &amp;erc20, &amp;Approval { owner, spender, value: approved_amount } )); // Spender transfers tokens from Owner to Recipient. env.set_caller(spender); erc20.transfer_from(&amp;owner, &amp;recipient, &amp;transfer_amount); // Tokens are transferred and allowance decremented. assert_eq!( erc20.balance_of(&amp;owner), U256::from(INITIAL_SUPPLY) - transfer_amount ); assert_eq!(erc20.balance_of(&amp;recipient), transfer_amount); assert!(env.emitted_event( &amp;erc20, &amp;Approval { owner, spender, value: approved_amount - transfer_amount } )); assert!(env.emitted_event( &amp;erc20, &amp;Transfer { from: Some(owner), to: Some(recipient), amount: transfer_amount } )); // assert!(env.emitted(erc20.address(), &quot;Transfer&quot;)); } #[test] fn transfer_from_error() { // Given a new instance. let (env, mut erc20) = setup(); // When the spender's allowance is zero. let (owner, spender, recipient) = (env.get_account(0), env.get_account(1), env.get_account(2)); let amount = 1_000.into(); env.set_caller(spender); // Then transfer fails. assert_eq!( erc20.try_transfer_from(&amp;owner, &amp;recipient, &amp;amount), Err(Error::InsufficientAllowance.into()) ); } }  L146 - Alternatively, if you don't want to check the entire event, you may assert only its type. ","version":"2.0.0","tagName":"h3"},{"title":"What's next​","type":1,"pageTitle":"ERC-20","url":"/docs/2.0.0/tutorials/erc20#whats-next","content":"Having two modules: Ownable and Erc20, let's combine them, and create an ERC-20 on steroids. ","version":"2.0.0","tagName":"h2"},{"title":"Ticketing System","type":0,"sectionRef":"#","url":"/docs/2.0.0/tutorials/nft","content":"","keywords":"","version":"2.0.0"},{"title":"Ticket Office Contract​","type":1,"pageTitle":"Ticketing System","url":"/docs/2.0.0/tutorials/nft#ticket-office-contract","content":"Our TicketOffice contract will include the following features: Compliance with the CEP-78 standard.Ownership functionality.Only the owner can issue new event tickets.Users can purchase tickets for events.Tickets are limited to a one-time sale.Public access to view the total income of the TicketOffice. ","version":"2.0.0","tagName":"h3"},{"title":"Setup the project​","type":1,"pageTitle":"Ticketing System","url":"/docs/2.0.0/tutorials/nft#setup-the-project","content":"Creating a new NFT token with Odra is straightforward. Use the cargo odra new command to create a new project with the CEP-78 template: cargo odra new --name ticket-office --template cep78  ","version":"2.0.0","tagName":"h3"},{"title":"Contract implementation​","type":1,"pageTitle":"Ticketing System","url":"/docs/2.0.0/tutorials/nft#contract-implementation","content":"Let's start implementing the TicketOffice contract by modify the code generated from the template. src/token.rs use odra::{ args::Maybe, casper_types::U512, prelude::* }; use odra_modules::access::Ownable; use odra_modules::cep78::{ modalities::{MetadataMutability, NFTIdentifierMode, NFTKind, NFTMetadataKind, OwnershipMode}, token::Cep78, }; pub type TicketId = u64; #[odra::odra_type] pub enum TicketStatus { Available, Sold, } #[odra::odra_type] pub struct TicketInfo { event_name: String, price: U512, status: TicketStatus, } #[odra::event] pub struct OnTicketIssue { ticket_id: TicketId, event_name: String, price: U512, } #[odra::event] pub struct OnTicketSell { ticket_id: TicketId, buyer: Address, } #[odra::odra_error] pub enum Error { TicketNotAvailableForSale = 200, InsufficientFunds = 201, InvalidTicketId = 202, TicketDoesNotExist = 203, } #[odra::module( events = [OnTicketIssue, OnTicketSell], errors = Error )] pub struct TicketOffice { token: SubModule&lt;Cep78&gt;, ownable: SubModule&lt;Ownable&gt;, tickets: Mapping&lt;TicketId, TicketInfo&gt;, } #[odra::module] impl TicketOffice { pub fn init(&amp;mut self, collection_name: String, collection_symbol: String, total_supply: u64) { self.ownable.init(); let receipt_name = format!(&quot;cep78_{}&quot;, collection_name); self.token.init( collection_name, collection_symbol, total_supply, OwnershipMode::Transferable, NFTKind::Digital, NFTIdentifierMode::Ordinal, NFTMetadataKind::Raw, MetadataMutability::Immutable, receipt_name, // remaining args are optional and can set to Maybe::None ... ); } pub fn issue_ticket(&amp;mut self, event_name: String, price: U512) { let env = self.env(); let caller = env.caller(); self.ownable.assert_owner(&amp;caller); // mint a new token let (_, _, token_id) = self.token.mint(caller, &quot;&quot;.to_string(), Maybe::None); let ticket_id: u64 = token_id .parse() .map_err(|_| Error::InvalidTicketId) .unwrap_or_revert(&amp;env); // store ticket info self.tickets.set( &amp;ticket_id, TicketInfo { event_name: event_name.clone(), price, status: TicketStatus::Available, }, ); // emit an event env.emit_event(OnTicketIssue { ticket_id, event_name, price, }); } #[odra(payable)] pub fn buy_ticket(&amp;mut self, ticket_id: TicketId) { let env = self.env(); let owner = self.ownable.get_owner(); let buyer = env.caller(); let value = env.attached_value(); // only tokens owned by the owner can be sold if self.token.owner_of(Maybe::Some(ticket_id), Maybe::None) != owner { env.revert(Error::TicketNotAvailableForSale); } let mut ticket = self .tickets .get(&amp;ticket_id) .unwrap_or_revert_with(&amp;env, Error::TicketDoesNotExist); // only available tickets can be sold if ticket.status != TicketStatus::Available { env.revert(Error::TicketNotAvailableForSale); } // check if the buyer sends enough funds if value &lt; ticket.price { env.revert(Error::InsufficientFunds); } // transfer csprs to the owner env.transfer_tokens(&amp;owner, &amp;value); // transfer the ticket to the buyer self.token .transfer(Maybe::Some(ticket_id), Maybe::None, owner, buyer); ticket.status = TicketStatus::Sold; self.tickets.set(&amp;ticket_id, ticket); env.emit_event(OnTicketSell { ticket_id, buyer }); } pub fn balance_of(&amp;self) -&gt; U512 { self.env().self_balance() } }  L10-L44 - We define structures and enums that will be used in our contract. TicketStatus enum represents the status of a ticket, TicketInfo struct contains information about a ticket that is written to the storage, TicketId is a type alias for u64. OnTicketIssue and OnTicketSell are events that will be emitted when a ticket is issued or sold.L46-L49 - Register errors and events that will be used in our contract, required to produce a complete contract schema.L51-L53 - TicketOffice module definition. The module contains a Cep78 token, an Ownable module, and a Mapping that stores information about tickets.L58-L74 - The init function has been generated from the template and there is no need to modify it, except the Ownable module initialization.L76-L94 - The issue_ticket function allows the owner to issue a new ticket. The function mints a new token, stores information about the ticket, and emits an OnTicketIssue event.L103 - The payable attribute indicates that the buy_ticket function can receive funds.L104-L134 - The buy_ticket function checks if the ticket is available for sale, if the buyer sends enough funds, and transfers the ticket to the buyer. Finally, the function updates the ticket status and emits an OnTicketSell event. Lets test the contract. The test scenario will be as follows: Deploy the contract.Issue two tickets.Try to buy a ticket with insufficient funds.Buy tickets.Try to buy the same ticket again.Check the balance of the contract. src/tests.rs use odra::{ casper_types::U512, host::{Deployer, HostRef}, }; use crate::token::{Error, TicketOfficeHostRef, TicketOfficeInitArgs}; #[test] fn it_works() { let env = odra_test::env(); let init_args = TicketOfficeInitArgs { collection_name: &quot;Ticket&quot;.to_string(), collection_symbol: &quot;T&quot;.to_string(), total_supply: 100, }; let mut contract = TicketOffice::deploy(&amp;env, init_args); contract.issue_ticket(&quot;Ev&quot;.to_string(), U512::from(100)); contract.issue_ticket(&quot;Ev&quot;.to_string(), U512::from(50)); let buyer = env.get_account(1); env.set_caller(buyer); assert_eq!( contract .with_tokens(U512::from(50)) .try_buy_ticket(0), Err(Error::InsufficientFunds.into()) ); assert_eq!( contract .with_tokens(U512::from(100)) .try_buy_ticket(0), Ok(()) ); assert_eq!( contract .with_tokens(U512::from(50)) .try_buy_ticket(1), Ok(()) ); assert_eq!( contract .with_tokens(U512::from(100)) .try_buy_ticket(0), Err(Error::TicketNotAvailableForSale.into()) ); }  Unfortunately, the test failed. The first assertion succeeds because the buyer sends insufficient funds to buy the ticket. However, the second assertion fails even though the buyer sends enough funds to purchase the ticket. The buy_ticket function reverts with Cep78Error::InvalidTokenOwner because the buyer attempts to transfer a token that they do not own, are not approved for, or are not an operator of. odra/modules/src/cep78/token78.rs pub fn transfer( &amp;mut self, token_id: Maybe&lt;u64&gt;, token_hash: Maybe&lt;String&gt;, source_key: Address, target_key: Address ) -&gt; TransferReceipt { ... if !is_owner &amp;&amp; !is_approved &amp;&amp; !is_operator { self.revert(CEP78Error::InvalidTokenOwner); } ... }  Let's fix it by redesigning our little system. ","version":"2.0.0","tagName":"h3"},{"title":"Redesign​","type":1,"pageTitle":"Ticketing System","url":"/docs/2.0.0/tutorials/nft#redesign","content":"Since a buyer cannot purchase a ticket directly, we need to introduce an intermediary — an operator who will be responsible for buying tickets on behalf of the buyer. The operator will be approved by the ticket office to transfer tickets. The sequence diagram below illustrates the new flow: Ticket Operator Contract​ As shown in the sequence diagram, a new contract will act as an operator for the ticket office. To create this new contract, use the cargo odra generate command. cargo odra generate -c ticket_operator  src/ticket_operator.rs use crate::token::{TicketId, TicketOfficeContractRef}; use odra::{casper_types::U512, prelude::*}; #[odra::odra_error] pub enum Error { UnknownTicketOffice = 300, } #[odra::module(errors = Error)] pub struct TicketOperator { ticket_office_address: Var&lt;Address&gt;, } #[odra::module] impl TicketOperator { pub fn register(&amp;mut self, ticket_office_address: Address) { self.ticket_office_address.set(ticket_office_address); } // now the operator's `buy_ticket` receives funds. #[odra(payable)] pub fn buy_ticket(&amp;mut self, ticket_id: TicketId) { let env = self.env(); let buyer = env.caller(); let value = env.attached_value(); let center = self .ticket_office_address .get() .unwrap_or_revert_with(&amp;env, Error::UnknownTicketOffice); let mut ticket_contract = TicketOfficeContractRef::new(env, center); // now and approved entity - the operator - buys the ticket on behalf of the buyer ticket_contract.buy_ticket(ticket_id, buyer, value); } pub fn balance_of(&amp;self) -&gt; U512 { self.env().self_balance() } }  L4-L7 - Define errors that will be used in the contract.L9-L13 - Define the TicketOperator module that stores the address of the ticketing office.L16-L18 - The register function sets the address of the ticketing office.L20-L32 - The buy_ticket function buys a ticket on behalf of the buyer using the ticket office address. The function forwards the call to the ticketing office contract. We simply create a TicketOfficeContractRef to interact we the TicketOffice contract. Note that, the operator's buy_ticket now receives funds. Now we need to adjust the TicketOffice contract to use the TicketOperator contract to buy tickets. src/token.rs #[odra::odra_error] pub enum Error { ... MissingOperator = 204, Unauthorized = 205, } #[odra::module] pub struct TicketOffice { ... operator: Var&lt;Address&gt;, } #[odra::module] impl TicketOffice { ... pub fn register_operator(&amp;mut self, operator: Address) { // only the owner can register an operator let caller = self.env().caller(); self.ownable.assert_owner(&amp;caller); // store the ticketing center address in the operator contract TicketOperatorContractRef::new(self.env(), operator).register(self.env().self_address()); self.operator.set(operator); } pub fn issue_ticket(&amp;mut self, event_name: String, price: U512) { // minting logic remains the same... ... // approve the operator to transfer the ticket let operator = self.operator(); self.token .approve(operator, Maybe::Some(ticket_id), Maybe::None); // emit an event ... } pub fn buy_ticket(&amp;mut self, ticket_id: TicketId, buyer: Address, value: U512) { let env = self.env(); let owner = self.ownable.get_owner(); let caller = env.caller(); // make sure the caller is the operator if !self.is_operator(caller) { env.revert(Error::Unauthorized); } ... // the logic remains the same, except for the csprs transfer // it is now handled by the operator contract. // env.transfer_tokens(&amp;owner, &amp;value); } #[inline] fn is_operator(&amp;self, caller: Address) -&gt; bool { Some(caller) == self.operator.get() } #[inline] fn operator(&amp;self) -&gt; Address { self.operator .get() .unwrap_or_revert_with(&amp;self.env(), Error::MissingOperator) } }  L11 - the contract stores the operator address.L18-L25 - a new function register_operator allows the owner to register an operator. Also calls the register entry point on the operator contract.L32-36 - modify the issue_ticket function: once a new token is minted, approves the operator to transfer the ticket later.L40-L53 - modify the buy_ticket function: check if the caller is the operator, do not transfer cspr to the contract - now the operator collect funds.We also added two helper functions: is_operator and operator to check if the caller is the operator and get the operator address. Two new errors were added: MissingOperator and Unauthorized. Now we need to update our tests to create a scenario we presented in the sequence diagram. src/tests.rs use odra::{ casper_types::U512, host::{Deployer, HostRef, NoArgs}, prelude::* }; use crate::{ ticket_operator::TicketOperatorHostRef, token::{Error, TicketId, TicketOfficeContractRef, TicketOfficeInitArgs}, }; #[test] fn it_works() { let env = odra_test::env(); let init_args = TicketOfficeInitArgs { collection_name: &quot;Ticket&quot;.to_string(), collection_symbol: &quot;T&quot;.to_string(), total_supply: 100, }; let operator = TicketOperator::deploy(&amp;env, NoArgs); let mut ticket_office = TicketOfficeContractRef::deploy(&amp;env, init_args); ticket_office.register_operator(operator.address().clone()); ticket_office.issue_ticket(&quot;Ev&quot;.to_string(), U512::from(100)); ticket_office.issue_ticket(&quot;Ev&quot;.to_string(), U512::from(50)); let buyer = env.get_account(1); env.set_caller(buyer); assert_eq!( buy_ticket(&amp;operator, 0, 50), Err(Error::InsufficientFunds.into()) ); assert_eq!(buy_ticket(&amp;operator, 0, 100), Ok(())); assert_eq!(buy_ticket(&amp;operator, 1, 50), Ok(())); assert_eq!( buy_ticket(&amp;operator, 0, 100), Err(Error::TicketNotAvailableForSale.into()) ); assert_eq!(operator.balance_of(), U512::from(150)); } fn buy_ticket(operator: &amp;TicketOperatorHostRef, id: TicketId, price: u64) -&gt; OdraResult&lt;()&gt; { operator.with_tokens(U512::from(price)).try_buy_ticket(id) }  ","version":"2.0.0","tagName":"h3"},{"title":"Conclusion​","type":1,"pageTitle":"Ticketing System","url":"/docs/2.0.0/tutorials/nft#conclusion","content":"In this tutorial, we created a simple ticketing system using the CEP-78 standard. This guide demonstrates how to combine various Odra features, including modules, events, errors, payable functions, and cross-contract calls. ","version":"2.0.0","tagName":"h3"},{"title":"Odra CLI","type":0,"sectionRef":"#","url":"/docs/2.0.0/tutorials/odra-cli","content":"","keywords":"","version":"2.0.0"},{"title":"Deploy script​","type":1,"pageTitle":"Odra CLI","url":"/docs/2.0.0/tutorials/odra-cli#deploy-script","content":"Let's go through an example available in the odra repository to see how to use the Odra CLI library. It creates a cli tool for a useful &quot;DogContract&quot;. To use the Odra CLI library in your project, you need to add odra-cli to your Cargo.toml file, alongside a new binary: [dependencies] ... odra-cli = &quot;2&quot; ... [[bin]] name = &quot;odra-cli&quot; path = &quot;src/bin/odra-cli.rs&quot;  Then, create a new file in the src/bin directory named odra-cli.rs: /// Deploys the `DogContract` and adds it to the container. pub struct DeployDogScript; impl DeployScript for DeployDogScript { fn deploy( &amp;self, env: &amp;HostEnv, container: &amp;mut DeployedContractsContainer ) -&gt; Result&lt;(), odra_cli::deploy::Error&gt; { env.set_gas(350_000_000_000); let dog_contract = DogContract::try_deploy( env, DogContractInitArgs { barks: true, weight: 10, name: &quot;Mantus&quot;.to_string() } )?; container.add_contract(&amp;dog_contract)?; Ok(()) } } /// Main function to run the CLI tool. pub fn main() { OdraCli::new() .about(&quot;Dog contract cli tool&quot;) .deploy(DeployDogScript) .contract::&lt;DogContract&gt;() .build() .run(); }  In the example above, we see an implementation of a simple DeployScript for our DogContract. It sets the gas limit, deploys the contract and adds it to a container. The main function creates a new OdraCli instance, and sets the deploy script, making it available for the user. ","version":"2.0.0","tagName":"h2"},{"title":"How to use it​","type":1,"pageTitle":"Odra CLI","url":"/docs/2.0.0/tutorials/odra-cli#how-to-use-it","content":"Assuming the correct livenet environment is set up, you can run the cli tool using the following command: cargo run --bin odra-cli  Which will display all of our options: Dog contract cli tool Usage: odra_cli &lt;COMMAND&gt; Commands: deploy Runs the deploy script contract Commands for interacting with contracts scenario Commands for running user-defined scenarios help Print this message or the help of the given subcommand(s) Options: -h, --help Print help  First, we need to deploy the contract: cargo run --bin odra_cli deploy  Which gives us an output: cargo run --bin odra_cli -- deploy Compiling odra-examples v2.0.0 (/home/kuba/Projekty/odra/odra/examples) Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.65s Running `../target/debug/odra_cli deploy` 💁 INFO : Found wasm under &quot;wasm/DogContract.wasm&quot;. 💁 INFO : Deploying &quot;DogContract&quot;. 🙄 WAIT : Waiting 10 for V1(TransactionV1Hash(10ce0134ac3a67772a668bb6c32a0dc74c09278f44d7896cc5419b8e2b2de33e)). 💁 INFO : Deploy &quot;10ce0134ac3a67772a668bb6c32a0dc74c09278f44d7896cc5419b8e2b2de33e&quot; successfully executed. 💁 INFO : Contract &quot;contract-package-3e1e053c2e9377e823d9156e0663b7614f74eb524d47d9dc4a621f8cd06a357b&quot; deployed. 💁 INFO : Command executed successfully  This will run the deploy script, and create a new file in the resources directory named deployed-contracts.toml: time = &quot;2025-05-22T14:40:31Z&quot; [[contracts]] name = &quot;DogContract&quot; package_hash = &quot;hash-3e1e053c2e9377e823d9156e0663b7614f74eb524d47d9dc4a621f8cd06a357b&quot;  All the calls to the contract will be made using this package hash. ","version":"2.0.0","tagName":"h2"},{"title":"Calling contract methods​","type":1,"pageTitle":"Odra CLI","url":"/docs/2.0.0/tutorials/odra-cli#calling-contract-methods","content":"To call a contract method, we need to use the contract command. The command itself will display all the available contracts: cargo run --bin odra_cli -- contract  Which outputs: Commands for interacting with contracts Usage: odra_cli contract &lt;COMMAND&gt; Commands: DogContract Commands for interacting with the DogContract contract help Print this message or the help of the given subcommand(s)  And when contract is selected, it will show us the available methods: cargo run --bin odra_cli -- contract DogContract  Commands for interacting with the DogContract contract Usage: odra_cli contract DogContract &lt;COMMAND&gt; Commands: barks Returns true if the dog barks. weight Returns the dog's weight. name Returns the dog's name. walks_amount Adds a walk to the dog's walks. walks_total_length Returns the total length of the dog's walks. help Print this message or the help of the given subcommand(s)  To run a command, compose a command like this: cargo run --bin odra_cli -- contract DogContract barks  It will result with: 💁 INFO : true 💁 INFO : Command executed successfully  ","version":"2.0.0","tagName":"h2"},{"title":"Creating and running a scenario​","type":1,"pageTitle":"Odra CLI","url":"/docs/2.0.0/tutorials/odra-cli#creating-and-running-a-scenario","content":"Sometimes we want to run multiple calls one after another. To simplify this, we can create a scenario. To do this implement the Scenario trait in the odra-cli binary:  /// Checks if the name of the deployed dog matches the provided name. pub struct DogCheckScenario; impl Scenario for DogCheckScenario { fn args(&amp;self) -&gt; Vec&lt;CommandArg&gt; { vec![CommandArg::new( &quot;name&quot;, &quot;The name of the dog&quot;, NamedCLType::String, false, false )] } fn run( &amp;self, env: &amp;HostEnv, container: DeployedContractsContainer, args: ScenarioArgs ) -&gt; Result&lt;(), ScenarioError&gt; { let dog_contract = container.get_ref::&lt;DogContract&gt;(env)?; let test_name = args.get_single::&lt;String&gt;(&quot;name&quot;)?; env.set_gas(50_000_000); let actual_name = dog_contract.try_name()?; assert_eq!(test_name, actual_name, &quot;Dog name mismatch&quot;); Ok(()) } } impl ScenarioMetadata for DogCheckScenario { const NAME: &amp;'static str = &quot;check&quot;; const DESCRIPTION: &amp;'static str = &quot;Checks if the name of the deployed dog matches the provided name&quot;; }  The example above performs a simple check on the return value of one of the methods. Of course, there is no limit to how complex a scenario can be. Remember to add the scenario in the main function: /// Main function to run the CLI tool. pub fn main() { OdraCli::new() .about(&quot;Dog contract cli tool&quot;) .deploy(DeployDogScript) .contract::&lt;DogContract&gt;() .scenario::&lt;DogCheckScenario&gt;(DogCheckScenario) // New scenario .build() .run(); }  It will appear in the scenario command: cargo run --bin odra_cli -- scenario  Will output: Commands for running user-defined scenarios Usage: odra_cli scenario &lt;COMMAND&gt; Commands: check Checks if the name of the deployed dog matches the provided name help Print this message or the help of the given subcommand(s)  It can be run like this: cargo run --bin odra_cli -- scenario check --name Doggy  This will output: thread 'main' panicked at examples/bin/odra_cli.rs:59:9: assertion `left == right` failed: Dog name mismatch left: &quot;Doggy&quot; right: &quot;Mantus&quot;  ","version":"2.0.0","tagName":"h2"},{"title":"OwnedToken","type":0,"sectionRef":"#","url":"/docs/2.0.0/tutorials/owned-token","content":"","keywords":"","version":"2.0.0"},{"title":"Code​","type":1,"pageTitle":"OwnedToken","url":"/docs/2.0.0/tutorials/owned-token#code","content":"What should our module be capable of? Conform the Erc20 interface.Allow only the module owner to mint tokens.Enable the current owner to designate a new owner. ","version":"2.0.0","tagName":"h2"},{"title":"Module definition​","type":1,"pageTitle":"OwnedToken","url":"/docs/2.0.0/tutorials/owned-token#module-definition","content":"Let's define a module called OwnedToken that is a composition of Ownable and Erc20 modules. owned_token.rs use crate::{erc20::Erc20, ownable::Ownable}; use odra::prelude::*; #[odra::module] pub struct OwnedToken { ownable: SubModule&lt;Ownable&gt;, erc20: SubModule&lt;Erc20&gt; }  As you can see, we do not need any storage definition - we just take advantage of the already-defined modules! ","version":"2.0.0","tagName":"h3"},{"title":"Delegation​","type":1,"pageTitle":"OwnedToken","url":"/docs/2.0.0/tutorials/owned-token#delegation","content":"owned_token.rs ... use odra::casper_types::U256; ... #[odra::module] impl OwnedToken { pub fn init(&amp;mut self, name: String, symbol: String, decimals: u8, initial_supply: U256) { let deployer = self.env().caller(); self.ownable.init(deployer); self.erc20.init(name, symbol, decimals, initial_supply); } pub fn name(&amp;self) -&gt; String { self.erc20.name() } pub fn symbol(&amp;self) -&gt; String { self.erc20.symbol() } pub fn decimals(&amp;self) -&gt; u8 { self.erc20.decimals() } pub fn total_supply(&amp;self) -&gt; U256 { self.erc20.total_supply() } pub fn balance_of(&amp;self, address: &amp;Address) -&gt; U256 { self.erc20.balance_of(address) } pub fn allowance(&amp;self, owner: &amp;Address, spender: &amp;Address) -&gt; U256 { self.erc20.allowance(owner, spender) } pub fn transfer(&amp;mut self, recipient: &amp;Address, amount: &amp;U256) { self.erc20.transfer(recipient, amount); } pub fn transfer_from(&amp;mut self, owner: &amp;Address, recipient: &amp;Address, amount: &amp;U256) { self.erc20.transfer_from(owner, recipient, amount); } pub fn approve(&amp;mut self, spender: &amp;Address, amount: &amp;U256) { self.erc20.approve(spender, amount); } pub fn get_owner(&amp;self) -&gt; Address { self.ownable.get_owner() } pub fn change_ownership(&amp;mut self, new_owner: &amp;Address) { self.ownable.change_ownership(new_owner); } pub fn mint(&amp;mut self, address: &amp;Address, amount: &amp;U256) { self.ownable.ensure_ownership(&amp;self.env().caller()); self.erc20.mint(address, amount); } }  Easy. However, there are a few worth mentioning subtleness: L9-L10 - A constructor is an excellent place to initialize both modules at once.L13-L15 - Most of the entrypoints do not need any modification, so we simply delegate them to the erc20 module.L49-L51 - The same is done with the ownable module.L57-L60 - Minting should not be unconditional, we need some control over it. First, using ownable we make sure the caller really is indeed the owner. ","version":"2.0.0","tagName":"h3"},{"title":"Summary​","type":1,"pageTitle":"OwnedToken","url":"/docs/2.0.0/tutorials/owned-token#summary","content":"The Odra Framework encourages a modularized design of your smart contracts. You can encapsulate features in smaller units and test them in isolation, ensuring your project is easy to maintain. Finally, unleash their full potential by combining modules. You do not need any magic bindings for that. ","version":"2.0.0","tagName":"h2"},{"title":"Ownable","type":0,"sectionRef":"#","url":"/docs/2.0.0/tutorials/ownable","content":"","keywords":"","version":"2.0.0"},{"title":"Framework features​","type":1,"pageTitle":"Ownable","url":"/docs/2.0.0/tutorials/ownable#framework-features","content":"A module we will write in a minute, will help you master a few Odra features: storing a single value,defining a constructor,error handling,defining and emitting events.registering a contact in a test environment,interactions with the test environment,assertions (value, events, errors assertions). ","version":"2.0.0","tagName":"h2"},{"title":"Code​","type":1,"pageTitle":"Ownable","url":"/docs/2.0.0/tutorials/ownable#code","content":"Before we write any code, we define functionalities we would like to implement. Module has an initializer that should be called once. Only the current owner can set a new owner.Read the current owner.A function that fails if called by a non-owner account. ","version":"2.0.0","tagName":"h2"},{"title":"Define a module​","type":1,"pageTitle":"Ownable","url":"/docs/2.0.0/tutorials/ownable#define-a-module","content":"ownable.rs use odra::prelude::*; #[odra::module(events = [OwnershipChanged])] pub struct Ownable { owner: Var&lt;Option&lt;Address&gt;&gt; }  That was easy, but it is crucial to understand the basics before we move on. L3 - Firstly, we need to create a struct called Ownable and apply #[odra::module(events = [OwnershipChanged])] attribute to it. The events attribute is optional but informs the Odra toolchain about the events that will be emitted by the module and includes them in the contract's metadata. OwnershipChanged is a type that will be defined later.L5 - Then we can define the layout of our module. It is extremely simple - just a single state value. What is most important is that you can never leave a raw type; you must always wrap it with Var. ","version":"2.0.0","tagName":"h3"},{"title":"Init the module​","type":1,"pageTitle":"Ownable","url":"/docs/2.0.0/tutorials/ownable#init-the-module","content":"ownable.rs #[odra::module] impl Ownable { pub fn init(&amp;mut self, owner: Address) { if self.owner.get_or_default().is_some() { self.env().revert(Error::OwnerIsAlreadyInitialized) } self.owner.set(Some(owner)); self.env().emit_event(OwnershipChanged { prev_owner: None, new_owner: owner }); } } #[odra::odra_error] pub enum Error { OwnerIsAlreadyInitialized = 1, } #[odra::event] pub struct OwnershipChanged { pub prev_owner: Option&lt;Address&gt;, pub new_owner: Address }  Ok, we have done a couple of things, let's analyze them one by one: L1 - The impl should be an Odra module, so add #[odra::module].L3 - The init function is a constructor. This matters if we would like to deploy the Ownable module as a standalone contract.L17-L20 - Before we set a new owner, we must assert there was no owner before and raise an error otherwise. For that purpose, we defined an Error enum. Notice that the #[odra::odra_error] attribute is applied to the enum. It generates, among others, the required Into&lt;odra::OdraError&gt; binding.L4-L6 - If the owner has been set already, we call ContractEnv::revert() function with an Error::OwnerIsAlreadyInitialized argument. L8 - Then we write the owner passed as an argument to the storage. To do so, we call the set() on Var.L22-L26 - Once the owner is set, we would like to inform the outside world. The first step is to define an event struct. The struct annotated with #[odra::event] attribute.L10 - Finally, call ContractEnv::emit_event() passing the OwnershipChanged instance to the function. Hence, we set the first owner, we set the prev_owner value to None.  ","version":"2.0.0","tagName":"h3"},{"title":"Features implementation​","type":1,"pageTitle":"Ownable","url":"/docs/2.0.0/tutorials/ownable#features-implementation","content":"ownable.rs #[odra::module] impl Ownable { ... pub fn ensure_ownership(&amp;self, address: &amp;Address) { if Some(address) != self.owner.get_or_default().as_ref() { self.env().revert(Error::NotOwner) } } pub fn change_ownership(&amp;mut self, new_owner: &amp;Address) { self.ensure_ownership(&amp;self.env().caller()); let current_owner = self.get_owner(); self.owner.set(Some(*new_owner)); self.env().emit_event(OwnershipChanged { prev_owner: Some(current_owner), new_owner: *new_owner }); } pub fn get_owner(&amp;self) -&gt; Address { match self.owner.get_or_default() { Some(owner) =&gt; owner, None =&gt; self.env().revert(Error::OwnerIsNotInitialized) } } } #[odra::odra_error] pub enum Error { NotOwner = 1, OwnerIsAlreadyInitialized = 2, OwnerIsNotInitialized = 3, }  The above implementation relies on the concepts we have already used in this tutorial, so it should be easy for you to get along. L7,L31 - ensure_ownership() reads the current owner and reverts if it does not match the input Address. Also, we need to update our Error enum by adding a new variant NotOwner.L11 - The function defined above can be reused in the change_ownership() implementation. We pass to it the current caller, using the ContractEnv::caller() function. Then we update the state and emit OwnershipChanged.L21,L33 - Lastly, a getter function. Read the owner from storage, if the getter is called on an uninitialized module, it should revert with a new Error variant OwnerIsNotInitialized. There is one worth-mentioning subtlety: Var::get() function returns Option&lt;T&gt;. If the type implements the Default trait, you can call the get_or_default() function, and the contract does not fail even if the value is not initialized. As the owner is of type Option&lt;Address&gt; the Var::get() would return Option&lt;Option&lt;Address&gt;&gt;, we use Var::get_or_default() instead. ","version":"2.0.0","tagName":"h3"},{"title":"Test​","type":1,"pageTitle":"Ownable","url":"/docs/2.0.0/tutorials/ownable#test","content":"ownable.rs #[cfg(test)] mod tests { use super::*; use odra::host::{Deployer, HostEnv, HostRef}; fn setup() -&gt; (OwnableHostRef, HostEnv, Address) { let env: HostEnv = odra_test::env(); let init_args = OwnableInitArgs { owner: env.get_account(0) }; (Ownable::deploy(&amp;env, init_args), env.clone(), env.get_account(0)) } #[test] fn initialization_works() { let (ownable, env, owner) = setup(); assert_eq!(ownable.get_owner(), owner); env.emitted_event( &amp;ownable, &amp;OwnershipChanged { prev_owner: None, new_owner: owner } ); } #[test] fn owner_can_change_ownership() { let (mut ownable, env, owner) = setup(); let new_owner = env.get_account(1); env.set_caller(owner); ownable.change_ownership(&amp;new_owner); assert_eq!(ownable.get_owner(), new_owner); env.emitted_event( &amp;ownable, &amp;OwnershipChanged { prev_owner: Some(owner), new_owner } ); } #[test] fn non_owner_cannot_change_ownership() { let (mut ownable, env, _) = setup(); let new_owner = env.get_account(1); ownable.change_ownership(&amp;new_owner); assert_eq!( ownable.try_change_ownership(&amp;new_owner), Err(Error::NotOwner.into()) ); } }  L6 - Each test case starts with the same initialization process, so for convenience, we have defined the setup() function, which we call in the first statement of each test. Take a look at the signature: fn setup() -&gt; (OwnableHostRef, HostEnv, Address). OwnableHostRef is a contract reference generated by Odra. This reference allows us to call all the defined entrypoints, namely: ensure_ownership(), change_ownership(), get_owner(), but not init(), which is a constructor.L7-L11 - The starting point of every test is getting an instance of HostEnv by calling odra_test::env(). Our function returns a triple: a contract ref, an env, and an address (the initial owner). Odra's #[odra::module] attribute implements a odra::host::Deployer for Ownable, and OwnableInitArgs that we pass as the second argument of the odra::host::Deployer::deploy() function. Lastly, the module needs an owner. The easiest way is to take one from the HostEnv. We choose the address of first account (which is the default one). L14 - It is time to define the first test. As you see, it is a regular Rust test.L16-17 - Using the setup() function, we get the owner and a reference (in this test, we don't use the env, so we ignore it). We make a standard assertion, comparing the owner we know with the value returned from the contract. note You may have noticed, we use here the term module interchangeably with contract. The reason is once we deploy our module onto a virtual blockchain it may be considered a contract. L19-25 - On the contract, only the init() function has been called, so we expect one event to have been emitted. To assert that, let's use HostEnv. To get the env, we call env() on the contract, then call HostEnv::emitted_event. As the first argument, pass the contract you want to read events from, followed by an event as you expect it to have occurred.L31 - Because we know the initial owner is the 0th account, we must select a different account. It could be any index from 1 to 19 - the HostEnv predefines 20 accounts.L33 - As mentioned, the default is the 0th account, if you want to change the executor, call the HostEnv::set_caller() function. note The caller switch applies only the next contract interaction, the second call will be done as the default account. L46-55 - If a non-owner account tries to change ownership, we expect it to fail. To capture the error, call HostEnv::try_change_ownership() instead of HostEnv::change_ownership(). HostEnv provides try_ functions for each contract's entrypoint. The try functions return OdraResult (an alias for Result&lt;T, OdraError&gt;) instead of panicking and halting the execution. In our case, we expect the contract to revert with the Error::NotOwner error. To compare the error, we use the Error::into() function, which converts the error into the OdraError type. ","version":"2.0.0","tagName":"h3"},{"title":"Summary​","type":1,"pageTitle":"Ownable","url":"/docs/2.0.0/tutorials/ownable#summary","content":"The Ownable module is ready, and we can test it against any defined backend. Theoretically it can be deployed as a standalone contract, but in upcoming tutorials you will see how to use it to compose a more complex contract. ","version":"2.0.0","tagName":"h2"},{"title":"What's next​","type":1,"pageTitle":"Ownable","url":"/docs/2.0.0/tutorials/ownable#whats-next","content":"In the next tutorial we will implement a ERC20 standard. ","version":"2.0.0","tagName":"h2"},{"title":"Odra framework","type":0,"sectionRef":"#","url":"/docs/2.0.1/","content":"","keywords":"","version":"2.0.1"},{"title":"What's next​","type":1,"pageTitle":"Odra framework","url":"/docs/2.0.1/#whats-next","content":"See the Installation and our Flipper example to find out how to start your new project with Odra. ","version":"2.0.1","tagName":"h2"},{"title":"Advanced Storage Concepts","type":0,"sectionRef":"#","url":"/docs/2.0.1/advanced/advanced-storage","content":"","keywords":"","version":"2.0.1"},{"title":"Recap and Basic Concepts​","type":1,"pageTitle":"Advanced Storage Concepts","url":"/docs/2.0.1/advanced/advanced-storage#recap-and-basic-concepts","content":"Before we delve into the advanced features, let's recap some basic storage concepts in Odra. In the realm of basic storage interaction, Odra provides several types for interacting with contract storage, including Var, Mapping, and List. These types enable contracts to store and retrieve data in a structured manner. The Var type is used to store a single value, while the List and Mapping types store collections of values. Var: A Var in Odra is a fundamental building block used for storing single values. Each Var is uniquely identified by its name in the contract. Mapping: Mapping in Odra serves as a key-value storage system. It stores an association of unique keys to values, and the value can be retrieved using the key. List: Built on top of the Var and Mapping building blocks, List in Odra allows storing an ordered collection of values that can be iterated over. If you need a refresher on these topics, please refer to our guide on basic storage in Odra. ","version":"2.0.1","tagName":"h2"},{"title":"Advanced Storage Concepts​","type":1,"pageTitle":"Advanced Storage Concepts","url":"/docs/2.0.1/advanced/advanced-storage#advanced-storage-concepts-1","content":"","version":"2.0.1","tagName":"h2"},{"title":"Sequence​","type":1,"pageTitle":"Advanced Storage Concepts","url":"/docs/2.0.1/advanced/advanced-storage#sequence","content":"The Sequence in Odra is a basic module that stores a single value in the storage that can be read or incremented. Internally, holds a Var which keeps track of the current value. pub struct Sequence&lt;T&gt; where T: Num + One + ToBytes + FromBytes + CLTyped { value: Var&lt;T&gt; }  The Sequence module provides functions get_current_value and next_value to get the current value and increment the value respectively. ","version":"2.0.1","tagName":"h3"},{"title":"Advanced Mapping​","type":1,"pageTitle":"Advanced Storage Concepts","url":"/docs/2.0.1/advanced/advanced-storage#advanced-mapping","content":"In Odra, a Mapping is a key-value storage system where the key is associated with a value. In previous examples, the value of the Mapping typically comprised a standard serializable type (such as number, string, or bool) or a custom type marked with the #[odra::odra_type] attribute. However, there are more advanced scenarios where the value of the Mapping represents a module itself. This approach is beneficial when managing a collection of modules, each maintaining its unique state. Let's consider the following example: examples/src/features/storage/mapping.rs use odra::casper_types::U256; use odra::prelude::*; use crate::owned_token::OwnedToken; #[odra::module] pub struct Mappings { strings: Mapping&lt;(String, u32, String), String&gt;, tokens: Mapping&lt;String, OwnedToken&gt; } #[odra::module] impl Mappings { ... pub fn total_supply(&amp;mut self, token_name: String) -&gt; U256 { self.tokens.module(&amp;token_name).total_supply() } pub fn get_string_api( &amp;self, key1: String, key2: u32, key3: String ) -&gt; String { let opt_string = self.strings.get(&amp;(key1, key2, key3)); opt_string.unwrap_or_revert(&amp;self.env()) } }  As you can see, a Mapping key can consist of a tuple of values, not limited to a single value. note Accessing Odra modules differs from accessing regular values such as strings or numbers. Firstly, within a Mapping, you don't encapsulate the module with Submodule. Secondly, rather than utilizing the Mapping::get() function, call Mapping::module(), which returns SubModule&lt;T&gt; and sets the appropriate namespace for nested modules. ","version":"2.0.1","tagName":"h3"},{"title":"AdvancedStorage Contract​","type":1,"pageTitle":"Advanced Storage Concepts","url":"/docs/2.0.1/advanced/advanced-storage#advancedstorage-contract","content":"The given code snippet showcases the AdvancedStorage contract that incorporates these storage concepts. use odra::casper_types::U512; use odra::prelude::*; use crate::modules::Token; #[odra::module] pub struct AdvancedStorage { counter: Sequence&lt;u32&gt;, tokens: Mapping&lt;(String, String), Token&gt;, } impl AdvancedStorage { pub fn current_value(&amp;self) -&gt; u32 { self.counter.get_current_value() } pub fn increment_and_get(&amp;mut self) -&gt; u32 { self.counter.next_value() } pub fn balance_of(&amp;mut self, token_name: String, creator: String, address: Address) -&gt; U512 { let token = self.tokens.module(&amp;(token_name, creator)); token.balance_of(&amp;address) } pub fn mint(&amp;self, token_name: String, creator: String, amount: U512, to: Address) { let mut token = self.tokens.module(&amp;(token_name, creator)); token.mint(amount, to); } }  ","version":"2.0.1","tagName":"h2"},{"title":"Conclusion​","type":1,"pageTitle":"Advanced Storage Concepts","url":"/docs/2.0.1/advanced/advanced-storage#conclusion","content":"Advanced storage features in Odra offer robust options for managing contract state. Two key takeaways from this document are: Odra offers a Sequence module, enabling contracts to store and increment a single value.Mappings support composite keys expressed as tuples and can store modules as values. Understanding these concepts can help developers design and implement more efficient and flexible smart contracts. ","version":"2.0.1","tagName":"h2"},{"title":"Pausable","type":0,"sectionRef":"#","url":"/docs/2.0.0/tutorials/pauseable","content":"","keywords":"","version":"2.0.0"},{"title":"Code​","type":1,"pageTitle":"Pausable","url":"/docs/2.0.0/tutorials/pauseable#code","content":"As always, we will start with defining functionalities of our module. Check the state - is it paused or not.State guards - a contract should stop execution if is in a state we don't expect.Switch the state. ","version":"2.0.0","tagName":"h2"},{"title":"Events and Error​","type":1,"pageTitle":"Pausable","url":"/docs/2.0.0/tutorials/pauseable#events-and-error","content":"There just two errors that may occur: PausedRequired, UnpausedRequired. We define them in a standard Odra way. Events definition is highly uncomplicated: Paused and Unpaused events holds only the address of the pauser. pauseable.rs use odra::prelude::*; #[odra::odra_error] pub enum Error { PausedRequired = 1_000, UnpausedRequired = 1_001, } #[odra::event] pub struct Paused { pub account: Address } #[odra::event] pub struct Unpaused { pub account: Address }  ","version":"2.0.0","tagName":"h3"},{"title":"Module definition​","type":1,"pageTitle":"Pausable","url":"/docs/2.0.0/tutorials/pauseable#module-definition","content":"The module storage is extremely simple - has a single Var of type bool, that indicates if a contract is paused. pauseable.rs #[odra::module(events = [Paused, Unpaused])] pub struct Pausable { is_paused: Var&lt;bool&gt; }  ","version":"2.0.0","tagName":"h3"},{"title":"Checks and guards​","type":1,"pageTitle":"Pausable","url":"/docs/2.0.0/tutorials/pauseable#checks-and-guards","content":"Now, let's move to state checks and guards. pauseable.rs impl Pausable { pub fn is_paused(&amp;self) -&gt; bool { self.is_paused.get_or_default() } pub fn require_not_paused(&amp;self) { if self.is_paused() { self.env().revert(Error::UnpausedRequired); } } pub fn require_paused(&amp;self) { if !self.is_paused() { self.env().revert(Error::PausedRequired); } } }  L1 - as mentioned in the intro, the module is not intended to be a standalone contract, so the only impl block is not annotated with odra::module and hence does not expose any entrypoint.L2 - is_paused() checks the contract state, if the Var is_paused has not been initialized, the default value (false) is returned.L6 - to guarantee the code is executed when the contract is not paused, require_not_paused() function reads the state and reverts if the contract is paused. L12 - require_paused() is a mirror function - stops the contract execution if the contract is not paused. ","version":"2.0.0","tagName":"h3"},{"title":"Actions​","type":1,"pageTitle":"Pausable","url":"/docs/2.0.0/tutorials/pauseable#actions","content":"Finally, we will add the ability to switch the module state. pauseable.rs impl Pausable { pub fn pause(&amp;mut self) { self.require_not_paused(); self.is_paused.set(true); self.env().emit_event(Paused { account: self.env().caller() }); } pub fn unpause(&amp;mut self) { self.require_paused(); self.is_paused.set(false); self.env().emit_event(Unpaused { account: self.env().caller() }); } }  pause() and unpause() functions do three things: ensure the contract is the right state (unpaused for pause(), not paused for unpause()), updates the state, and finally emits events (Paused/Unpaused). ","version":"2.0.0","tagName":"h3"},{"title":"Pausable counter​","type":1,"pageTitle":"Pausable","url":"/docs/2.0.0/tutorials/pauseable#pausable-counter","content":"In the end, let's use the module in a contract. For this purpose, we will implement a mock contract called PausableCounter. The contract consists of a Var value and a Pausable module. The counter can only be incremented if the contract is in a normal state (is not paused). pauseable.rs ... #[odra::module] pub struct PausableCounter { value: Var&lt;u32&gt;, pauseable: SubModule&lt;Pausable&gt; } #[odra::module] impl PausableCounter { pub fn increment(&amp;mut self) { self.pauseable.require_not_paused(); let new_value = self.value.get_or_default() + 1; self.value.set(new_value); } pub fn pause(&amp;mut self) { self.pauseable.pause(); } pub fn unpause(&amp;mut self) { self.pauseable.unpause(); } pub fn get_value(&amp;self) -&gt; u32 { self.value.get_or_default() } } #[cfg(test)] mod test { use super::*; use odra::host::{Deployer, NoArgs}; #[test] fn increment_only_if_unpaused() { let test_env = odra_test::env(); let mut contract = PausableCounter::deploy(&amp;test_env, NoArgs); contract.increment(); contract.pause(); assert_eq!( contract.try_increment().unwrap_err(), Error::UnpausedRequired.into() ); assert_eq!(contract.get_value(), 1); } }  As we see in the test, in a simple way, using a single function call we can turn off the counter for a while and freeze the counter. Any time we want we can turn it back on. Easy! ","version":"2.0.0","tagName":"h2"},{"title":"Building contracts manually","type":0,"sectionRef":"#","url":"/docs/2.0.1/advanced/building-manually","content":"","keywords":"","version":"2.0.1"},{"title":"Building the contract manually​","type":1,"pageTitle":"Building contracts manually","url":"/docs/2.0.1/advanced/building-manually#building-the-contract-manually","content":"To build the contract manually, cargo odra uses the following command: ODRA_MODULE=my_contract cargo build --release --target wasm32-unknown-unknown --bin my_project_build_contract  info Odra uses the environment variable ODRA_MODULE to determine which contract to build. Assuming that project's crate is named my_project, this command will build the my_contract contract in release mode and generate the wasm file. The file will be put into the target/wasm32-unknown-unknown/release directory under the name my_project_build_contract.wasm. The Odra Framework expects the contracts to be placed in the wasm directory, and to be named correctly, so the next step would be to move the file: mv target/wasm32-unknown-unknown/release/my_project_build_contract.wasm wasm/my_contract.wasm  ","version":"2.0.1","tagName":"h2"},{"title":"Optimizing the contract​","type":1,"pageTitle":"Building contracts manually","url":"/docs/2.0.1/advanced/building-manually#optimizing-the-contract","content":"To lower the size of the wasm file, cargo odra uses the wasm-strip tool: wasm-strip wasm/my_contract.wasm  To further optimize the wasm file, the wasm-opt tool is also used. wasm-opt --signext-lowering wasm/my_contract.wasm -o wasm/my_contract.wasm  danger This step is required, as the wasm file generated by the Rust compiler is not fully compatible with the Casper execution engine. ","version":"2.0.1","tagName":"h2"},{"title":"Running the tests manually​","type":1,"pageTitle":"Building contracts manually","url":"/docs/2.0.1/advanced/building-manually#running-the-tests-manually","content":"To run the tests manually, Odra needs to know which backend to use. To run tests against Casper backend, the following command needs to be used: ODRA_BACKEND=casper cargo test  ","version":"2.0.1","tagName":"h2"},{"title":"Wrapping up​","type":1,"pageTitle":"Building contracts manually","url":"/docs/2.0.1/advanced/building-manually#wrapping-up","content":"Let's say we want to build the my_contract in debug mode, run the tests against the casper backend and use the my-own-allocator feature from our my_project project. To do that, we can use the following set of commands: ODRA_MODULE=my_contract cargo build --target wasm32-unknown-unknown --bin my_project_build_contract mv target/wasm32-unknown-unknown/debug/my_project_build_contract.wasm wasm/my_contract.wasm wasm-strip wasm/my_contract.wasm wasm-opt --signext-lowering wasm/my_contract.wasm -o wasm/my_contract.wasm ODRA_BACKEND=casper cargo test --features my-own-allocator  ","version":"2.0.1","tagName":"h2"},{"title":"Using Proxy Caller","type":0,"sectionRef":"#","url":"/docs/2.0.0/tutorials/using-proxy-caller","content":"","keywords":"","version":"2.0.0"},{"title":"Contract​","type":1,"pageTitle":"Using Proxy Caller","url":"/docs/2.0.0/tutorials/using-proxy-caller#contract","content":"For this tutorial, we will use the TimeLockWallet contract from our examples. examples/src/contracts/tlw.rs use odra::prelude::*; use odra::casper_types::U512; #[odra::module(errors = Error, events = [Deposit, Withdrawal])] pub struct TimeLockWallet { balances: Mapping&lt;Address, U512&gt;, lock_expiration_map: Mapping&lt;Address, u64&gt;, lock_duration: Var&lt;u64&gt; } #[odra::module] impl TimeLockWallet { /// Initializes the contract with the lock duration. pub fn init(&amp;mut self, lock_duration: u64) { self.lock_duration.set(lock_duration); } /// Deposits the tokens into the contract. #[odra(payable)] pub fn deposit(&amp;mut self) { // Extract values let caller: Address = self.env().caller(); let amount: U512 = self.env().attached_value(); let current_block_time: u64 = self.env().get_block_time(); // Multiple lock check if self.balances.get(&amp;caller).is_some() { self.env().revert(Error::CannotLockTwice) } // Update state, emit event self.balances.set(&amp;caller, amount); self.lock_expiration_map .set(&amp;caller, current_block_time + self.lock_duration()); self.env().emit_event(Deposit { address: caller, amount }); } /// Withdraws the tokens from the contract. pub fn withdraw(&amp;mut self, amount: &amp;U512) { // code omitted for brevity } /// Returns the balance of the given account. pub fn get_balance(&amp;self, address: &amp;Address) -&gt; U512 { // code omitted for brevity } /// Returns the lock duration. pub fn lock_duration(&amp;self) -&gt; u64 { // code omitted for brevity } } /// Errors that may occur during the contract execution. #[odra::odra_error] pub enum Error { LockIsNotOver = 1, CannotLockTwice = 2, InsufficientBalance = 3 } /// Deposit event. #[odra::event] pub struct Deposit { pub address: Address, pub amount: U512 } /// Withdrawal event. #[odra::event] pub struct Withdrawal { pub address: Address, pub amount: U512 }  Full code can be found here. ","version":"2.0.0","tagName":"h2"},{"title":"Client​","type":1,"pageTitle":"Using Proxy Caller","url":"/docs/2.0.0/tutorials/using-proxy-caller#client","content":"Before we can interact with the node, we need to set it up. We will use the casper-nctl-docker image. docker run --rm -it --name mynctl -d -p 11101:11101 -p 14101:14101 -p 18101:18101 makesoftware/casper-nctl  Make sure you have the contract's wasm file and the secret key. # Build the contract cargo odra build -c TimeLockWallet # Extract secret key docker exec mynctl /bin/bash -c &quot;cat /home/casper/casper-node/utils/nctl/assets/net-1/users/user-1/secret_key.pem&quot; &gt; your/path/secret_key.pem  RustTypeScript To interact with the contract, we use the livenet backend. It allows to write the code in the same manner as the test code, but it interacts with the live network (a local node in our case). Cargo.toml [package] name = &quot;odra-examples&quot; version = &quot;1.4.0&quot; edition = &quot;2021&quot; [dependencies] odra = { path = &quot;../odra&quot;, default-features = false } ... # other dependencies odra-casper-livenet-env = { version = &quot;1.4.0&quot;, optional = true } ... # other sections [features] default = [] livenet = [&quot;odra-casper-livenet-env&quot;] ... # other sections [[bin]] name = &quot;tlw_on_livenet&quot; path = &quot;bin/tlw_on_livenet.rs&quot; required-features = [&quot;livenet&quot;] test = false ... # other sections examples/bin/tlw_on_livenet.rs //! Deploys an [odra_examples::contracts::tlw::TimeLockWallet] contract, then deposits and withdraw some CSPRs. use odra::casper_types::{AsymmetricType, PublicKey, U512}; use odra::host::{Deployer, HostRef}; use odra::prelude::*; use odra_examples::contracts::tlw::{TimeLockWallet, TimeLockWalletInitArgs}; const DEPOSIT: u64 = 100; const WITHDRAWAL: u64 = 99; const GAS: u64 = 20u64.pow(9); fn main() { let env = odra_casper_livenet_env::env(); let caller = env.get_account(0); env.set_caller(caller); env.set_gas(GAS); let mut contract = TimeLockWallet::deploy( &amp;env, TimeLockWalletInitArgs { lock_duration: 60 * 60 } ); // Send 100 CSPRs to the contract. contract .with_tokens(U512::from(DEPOSIT)) .deposit(); println!(&quot;Caller's balance: {:?}&quot;, contract.get_balance(&amp;caller)); // Withdraw 99 CSPRs from the contract. contract.withdraw(&amp;U512::from(WITHDRAWAL)); println!(&quot;Remaining balance: {:?}&quot;, contract.get_balance(&amp;caller)); } To run the code, execute the following command: ODRA_CASPER_LIVENET_SECRET_KEY_PATH=.node-keys/secret_key.pem \\ ODRA_CASPER_LIVENET_NODE_ADDRESS=http://localhost:11101 \\ ODRA_CASPER_LIVENET_CHAIN_NAME=casper-net-1 \\ cargo run --bin tlw_on_livenet --features=livenet # Sample output 💁 INFO : Deploying &quot;TimeLockWallet&quot;. 💁 INFO : Found wasm under &quot;wasm/TimeLockWallet.wasm&quot;. 🙄 WAIT : Waiting 15s for &quot;74f0df4bc65cdf9e05bca70a8b786bd0f528858f26e11f5a9866dfe286551558&quot;. 💁 INFO : Deploy &quot;74f0df4bc65cdf9e05bca70a8b786bd0f528858f26e11f5a9866dfe286551558&quot; successfully executed. 💁 INFO : Contract &quot;hash-cce6a97e0db6feea0c4d99f670196c9462e0789fb3cdedd3dfbc6dfcbf66252e&quot; deployed. 💁 INFO : Calling &quot;hash-cce6a97e0db6feea0c4d99f670196c9462e0789fb3cdedd3dfbc6dfcbf66252e&quot; with entrypoint &quot;deposit&quot; through proxy. 🙄 WAIT : Waiting 15s for &quot;bd571ab64c13d2b2fdb8e0e6dd8473b696349dfb5a891b55dbe9f33d017057d3&quot;. 💁 INFO : Deploy &quot;bd571ab64c13d2b2fdb8e0e6dd8473b696349dfb5a891b55dbe9f33d017057d3&quot; successfully executed. Caller's balance: 100 💁 INFO : Calling &quot;hash-cce6a97e0db6feea0c4d99f670196c9462e0789fb3cdedd3dfbc6dfcbf66252e&quot; with entrypoint &quot;withdraw&quot;. 🙄 WAIT : Waiting 15s for &quot;57f9aadbd77cbfbbe9b2ba54759d025f94203f9230121289fa37585f8b17020e&quot;. 💁 INFO : Deploy &quot;57f9aadbd77cbfbbe9b2ba54759d025f94203f9230121289fa37585f8b17020e&quot; successfully executed. Remaining balance: 1 As observed, the contract was successfully deployed, and the Caller deposited tokens. Subsequently, the caller withdrew 99 CSPRs from the contract, leaving the contract's balance at 1 CSPR. The logs display deploy hashes, the contract's hash, and even indicate if the call was made through the proxy, providing a comprehensive overview of the on-chain activity. ","version":"2.0.0","tagName":"h2"},{"title":"Conclusion​","type":1,"pageTitle":"Using Proxy Caller","url":"/docs/2.0.0/tutorials/using-proxy-caller#conclusion","content":"In this tutorial, we learned how to use the proxy_caller wasm to make a payable function call. We deployed the TimeLockWallet contract, deposited tokens using the proxy_caller with attached CSPRs, and withdrew them. You got to try it out in both Rust and TypeScript, so you can choose whichever you prefer. Rust code seemed simpler, thanks to the Odra livenet backend making chain interactions easier to handle. ","version":"2.0.0","tagName":"h2"},{"title":"Attributes","type":0,"sectionRef":"#","url":"/docs/2.0.1/advanced/attributes","content":"","keywords":"","version":"2.0.1"},{"title":"Payable​","type":1,"pageTitle":"Attributes","url":"/docs/2.0.1/advanced/attributes#payable","content":"When writing a smart contract, you need to make sure that money can be both sent to and extracted from the contract. The 'payable' attribute helps wit this. Any function, except for a constructor, with the #[odra(payable)] attribute can send and take money in the form of native tokens. ","version":"2.0.1","tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"Attributes","url":"/docs/2.0.1/advanced/attributes#example","content":"examples/src/contracts/tlw.rs #[odra(payable)] pub fn deposit(&amp;mut self) { // Extract values let caller: Address = self.env().caller(); let amount: U256 = self.env().attached_value(); let current_block_time: u64 = self.env().get_block_time(); // Multiple lock check if self.balances.get(&amp;caller).is_some() { self.env.revert(Error::CannotLockTwice) } // Update state, emit event self.balances.set(&amp;caller, amount); self.lock_expiration_map .set(&amp;caller, current_block_time + self.lock_duration()); self.env() .emit_event(Deposit { address: caller, amount }); }  If you try to send tokens to a non-payable function, the transaction will be automatically rejected. ","version":"2.0.1","tagName":"h3"},{"title":"Non Reentrant​","type":1,"pageTitle":"Attributes","url":"/docs/2.0.1/advanced/attributes#non-reentrant","content":"Reentrancy attacks in smart contracts exploit the possibility of a function being called multiple times before its initial execution is completed, leading to the repeated unauthorized withdrawal of funds. To prevent such attacks, developers should ensure that all effects on the contract's state and balance checks occur before calling external contracts. They can also use reentrancy guards to block recursive calls to sensitive functions. In Odra you can just apply the #[odra(non_reentrant)] attribute to your function. ","version":"2.0.1","tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"Attributes","url":"/docs/2.0.1/advanced/attributes#example-1","content":"#[odra::module] pub struct NonReentrantCounter { counter: Var&lt;u32&gt; } #[odra::module] impl NonReentrantCounter { #[odra(non_reentrant)] pub fn count_ref_recursive(&amp;mut self, n: u32) { if n &gt; 0 { self.count(); ReentrancyMockRef::new(self.env(), self.env().self_address()).count_ref_recursive(n - 1); } } } impl NonReentrantCounter { fn count(&amp;mut self) { let c = self.counter.get_or_default(); self.counter.set(c + 1); } } #[cfg(test)] mod test { use super::*; use odra::host::{Deployer, NoArgs}; #[test] fn ref_recursion_not_allowed() { let test_env = odra_test::env(); let mut contract = NonReentrantCounter::deploy(&amp;test_env, NoArgs); let result = contract.count_ref_recursive(11); assert_eq!(result, ExecutionError::ReentrantCall.into()); } }  ","version":"2.0.1","tagName":"h3"},{"title":"Mixing attributes​","type":1,"pageTitle":"Attributes","url":"/docs/2.0.1/advanced/attributes#mixing-attributes","content":"A function can accept more than one attribute. The only exclusion is a constructor cannot be payable. To apply multiple attributes, you can write: #[odra(payable, non_reentrant)] fn deposit() { // your logic... }  or #[odra(payable)] #[odra(non_reentrant)] fn deposit() { // your logic... }  In both cases attributes order does not matter. ","version":"2.0.1","tagName":"h2"},{"title":"Delegate","type":0,"sectionRef":"#","url":"/docs/2.0.1/advanced/delegate","content":"","keywords":"","version":"2.0.1"},{"title":"Overview​","type":1,"pageTitle":"Delegate","url":"/docs/2.0.1/advanced/delegate#overview","content":"To utilize the delegate feature in your contract, use the delegate! macro provided by Odra. This macro allows you to list the functions you wish to delegate to the child modules. By using the delegate! macro, your parent module remains clean and easy to understand. You can delegate functions to as many child modules as you like. The functions will be available as if they were implemented in the parent module itself. ","version":"2.0.1","tagName":"h2"},{"title":"Code Examples​","type":1,"pageTitle":"Delegate","url":"/docs/2.0.1/advanced/delegate#code-examples","content":"Consider the following basic example for better understanding: use crate::{erc20::Erc20, ownable::Ownable}; use odra::{casper_types::U256, prelude::*}; #[odra::module] pub struct OwnedToken { ownable: SubModule&lt;Ownable&gt;, erc20: SubModule&lt;Erc20&gt; } #[odra::module] impl OwnedToken { pub fn init(&amp;mut self, name: String, symbol: String, decimals: u8, initial_supply: U256) { let deployer = self.env().caller(); self.ownable.init(deployer); self.erc20.init(name, symbol, decimals, initial_supply); } delegate! { to self.erc20 { fn transfer(&amp;mut self, recipient: Address, amount: U256); fn transfer_from(&amp;mut self, owner: Address, recipient: Address, amount: U256); fn approve(&amp;mut self, spender: Address, amount: U256); fn name(&amp;self) -&gt; String; fn symbol(&amp;self) -&gt; String; fn decimals(&amp;self) -&gt; u8; fn total_supply(&amp;self) -&gt; U256; fn balance_of(&amp;self, owner: Address) -&gt; U256; fn allowance(&amp;self, owner: Address, spender: Address) -&gt; U256; } to self.ownable { fn get_owner(&amp;self) -&gt; Address; fn change_ownership(&amp;mut self, new_owner: Address); } } pub fn mint(&amp;mut self, address: Address, amount: U256) { self.ownable.ensure_ownership(self.env().caller()); self.erc20.mint(address, amount); } }  This OwnedToken contract includes two modules: Erc20 and Ownable. We delegate various functions from both modules using the delegate! macro. As a result, the contract retains its succinctness without compromising on functionality. The above example basically merges the functionalities of modules and adds some control over the minting process. But you can use delegation to build more complex contracts, cherry-picking just a few module functionalities. Let's take a look at another example. use crate::{erc20::Erc20, ownable::Ownable, exchange::Exchange}; use odra::{casper_types::U256, prelude::*}; #[odra::module] pub struct DeFiPlatform { ownable: SubModule&lt;Ownable&gt;, erc20: SubModule&lt;Erc20&gt;, exchange: SubModule&lt;Exchange&gt; } #[odra::module] impl DeFiPlatform { pub fn init(&amp;mut self, name: String, symbol: String, decimals: u8, initial_supply: U256, exchange_rate: u64) { let deployer = self.env().caller(); self.ownable.init(deployer); self.erc20.init(name, symbol, decimals, initial_supply); self.exchange.init(exchange_rate); } delegate! { to self.erc20 { fn transfer(&amp;mut self, recipient: Address, amount: U256); fn balance_of(&amp;self, owner: Address) -&gt; U256; } to self.ownable { fn get_owner(&amp;self) -&gt; Address; } to self.exchange { fn swap(&amp;mut self, sender: Address, recipient: Address); fn set_exchange_rate(&amp;mut self, new_rate: u64); } } pub fn mint(&amp;mut self, address: Address, amount: U256) { self.ownable.ensure_ownership(self.env().caller()); self.erc20.mint(address, amount); } }  In this DeFiPlatform contract, we include Erc20, Ownable, and Exchange modules. By delegating functions from these modules, the parent contract becomes a powerhouse of functionality while retaining its readability and structure. Remember, the possibilities are endless with Odra's. By leveraging this feature, you can write cleaner, more efficient, and modular smart contracts. ","version":"2.0.1","tagName":"h2"},{"title":"Signatures","type":0,"sectionRef":"#","url":"/docs/2.0.1/advanced/signatures","content":"","keywords":"","version":"2.0.1"},{"title":"Signature verification​","type":1,"pageTitle":"Signatures","url":"/docs/2.0.1/advanced/signatures#signature-verification","content":"Signature verification is conducted by a function in contract's env(): pub fn verify_signature(message: &amp;Bytes, signature: &amp;Bytes, public_key: &amp;PublicKey) -&gt; bool;  Here's the simplest example of this function used in a contract: examples/src/features/signature_verifier.rs #[odra::module] impl SignatureVerifier { pub fn verify_signature( &amp;self, message: &amp;Bytes, signature: &amp;Bytes, public_key: &amp;PublicKey ) -&gt; bool { self.env().verify_signature(message, signature, public_key) } }  ","version":"2.0.1","tagName":"h2"},{"title":"Testing​","type":1,"pageTitle":"Signatures","url":"/docs/2.0.1/advanced/signatures#testing","content":"Besides the above function in the contract context, Odra provides corresponding functions in the HostEnv: pub fn sign_message(message: &amp;Bytes, address: &amp;Address) -&gt; Bytes; pub fn public_key(address: &amp;Address) -&gt; PublicKey;  sign_message will return a signed message. The signing itself will be performed using a private key of an account behind the address. public_key returns the PublicKey of an address account. Here's a complete example of how to test the signature verification in the contract: examples/src/features/signature_verifier.rs #[test] fn signature_verification_works() { let test_env = odra_test::env(); let message = &quot;Message to be signed&quot;; let message_bytes = Bytes::from(message.as_bytes()); let account = test_env.get_account(0); let signature = test_env.sign_message(&amp;message_bytes, &amp;account); let public_key = test_env.public_key(&amp;account); let signature_verifier = SignatureVerifier::deploy(&amp;test_env, NoArgs); assert!(signature_verifier.verify_signature(&amp;message_bytes, &amp;signature, &amp;public_key)); }  If you want, you can also test signatures created outside Odra: examples/src/features/signature_verifier.rs #[test] fn verify_signature_casper_wallet() { // Casper Wallet for the message &quot;Ahoj przygodo!&quot; signed using SECP256K1 key // produces the following signature: // 1e87e186238fa1df9c222b387a79910388c6ef56285924c7e4f6d7e77ed1d6c61815312cf66a5318db204c693b79e020b1d392dafe8c1b3841e1f6b4c41ca0fa // Casper Wallet adds &quot;Casper Message:\\n&quot; prefix to the message: let message = &quot;Casper Message:\\nAhoj przygodo!&quot;; let message_bytes = Bytes::from(message.as_bytes()); // Depending on the type of the key, we need to prefix the signature with a tag: // 0x01 for ED25519 // 0x02 for SECP256K1 let signature_hex = &quot;021e87e186238fa1df9c222b387a79910388c6ef56285924c7e4f6d7e77ed1d6c61815312cf66a5318db204c693b79e020b1d392dafe8c1b3841e1f6b4c41ca0fa&quot;; let signature: [u8; 65] = hex::decode(signature_hex).unwrap().try_into().unwrap(); let signature_bytes = Bytes::from(signature.as_slice()); // Similar to the above, the public key is tagged: let public_key_hex = &quot;02036d9b880e44254afaf34330e57703a63aec53b5918d4470059b67a4a906350105&quot;; let public_key_decoded = hex::decode(public_key_hex).unwrap(); let (public_key, _) = PublicKey::from_bytes(public_key_decoded.as_slice()).unwrap(); let signature_verifier = SignatureVerifier::deploy(&amp;odra_test::env(), NoArgs); assert!(signature_verifier.verify_signature(&amp;message_bytes, &amp;signature_bytes, &amp;public_key)); }  ","version":"2.0.1","tagName":"h2"},{"title":"Delegating CSPR to Validators","type":0,"sectionRef":"#","url":"/docs/2.0.1/advanced/delegating-cspr","content":"","keywords":"","version":"2.0.1"},{"title":"Sample implementation​","type":1,"pageTitle":"Delegating CSPR to Validators","url":"/docs/2.0.1/advanced/delegating-cspr#sample-implementation","content":"The following code shows how to implement a simple contract that allows delegating CSPR tokens to a validator. examples/src/features/validators.rs use odra::{ casper_types::{PublicKey, U512}, prelude::* }; #[odra::module] pub struct ValidatorsContract { /// In this variable we store the validator's public key, this is the only way we can identify the validator validator: Var&lt;PublicKey&gt; } /// Implementation of the TestingContract #[odra::module] impl ValidatorsContract { /// Initializes the contract with the validator's public key pub fn init(&amp;mut self, validator: PublicKey) { self.validator.set(validator); } /// Stake the amount of tokens #[odra(payable)] pub fn stake(&amp;mut self) { // Get the amount of tokens attached to the call let amount = self.env().attached_value(); if amount.is_zero() { self.env().revert(ValError::InsufficientBalance); } // Use the ContractEnv's delegate method to delegate the tokens to the validator self.env().delegate(self.validator.get().unwrap(), amount); } /// Undelegate the amount from the validator pub fn unstake(&amp;mut self, amount: U512) { self.env().undelegate(self.validator.get().unwrap(), amount); } /// Withdraw the amount from the validator pub fn withdraw(&amp;mut self, amount: U512) { self.env().transfer_tokens(&amp;self.env().caller(), &amp;amount); } ... }  ","version":"2.0.1","tagName":"h2"},{"title":"Explanation​","type":1,"pageTitle":"Delegating CSPR to Validators","url":"/docs/2.0.1/advanced/delegating-cspr#explanation","content":"The above example can be a good starting point for implementing a liquid staking solution. The main things to remember are the new api methods in ContractEnv: pub fn delegate(&amp;self, validator: PublicKey, amount: U512); pub fn undelegate(&amp;self, validator: PublicKey, amount: U512); pub fn delegated_amount(&amp;self, validator: PublicKey) -&gt; U512;  As you can see, we identify the validator by its public key. Funds delegated to the validator are assigned to the calling contract. Remember, that the delegation and undelegation takes some time, depending on the configuration of the blockchain - it's not instant. For example in the Casper mainnet, the delegation takes 1 era and the undelegation takes 7 eras. ","version":"2.0.1","tagName":"h2"},{"title":"Testing​","type":1,"pageTitle":"Delegating CSPR to Validators","url":"/docs/2.0.1/advanced/delegating-cspr#testing","content":"It is possible to test the delegation and undelegation of tokens in the contract. The following code shows how to do it: examples/src/features/validators.rs ... let test_env = odra_test::env(); let auction_delay = test_env.auction_delay(); let unbonding_delay = test_env.unbonding_delay(); test_env.set_caller(test_env.get_account(0)); let mut staking = ValidatorsContract::deploy( &amp;test_env, ValidatorsContractInitArgs { validator: test_env.get_validator(0) } ); let initial_account_balance = test_env.balance_of(&amp;test_env.get_account(0)); // Stake some amount let staking_amount = U512::from(1_000_000_000_000u64); staking.with_tokens(staking_amount).stake(); assert_eq!(staking.currently_delegated_amount(), staking_amount); assert_eq!( test_env.balance_of(&amp;test_env.get_account(0)), initial_account_balance - staking_amount ); // Advance time, run auctions and give off rewards test_env.advance_with_auctions(auction_delay * 2); // Check that the amount is greater than the staking amount let staking_with_reward = staking.currently_delegated_amount(); assert!(staking_with_reward &gt; staking_amount); ...  You can see, that we use the new methods from HostEnv, namely:  fn advance_with_auctions(&amp;self, time_diff: u64); fn auction_delay(&amp;self) -&gt; u64; fn unbonding_delay(&amp;self) -&gt; u64; fn delegated_amount(&amp;self, delegator: Address, validator: PublicKey) -&gt; U512;  advance_with_auctions works in a similar way to advance_block_time, but it also runs the auctions and gives off rewards. The auction_delay and unbonding_delay methods return the values of the auction and unbonding delays specific to the network or backend. We used currently_delegated_amount in the example, it uses delegated_amount method from ContractEnv, but it is also possible to query this information from the HostEnv using delegated_amount method. ","version":"2.0.1","tagName":"h2"},{"title":"Memory allocators","type":0,"sectionRef":"#","url":"/docs/2.0.1/advanced/using-different-allocator","content":"","keywords":"","version":"2.0.1"},{"title":"Using a different allocator​","type":1,"pageTitle":"Memory allocators","url":"/docs/2.0.1/advanced/using-different-allocator#using-a-different-allocator","content":"If the default allocator does not suit your needs, or you use a crate that already provides an allocator, you can disable the default allocator by enabling the disable-allocator feature in the odra dependency in your project: [dependencies] odra = { path = &quot;../odra&quot;, features = [&quot;disable-allocator&quot;] }  If you want to have a better control over the features that are enabled during the building and tests, see the next article on building manually. ","version":"2.0.1","tagName":"h2"},{"title":"Storage Layout","type":0,"sectionRef":"#","url":"/docs/2.0.1/advanced/storage-layout","content":"","keywords":"","version":"2.0.1"},{"title":"Casper VM Perspective​","type":1,"pageTitle":"Storage Layout","url":"/docs/2.0.1/advanced/storage-layout#casper-vm-perspective","content":"The Casper Execution Engine (VM) enables the storage of data in named keys or dictionaries. However, a smart contract has a limited number of named keys, making it unsuitable for storing substantial data volumes. Odra resolves this issue by storing all user-generated data in a dictionary called state. This dictionary operates as a key-value store, where keys are strings with a maximum length of 64 characters, and values are arbitrary byte arrays. Here is an example of what the interface for reading and writing data could look like: pub trait CasperStorage { fn read(key: &amp;str) -&gt; Option&lt;Vec&lt;u8&gt;&gt;; fn write(key: &amp;str, value: Vec&lt;u8&gt;); }  ","version":"2.0.1","tagName":"h2"},{"title":"Odra Perspective​","type":1,"pageTitle":"Storage Layout","url":"/docs/2.0.1/advanced/storage-layout#odra-perspective","content":"Odra was conceived with modularity and code reusability in mind. Additionally, we aimed to streamline storage definition through the struct object. Consider this straightforward storage definition: #[odra::module] pub struct Token { name: Var&lt;String&gt;, balances: Mapping&lt;Address, U256&gt; }  The Token structure contains two fields: name of type String andbalances, which functions as a key-value store with Address as keys andU256 as values. The Token module can be reused in another module, as demonstrated in a more complex example: #[odra::module] pub struct Loans { lenders: SubModule&lt;Token&gt;, borrowers: SubModule&lt;Token&gt;, }  The Loans module has two fields: lenders and borrowers, both of which have the same storage layout as defined by the Token module. Odra guarantees thatlenders and borrowers are stored under distinct keys within the storage dictionary. Both Token and Loans serve as examples to show how Odra's storage layout operates. ","version":"2.0.1","tagName":"h2"},{"title":"Key generation.​","type":1,"pageTitle":"Storage Layout","url":"/docs/2.0.1/advanced/storage-layout#key-generation","content":"Every element of a module (struct) with N elements is associated with an index ranging from 0 to N-1, represented as a u8 with a maximum of 256 elements. If an element of a module is another module (SubModule&lt;...&gt;), the associated index serves as a prefix for the indexes of the inner module. While this may initially appear complex, it is easily understood through an example. In the example, indexes are presented as bytes, reflecting the actual implementation. Loans { lenders: Token { // prefix: 0x0001 name: 1, // key: 0x0001_0001 balances: 2 // key: 0x0001_0010 }, borrowers: Token { // prefix: 0x0010 name: 1, // key: 0x0010_0001 balances: 2 // key: 0x0010_0010 } }  Additionally, it's worth mentioning how Mapping's keys are used in thestorage. They are simply concatenated with the index of the module, as demonstrated in the example. For instance, triggering borrowers.balances.get(0x1234abcd) would result in a key: 0x0001_0001_1234_abcd  Finally, the key must be hashed to fit within the 64-character limit and then encoded in hexadecimal format. ","version":"2.0.1","tagName":"h2"},{"title":"Value serialization​","type":1,"pageTitle":"Storage Layout","url":"/docs/2.0.1/advanced/storage-layout#value-serialization","content":"Before being stored in the storage, each value is serialized into bytes using the CLType serialization method and subsequently encapsulated with Casper'sBytes types. ","version":"2.0.1","tagName":"h2"},{"title":"OdraVM","type":0,"sectionRef":"#","url":"/docs/2.0.1/backends/odra-vm","content":"","keywords":"","version":"2.0.1"},{"title":"Usage​","type":1,"pageTitle":"OdraVM","url":"/docs/2.0.1/backends/odra-vm#usage","content":"The OdraVM is the default backend for Odra framework, so each time you run cargo odra test  You are running your code against it. ","version":"2.0.1","tagName":"h2"},{"title":"Architecture​","type":1,"pageTitle":"OdraVM","url":"/docs/2.0.1/backends/odra-vm#architecture","content":"OdraVM consists of two main parts: the Contract Register and the State. The Contract Register is a list of contracts deployed onto the OdraVM, identified by an Address. Contracts and Test Env functions can modify the State of the OdraVM. Contrary to the &quot;real&quot; backend, which holds the whole history of the blockchain, the OdraVM State holds only the current state of the OdraVM. Thanks to this and the fact that we do not need the blockchain itself, OdraVM starts instantly and runs the tests in the native speed. ","version":"2.0.1","tagName":"h2"},{"title":"Execution​","type":1,"pageTitle":"OdraVM","url":"/docs/2.0.1/backends/odra-vm#execution","content":"When the OdraVM backend is enabled, the #[odra::module] attribute is responsible for converting your pub functions into a list of Entrypoints, which are put into a Contract Container. When the contract is deployed, its Container registered into a Registry under an address. During the contract call, OdraVM finds an Entrypoint and executes the code. ","version":"2.0.1","tagName":"h2"},{"title":"What is a backend?","type":0,"sectionRef":"#","url":"/docs/2.0.1/backends/what-is-a-backend","content":"","keywords":"","version":"2.0.1"},{"title":"Contract Env​","type":1,"pageTitle":"What is a backend?","url":"/docs/2.0.1/backends/what-is-a-backend#contract-env","content":"The Contract Env is a simple interface that each backend needs to implement, exposing features of the blockchain from the perspective of the contract. It gives Odra a set of functions, which allows implementing more complex concepts - for example, to implement Mapping, Odra requires some kind of storage integration. The exact implementation of those functions is a responsibility of a backend, making Odra and its user free to implement the contract logic, instead of messing with the blockchain internals. Other functions from Contract Env include handling transfers, addresses, block time, errors and events. ","version":"2.0.1","tagName":"h2"},{"title":"Host Env​","type":1,"pageTitle":"What is a backend?","url":"/docs/2.0.1/backends/what-is-a-backend#host-env","content":"Similarly to the Contract Env, the Host Env exposes a set of functions that allows the communication with the backend from the outside world - really useful for implementing tests. This ranges from interacting with the blockchain - like deploying new, loading existing and calling the contracts, to the more test-oriented - handling errors, forwarding the block time, etc. ","version":"2.0.1","tagName":"h2"},{"title":"What's next​","type":1,"pageTitle":"What is a backend?","url":"/docs/2.0.1/backends/what-is-a-backend#whats-next","content":"We will take a look at backends Odra implements in more detail. ","version":"2.0.1","tagName":"h2"},{"title":"Casper","type":0,"sectionRef":"#","url":"/docs/2.0.1/backends/casper","content":"","keywords":"","version":"2.0.1"},{"title":"Contract Env​","type":1,"pageTitle":"Casper","url":"/docs/2.0.1/backends/casper#contract-env","content":"As with any other backend, Casper Backend must implement the same features, but some do not have native support. Let's take a closer look at how Odra overcomes these hindrances. ","version":"2.0.1","tagName":"h2"},{"title":"Events​","type":1,"pageTitle":"Casper","url":"/docs/2.0.1/backends/casper#events","content":"An event is not a first-class citizen in Casper like in Ethereum, so Odra mimics it. As you've already learned from the events article, in Odra you emit an event, similarly, you would do it in Solidity. Under the hood, Odra integrates with Casper Event Standard and creates a few URefs in the global state when a contract is being installed: __events - a dictionary that stores events' data.__events_length - the evens count.__events_ces_version - the version of Casper Event Standard. __events_schema - a dictionary that stores event schemas. Besides that, all the events the contract emits are registered - events schemas are written to the storage under the __events_schema key. So, Events are nothing different from any other data stored by a contract. A struct to be an event must implement traits defined by Casper Event Standard, thankfully you can derive them using #[odra::event]. note Don't forget to expose events in the module using #[odra::module(events = [...])]. ","version":"2.0.1","tagName":"h3"},{"title":"Payable​","type":1,"pageTitle":"Casper","url":"/docs/2.0.1/backends/casper#payable","content":"The first Odra idiom is a Contract Main Purse. It is a purse associated with a contract. The purse is created lazily - when the first transfer to the contract occurs, a proper URef and a purse are created and stored under the __contract_main_purse key. Casper does not allow direct transfers from an account to a contract, so Odra comes up with the second idiom - a Cargo Purse. It is a one-time-use purse proxy between an account and a contract. First, motes go from the account to the cargo purse and then to the contract's main purse. Behind the scenes, Odra handles an account-contract transfer via a cargo purse when a function is marked as payable. If under the way something goes wrong with the transfer, the contract reverts. The transferred amount can be read inside the contract by calling self.env().attached_value(). note Odra expects the cargo_purse runtime argument to be attached to a contract call. In case of its absence, the contract_env::attached_value() returns zero. ","version":"2.0.1","tagName":"h3"},{"title":"Revert​","type":1,"pageTitle":"Casper","url":"/docs/2.0.1/backends/casper#revert","content":"In Casper, we can stop the execution pretty straightforwardly - call the runtime::revert(). Odra adds an extra abstraction layer - in a contract ExecutionErrors are defined, which ultimately are transformed into Casper's ApiError::User. ","version":"2.0.1","tagName":"h3"},{"title":"Context​","type":1,"pageTitle":"Casper","url":"/docs/2.0.1/backends/casper#context","content":"Casper equips developers with very low-level tooling, which can be cumbersome for newcomers. If you want to check who called the contract or its address, you can not do it off-hand - you must analyze the call stack. The self.env().self_address() function takes the first element of the callstack (runtime::get_call_stack()) and casts it to Address. The self.env().caller() function takes the second element of the call stack (runtime::get_call_stack()) and casts it to Address. As mentioned in the [Payable] section, to store CSPR, each contract creates its purse. To read the contract balance, you call self.env().self_balance(), which checks the balance of the purse stored under __contract_main_purse. ","version":"2.0.1","tagName":"h3"},{"title":"Test Env​","type":1,"pageTitle":"Casper","url":"/docs/2.0.1/backends/casper#test-env","content":"Test environment allows you to test wasm contracts before you deploy them onto the testnet or livenet. It is built on top of the Casper Execution Engine. In your test, you can freely switch execution context by setting as a caller (test_env::set_caller()) one of the 20 predefined accounts. Each account possesses the default amount of Motes (100_000_000_000_000_000). The Test Env internally keeps track of the current block time, error and attached value. Each test is executed on a fresh instance of the Test Env. ","version":"2.0.1","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"Casper","url":"/docs/2.0.1/backends/casper#usage","content":"Name of the Casper backend in Odra is casper, so to run the tests against it, simply pass it as a -bparameter: cargo odra test -b casper  If you want to just generate a wasm file, simply run: cargo odra build -b casper  ","version":"2.0.1","tagName":"h2"},{"title":"Deploying a contract to Casper network​","type":1,"pageTitle":"Casper","url":"/docs/2.0.1/backends/casper#deploying-a-contract-to-casper-network","content":"There would be no point in writing a contract if you couldn't deploy it to the blockchain. You can do it in two ways: provided by the Casper itself: using the casper-client tool or using the Odra's Livenet integration. Let's explore the first option to better understand the process. note If you wish, you can skip the following section and jump to the Livenet integration. ","version":"2.0.1","tagName":"h2"},{"title":"WASM arguments​","type":1,"pageTitle":"Casper","url":"/docs/2.0.1/backends/casper#wasm-arguments","content":"When deploying a new contract you can pass some arguments to it. Every contract written in Odra expects those arguments to be set: odra_cfg_package_hash_key_name - String type. The key under which the package hash of the contract will be stored.odra_cfg_allow_key_override - Bool type. If true and the key specified in odra_cfg_package_hash_key_name already exists, it will be overwritten.odra_cfg_is_upgradable - Bool type. If true, the contract will be deployed as upgradable. Additionally, if required by the contract, you can pass constructor arguments. When working with the test env via cargo odra or when usingLivenet integration this is handled automatically. However, if you rather usecasper-client directly, you have to pass them manually: ","version":"2.0.1","tagName":"h3"},{"title":"Example: Deploy Counter​","type":1,"pageTitle":"Casper","url":"/docs/2.0.1/backends/casper#example-deploy-counter","content":"To deploy your contract with a constructor using casper-client, you need to pass the above arguments. Additionally, you need to pass the value argument, which sets the arbitrary initial value for the counter. casper-client put-deploy \\ --node-address [NODE_ADDRESS] \\ --chain-name casper-test \\ --secret-key [PATH_TO_YOUR_KEY]/secret_key.pem \\ --payment-amount 5000000000000 \\ --session-path ./wasm/counter.wasm \\ --session-arg &quot;odra_cfg_package_hash_key_name:string:'counter_package_hash'&quot; \\ --session-arg &quot;odra_cfg_allow_key_override:bool:'true'&quot; \\ --session-arg &quot;odra_cfg_is_upgradable:bool:'true'&quot; \\ --session-arg &quot;value:u32:42&quot;  For a more in-depth tutorial, please refer to the Casper's 'Writing On-Chain Code'. ","version":"2.0.1","tagName":"h3"},{"title":"Example: Deploy ERC721​","type":1,"pageTitle":"Casper","url":"/docs/2.0.1/backends/casper#example-deploy-erc721","content":"Odra comes with a standard ERC721 token implementation. Clone the main Odra repo and navigate to the modules directory. Firstly contract needs to be compiled. cargo odra build -b casper -c erc721_token  It produces the erc721_token.wasm file in the wasm directory. Now it's time to deploy the contract. casper-client put-deploy \\ --node-address [NODE_ADDRESS] \\ --chain-name casper-test \\ --secret-key [PATH_TO_YOUR_KEY]/secret_key.pem \\ --payment-amount 300000000000 \\ --session-path ./wasm/erc721_token.wasm \\ --session-arg &quot;odra_cfg_package_hash_key_name:string:'my_nft'&quot; \\ --session-arg &quot;odra_cfg_allow_key_override:bool:'false'&quot; \\ --session-arg &quot;odra_cfg_is_upgradable:bool:'true'&quot; \\ --session-arg &quot;name:string:'MyNFT'&quot; \\ --session-arg &quot;symbol:string:'NFT'&quot; \\ --session-arg &quot;base_uri:string:'https://example.com/'&quot;  It's done. The contract is deployed and ready to use. Your account is the owner of the contract and you can mint and burn tokens. For more details see the code of the ERC721 module. To obtain the package hash of the contract search for my_nft key in your account's named keys. ","version":"2.0.1","tagName":"h3"},{"title":"Example: Deploy ERC1155​","type":1,"pageTitle":"Casper","url":"/docs/2.0.1/backends/casper#example-deploy-erc1155","content":"The process is similar to the one described in the previous section. Contract compilation: cargo odra build -b casper -c erc1155_token  Contract deployment: casper-client put-deploy \\ --node-address [NODE_ADDRESS] \\ --chain-name casper-test \\ --secret-key [PATH_TO_YOUR_KEY]/secret_key.pem \\ --payment-amount 300000000000 \\ --session-path ./wasm/erc1155_token.wasm \\ --session-arg &quot;odra_cfg_package_hash_key_name:string:'my_tokens'&quot; \\ --session-arg &quot;odra_cfg_allow_key_override:bool:'false'&quot; \\ --session-arg &quot;odra_cfg_is_upgradable:bool:'true'&quot; \\ --session-arg &quot;odra_cfg_constructor:string:'init'&quot; \\  As previously, your account is the owner and can mint and burn tokens. For more details see the code of the ERC1155 module. ","version":"2.0.1","tagName":"h3"},{"title":"Sending CSPR to a contract​","type":1,"pageTitle":"Casper","url":"/docs/2.0.1/backends/casper#sending-cspr-to-a-contract","content":"Defining payable entry points is described in Native Token section. What is happening under the hood is that Odra creates a new cargo_purse argument for each payable entry point. The cargo_purse needs to be top-upped with CSPR before calling the contract. When a contract adds CSPR to another contract call, Odra handles it for you. The problem arises when you want to call an entry point and attach CSPR as an account. The only way of doing that is by executing code in the sessions context, that top-ups the cargo_purse and then calls the contract. Odra provides a generic proxy_caller.wasm that does exactly that. You can build it by yourself from the main Odra repository, or use the proxy_caller.wasmwe maintain. ","version":"2.0.1","tagName":"h2"},{"title":"Using proxy_caller.wasm​","type":1,"pageTitle":"Casper","url":"/docs/2.0.1/backends/casper#using-proxy_callerwasm","content":"To use the proxy_caller.wasm you need to attach the following arguments: contract_package_hash - BytesArray(32) type. The package hash of the contract you want to call. Result of to_bytes on CasperPackageHash.entry_point - String type. The name of the entry point you want to call.args - Bytes type. It is a serialized RuntimeArgs with the arguments you want to pass to the entry point. To be specific it is the result of to_bytes method wrapped with Bytes type.attached_value. U512 type. The amount of CSPR you want to attach to the call.amount. U512 type. Should be the same value as attached_value if not None. It is a special Casper argument that enables the access to account's main purse. Currently casper-client doesn't allow building such arguments. You have to build it using your SDK. See an example in the Tutorial section. ","version":"2.0.1","tagName":"h3"},{"title":"Execution​","type":1,"pageTitle":"Casper","url":"/docs/2.0.1/backends/casper#execution","content":"First thing Odra does with your code, is similar to the one used in OdraVM - a list of entrypoints is generated, thanks to the #[odra::module] attribute. ","version":"2.0.1","tagName":"h2"},{"title":"Livenet","type":0,"sectionRef":"#","url":"/docs/2.0.1/backends/livenet","content":"","keywords":"","version":"2.0.1"},{"title":"Setup​","type":1,"pageTitle":"Livenet","url":"/docs/2.0.1/backends/livenet#setup","content":"To use Livenet backend, we need to provide Odra with some information - the network address, our private key and the name of the chain we want to use. Optionally, we can add multiple private keys to use more than one account in our tests. Those values are passed using environment variables. We can use .env file to store them - let's take a look at an example .env file, created from the .env.sample file from the examples folder: # Path to the secret key of the account that will be used # to deploy the contracts. # We're using .keys folder so we don't accidentally commit # the secret key to the repository. ODRA_CASPER_LIVENET_SECRET_KEY_PATH=.keys/secret_key.pem # RPC address of the node that will be used to deploy the contracts. ODRA_CASPER_LIVENET_NODE_ADDRESS=localhost:7777 # Chain name of the network. Known values: # - integration-test ODRA_CASPER_LIVENET_CHAIN_NAME=integration-test # Paths to the secret keys of the additional accounts. # Main secret key will be 0th account. ODRA_CASPER_LIVENET_KEY_1=.keys/secret_key_1.pem ODRA_CASPER_LIVENET_KEY_2=.keys/secret_key_2.pem # If using CSPR.cloud, you can set the auth token here. # CSPR_CLOUD_AUTH_TOKEN=  note CSPR.cloud is a service that provides mainnet and testnet Casper nodes on demand. With the proper value in place, we can write our tests or deploy scenarios. In the examples, we can find a simple binary that deploys a contract and calls it. The test is located in the erc20_on_livenet.rs file. Let's go through the code: fn main() { // Similar to the OdraVM backend, we need to initialize // the environment: let env = odra_casper_livenet_env::env(); // Most of the host env works the same as in the // OdraVM backend. let owner = env.caller(); // Addresses are the real addresses on the blockchain, // so we need to provide them // if we did not import their secret keys. let recipient = &quot;hash-2c4a6ce0da5d175e9638ec0830e01dd6cf5f4b1fbb0724f7d2d9de12b1e0f840&quot;; let recipient = Address::from_str(recipient).unwrap(); // Arguments for the contract init method. let name = String::from(&quot;Plascoin&quot;); let symbol = String::from(&quot;PLS&quot;); let decimals = 10u8; let initial_supply: U256 = U256::from(10_000); // The main difference between other backends - we need to specify // the gas limit for each action. // The limit will be used for every consecutive action // until we change it. env.set_gas(100_000_000_000u64); // Deploy the contract. The API is the same as in the OdraVM backend. let init_args = Erc20InitArgs { name, symbol, decimals, initial_supply: Some(initial_supply) }; let mut token = Erc20::deploy(env, init_args); // We can now use the contract as we would in the OdraVM backend. println!(&quot;Token address: {}&quot;, token.address().to_string()); // Uncomment to load existing contract. // let address = &quot;hash-d26fcbd2106e37be975d2045c580334a6d7b9d0a241c2358a4db970dfd516945&quot;; // let address = Address::from_str(address).unwrap(); // We use the Livenet-specific `load` method to load the contract // that is already deployed. // let mut token = Erc20Deployer::load(env, address); // Non-mutable calls are free! Neat, huh? More on that later. println!(&quot;Token name: {}&quot;, token.name()); // The next call is mutable, but the cost is lower than the deployment, // so we change the amount of gas env.set_gas(3_000_000_000u64); token.transfer(recipient, U256::from(1000)); println!(&quot;Owner's balance: {:?}&quot;, token.balance_of(owner)); println!(&quot;Recipient's balance: {:?}&quot;, token.balance_of(recipient)); }  note The above example is a rust binary, not a test. Note that it is also added as a section of theCargo.toml file: [bin] name = &quot;erc20_on_livenet&quot; path = &quot;src/bin/erc20_on_livenet.rs&quot; required-features = [&quot;livenet&quot;] test = false  ","version":"2.0.1","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"Livenet","url":"/docs/2.0.1/backends/livenet#usage","content":"To run the above code, we simply need to run the binary with the livenet feature enabled: cargo run --bin erc20_on_livenet --features=livenet  note Before executing the binary, make sure you built a wasm file. A part of a sample output should look like this: ... 💁 INFO : Calling &quot;hash-d26fcbd210...&quot; with entrypoint &quot;transfer&quot;. 🙄 WAIT : Waiting 15s for &quot;65b1a5d21...&quot;. 🙄 WAIT : Waiting 15s for &quot;65b1a5d21...&quot;. 💁 INFO : Deploy &quot;65b1a5d21...&quot; successfully executed. Owner's balance: 4004 Recipient's balance: 4000  Those logs are a result of the last 4 lines of the above listing. Each deployment or a call to the blockchain will be noted and will take some time to execute. We can see that the transfer call took over 15 seconds to execute. But calling balance_of was nearly instant and cost us nothing. How it is possible? info You can see the deployment on http://cspr.live/ - the transfer from the example can be seen here. ","version":"2.0.1","tagName":"h2"},{"title":"How Livenet backend works​","type":1,"pageTitle":"Livenet","url":"/docs/2.0.1/backends/livenet#how-livenet-backend-works","content":"All calls of entrypoints executed on a Casper blockchain cost gas - even if they do not change the state. It is possible, however, to query the state of the blockchain for free. This principle is used in the Livenet backend - all calls that do not change the state of the blockchain are really executed offline - the only thing that is requested from the node is the current state. This is why the balance_of call was almost instant and free. Basically, if the entrypoint function is not mutable or does not make a call to an unknown external contract (see Cross Calls), it is executed offline and node is used for the state query only. However, the Livenet needs to know the connection between the contracts and the code, so make sure to deploy or load already deployed contracts ","version":"2.0.1","tagName":"h2"},{"title":"Multiple environments​","type":1,"pageTitle":"Livenet","url":"/docs/2.0.1/backends/livenet#multiple-environments","content":"It is possible to have multiple environments for the Livenet backend. This is useful if we want to easily switch between multiple accounts, multiple nodes or even multiple chains. To do this, simply create a new .env file with a different prefix - for example, integration.env and mainnet.env. Then, pass the ODRA_CASPER_LIVENET_ENV variable with value either integration or mainnet to select which file has to be used first. If your integration.env file has a value that IS present in the .env file, it will override the value from the .env file. ODRA_CASPER_LIVENET_ENV=integration cargo run --bin erc20_on_livenet --features=livenet  To sum up - this command will firstly load the integration.env file and then load the missing values from .env file. ","version":"2.0.1","tagName":"h2"},{"title":"Cargo Odra","type":0,"sectionRef":"#","url":"/docs/2.0.1/basics/cargo-odra","content":"","keywords":"","version":"2.0.1"},{"title":"Managing projects​","type":1,"pageTitle":"Cargo Odra","url":"/docs/2.0.1/basics/cargo-odra#managing-projects","content":"Two commands help you create a new project. The first one is cargo odra new. You need to pass one parameter, namely --name {PROJECT_NAME}: cargo odra new --name my-project  This creates a new project in the my_project folder and name it my_project. You can see it for yourself, for example by taking a look into a Cargo.toml file created in your project's folder: [package] name = &quot;my_project&quot; version = &quot;0.1.0&quot; edition = &quot;2021&quot;  The project is created using the template located in Odra's main repository. By default it uses full template, if you want, you can use minimalistic blank by running: cargo odra new -t blank --name my-project  The third available template is workspace, which creates a workspace with two projects, similar to the one created with the full template. There are also two templates which create a project with a sample tokens native to Casper Network: cep18 and cep78. By default, the latest release of Odra will be used for the template and as a dependency. You can pass a source of Odra you want to use, by using -s parameter: cargo odra new -n my-project -s ../odra # will use local folder of odra cargo odra new -n my-project -s release/0.9.0 # will use github branch, e.g. if you want to test new release cargo odra new -n my-project -s 1.1.0 # will use a version released on crates.io  The second way of creating a project is by using init command: cargo odra init --name my-project  It works in the same way as new, but instead of creating a new folder, it creates a project in the current, empty directory. ","version":"2.0.1","tagName":"h2"},{"title":"Generating code​","type":1,"pageTitle":"Cargo Odra","url":"/docs/2.0.1/basics/cargo-odra#generating-code","content":"If you want to quickly create a new contract code, you can use the generate command: cargo odra generate -c counter  This creates a new file src/counter.rs with sample code, add appropriate use and mod sections to src/lib.rs and update the Odra.toml file accordingly. To learn more about Odra.toml file, visit Odra.toml. ","version":"2.0.1","tagName":"h2"},{"title":"Testing​","type":1,"pageTitle":"Cargo Odra","url":"/docs/2.0.1/basics/cargo-odra#testing","content":"The most used command during the development of your project should be this one: cargo odra test  It runs your tests against Odra's MockVM. It is substantially faster than CasperVMand implements all the features Odra uses. When you want to run tests against a &quot;real&quot; VM, just provide the name of the backend using -boption: cargo odra test -b casper  In the example above, Cargo Odra builds the project, generates the wasm files, spin up CasperVM instance, deploys the contracts onto it and runs the tests against it. Pretty neat. Keep in mind that this is a lot slower than OdraVM and you cannot use the debugger. This is why OdraVM was created and should be your first choice when developing contracts. Of course, testing all of your code against a blockchain VM is a must in the end. If you want to run only some of the tests, you can pass arguments to the cargo test command (which is run in the background obviously): cargo odra test -- this-will-be-passed-to-cargo-test  If you want to run tests which names contain the word two, you can execute: cargo odra test -- two  Of course, you can do the same when using the backend: cargo odra test -b casper -- two  ","version":"2.0.1","tagName":"h2"},{"title":"Building code​","type":1,"pageTitle":"Cargo Odra","url":"/docs/2.0.1/basics/cargo-odra#building-code","content":"You can also build the code itself and generate the output contracts without running the tests. To do so, simply run: cargo odra build  If the build process finishes successfully, wasm files will be located in wasm folder. Notice, that this command does not require the -b option. If you want to build specific contract, you can use -c option: cargo odra build -c counter # you pass many comma separated contracts  ","version":"2.0.1","tagName":"h2"},{"title":"Skipping building​","type":1,"pageTitle":"Cargo Odra","url":"/docs/2.0.1/basics/cargo-odra#skipping-building","content":"As building wasm files can take a long time, especially if you have a lot of contracts. If you did not change anything in your contracts and you just want to rerun the tests for the casper backend, use the -s option: cargo odra test -b casper -s  ","version":"2.0.1","tagName":"h2"},{"title":"Generating contract schema​","type":1,"pageTitle":"Cargo Odra","url":"/docs/2.0.1/basics/cargo-odra#generating-contract-schema","content":"If you want to generate a schema (including the name, entrypoints, events, etc.) for your contract, you can use the schema command: cargo odra schema  This generates a schema file in JSON format for all your contracts and places them in the resources folder. If the resources folder does not exist, it creates the folder for you. Like with the build command, you can use the -c option to generate a schema for a specific contract. ","version":"2.0.1","tagName":"h2"},{"title":"What's next​","type":1,"pageTitle":"Cargo Odra","url":"/docs/2.0.1/basics/cargo-odra#whats-next","content":"In the next section, we will take a look at all the files and directories that cargo odra created for us and explain their purpose. ","version":"2.0.1","tagName":"h2"},{"title":"Host Communication","type":0,"sectionRef":"#","url":"/docs/2.0.1/basics/communicating-with-host","content":"","keywords":"","version":"2.0.1"},{"title":"What's next​","type":1,"pageTitle":"Host Communication","url":"/docs/2.0.1/basics/communicating-with-host#whats-next","content":"In the next article, we'll dive into testing your contracts with Odra, so you can check that the code we presented in fact works! ","version":"2.0.1","tagName":"h2"},{"title":"directory-structure","type":0,"sectionRef":"#","url":"/docs/2.0.1/basics/directory-structure","content":"","keywords":"","version":"2.0.1"},{"title":"Directory structure​","type":1,"pageTitle":"directory-structure","url":"/docs/2.0.1/basics/directory-structure#directory-structure","content":"After creating a new project using Odra and running the tests, you will be presented with the following files and directories: . ├── Cargo.lock ├── Cargo.toml ├── CHANGELOG.md ├── Odra.toml ├── README.md ├── rust-toolchain ├── src/ │ ├── flipper.rs │ └── lib.rs ├── bin/ | |── build_contract.rs | └── build_schema.rs ├── target/ └── wasm/  ","version":"2.0.1","tagName":"h2"},{"title":"Cargo.toml​","type":1,"pageTitle":"directory-structure","url":"/docs/2.0.1/basics/directory-structure#cargotoml","content":"Let's first take a look at Cargo.toml file: [package] name = &quot;sample&quot; version = &quot;0.1.0&quot; edition = &quot;2021&quot; [dependencies] odra = &quot;2.0.1&quot; [dev-dependencies] odra-test = &quot;2.0.1&quot; [build-dependencies] odra-build = &quot;2.0.1&quot; [[bin]] name = &quot;sample_build_contract&quot; path = &quot;bin/build_contract.rs&quot; test = false [[bin]] name = &quot;sample_build_schema&quot; path = &quot;bin/build_schema.rs&quot; test = false [profile.release] codegen-units = 1 lto = true [profile.dev.package.&quot;*&quot;] opt-level = 3  By default, your project will use the latest odra version available at crates.io. For testing purposes,odra-test is also added as a dev dependency. ","version":"2.0.1","tagName":"h3"},{"title":"Odra.toml​","type":1,"pageTitle":"directory-structure","url":"/docs/2.0.1/basics/directory-structure#odratoml","content":"This is the file that holds information about contracts that will be generated when running cargo odra build andcargo odra test: [[contracts]] fqn = &quot;sample::Flipper&quot;  As we can see, we have a single contract, its fqn (Fully Qualified Name) corresponds to the contract is located in src/flipper.rs. More contracts can be added here by hand, or by using cargo odra generate command. ","version":"2.0.1","tagName":"h3"},{"title":"src/​","type":1,"pageTitle":"directory-structure","url":"/docs/2.0.1/basics/directory-structure#src","content":"This is the folder where your smart contract files live. ","version":"2.0.1","tagName":"h3"},{"title":"bin/​","type":1,"pageTitle":"directory-structure","url":"/docs/2.0.1/basics/directory-structure#bin","content":"This is the folder where scripts that will be used to generate code or schemas live. You don't need to modify those files, they are generated by cargo odra new command and are used by cargo odra build, cargo odra test and cargo odra schema commands. ","version":"2.0.1","tagName":"h3"},{"title":"target/​","type":1,"pageTitle":"directory-structure","url":"/docs/2.0.1/basics/directory-structure#target","content":"Files generated by cargo during the build process are put here. ","version":"2.0.1","tagName":"h3"},{"title":"wasm/​","type":1,"pageTitle":"directory-structure","url":"/docs/2.0.1/basics/directory-structure#wasm","content":"WASM files generated by cargo odra build and cargo odra test are put here. You can grab those WASM files and deploy them on the blockchain. ","version":"2.0.1","tagName":"h3"},{"title":"What's next​","type":1,"pageTitle":"directory-structure","url":"/docs/2.0.1/basics/directory-structure#whats-next","content":"Now, let's take a look at one of the files mentioned above in more detail, namely the Odra.toml file. ","version":"2.0.1","tagName":"h2"},{"title":"Casper Contract Schema","type":0,"sectionRef":"#","url":"/docs/2.0.1/basics/casper-contract-schema","content":"","keywords":"","version":"2.0.1"},{"title":"Odra and CCS​","type":1,"pageTitle":"Casper Contract Schema","url":"/docs/2.0.1/basics/casper-contract-schema#odra-and-ccs","content":"There is almost nothing you need to do to use CCS in your Odra project. The only thing to be taken care of is using odra attributes namely: module, event, odra_error and odra_type. The schema will be generated for you and available in the resources directory. note If you forget to register events and errors in the module attribute, the definition remains valid; however, the errors and events will not be incorporated into the schema. src/contract.rs use odra::prelude::*; #[odra::module( // the name of the contract, default is the module name name = &quot;MyContract&quot;, // the version of the contract, default is the version of the crate version = &quot;0.1.0&quot;, // events that the contract can emit, collected recursively if submodules are used events = [ Created, Updated ], // the error enum the contract can revert with, collected recursively if submodules are used errors = MyErrors )] pub struct MyContract { name: Var&lt;String&gt;, owner: Var&lt;Address&gt;, } #[odra::module] impl MyContract { /// Initializes the contract, sets the name and owner and emits an event pub fn init(&amp;mut self, name: String, owner: Address) { self.name.set(name.clone()); self.owner.set(owner.clone()); self.env().emit_event(Created { name }); } /// Updates the name of the contract and emits an event pub fn update(&amp;mut self, name: String) { self.name.set(name.clone()); self.env().emit_event(Updated { name }); } /// Returns the data of the contract pub fn get_data(&amp;self) -&gt; Data { Data { name: self.name.get_or_default(), owner: self.owner.get_or_revert_with(MyErrors::InvalidOwner), } } } // The struct will we visible in the schema in the types section #[odra::odra_type] pub struct Data { name: String, owner: Address, } // The enum variants will we visible in the schema in the errors section #[odra::odra_error] pub enum MyErrors { /// The owner is invalid InvalidOwner, /// The name is invalid InvalidName, } // The struct will we visible in the schema in the types and events section #[odra::event] pub struct Updated { name: String, } // The struct will we visible in the schema in the types section and events section #[odra::event] pub struct Created { name: String, }  ","version":"2.0.1","tagName":"h2"},{"title":"Generating the Schema​","type":1,"pageTitle":"Casper Contract Schema","url":"/docs/2.0.1/basics/casper-contract-schema#generating-the-schema","content":"To generate the schema run the following cargo-odra command: cargo odra schema # or pass -c flag to generate the schema for a specific contract  ","version":"2.0.1","tagName":"h2"},{"title":"Schema Output​","type":1,"pageTitle":"Casper Contract Schema","url":"/docs/2.0.1/basics/casper-contract-schema#schema-output","content":"The generated schema will be available in the resources directory. The schema is a JSON file that contains all the information about the contract. Here is an example of the generated schema: resources/my_contract_schema.json { &quot;casper_contract_schema_version&quot;: 1, &quot;toolchain&quot;: &quot;rustc 1.77.0-nightly (5bd5d214e 2024-01-25)&quot;, &quot;authors&quot;: [], &quot;repository&quot;: null, &quot;homepage&quot;: null, &quot;contract_name&quot;: &quot;MyContract&quot;, &quot;contract_version&quot;: &quot;0.1.0&quot;, &quot;types&quot;: [ { &quot;struct&quot;: { &quot;name&quot;: &quot;Created&quot;, &quot;description&quot;: null, &quot;members&quot;: [ { &quot;name&quot;: &quot;name&quot;, &quot;description&quot;: null, &quot;ty&quot;: &quot;String&quot; } ] } }, { &quot;struct&quot;: { &quot;name&quot;: &quot;Data&quot;, &quot;description&quot;: null, &quot;members&quot;: [ { &quot;name&quot;: &quot;name&quot;, &quot;description&quot;: null, &quot;ty&quot;: &quot;String&quot; }, { &quot;name&quot;: &quot;owner&quot;, &quot;description&quot;: null, &quot;ty&quot;: &quot;Key&quot; } ] } }, { &quot;struct&quot;: { &quot;name&quot;: &quot;Updated&quot;, &quot;description&quot;: null, &quot;members&quot;: [ { &quot;name&quot;: &quot;name&quot;, &quot;description&quot;: null, &quot;ty&quot;: &quot;String&quot; } ] } } ], &quot;errors&quot;: [ { &quot;name&quot;: &quot;InvalidName&quot;, &quot;description&quot;: &quot;The name is invalid&quot;, &quot;discriminant&quot;: 1 }, { &quot;name&quot;: &quot;InvalidOwner&quot;, &quot;description&quot;: &quot;The owner is invalid&quot;, &quot;discriminant&quot;: 0 } ], &quot;entry_points&quot;: [ { &quot;name&quot;: &quot;update&quot;, &quot;description&quot;: &quot;Updates the name of the contract and emits an event&quot;, &quot;is_mutable&quot;: true, &quot;arguments&quot;: [ { &quot;name&quot;: &quot;name&quot;, &quot;description&quot;: null, &quot;ty&quot;: &quot;String&quot;, &quot;optional&quot;: false } ], &quot;return_ty&quot;: &quot;Unit&quot;, &quot;is_contract_context&quot;: true, &quot;access&quot;: &quot;public&quot; }, { &quot;name&quot;: &quot;get_data&quot;, &quot;description&quot;: &quot;Returns the data of the contract&quot;, &quot;is_mutable&quot;: false, &quot;arguments&quot;: [], &quot;return_ty&quot;: &quot;Data&quot;, &quot;is_contract_context&quot;: true, &quot;access&quot;: &quot;public&quot; } ], &quot;events&quot;: [ { &quot;name&quot;: &quot;Created&quot;, &quot;ty&quot;: &quot;Created&quot; }, { &quot;name&quot;: &quot;Updated&quot;, &quot;ty&quot;: &quot;Updated&quot; } ], &quot;call&quot;: { &quot;wasm_file_name&quot;: &quot;MyContract.wasm&quot;, &quot;description&quot;: &quot;Initializes the contract, sets the name and owner and emits an event&quot;, &quot;arguments&quot;: [ { &quot;name&quot;: &quot;odra_cfg_package_hash_key_name&quot;, &quot;description&quot;: &quot;The arg name for the package hash key name.&quot;, &quot;ty&quot;: &quot;String&quot;, &quot;optional&quot;: false }, { &quot;name&quot;: &quot;odra_cfg_allow_key_override&quot;, &quot;description&quot;: &quot;The arg name for the allow key override.&quot;, &quot;ty&quot;: &quot;Bool&quot;, &quot;optional&quot;: false }, { &quot;name&quot;: &quot;odra_cfg_is_upgradable&quot;, &quot;description&quot;: &quot;The arg name for the contract upgradeability setting.&quot;, &quot;ty&quot;: &quot;Bool&quot;, &quot;optional&quot;: false }, { &quot;name&quot;: &quot;name&quot;, &quot;description&quot;: null, &quot;ty&quot;: &quot;String&quot;, &quot;optional&quot;: false }, { &quot;name&quot;: &quot;owner&quot;, &quot;description&quot;: null, &quot;ty&quot;: &quot;Key&quot;, &quot;optional&quot;: false } ] } }  ","version":"2.0.1","tagName":"h2"},{"title":"Schema Fields​","type":1,"pageTitle":"Casper Contract Schema","url":"/docs/2.0.1/basics/casper-contract-schema#schema-fields","content":"casper_contract_schema_version is the version of the schema.toolchain is the version of the Rust compiler used to compile the contract.Fields authors, repository, and homepage are optional and can be set in the Cargo.toml file.contract_name is the name of the contract - by default is the module name, may be overriden by the module attribute.contract_version denotes the version of the contract, defaulting to the version specified in the Cargo.toml file, but can be overridden by the module attribute.types comprises a list of custom structs and enums defined within the contract. Each struct or enum includes a name, description (not currently supported, with the value set to null), and a list of members.errors is a list of error enums defined within the contract. Each error includes a name, description (the first line of the variant documentation), and a discriminant.entry_points is a list of contract functions that can be called from the outside. Each entry point includes a name, description (not currently supported, with the value set to null), whether the function is mutable, a list of arguments, the return type, whether the function is called in the contract context, and the access level.events is a list of events that the contract can emit. Each event includes a name and the type (earlier defined in types) of the event.The call section provides details regarding the contract's call function, which executes upon contract deployment. It includes the name of the Wasm file, a description (reflecting the constructor's description, typically the init function), and a list of arguments. These arguments are a combination of Odra configuration arguments and constructor arguments. ","version":"2.0.1","tagName":"h2"},{"title":"Cross calls","type":0,"sectionRef":"#","url":"/docs/2.0.1/basics/cross-calls","content":"","keywords":"","version":"2.0.1"},{"title":"Contract Ref​","type":1,"pageTitle":"Cross calls","url":"/docs/2.0.1/basics/cross-calls#contract-ref","content":"We mentioned HostRef already in our Testing article - a host side reference to already deployed contract. In the module context we use a ContractRef instead, to call other contracts. Similarly to the HostRef trait implemetation for the module, the {{ModuleName}}ContractRef is generated automatically, by the #[odra::module] attribute. The reference implements all the public endpoints to the contract (those marked as pub in #[odra::module]impl), and the {{ModuleName}}ContractRef::address() function, which returns the address of the contract. External Contracts Sometimes in our contract, we would like to interact with a someone else's contract, already deployed onto the blockchain. The only thing we know about the contract is the ABI. For that purpose, we use #[odra:external_contract] attribute. This attribute should be applied to a trait. The trait defines the part of the ABI we would like to take advantage of. Let's pretend the MathEngine we defined is an external contract. There is a contract with add() function that adds two numbers somewhere. #[odra::external_contract] pub trait Adder { fn add(&amp;self, n1: u32, n2: u32) -&gt; u32; }  Odra automatically creates the AdderContractRef struct. Having an address, in the module context we can call: struct Contract { adder: External&lt;AdderContractRef&gt; } // in some function self.adder.add(3, 5) // or struct Contract { adder: Var&lt;Address&gt; } // in some function AdderContractRef::new(self.env(), address).add(3, 5)  ","version":"2.0.1","tagName":"h2"},{"title":"Loading the contract​","type":1,"pageTitle":"Cross calls","url":"/docs/2.0.1/basics/cross-calls#loading-the-contract","content":"Sometimes it is useful to load the deployed contract instead of deploying it by ourselves. This is especially useful when we want to test our contracts in Livenet backend. We can load the contract using load method on the Deployer: examples/bin/erc20_on_livenet.rs fn _load_erc20(env: &amp;HostEnv) -&gt; Erc20HostRef { let address = &quot;hash-d26fcbd2106e37be975d2045c580334a6d7b9d0a241c2358a4db970dfd516945&quot;; let address = Address::from_str(address).unwrap(); Erc20::load(env, address) }  ","version":"2.0.1","tagName":"h3"},{"title":"Testing​","type":1,"pageTitle":"Cross calls","url":"/docs/2.0.1/basics/cross-calls#testing","content":"Let's see how we can test our cross calls using this knowledge: examples/src/features/cross_calls.rs #[cfg(test)] mod tests { use super::{CrossContract, CrossContractInitArgs, MathEngineHostRef}; use odra::host::{Deployer, HostRef, NoArgs}; #[test] fn test_cross_calls() { let test_env = odra_test::env(); let math_engine_contract = MathEngine::deploy(&amp;test_env, NoArgs); let cross_contract = CrossContract::deploy( &amp;test_env, CrossContractInitArgs { math_engine_address: *math_engine_contract.address() } ); assert_eq!(cross_contract.add_using_another(), 8); } }  Each test begins with a clean instance of the blockchain, with no contracts deployed. To test an external contract, we first deploy a MathEngine contract, although we won't directly utilize it. Instead, we only extract its address. Let's continue assuming there is a contract featuring the add() function that we intend to utilize. #[cfg(test)] mod tests { use super::*; use odra::{host::{Deployer, HostRef, NoArgs}}; #[test] fn test_ext() { let test_env = odra_test::env(); let adder = Adder::new(&amp;test_env, get_adder_address(&amp;test_env)).add(3, 5) assert_eq!(adder.add(1, 2), 3); } fn get_adder_address(test_env: &amp;HostEnv) -&gt; Address { let contract = MathEngine::deploy(test_env, NoArgs); *contract.address() } }  ","version":"2.0.1","tagName":"h2"},{"title":"Errors","type":0,"sectionRef":"#","url":"/docs/2.0.1/basics/errors","content":"","keywords":"","version":"2.0.1"},{"title":"Testing errors​","type":1,"pageTitle":"Errors","url":"/docs/2.0.1/basics/errors#testing-errors","content":"Okay, but how about testing it? Let's write a test that will check if the error is thrown when the caller is not an owner: examples/src/features/handling_errors.rs #[cfg(test)] mod tests { use super::{Error, OwnedContract, OwnedContractInitArgs}; use odra::{host::Deployer, prelude::*}; #[test] fn test_owner_error() { let test_env = odra_test::env(); let owner = test_env.get_account(0); let not_an_owner = test_env.get_account(1); test_env.set_caller(owner); let init_args = OwnedContractInitArgs { name: &quot;OwnedContract&quot;.to_string() }; let mut owned_contract = OwnedContract::deploy(&amp;test_env, init_args); test_env.set_caller(not_an_owner); assert_eq!( owned_contract.try_change_name(&quot;NewName&quot;.to_string()), Err(Error::NotAnOwner.into()) ); } }  Each deployed contract is of {{ModuleName}}HostRef type and has try_{{entry_point_name}} functions that return an OdraResult.OwnedContractHostRef implements regular entrypoints: name, owner, change_name, and and safe its safe version: try_name, try_owner, try_change_name. In our example, we are calling try_change_name and expecting an error to be thrown. For assertions, we are using a standard assert_eq! macro. As the contract call returns an OdraError, we need to convert our custom error to OdraError using Into::into(). ","version":"2.0.1","tagName":"h2"},{"title":"What's next​","type":1,"pageTitle":"Errors","url":"/docs/2.0.1/basics/errors#whats-next","content":"We will learn how to emit and test events using Odra. ","version":"2.0.1","tagName":"h2"},{"title":"Events","type":0,"sectionRef":"#","url":"/docs/2.0.1/basics/events","content":"","keywords":"","version":"2.0.1"},{"title":"Testing events​","type":1,"pageTitle":"Events","url":"/docs/2.0.1/basics/events#testing-events","content":"Odra's HostEnv comes with a few functions which lets you easily test the events that a given contract has emitted: examples/src/features/events.rs use super::{PartyContract, PartyStarted}; use odra::host::{Deployer, HostEnv, NoArgs}; #[test] fn test_party() { let test_env: HostEnv = odra_test::env(); let party_contract = PartyContract::deploy(&amp;test_env, NoArgs); assert!(test_env.emitted_event( &amp;party_contract, &amp;PartyStarted { caller: test_env.get_account(0), block_time: 0 } )); assert!(test_env.emitted_native_event( &amp;party_contract, &amp;NativePartyStarted { caller: test_env.get_account(0), block_time: 0 } )); // If you do not want to check the exact event, you can use `emitted` function assert!(test_env.emitted(&amp;party_contract, &quot;PartyStarted&quot;)); // Or `emitted_native` for the native events assert!(test_env.emitted_native(&amp;party_contract, &quot;NativePartyStarted&quot;)); // You can also check how many events were emitted: assert_eq!(test_env.events_count(&amp;party_contract), 1); assert_eq!(test_env.native_events_count(&amp;party_contract), 1); }  To explore more event testing functions, check the HostEnv documentation. ","version":"2.0.1","tagName":"h2"},{"title":"What's next​","type":1,"pageTitle":"Events","url":"/docs/2.0.1/basics/events#whats-next","content":"Read the next article to learn how to call other contracts from the contract context. ","version":"2.0.1","tagName":"h2"},{"title":"Flipper Internals","type":0,"sectionRef":"#","url":"/docs/2.0.1/basics/flipper-internals","content":"","keywords":"","version":"2.0.1"},{"title":"Header​","type":1,"pageTitle":"Flipper Internals","url":"/docs/2.0.1/basics/flipper-internals#header","content":"flipper.rs use odra::prelude::*;  The first line of the file imports the odra crate. The prelude module contains all the necessary types and traits that you will need to write your contract. It is a good practice to import theodra::prelude::* module in every file that contains Odra code. This way, you will not have to import each type or trait separately. ","version":"2.0.1","tagName":"h2"},{"title":"Struct​","type":1,"pageTitle":"Flipper Internals","url":"/docs/2.0.1/basics/flipper-internals#struct","content":"flipper.rs /// A module definition. Each module struct consists of Vars and Mappings /// or/and other modules. #[odra::module] pub struct Flipper { /// The module itself does not store the value, /// it's a proxy that writes/reads value to/from the host. value: Var&lt;bool&gt;, }  In Odra, all contracts are also modules, which can be reused between contracts. That's why we need to mark the struct with the #[odra::module] attribute. In the struct definition itself, we state all the fields of the contract. Those fields can be regular Rust data types, however - those will not be persisted on the blockchain. They can also be Odra modules - defined in your project or coming from Odra itself. Finally, to make the data persistent on the blockchain, you can use something likeVar&lt;T&gt; showed above. To learn more about storage interaction, take a look at thenext article. ","version":"2.0.1","tagName":"h2"},{"title":"Impl​","type":1,"pageTitle":"Flipper Internals","url":"/docs/2.0.1/basics/flipper-internals#impl","content":"flipper.rs /// Module implementation. /// /// To generate entrypoints, /// an implementation block must be marked as #[odra::module]. #[odra::module] impl Flipper { /// Odra constructor. /// /// Initializes the contract with the value of value. pub fn init(&amp;mut self) { self.value.set(false); } ...  Similarly to the struct, we mark the impl section with the #[odra::module] attribute. Odra will take allpub functions from this section and create contract endpoints from them. So, if you wish to have functions that are not available for calling outside the contract, do not make them public. Alternatively, you can create a separate impl section without the attribute - all functions defined there, even marked with pub will be not callable. The function named init is the constructor of the contract. This function will be limited only to a single call, all further calls to it will result in an error. The init function is optional, if your contract does not need any initialization, you can skip it. flipper.rs ... /// Replaces the current value with the passed argument. pub fn set(&amp;mut self, value: bool) { self.value.set(value); } /// Replaces the current value with the opposite value. pub fn flip(&amp;mut self) { self.value.set(!self.get()); } ...  The endpoints above show you how to interact with the simplest type of storage - Var&lt;T&gt;. The data saved there using set function will be persisted in the blockchain. ","version":"2.0.1","tagName":"h2"},{"title":"Tests​","type":1,"pageTitle":"Flipper Internals","url":"/docs/2.0.1/basics/flipper-internals#tests","content":"flipper.rs #[cfg(test)] mod tests { use crate::flipper::Flipper; use odra::host::{Deployer, NoArgs}; #[test] fn flipping() { let env = odra_test::env(); // To test a module we need to deploy it. `Flipper` implements `Deployer` trait, // so we can use it to deploy the module. let mut contract = Flipper::deploy(&amp;env, NoArgs); assert!(!contract.get()); contract.flip(); assert!(contract.get()); } ...  You can write tests in any way you prefer and know in Rust. In the example above we are deploying the contract using Deployer::deploy function called on Flipper - a piece of code generated by the #[odra::module]. Because the module implements the constructor but does not accept any arguments, as the second argument of the deploy function, we pass NoArgs - one of the implementations of the InitArgs trait provided with the framework. The contract will be deployed on the VM you chose while running cargo odra test. ","version":"2.0.1","tagName":"h2"},{"title":"What's next​","type":1,"pageTitle":"Flipper Internals","url":"/docs/2.0.1/basics/flipper-internals#whats-next","content":"Now let's take a look at the different types of storage that Odra provides and how to use them. ","version":"2.0.1","tagName":"h2"},{"title":"Modules","type":0,"sectionRef":"#","url":"/docs/2.0.1/basics/modules","content":"","keywords":"","version":"2.0.1"},{"title":"Testing​","type":1,"pageTitle":"Modules","url":"/docs/2.0.1/basics/modules#testing","content":"As we don't need to hold addresses, the test is really simple: examples/src/features/modules.rs #[cfg(test)] mod tests { use super::ModulesContract; use odra::host::{Deployer, NoArgs}; #[test] fn test_modules() { let test_env = odra_test::env(); let modules_contract = ModulesContract::deploy(&amp;test_env, NoArgs); assert_eq!(modules_contract.add_using_module(), 8); } }  ","version":"2.0.1","tagName":"h2"},{"title":"What's next​","type":1,"pageTitle":"Modules","url":"/docs/2.0.1/basics/modules#whats-next","content":"We will see how to handle native token transfers. ","version":"2.0.1","tagName":"h2"},{"title":"Odra.toml","type":0,"sectionRef":"#","url":"/docs/2.0.1/basics/odra-toml","content":"","keywords":"","version":"2.0.1"},{"title":"Adding a new contract manually​","type":1,"pageTitle":"Odra.toml","url":"/docs/2.0.1/basics/odra-toml#adding-a-new-contract-manually","content":"Besides using the cargo odra generate command, you can add a new contract to be compiled by hand. To do this, add another [[contracts]] element, name it and make sure that the fqn is set correctly. For example, if you want to create a new contract called counter, your Odra.toml file should finally look like this: [[contracts]] fqn = &quot;sample::Flipper&quot; [[contracts]] fqn = &quot;sample::Counter&quot;  ","version":"2.0.1","tagName":"h2"},{"title":"What's next​","type":1,"pageTitle":"Odra.toml","url":"/docs/2.0.1/basics/odra-toml#whats-next","content":"In the next section, we'll take a closer look at the code that was generated by Odra by default - the famousFlipper contract. ","version":"2.0.1","tagName":"h2"},{"title":"Native token","type":0,"sectionRef":"#","url":"/docs/2.0.1/basics/native-token","content":"","keywords":"","version":"2.0.1"},{"title":"Testing​","type":1,"pageTitle":"Native token","url":"/docs/2.0.1/basics/native-token#testing","content":"To be able to test how many tokens a contract (or any address) has, HostEnv comes with a function -balance_of: examples/src/features/native_token.rs #[cfg(test)] mod tests { use super::PublicWallet; use odra::{casper_types::U512, host::{Deployer, HostRef, NoArgs}}; #[test] fn test_modules() { let test_env = odra_test::env(); let mut my_contract = PublicWallet::deploy(&amp;test_env, NoArgs); assert_eq!(test_env.balance_of(my_contract.address()), U512::zero()); my_contract.with_tokens(U512::from(100)).deposit(); assert_eq!(test_env.balance_of(my_contract.address()), U512::from(100)); my_contract.withdraw(U512::from(25)); assert_eq!(test_env.balance_of(my_contract.address()), U512::from(75)); } }  ","version":"2.0.1","tagName":"h2"},{"title":"HostEnv​","type":1,"pageTitle":"Native token","url":"/docs/2.0.1/basics/native-token#hostenv","content":"In a broader context of the host environment (test, livenet), you can also transfer CSPR tokens between accounts: let env = odra_casper_livenet_env::env(); //let env = odra_test::env(); let (alice, bob) = (env.get_account(0), env.get_account(1)); env.set_caller(alice); let result = env.transfer_tokens(bob, odra::casper_types::U512::from(100));  ","version":"2.0.1","tagName":"h2"},{"title":"Testing","type":0,"sectionRef":"#","url":"/docs/2.0.1/basics/testing","content":"","keywords":"","version":"2.0.1"},{"title":"HostEnv​","type":1,"pageTitle":"Testing","url":"/docs/2.0.1/basics/testing#hostenv","content":"Odra gives us some additional functions that we can use to communicate with the host (outside the contract context) and to configure how the contracts are deployed and called. Let's revisit the example from the previous article about host communication and implement the tests that prove it works: examples/src/features/testing.rs #[cfg(test)] mod tests { use crate::features::testing::{TestingContract, TestingContractInitArgs}; use odra::{host::{Deployer, HostEnv}, prelude::*}; #[test] fn env() { let test_env: HostEnv = odra_test::env(); test_env.set_caller(test_env.get_account(0)); let init_args = TestingContractInitArgs { name: &quot;MyContract&quot;.to_string() }; let testing_contract = TestingContract::deploy(&amp;test_env, init_args); let creator = testing_contract.created_by(); test_env.set_caller(test_env.get_account(1)); let init_args = TestingContractInitArgs { name: &quot;MyContract2&quot;.to_string() }; let testing_contract2 = TestingContract::deploy(&amp;test_env, init_args); let creator2 = testing_contract2.created_by(); assert_ne!(creator, creator2); } }  In the code above, at the beginning of the test, we are obtaining a HostEnv instance using odra_test::env(). Next, we are deploying two instances of the same contract, but we're using HostEnv::set_callerto change the caller - so the Address which is deploying the contract. This changes the result of the odra::ContractEnv::caller()the function we are calling inside the contract. HostEnv comes with a set of functions that will let you write better tests: fn set_caller(&amp;self, address: Address) - you've seen it in action just nowfn balance_of(&amp;self, address: &amp;Address) -&gt; U512 - returns the balance of the account associated with the given addressfn advance_block_time(&amp;self, time_diff: u64) - increases the current value of block_timefn get_account(&amp;self, n: usize) -&gt; Address - returns an n-th address that was prepared for you by Odra in advance; by default, you start with the 0-th accountfn emitted_event&lt;T: ToBytes + EventInstance, R: Addressable&gt;(&amp;self, contract_address: &amp;R, event: &amp;T) -&gt; bool - verifies if the event was emitted by the contract Full list of functions can be found in the HostEnv documentation. ","version":"2.0.1","tagName":"h2"},{"title":"What's next​","type":1,"pageTitle":"Testing","url":"/docs/2.0.1/basics/testing#whats-next","content":"We take a look at how Odra handles errors! ","version":"2.0.1","tagName":"h2"},{"title":"Storage interaction","type":0,"sectionRef":"#","url":"/docs/2.0.1/basics/storage-interaction","content":"","keywords":"","version":"2.0.1"},{"title":"Var​","type":1,"pageTitle":"Storage interaction","url":"/docs/2.0.1/basics/storage-interaction#var","content":"The Var is the simplest storage type available in the Odra framework. It serializes the data and stores it under a single key in the blockchain storage. To use it, just wrap your variable in the Var type. Let's look at a &quot;real world&quot; example of a contract that represents a dog: examples/src/features/storage/variable.rs use odra::prelude::*; #[odra::module] pub struct DogContract { barks: Var&lt;bool&gt;, weight: Var&lt;u32&gt;, name: Var&lt;String&gt;, walks: Var&lt;Vec&lt;u32&gt;&gt;, }  You can see the Var wrapping the data. Even complex types like Vec can be wrapped (with some caveats)! Let's make this contract usable, by providing a constructor and some getter functions: examples/src/features/storage/variable.rs #[odra::module] impl DogContract { pub fn init(&amp;mut self, barks: bool, weight: u32, name: String) { self.barks.set(barks); self.weight.set(weight); self.name.set(name); self.walks.set(Vec::&lt;u32&gt;::default()); } pub fn barks(&amp;self) -&gt; bool { self.barks.get_or_default() } pub fn weight(&amp;self) -&gt; u32 { self.weight.get_or_default() } pub fn name(&amp;self) -&gt; String { self.name.get_or_default() } pub fn walks_amount(&amp;self) -&gt; u32 { let walks = self.walks.get_or_default(); walks.len() as u32 } pub fn walks_total_length(&amp;self) -&gt; u32 { let walks = self.walks.get_or_default(); walks.iter().sum() } }  As you can see, you can access the data, by using get_or_default function: examples/src/features/storage/variable.rs ... self.barks.get_or_default() ...  note Keep in mind that using get() will result in an Option that you'll need to unwrap - the variable doesn't have to be initialized! To modify the data, use the set() function: examples/src/features/storage/variable.rs self.barks.set(barks);  A Var is easy to use and efficient for simple data types. One of its downsides is that it serializes the data as a whole, so when you're using complex types like Vec or HashMap, each time you get or set the whole data is read and written to the blockchain storage. In the example above, if we want to see how many walks our dog had, we would use the function: examples/src/features/storage/variable.rs pub fn walks_amount(&amp;self) -&gt; usize { let walks = self.walks.get_or_default(); walks.len() }  But to do so, we need to extract the whole serialized vector from the storage, which would inefficient, especially for larger sets of data. To tackle this issue following two types were created. ","version":"2.0.1","tagName":"h2"},{"title":"Mapping​","type":1,"pageTitle":"Storage interaction","url":"/docs/2.0.1/basics/storage-interaction#mapping","content":"The Mapping is used to store and access data as key-value pairs. To define a Mapping, you need to pass two values - the key type and the value type. Let's look at the variation of the Dog contract, that uses Mapping to store information about our dog's friends and how many times they visited: examples/src/features/storage/mapping.rs use odra::prelude::*; #[odra::module] pub struct DogContract2 { name: Var&lt;String&gt;, friends: Mapping&lt;String, u32&gt;, }  In the example above, our key is a String (it is a name of the friend) and we are storing u32 values (amount of visits). To read and write values from and into a Mapping we use a similar approach to the one shown in the Vars section with one difference - we need to pass a key: examples/src/features/storage/mapping.rs pub fn visit(&amp;mut self, friend_name: String) { let visits = self.visits(friend_name.clone()); self.friends.set(&amp;friend_name, visits + 1); } pub fn visits(&amp;self, friend_name: String) -&gt; u32 { self.friends.get_or_default(&amp;friend_name) }  The biggest improvement over a Var is that we can model functionality of a HashMap using Mapping. The amount of data written to and read from the storage is minimal. However, we cannot iterate over Mapping. We could implement such behavior by using a numeric type key and saving the length of the set in a separate variable. Thankfully Odra comes with a prepared solution - the List type. note If you take a look into List implementation in Odra, you'll see that in fact it is just a Mapping with a Var working together: core/src/list.rs use odra::prelude::*; pub struct List&lt;T&gt; { values: Mapping&lt;u32, T&gt;, index: Var&lt;u32&gt; }  ","version":"2.0.1","tagName":"h2"},{"title":"List​","type":1,"pageTitle":"Storage interaction","url":"/docs/2.0.1/basics/storage-interaction#list","content":"Going back to our DogContract example - let's revisit the walk case. This time, instead of Vec, we'll use the list: examples/src/features/storage/list.rs use odra::prelude::*; #[odra::module] pub struct DogContract3 { name: Var&lt;String&gt;, walks: List&lt;u32&gt;, }  As you can see, the notation is very similar to the Vec. To understand the usage, take a look at the reimplementation of the functions with an additional function that takes our dog for a walk (it writes the data to the storage): examples/src/features/storage/list.rs #[odra::module] impl DogContract3 { pub fn init(&amp;mut self, name: String) { self.name.set(name); } pub fn name(&amp;self) -&gt; String { self.name.get_or_default() } pub fn walks_amount(&amp;self) -&gt; u32 { self.walks.len() } pub fn walks_total_length(&amp;self) -&gt; u32 { self.walks.iter().sum() } pub fn walk_the_dog(&amp;mut self, length: u32) { self.walks.push(length); } }  Now, we can know how many walks our dog had without loading the whole vector from the storage. We need to do this to sum the length of all the walks, but the Odra framework cannot (yet) handle all the cases for you. info All of the above examples, alongside the tests, are available in the Odra repository in the examples/src/features/ folder. ","version":"2.0.1","tagName":"h2"},{"title":"Custom Types​","type":1,"pageTitle":"Storage interaction","url":"/docs/2.0.1/basics/storage-interaction#custom-types","content":"By default you can store only built-in types like numbers, Options, Results, Strings, Vectors. Implementing custom types is straightforward, your type must add #[odra::odra_type] attribute. Let's see how to implement a Dog type: use odra::prelude::*; #[odra::odra_type] pub struct Dog { pub name: String, pub age: u8, pub owner: Option&lt;Address&gt; }  #[odra_type] is applicable to named field structs and enums. It generates serialization, deserialization and schema code for your type.CLType of a custom type is CLType::Any, except for an unit-only enum, which is CLType::U8. unit_only_enum.rs enum Enum { Foo = 3, Bar = 2, Baz = 1, }  note Each custom typed field of your struct must be marked with the #[odra::odra_type] attribute . ","version":"2.0.1","tagName":"h2"},{"title":"What's next​","type":1,"pageTitle":"Storage interaction","url":"/docs/2.0.1/basics/storage-interaction#whats-next","content":"In the next article, we'll see how to query the host for information about the world and our contract. ","version":"2.0.1","tagName":"h2"},{"title":"odra-examples","type":0,"sectionRef":"#","url":"/docs/2.0.1/examples/odra-examples","content":"","keywords":"","version":"2.0.1"},{"title":"What's next​","type":1,"pageTitle":"odra-examples","url":"/docs/2.0.1/examples/odra-examples#whats-next","content":"Read the next article to learn about reusable Odra components encapsulated in odra-modules. ","version":"2.0.1","tagName":"h2"},{"title":"Installation","type":0,"sectionRef":"#","url":"/docs/2.0.1/getting-started/installation","content":"","keywords":"","version":"2.0.1"},{"title":"Prerequisites​","type":1,"pageTitle":"Installation","url":"/docs/2.0.1/getting-started/installation#prerequisites","content":"To start working with Odra, you need to have the following installed on your machine: Rust toolchain installed (see rustup.rs)wasmstrip tool installed (see wabt)wasm-opt tool installed (see binaryen) We do not provide exact commands for installing these tools, as they are different for different operating systems. Please refer to the documentation of the tools themselves. With Rust toolchain ready, you can add a new target: rustup target add wasm32-unknown-unknown  note wasm32-unknown-unknown is a target that will be used by Odra to compile your smart contracts to WASM files. ","version":"2.0.1","tagName":"h2"},{"title":"Installing Cargo Odra​","type":1,"pageTitle":"Installation","url":"/docs/2.0.1/getting-started/installation#installing-cargo-odra","content":"Cargo Odra is a helpful tool that will help you to build and test your smart contracts. It is not required to use Odra, but the documentation will assume that you have it installed. To install it, simply execute the following command: cargo install cargo-odra --locked  To check if it was installed correctly and see available commands, type: cargo odra --help  If everything went fine, we can proceed to the next step. ","version":"2.0.1","tagName":"h2"},{"title":"Creating a new Odra project​","type":1,"pageTitle":"Installation","url":"/docs/2.0.1/getting-started/installation#creating-a-new-odra-project","content":"To create a new project, simply execute: cargo odra new --name my-project &amp;&amp; cd my_project  This will create a new folder called my_project and initialize Odra there. Cargo Odra will create a sample contract for you in src directory. You can run the tests of this contract by executing: cargo odra test  This will run tests using Odra's internal OdraVM. You can run those tests against a real backend, let's use CasperVM: cargo odra test -b casper  Congratulations! Now you are ready to create contracts using Odra framework! If you had any problems during the installation process, feel free to ask for help on our Discord. ","version":"2.0.1","tagName":"h2"},{"title":"What's next?​","type":1,"pageTitle":"Installation","url":"/docs/2.0.1/getting-started/installation#whats-next","content":"If you want to see the code that you just tested, continue to the description of Flipper example. ","version":"2.0.1","tagName":"h2"},{"title":"Flipper example","type":0,"sectionRef":"#","url":"/docs/2.0.1/getting-started/flipper","content":"","keywords":"","version":"2.0.1"},{"title":"Let's flip​","type":1,"pageTitle":"Flipper example","url":"/docs/2.0.1/getting-started/flipper#lets-flip","content":"flipper.rs use odra::prelude::*; /// A module definition. Each module struct consists Vars and Mappings /// or/and another modules. #[odra::module] pub struct Flipper { /// The module itself does not store the value, /// it's a proxy that writes/reads value to/from the host. value: Var&lt;bool&gt;, } /// Module implementation. /// /// To generate entrypoints, /// an implementation block must be marked as #[odra::module]. #[odra::module] impl Flipper { /// Odra constructor. /// /// Initializes the contract. pub fn init(&amp;mut self) { self.value.set(false); } /// Replaces the current value with the passed argument. pub fn set(&amp;mut self, value: bool) { self.value.set(value); } /// Replaces the current value with the opposite value. pub fn flip(&amp;mut self) { self.value.set(!self.get()); } /// Retrieves value from the storage. /// If the value has never been set, the default value is returned. pub fn get(&amp;self) -&gt; bool { self.value.get_or_default() } } #[cfg(test)] mod tests { use crate::flipper::Flipper; use odra::host::{Deployer, NoArgs}; #[test] fn flipping() { let env = odra_test::env(); // To test a module we need to deploy it. `Flipper` implements `Deployer` trait, // so we can use it to deploy the module. let mut contract = Flipper::deploy(&amp;env, NoArgs); assert!(!contract.get()); contract.flip(); assert!(contract.get()); } }  ","version":"2.0.1","tagName":"h2"},{"title":"Testing​","type":1,"pageTitle":"Flipper example","url":"/docs/2.0.1/getting-started/flipper#testing","content":"To run the tests, execute the following command: cargo odra test # or add the `-b casper` flag to run tests on the CasperVM  ","version":"2.0.1","tagName":"h2"},{"title":"What's next​","type":1,"pageTitle":"Flipper example","url":"/docs/2.0.1/getting-started/flipper#whats-next","content":"In the next category of articles, we will go through basic concepts of Odra. ","version":"2.0.1","tagName":"h2"},{"title":"Odra for Solidity developers","type":0,"sectionRef":"#","url":"/docs/2.0.0/tutorials/odra-solidity","content":"","keywords":"","version":"2.0.0"},{"title":"Introduction​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.0.0/tutorials/odra-solidity#introduction","content":"Hi, stranger Solidity developer! If you are looking to expand your horizons into Rust-based smart contract development, you've come to the right place. Odra is a high-level framework designed to simplify the development of smart contracts for the Casper Network. This tutorial will guide you through the basics of transitioning from Solidity to Odra, highlighting key differences and providing practical examples. Before we delve into the details, we have great news for you. From the very beginning, we have been thinking of you. Our main goal was to design the framework in a way that flattens the learning curve, especially for Solidity developers. ","version":"2.0.0","tagName":"h2"},{"title":"Prerequisites​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.0.0/tutorials/odra-solidity#prerequisites","content":"To follow this guide, you should have: Knowledge of Solidity.Familiarity with Ethereum and smart contract concepts.Basic understanding of Rust, as Odra is based on it. ","version":"2.0.0","tagName":"h2"},{"title":"Hello World​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.0.0/tutorials/odra-solidity#hello-world","content":"Let's start with a simple &quot;Hello World&quot; contract in Odra. The following code snippet demonstrates a basic smart contract that stores a greeting message. OdraSolidity use odra::prelude::*; #[odra::module] pub struct HelloWorld { greet: Var&lt;String&gt;, } #[odra::module] impl HelloWorld { pub fn init(&amp;mut self, message: String) { self.greet.set(message); } pub fn get(&amp;self) -&gt; String { self.greet.get_or_default() } }  As you may have noticed, the Odra code is slightly more verbose than the Solidity code. To define a contract in Odra, you need to create a struct and implement a module for it, both annotated with the odra::module attribute. The struct contains the contract's state variables, while the module defines the contract's functions. In this example, the HelloWorld struct has a single state variable greet, which stores the greeting message. The module contains two functions: init to set the greeting message and get to retrieve it. Two key differences are: Odra does not generate getters for public state variables automatically, so you need to define them explicitly.To initialize values, you must do it in the init function, which is the contract constructor. You can't assign defaults outside the constructor. ","version":"2.0.0","tagName":"h2"},{"title":"Variable Storage and State Management​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.0.0/tutorials/odra-solidity#variable-storage-and-state-management","content":"","version":"2.0.0","tagName":"h2"},{"title":"Data Types​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.0.0/tutorials/odra-solidity#data-types","content":"OdraSolidity use core::str::FromStr; use odra::{casper_types::{bytesrepr::Bytes, U256}, prelude::*}; #[odra::module] pub struct Primitives { boo: Var&lt;bool&gt;, u: Var&lt;u8&gt;, // u8 is the smallest unsigned integer type u2: Var&lt;U256&gt;, // U256 is the biggest unsigned integer type i: Var&lt;i32&gt;, // i32 is the smallest signed integer type i2: Var&lt;i64&gt;, // i64 is the biggest signed integer type address: Var&lt;Address&gt;, bytes: Var&lt;Bytes&gt;, default_boo: Var&lt;bool&gt;, default_uint: Var&lt;U256&gt;, default_int: Var&lt;i64&gt;, default_addr: Var&lt;Address&gt;, } #[odra::module] impl Primitives { pub fn init(&amp;mut self) { self.boo.set(true); self.u.set(1); self.u2.set(U256::from(456)); self.i.set(-1); self.i2.set(456); self.address.set( Address::from_str( &quot;hash-d4b8fa492d55ac7a515c0c6043d72ba43c49cd120e7ba7eec8c0a330dedab3fb&quot;, ) .unwrap_or_revert(&amp;self.env()), ); self.bytes.set(Bytes::from(vec![0xb5])); let _min_int = U256::zero(); let _max_int = U256::MAX; } // For the types that have default values, we can use the get_or_default method pub fn get_default_boo(&amp;self) -&gt; bool { self.default_boo.get_or_default() } pub fn get_default_uint(&amp;self) -&gt; U256 { self.default_uint.get_or_default() } pub fn get_default_int(&amp;self) -&gt; i64 { self.default_int.get_or_default() } // Does not compile - Address does not have the default value pub fn get_default_addr(&amp;self) -&gt; Address { self.default_addr.get_or_default() } }  The range of integer types in Odra is slightly different from Solidity. Odra provides a wide range of integer types: u8, u16, u32, u64, U128, and U256 for unsigned integers, and i32 and i64 for signed integers. The Address type in Odra is used to represent account and contract addresses. In Odra, there is no default/zero value for the Address type; the workaround is to use Option&lt;Address&gt;. The Bytes type is used to store byte arrays. Values are stored in units called Named Keys and Dictionaries. Additionally, local variables are available within the entry points and can be used to perform necessary actions or computations within the scope of each entry point. ","version":"2.0.0","tagName":"h3"},{"title":"Constants and Immutability​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.0.0/tutorials/odra-solidity#constants-and-immutability","content":"OdraSolidity use odra::{casper_types::{account::AccountHash, U256}, prelude::*}; #[odra::module] pub struct Constants; #[odra::module] impl Constants { pub const MY_UINT: U256 = U256([123, 0, 0, 0]); pub const MY_ADDRESS: Address = Address::Account( AccountHash([0u8; 32]) ); }  In Odra, you can define constants using the const keyword. Constants are immutable and can be of any type, including custom types. In addition to constants, Solidity also supports the immutable keyword, which is used to set the value of a variable once, in the constructor. Further attempts to alter this value result in a compile error. Odra/Rust does not have an equivalent to Solidity's immutable keyword. ","version":"2.0.0","tagName":"h3"},{"title":"Variables​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.0.0/tutorials/odra-solidity#variables","content":"OdraSolidity use odra::{casper_types::U256, prelude::*}; #[odra::module] pub struct Variables { text: Var&lt;String&gt;, my_uint: Var&lt;U256&gt;, } #[odra::module] impl Variables { pub fn init(&amp;mut self) { self.text.set(&quot;Hello&quot;.to_string()); self.my_uint.set(U256::from(123)); } pub fn do_something(&amp;self) { // Local variables let i = 456; // Env variables let timestamp = self.env().get_block_time(); let sender = self.env().caller(); } }  In Solidity there are three types of variables: state variables, local variables, and global variables. State variables are stored on the blockchain and are accessible by all functions within the contract. Local variables are not stored on the blockchain and are only available within the function in which they are declared. Global variables provide information about the blockchain. Odra uses very similar concepts, but with some differences. In Odra, state variables are a part of a module definition, and local variables are available within the entry points and can be used to perform necessary actions or computations within the scope of each entry point. Global variables are accessed using an instance of ContractEnv retrieved using the env() function. ","version":"2.0.0","tagName":"h3"},{"title":"Arrays and Mappings​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.0.0/tutorials/odra-solidity#arrays-and-mappings","content":"OdraSolidity use odra::{casper_types::U256, prelude::*}; #[odra::module] pub struct MappingContract { my_map: Mapping&lt;Address, Option&lt;U256&gt;&gt; } #[odra::module] impl MappingContract { pub fn get(&amp;self, addr: Address) -&gt; U256 { // self.my_map.get(&amp;addr) would return Option&lt;Option&lt;U256&gt;&gt; // so we use get_or_default instead and unwrap the inner Option self.my_map.get_or_default(&amp;addr).unwrap_or_default() } pub fn set(&amp;mut self, addr: Address, i: U256) { self.my_map.set(&amp;addr, Some(i)); } pub fn remove(&amp;mut self, addr: Address) { self.my_map.set(&amp;addr, None); } } #[odra::module] pub struct NestedMapping { my_map: Mapping&lt;(Address, U256), Option&lt;bool&gt;&gt; } #[odra::module] impl NestedMapping { pub fn get(&amp;self, addr: Address, i: U256) -&gt; bool { self.my_map.get_or_default(&amp;(addr, i)).unwrap_or_default() } pub fn set(&amp;mut self, addr: Address, i: U256, boo: bool) { self.my_map.set(&amp;(addr, i), Some(boo)); } pub fn remove(&amp;mut self, addr: Address, i: U256) { self.my_map.set(&amp;(addr, i), None); } }  OdraSolidity use odra::prelude::*; #[odra::module] pub struct Array { // the size of the array must be known at compile time arr: Var&lt;[u8; 10]&gt;, vec: Var&lt;Vec&lt;u32&gt;&gt;, } #[odra::module] impl Array { pub fn init(&amp;mut self) { self.arr.set([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]); self.vec.set(vec![1, 2, 3, 4, 5]); } pub fn get_arr(&amp;self) -&gt; [u8; 10] { self.arr.get_or_default() } pub fn push_vec(&amp;mut self, value: u32) { let mut vec = self.vec.get_or_default(); vec.push(value); self.vec.set(vec); } pub fn pop_vec(&amp;mut self) { let mut vec = self.vec.get_or_default(); vec.pop(); self.vec.set(vec); } pub fn update_arr(&amp;mut self, index: u8, value: u8) { let mut arr = self.arr.get_or_default(); arr[index as usize] = value; self.arr.set(arr); } }  For storing a collection of data as a single unit, Odra uses the Vec type for dynamic arrays and fixed-size arrays, both wrapped with the Var container. As in Solidity, you must be aware that reading the entire array in one go can be expensive, so it's better to avoid it for large arrays. In many cases, you can use a Mapping or List instead of an array or vector to store data. ","version":"2.0.0","tagName":"h3"},{"title":"Custom types​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.0.0/tutorials/odra-solidity#custom-types","content":"OdraSolidity use odra::prelude::*; #[odra::odra_type] #[derive(Default)] pub enum Status { #[default] Pending, Shipped, Accepted, Rejected, Canceled, } #[odra::module] pub struct Enum { status: Var&lt;Status&gt;, } #[odra::module] impl Enum { pub fn get(&amp;self) -&gt; Status { self.status.get_or_default() } pub fn set(&amp;mut self, status: Status) { self.status.set(status); } pub fn cancel(&amp;mut self) { self.status.set(Status::Canceled); } pub fn reset(&amp;mut self) { self.status.set(Default::default()); } }  In Odra, custom types are defined using the #[odra::odra_type] attribute. The enum can have a default value specified using the #[default] attribute if derived from the Default trait. The enum can be used as a state variable in a contract, and its value can be set and retrieved using the set and get functions. The value cannot be deleted; however, it can be set using the Default::default() function. OdraSolidity use odra::prelude::*; #[odra::odra_type] pub struct Todo { text: String, completed: bool, } #[odra::module] pub struct Enum { // You could also use Var&lt;Vec&lt;Todo&gt;&gt; instead of List&lt;Todo&gt;, // but List is more efficient for large arrays, // it loads items lazily. todos: List&lt;Todo&gt;, } #[odra::module] impl Enum { pub fn create(&amp;mut self, text: String) { self.todos.push(Todo { text, completed: false, }); } pub fn update_text(&amp;mut self, index: u32, text: String) { if let Some(mut todo) = self.todos.get(index) { todo.text = text; self.todos.replace(index, todo); } } pub fn toggle_complete(&amp;mut self, index: u32) { if let Some(mut todo) = self.todos.get(index) { todo.completed = !todo.completed; self.todos.replace(index, todo); } } // Odra does not create getters by default pub fn get(&amp;self, index: u32) -&gt; Option&lt;Todo&gt; { self.todos.get(index) } }  Similarly to enums, custom structs are defined using the #[odra::odra_type] attribute. The struct can be used to define a list of items in a contract. The list can be created using the List type, which is more efficient for large arrays as it loads items lazily. ","version":"2.0.0","tagName":"h3"},{"title":"Data Location​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.0.0/tutorials/odra-solidity#data-location","content":"In Solidity, data location is an important concept that determines where the data is stored and how it can be accessed. The data location can be memory, storage, or calldata. In Odra, data location is not explicitly defined, but whenever interacting with storage primitives (e.g., Var, Mapping, List), the data is stored in the contract's storage. ","version":"2.0.0","tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.0.0/tutorials/odra-solidity#functions","content":"Odra contracts define their entry point and internal functions within the impl block. Here's an example of a transfer function: impl Erc20 { pub fn transfer(&amp;mut self, recipient: &amp;Address, amount: &amp;U256) { self.internal_transfer(&amp;self.env().caller(), recipient, amount); // Transfer logic goes here } fn internal_transfer(&amp;mut self, sender: &amp;Address, recipient: &amp;Address, amount: &amp;U256) { // Internal transfer logic goes here } }  Functions can modify contract state and emit events using the ContractEnv function. ","version":"2.0.0","tagName":"h2"},{"title":"View and Pure​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.0.0/tutorials/odra-solidity#view-and-pure","content":"OdraSolidity use odra::prelude::*; #[odra::module] pub struct ViewAndPure { x: Var&lt;u32&gt; } #[odra::module] impl ViewAndPure { pub fn add_to_x(&amp;self, y: u32) -&gt; u32 { self.x.get_or_default() + y } } pub fn add(i: u32, j: u32) -&gt; u32 { i + j }  In Odra, you don't need to specify view or pure functions explicitly. All functions are considered view functions by default, meaning they can read contract state but not modify it. To modify the state, the first parameter (called the receiver parameter) should be &amp;mut self. If you want to create a pure function that doesn't read or modify state, you can define it as a regular Rust function without any side effects. ","version":"2.0.0","tagName":"h3"},{"title":"Modifiers​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.0.0/tutorials/odra-solidity#modifiers","content":"OdraSolidity use odra::prelude::*; #[odra::module] pub struct FunctionModifier { x: Var&lt;u32&gt;, locked: Var&lt;bool&gt;, } #[odra::module] impl FunctionModifier { pub fn decrement(&amp;mut self, i: u32) { self.lock(); self.x.set(self.x.get_or_default() - i); if i &gt; 1 { self.decrement(i - 1); } self.unlock(); } #[inline] fn lock(&amp;mut self) { if self.locked.get_or_default() { self.env().revert(Error::NoReentrancy); } self.locked.set(true); } #[inline] fn unlock(&amp;mut self) { self.locked.set(false); } } #[odra::odra_error] pub enum Error { NoReentrancy = 1, }  In Odra, there is no direct equivalent to Solidity's function modifiers. Instead, you can define functions that perform certain actions before or after the main function logic. In the example above, the lock and unlock functions are called before and after the decrement function, respectively, but they must be called explicitly. As often as practicable, developers should inline functions by including the body of the function within their code using the #[inline] attribute. In the context of coding for Casper blockchain purposes, this reduces the overhead of executed Wasm and prevents unexpected errors due to exceeding resource tolerances. ","version":"2.0.0","tagName":"h3"},{"title":"Visibility​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.0.0/tutorials/odra-solidity#visibility","content":"Functions and state variables have to declare whether they are accessible by other contracts. Functions can be declared as: OdraSolidity `pub` inside `#[odra::module]` impl block - any contract/submodule and account can call. `pub` inside a regular impl block - any submodule can call. `default/no modifier/private` - only inside the contract that defines the function.  ","version":"2.0.0","tagName":"h3"},{"title":"Payable​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.0.0/tutorials/odra-solidity#payable","content":"OdraSolidity use odra::{casper_types::U512, prelude::*}; #[odra::module] pub struct Payable { owner: Var&lt;Address&gt;, } #[odra::module] impl Payable { pub fn init(&amp;mut self) { self.owner.set(self.env().caller()); } #[odra(payable)] pub fn deposit(&amp;self) { } pub fn not_payable(&amp;self) { } pub fn withdraw(&amp;self) { let amount = self.env().self_balance(); self.env().transfer_tokens(&amp;self.owner.get_or_revert_with(ExecutionError::UnwrapError), &amp;amount); } pub fn transfer(&amp;self, to: Address, amount: U512) { self.env().transfer_tokens(&amp;to, &amp;amount); } }  In Odra, you can define a function with the #[odra(payable)] attribute to indicate that the function can receive CSPRs. In Solidity, the payable keyword is used to define functions that can receive Ether. ","version":"2.0.0","tagName":"h3"},{"title":"Selectors​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.0.0/tutorials/odra-solidity#selectors","content":"In Solidity, when a function is called, the first 4 bytes of calldata specify which function to call. This is called a function selector. contract_addr.call( abi.encodeWithSignature(&quot;transfer(address,uint256)&quot;, address, 1234) )  Odra does not support such a mechanism. You must have access to the contract interface to call a function. ","version":"2.0.0","tagName":"h3"},{"title":"Events and Logging​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.0.0/tutorials/odra-solidity#events-and-logging","content":"OdraSolidity use odra::prelude::*; #[odra::event] pub struct Log { sender: Address, message: String, } #[odra::event] pub struct AnotherLog {} #[odra::module] struct Event; #[odra::module] impl Event { pub fn test(&amp;self) { let env = self.env(); env.emit_event(Log { sender: env.caller(), message: &quot;Hello World!&quot;.to_string(), }); env.emit_event(Log { sender: env.caller(), message: &quot;Hello Casper!&quot;.to_string(), }); env.emit_event(AnotherLog {}); } }  In Odra, events are regular structs defined using the #[odra::event] attribute. The event struct can contain multiple fields, which can be of any type (primitive or custom Odra type). To emit an event, use the env's emit_event() function, passing the event struct as an argument. note Events in Solidity are used to emit logs that off-chain services can capture. However, Casper does not support events natively. Odra mimics this feature. Read more about it in the Basics section. ","version":"2.0.0","tagName":"h2"},{"title":"Error Handling​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.0.0/tutorials/odra-solidity#error-handling","content":"OdraSolidity use odra::{prelude::*, casper_types::{U256, U512}}; #[odra::odra_error] pub enum CustomError { InsufficientBalance = 1, InputLowerThanTen = 2, } #[odra::module] pub struct Error; #[odra::module] impl Error { pub fn test_require(&amp;mut self, i: U256) { if i &lt;= 10.into() { self.env().revert(CustomError::InputLowerThanTen); } } pub fn execute_external_call(&amp;self, withdraw_amount: U512) { let balance = self.env().self_balance(); if balance &lt; withdraw_amount { self.env().revert(CustomError::InsufficientBalance); } } }  In Solidity, there are four ways to handle errors: require, revert, assert, and custom errors. In Odra, there is only one way to revert the execution of a function - by using the env().revert() function. The function takes an error type as an argument and stops the execution of the function. You define an error type using the #[odra::odra_error] attribute. On Casper, an error is only a number, so you can't pass a message with the error. ","version":"2.0.0","tagName":"h2"},{"title":"Composition vs. Inheritance​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.0.0/tutorials/odra-solidity#composition-vs-inheritance","content":"In Solidity, developers often use inheritance to reuse code and establish relationships between contracts. However, Odra and Rust follow a different paradigm known as composition. Instead of inheriting behavior from parent contracts, Odra encourages the composition of contracts by embedding one contract within another. Let's take a look at the difference between inheritance in Solidity and composition in Odra. OdraSolidity use odra::prelude::*; #[odra::module] pub struct A; #[odra::module] impl A { pub fn foo(&amp;self) -&gt; String { &quot;A&quot;.to_string() } } #[odra::module] pub struct B { a: SubModule&lt;A&gt; } #[odra::module] impl B { pub fn foo(&amp;self) -&gt; String { &quot;B&quot;.to_string() } } #[odra::module] pub struct C { a: SubModule&lt;A&gt; } #[odra::module] impl C { pub fn foo(&amp;self) -&gt; String { &quot;C&quot;.to_string() } } #[odra::module] pub struct D { b: SubModule&lt;B&gt;, c: SubModule&lt;C&gt; } #[odra::module] impl D { pub fn foo(&amp;self) -&gt; String { self.c.foo() } } #[odra::module] pub struct E { b: SubModule&lt;B&gt;, c: SubModule&lt;C&gt; } #[odra::module] impl E { pub fn foo(&amp;self) -&gt; String { self.b.foo() } } #[odra::module] pub struct F { a: SubModule&lt;A&gt;, b: SubModule&lt;B&gt;, } #[odra::module] impl F { pub fn foo(&amp;self) -&gt; String { self.a.foo() } }  Solidity supports both single and multiple inheritance. This means a contract can inherit from one or more contracts. Solidity uses a technique called &quot;C3 linearization&quot; to resolve the order in which base contracts are inherited in the case of multiple inheritance. This helps to ensure a consistent method resolution order. However, multiple inheritance can lead to complex code and potential issues, especially for inexperienced developers. In contrast, Rust does not have a direct equivalent to the inheritance model, but it achieves similar goals through composition. Each contract is defined as a struct, and contracts can be composed by embedding one struct within another. This approach provides a more flexible and modular way to reuse code and establish relationships between contracts. ","version":"2.0.0","tagName":"h2"},{"title":"Libraries and Utility​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.0.0/tutorials/odra-solidity#libraries-and-utility","content":"OdraSolidity use odra::{casper_types::U256, prelude::*}; mod math { use odra::casper_types::U256; pub fn sqrt(y: U256) -&gt; U256 { let mut z = y; if y &gt; 3.into() { let mut x = y / 2 + 1; while x &lt; z { z = x; x = (y / x + x) / 2; } } else if y != U256::zero() { z = U256::one(); } z } } #[odra::module] struct TestMath; #[odra::module] impl TestMath { pub fn test_square_root(&amp;self, x: U256) -&gt; U256 { math::sqrt(x) } } #[odra::odra_error] enum Error { EmptyArray = 100, } trait Removable { fn remove(&amp;mut self, index: usize); } impl Removable for Var&lt;Vec&lt;U256&gt;&gt; { fn remove(&amp;mut self, index: usize) { let env = self.env(); let mut vec = self.get_or_default(); if vec.is_empty() { env.revert(Error::EmptyArray); } vec[index] = vec.pop().unwrap_or_revert(&amp;env); self.set(vec); } } #[odra::module] struct TestArray { arr: Var&lt;Vec&lt;U256&gt;&gt;, } #[odra::module] impl TestArray { pub fn test_array_remove(&amp;mut self) { let mut arr = self.arr.get_or_default(); for i in 0..3 { arr.push(i.into()); } self.arr.set(arr); self.arr.remove(1); let arr = self.arr.get_or_default(); assert_eq!(arr.len(), 2); assert_eq!(arr[0], 0.into()); assert_eq!(arr[1], 2.into()); } }  In Solidity, libraries are similar to contracts but can't declare any state variables and can't receive Ether. In the sample code above, the Math library contains a square root function, while the Array library provides a function to remove an element from an array. Both libraries are consumed in different ways: the TestMath contract calls the sqrt function directly, while the TestArray contract uses the using keyword, which extends the type uint256[] by adding the remove function. In Odra, you use language-level features: modules and traits. The mod keyword defines a module, which is similar to a library in Solidity. Modules can contain functions, types, and other items that can be reused across multiple contracts. Traits are similar to interfaces in other programming languages, defining a set of functions that a type must implement. Implementing the Removable trait for the Var&lt;Vec&lt;U256&gt;&gt; type allows the remove function to be called on a variable that stores a vector of U256 values. ","version":"2.0.0","tagName":"h2"},{"title":"Fallback and Receive Functions​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.0.0/tutorials/odra-solidity#fallback-and-receive-functions","content":"In Solidity, a contract receiving Ether must implement a receive() and/or fallback() function. The receive() function is called when Ether is sent to the contract with no data, while the fallback() function is called when the contract receives Ether with data or when a function that does not exist is called. Odra does not have a direct equivalent to the receive() and fallback() functions. Instead, you can define a function with the #[odra(payable)] attribute to indicate that the function can receive CSPRs. ","version":"2.0.0","tagName":"h2"},{"title":"Miscellaneous​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.0.0/tutorials/odra-solidity#miscellaneous","content":"","version":"2.0.0","tagName":"h2"},{"title":"Hashing​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.0.0/tutorials/odra-solidity#hashing","content":"OdraSolidity use odra::{casper_types::{bytesrepr::ToBytes, U256}, prelude::*}; #[odra::module] pub struct HashFunction; #[odra::module] impl HashFunction { pub fn hash(&amp;self, text: String, num: U256, addr: Address) -&gt; [u8; 32] { let env = self.env(); let mut data = Vec::new(); data.extend(text.to_bytes().unwrap_or_revert(&amp;env)); data.extend(num.to_bytes().unwrap_or_revert(&amp;env)); data.extend(addr.to_bytes().unwrap_or_revert(&amp;env)); env.hash(data) } } #[odra::module] pub struct GuessTheMagicWord { answer: Var&lt;[u8; 32]&gt;, } #[odra::module] impl GuessTheMagicWord { /// Initializes the contract with the magic word hash. pub fn init(&amp;mut self) { self.answer.set([ 0x86, 0x67, 0x15, 0xbb, 0x0b, 0x96, 0xf1, 0x06, 0xe0, 0x68, 0x07, 0x89, 0x22, 0x84, 0x42, 0x81, 0x19, 0x6b, 0x1e, 0x61, 0x45, 0x50, 0xa5, 0x70, 0x4a, 0xb0, 0xa7, 0x55, 0xbe, 0xd7, 0x56, 0x08, ]); } /// Checks if the `word` is the magic word. pub fn guess(&amp;self, word: String) -&gt; bool { let env = self.env(); let hash = env.hash(word.to_bytes().unwrap_or_revert(&amp;env)); hash == self.answer.get_or_default() } }  The key difference between the two is that in Solidity, the keccak256 function is used to hash data, while in Odra, the env.hash() function is used, which implements the blake2b algorithm. Both functions take a byte array as input and return a 32-byte hash. ","version":"2.0.0","tagName":"h3"},{"title":"Try-catch​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.0.0/tutorials/odra-solidity#try-catch","content":"OdraSolidity use odra::prelude::*; #[odra::module] pub struct Example { other_contract: External&lt;OtherContractContractRef&gt;, } #[odra::module] impl Example { pub fn init(&amp;mut self, other_contract: Address) { self.other_contract.set(other_contract); } pub fn execute_external_call(&amp;self) { let result = self.other_contract.some_function(); match result { Ok(success) =&gt; { // Code to execute if the external call was successful } Err(reason) =&gt; { // Code to execute if the external call failed } } } } #[odra::module] pub struct OtherContract; #[odra::module] impl OtherContract { pub fn some_function(&amp;self) -&gt; Result&lt;bool, ()&gt; { Ok(true) } }  In Solidity, try/catch is a feature that allows developers to handle exceptions and errors more gracefully. The try/catch statement allows developers to catch and handle exceptions that occur during external function calls and contract creation. In Odra, there is no direct equivalent to the try/catch statement in Solidity. However, you can use the Result type to handle errors in a similar way. The Result type is an enum that represents either success (Ok) or failure (Err). You can use the match statement to handle the Result type and execute different code based on the result. However, if an unexpected error occurs on the way, the whole transaction reverts. ","version":"2.0.0","tagName":"h3"},{"title":"Conclusion​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.0.0/tutorials/odra-solidity#conclusion","content":"Congratulations! You've now learned the main differences in writing smart contracts with the Odra Framework. By understanding the structure, initialization, error handling, and the composition pattern in Odra, you can effectively transition from Solidity to Odra for Casper blockchain development. Experiment with the provided code samples, explore more advanced features, and unleash the full potential of the Odra Framework. Read more about the Odra Framework in the Basics and Advanced sections. Learn by example with our Tutorial series, you will find there a contract you likely familiar with - the Erc20 standard implementation. If you have any further questions or need clarification on specific topics, feel free to join our Discord! ","version":"2.0.0","tagName":"h2"},{"title":"Using odra-modules","type":0,"sectionRef":"#","url":"/docs/2.0.1/examples/using-odra-modules","content":"","keywords":"","version":"2.0.1"},{"title":"Available modules​","type":1,"pageTitle":"Using odra-modules","url":"/docs/2.0.1/examples/using-odra-modules#available-modules","content":"Odra modules comes with couple of ready-to-use modules and reusable extensions. ","version":"2.0.1","tagName":"h2"},{"title":"Tokens​","type":1,"pageTitle":"Using odra-modules","url":"/docs/2.0.1/examples/using-odra-modules#tokens","content":"CEP-18​ Casper Ecosystem Proposal 18 (CEP-18) is a standard interface for the CSPR and the custom made tokens. Inspired by the ERC20 standard. Read more about the CEP-18 here. CEP-95​ Casper Ecosystem Proposal 95 (CEP-95) is a Casper NFT Standard. It aims to replace CEP-47 and CEP-78, which have flaws that complicate their support in the ecosystem. This standard is aligned with Ethereum's ERC-721, but makes adjustments relevant for the Casper Ecosystem. Similarly to ERC-721, this standard can be used to represent a various range of tokenized assets Read more about the CEP-95 here. Erc20​ The Erc20 module implements the ERC20 standard. Erc721​ The Erc721Base module implements the ERC721 standard, adjusted for the Odra framework. The Erc721Token module implements the ERC721Base and additionally uses the Erc721Metadata and Ownable extensions. The Erc721Receiver trait lets you implement your own logic for receiving NFTs. The OwnedErc721WithMetadata trait is a combination of Erc721Token, Erc721Metadata and Ownable modules. Erc1155​ The Erc1155Base module implements the ERC1155 standard, adjusted for the Odra framework. The Erc1155Token module implements the ERC1155Base and additionally uses the Ownable extension. The OwnedErc1155 trait is a combination of Erc1155Token and Ownable modules. Wrapped native token​ The WrappedNativeToken module implements the Wrapper for the native token, it was inspired by the WETH. ","version":"2.0.1","tagName":"h3"},{"title":"Access​","type":1,"pageTitle":"Using odra-modules","url":"/docs/2.0.1/examples/using-odra-modules#access","content":"AccessControl​ This module enables the implementation of role-based access control mechanisms for children modules. Roles are identified by their 32-bytes identifier, which should be unique and exposed in the external API. Ownable​ This module provides a straightforward access control feature that enables exclusive access to particular functions by an account, known as the owner. The account that initiates the module is automatically assigned as the owner. However, ownership can be transferred later by using thetransfer_ownership() function. Ownable2Step​ An extension of the Ownable module. Ownership can be transferred in a two-step process by using transfer_ownership() and accept_ownership() functions. ","version":"2.0.1","tagName":"h3"},{"title":"Security​","type":1,"pageTitle":"Using odra-modules","url":"/docs/2.0.1/examples/using-odra-modules#security","content":"Pausable​ A module allowing to implement an emergency stop mechanism that can be triggered by any account. ","version":"2.0.1","tagName":"h3"},{"title":"Migration guide to v1.3.0","type":0,"sectionRef":"#","url":"/docs/2.0.1/migrations/to-1.3.0","content":"","keywords":"","version":"2.0.1"},{"title":"Migrating to Odra v1.3.0​","type":1,"pageTitle":"Migration guide to v1.3.0","url":"/docs/2.0.1/migrations/to-1.3.0#migrating-to-odra-v130","content":"To migrate your smart contracts to Odra v1.3.0, remove the use the deploy method from the module instead of the {{ModuleName}}HostRef struct: before.rs let token = TokenHostRef::deploy(env, init_args); let another_token = AnotherTokenHostRef::load(env, address);  after.rs let token = Token::deploy(env, init_args); let another_token = AnotherToken::load(env, address);  ","version":"2.0.1","tagName":"h2"},{"title":"Migration guide to v2.0.0 from 1.*","type":0,"sectionRef":"#","url":"/docs/2.0.1/migrations/to-2.0.0","content":"","keywords":"","version":"2.0.1"},{"title":"Updating rustc version​","type":1,"pageTitle":"Migration guide to v2.0.0 from 1.*","url":"/docs/2.0.1/migrations/to-2.0.0#updating-rustc-version","content":"Update rust-toolchain file in your project: nightly-2024-07-31  ","version":"2.0.1","tagName":"h2"},{"title":"Access Control","type":0,"sectionRef":"#","url":"/docs/2.0.1/tutorials/access-control","content":"","keywords":"","version":"2.0.1"},{"title":"Code​","type":1,"pageTitle":"Access Control","url":"/docs/2.0.1/tutorials/access-control#code","content":"Before we start writing code, we list the functionalities of our access control layer. A Role type is used across the module.A Role can be assigned to many Addresses.Each Role may have a corresponding admin role.Only an admin can grant/revoke a Role.A Role can be renounced.A Role cannot be renounced on someone's behalf.Each action triggers an event.Unauthorized access stops contract execution. ","version":"2.0.1","tagName":"h2"},{"title":"Project Structure​","type":1,"pageTitle":"Access Control","url":"/docs/2.0.1/tutorials/access-control#project-structure","content":"access-control ├── src │ ├── access │ │ ├── access_control.rs │ │ ├── events.rs │ │ └── errors.rs │ └── lib.rs |── build.rs |── Cargo.toml └── Odra.toml  ","version":"2.0.1","tagName":"h3"},{"title":"Events and Errors​","type":1,"pageTitle":"Access Control","url":"/docs/2.0.1/tutorials/access-control#events-and-errors","content":"There are three actions that can be performed concerning a Role: granting, revoking, and altering the admin role. Let us establish standard Odra events for each of these actions. events.rs use odra::prelude::*; use super::access_control::Role; #[odra::event] pub struct RoleGranted { pub role: Role, pub address: Address, pub sender: Address } #[odra::event] pub struct RoleRevoked { pub role: Role, pub address: Address, pub sender: Address } #[odra::event] pub struct RoleAdminChanged { pub role: Role, pub previous_admin_role: Role, pub new_admin_role: Role }  L4-L16 - to describe the grant or revoke actions, our events specify the Role, and Addresses indicating who receives or loses access and who provides or withdraws it.L18-L23 - the event describing the admin role change, requires the subject Role, the previous and the current admin Role. errors.rs #[odra::odra_error] pub enum Error { MissingRole = 20_000, RoleRenounceForAnotherAddress = 20_001, }  Errors definition is straightforward - there are only two invalid states: An action is triggered by an unauthorized actor.The caller is attempting to resign the Role on someone's behalf.  ","version":"2.0.1","tagName":"h3"},{"title":"Module​","type":1,"pageTitle":"Access Control","url":"/docs/2.0.1/tutorials/access-control#module","content":"Now, we are stepping into the most interesting part: the module definition and implementation. access_control.rs use super::events::*; use super::errors::Error; use odra::prelude::*; pub type Role = [u8; 32]; pub const DEFAULT_ADMIN_ROLE: Role = [0u8; 32]; #[odra::module(events = [RoleAdminChanged, RoleGranted, RoleRevoked])] pub struct AccessControl { roles: Mapping&lt;(Role, Address), bool&gt;, role_admin: Mapping&lt;Role, Role&gt; } #[odra::module] impl AccessControl { pub fn has_role(&amp;self, role: &amp;Role, address: &amp;Address) -&gt; bool { self.roles.get_or_default(&amp;(*role, *address)) } pub fn get_role_admin(&amp;self, role: &amp;Role) -&gt; Role { let admin_role = self.role_admin.get(role); if let Some(admin) = admin_role { admin } else { DEFAULT_ADMIN_ROLE } } pub fn grant_role(&amp;mut self, role: &amp;Role, address: &amp;Address) { self.check_role(&amp;self.get_role_admin(role), &amp;self.env().caller()); self.unchecked_grant_role(role, address); } pub fn revoke_role(&amp;mut self, role: &amp;Role, address: &amp;Address) { self.check_role(&amp;self.get_role_admin(role), &amp;self.env().caller()); self.unchecked_revoke_role(role, address); } pub fn renounce_role(&amp;mut self, role: &amp;Role, address: &amp;Address) { if address != &amp;self.env().caller() { self.env().revert(Error::RoleRenounceForAnotherAddress); } self.unchecked_revoke_role(role, address); } } impl AccessControl { pub fn check_role(&amp;self, role: &amp;Role, address: &amp;Address) { if !self.has_role(role, address) { self.env().revert(Error::MissingRole); } } pub fn set_admin_role(&amp;mut self, role: &amp;Role, admin_role: &amp;Role) { let previous_admin_role = self.get_role_admin(role); self.role_admin.set(role, *admin_role); self.env().emit_event(RoleAdminChanged { role: *role, previous_admin_role, new_admin_role: *admin_role }); } pub fn unchecked_grant_role(&amp;mut self, role: &amp;Role, address: &amp;Address) { if !self.has_role(role, address) { self.roles.set(&amp;(*role, *address), true); self.env().emit_event(RoleGranted { role: *role, address: *address, sender: self.env().caller() }); } } pub fn unchecked_revoke_role(&amp;mut self, role: &amp;Role, address: &amp;Address) { if self.has_role(role, address) { self.roles.set(&amp;(*role, *address), false); self.env().emit_event(RoleRevoked { role: *role, address: *address, sender: self.env().caller() }); } } }  L5 - Firstly, we need the Role type. It is simply an alias for a 32-byte array.L7 - The default role is an array filled with zeros.L10-L13 - The storage consists of two mappings: roles - a nested mapping that stores information about whether a certain Role is granted to a given Address.role_admin - each Role can have a single admin Role. L17-L19 - This is a simple check to determine if a Role has been granted to a given Address. It is an exposed entry point and an important building block widely used throughout the entire module.L48 - This is a non-exported block containing helper functions.L49-L53 - The check_role() function serves as a guard function. Before a Role is granted or revoked, we must ensure that the caller is allowed to do so. For this purpose, the function reads the roles mapping. If the role has not been granted to the address, the contract reverts with Error::MissingRole.L55-L63 - The set_admin_role() function simply updates the role_admin mapping and emits the RoleAdminChanged event.L65-L85 - The unchecked_grant_role() and unchecked_revoke_role() functions are mirror functions that update the roles mapping and post RoleGranted or RoleRevoked events. If the role is already granted, unchecked_grant_role() has no effect (the opposite check is made in the case of revoking a role).L21-L28 - The get_role_admin() entry point reads the role_admin. If there is no admin role for a given role, it returns the default role.L30-L45 - This is a combination of check_role() and unchecked_*_role(). Entry points fail on unauthorized access. ","version":"2.0.1","tagName":"h3"},{"title":"Migration guide to v0.9.0","type":0,"sectionRef":"#","url":"/docs/2.0.1/migrations/to-0.9.0","content":"","keywords":"","version":"2.0.1"},{"title":"1. Prerequisites​","type":1,"pageTitle":"Migration guide to v0.9.0","url":"/docs/2.0.1/migrations/to-0.9.0#1-prerequisites","content":"","version":"2.0.1","tagName":"h2"},{"title":"1.1. Update cargo-odra​","type":1,"pageTitle":"Migration guide to v0.9.0","url":"/docs/2.0.1/migrations/to-0.9.0#11-update-cargo-odra","content":"Before you begin the migration process, make sure you installed the latest version of the Cargo Odra toolchain. You can install it by running the following command: cargo install cargo-odra --force --locked  ","version":"2.0.1","tagName":"h3"},{"title":"1.2. Review the Changelog​","type":1,"pageTitle":"Migration guide to v0.9.0","url":"/docs/2.0.1/migrations/to-0.9.0#12-review-the-changelog","content":"Before you move to changing your code, start by reviewing the Changelog to understand the changes introduced in v0.9.0. ","version":"2.0.1","tagName":"h3"},{"title":"2. Migration Steps​","type":1,"pageTitle":"Migration guide to v0.9.0","url":"/docs/2.0.1/migrations/to-0.9.0#2-migration-steps","content":"","version":"2.0.1","tagName":"h2"},{"title":"2.1 Update build_schema.rs bin​","type":1,"pageTitle":"Migration guide to v0.9.0","url":"/docs/2.0.1/migrations/to-0.9.0#21-update-build_schemars-bin","content":"Odra 0.9.0 adds a new standardized way of generating contract schema - Casper Contract Schema. You can find the updated build_schema.rs file in templates directory in the Odra main repository. You can choose whatever template you want to use and copy the files to your project. In both files, you should replace {{project-name}} with the name of your project. ","version":"2.0.1","tagName":"h3"},{"title":"2.2 Update smart contract code​","type":1,"pageTitle":"Migration guide to v0.9.0","url":"/docs/2.0.1/migrations/to-0.9.0#22-update-smart-contract-code","content":"The main changes in the smart contract code are related to the way of defining custom types, events and errors. The following sections will guide you through the necessary changes. 2.2.1. Update custom types definitions.​ #[derive(OdraType)] attribute has been replace with #[odra::odra_type] attribute. 0.9.00.8.0 use odra::Address; #[odra::odra_type] pub struct Dog { pub name: String, pub age: u8, pub owner: Option&lt;Address&gt; }  2.2.2. Update errors definitions.​ #[derive(OdraError)] attribute has been replace with #[odra::odra_error] attribute. Error enum should be passed as a parameter to the #[odra::module] attribute. 0.9.00.8.0 #[odra::module(events = [/* events go here */], errors = Error)] pub struct Erc20 { // fields } #[odra::odra_error] pub enum Error { InsufficientBalance = 30_000, InsufficientAllowance = 30_001, NameNotSet = 30_002, SymbolNotSet = 30_003, DecimalsNotSet = 30_004 }  2.2.3. Update events definitions.​ #[derive(Event)] attribute has been replace with #[odra::event] attribute. 0.9.00.8.0 use odra::prelude::*; use odra::{Address, casper_types::U256}; #[odra::event] pub struct Transfer { pub from: Option&lt;Address&gt;, pub to: Option&lt;Address&gt;, pub amount: U256 }  ","version":"2.0.1","tagName":"h3"},{"title":"3. Code Examples​","type":1,"pageTitle":"Migration guide to v0.9.0","url":"/docs/2.0.1/migrations/to-0.9.0#3-code-examples","content":"Here is a complete example of a smart contract after and before the migration to v0.9.0. 0.9.0Prev src/erc20.rs use crate::erc20::errors::Error; use crate::erc20::events::*; use odra::prelude::*; use odra::{casper_types::U256, Address, Mapping, Var}; #[odra::module(events = [Approval, Transfer], errors = Error)] pub struct Erc20 { decimals: Var&lt;u8&gt;, symbol: Var&lt;String&gt;, name: Var&lt;String&gt;, total_supply: Var&lt;U256&gt;, balances: Mapping&lt;Address, U256&gt;, allowances: Mapping&lt;(Address, Address), U256&gt; } #[odra::module] impl Erc20 { pub fn init( &amp;mut self, symbol: String, name: String, decimals: u8, initial_supply: Option&lt;U256&gt; ) { let caller = self.env().caller(); self.symbol.set(symbol); self.name.set(name); self.decimals.set(decimals); if let Some(initial_supply) = initial_supply { self.total_supply.set(initial_supply); self.balances.set(&amp;caller, initial_supply); if !initial_supply.is_zero() { self.env().emit_event(Transfer { from: None, to: Some(caller), amount: initial_supply }); } } } pub fn transfer(&amp;mut self, recipient: &amp;Address, amount: &amp;U256) { let caller = self.env().caller(); self.raw_transfer(&amp;caller, recipient, amount); } pub fn transfer_from(&amp;mut self, owner: &amp;Address, recipient: &amp;Address, amount: &amp;U256) { let spender = self.env().caller(); self.spend_allowance(owner, &amp;spender, amount); self.raw_transfer(owner, recipient, amount); } pub fn approve(&amp;mut self, spender: &amp;Address, amount: &amp;U256) { let owner = self.env().caller(); self.allowances.set(&amp;(owner, *spender), *amount); self.env().emit_event(Approval { owner, spender: *spender, value: *amount }); } pub fn name(&amp;self) -&gt; String { self.name.get_or_revert_with(Error::NameNotSet) } // Other getter functions... pub fn allowance(&amp;self, owner: &amp;Address, spender: &amp;Address) -&gt; U256 { self.allowances.get_or_default(&amp;(*owner, *spender)) } pub fn mint(&amp;mut self, address: &amp;Address, amount: &amp;U256) { self.total_supply.add(*amount); self.balances.add(address, *amount); self.env().emit_event(Transfer { from: None, to: Some(*address), amount: *amount }); } pub fn burn(&amp;mut self, address: &amp;Address, amount: &amp;U256) { if self.balance_of(address) &lt; *amount { self.env().revert(Error::InsufficientBalance); } self.total_supply.subtract(*amount); self.balances.subtract(address, *amount); self.env().emit_event(Transfer { from: Some(*address), to: None, amount: *amount }); } } impl Erc20 { fn raw_transfer(&amp;mut self, owner: &amp;Address, recipient: &amp;Address, amount: &amp;U256) { if *amount &gt; self.balances.get_or_default(owner) { self.env().revert(Error::InsufficientBalance) } self.balances.subtract(owner, *amount); self.balances.add(recipient, *amount); self.env().emit_event(Transfer { from: Some(*owner), to: Some(*recipient), amount: *amount }); } fn spend_allowance(&amp;mut self, owner: &amp;Address, spender: &amp;Address, amount: &amp;U256) { let allowance = self.allowances.get_or_default(&amp;(*owner, *spender)); if allowance &lt; *amount { self.env().revert(Error::InsufficientAllowance) } self.allowances.subtract(&amp;(*owner, *spender), *amount); self.env().emit_event(Approval { owner: *owner, spender: *spender, value: allowance - *amount }); } } pub mod events { use odra::prelude::*; use odra::{casper_types::U256, Address}; #[odra::event] pub struct Transfer { pub from: Option&lt;Address&gt;, pub to: Option&lt;Address&gt;, pub amount: U256 } #[odra::event] pub struct Approval { pub owner: Address, pub spender: Address, pub value: U256 } } pub mod errors { #[odra::odra_error] pub enum Error { InsufficientBalance = 30_000, InsufficientAllowance = 30_001, NameNotSet = 30_002, SymbolNotSet = 30_003, DecimalsNotSet = 30_004 } } #[cfg(test)] mod tests { // nothing changed in the tests }  ","version":"2.0.1","tagName":"h2"},{"title":"4. Troubleshooting​","type":1,"pageTitle":"Migration guide to v0.9.0","url":"/docs/2.0.1/migrations/to-0.9.0#4-troubleshooting","content":"If you encounter any further issues after completing the migration steps, please don't hesitate to reach out to us on Discord or explore the other sections this documentation. You can also refer to the technical documentation for more detailed information. Additionally, our examples repository offers a wide range of examples to assist you in understanding the new features and APIs. Be sure to carefully review any compilation errors and warnings, as they may provide valuable insights into the necessary adjustments. ","version":"2.0.1","tagName":"h2"},{"title":"5. References​","type":1,"pageTitle":"Migration guide to v0.9.0","url":"/docs/2.0.1/migrations/to-0.9.0#5-references","content":"ChangelogOdra DocumentationDocs.rsExamples ","version":"2.0.1","tagName":"h2"},{"title":"Build, Deploy and Read the State of a Contract","type":0,"sectionRef":"#","url":"/docs/2.0.1/tutorials/build-deploy-read","content":"","keywords":"","version":"2.0.1"},{"title":"Contract​","type":1,"pageTitle":"Build, Deploy and Read the State of a Contract","url":"/docs/2.0.1/tutorials/build-deploy-read#contract","content":"Let's write a contract with complex storage layout. The contract stores a plain numeric value, a custom nested type and a submodule with another submodule with stores a Mapping. We will expose two methods: The constructor init which sets the metadata and the version of the contract.The method set_data which sets the value of the numeric field and the values of the mapping. custom_item.rs use odra::{casper_types::U256, prelude::*}; // A custom type with a vector of another custom type #[odra::odra_type] pub struct Metadata { name: String, description: String, prices: Vec&lt;Price&gt;, } #[odra::odra_type] pub struct Price { value: U256, } // The main contract with a version, metadata and a submodule #[odra::module] pub struct CustomItem { version: Var&lt;u32&gt;, meta: Var&lt;Metadata&gt;, data: SubModule&lt;Data&gt; } #[odra::module] impl CustomItem { pub fn init(&amp;mut self, name: String, description: String, price_1: U256, price_2: U256) { let meta = Metadata { name, description, prices: vec![ Price { value: price_1 }, Price { value: price_2 } ] }; self.meta.set(meta); self.version.set(self.version.get_or_default() + 1); } pub fn set_data(&amp;mut self, value: u32, name: String, name2: String) { self.data.value.set(value); self.data.inner.named_values.set(&amp;name, 10); self.data.inner.named_values.set(&amp;name2, 20); } } // A submodule with a numeric value and another submodule #[odra::module] struct Data { value: Var&lt;u32&gt;, inner: SubModule&lt;InnerData&gt;, } // A submodule with a mapping #[odra::module] struct InnerData { named_values: Mapping&lt;String, u32&gt;, }  ","version":"2.0.1","tagName":"h3"},{"title":"Deploying the contract​","type":1,"pageTitle":"Build, Deploy and Read the State of a Contract","url":"/docs/2.0.1/tutorials/build-deploy-read#deploying-the-contract","content":"First, we need to setup the chain. We will use the NCTL docker image to run a local network. docker run --rm -it --name mynctl -d -p 11101:11101 -p 14101:14101 -p 18101:18101 makesoftware/casper-nctl  Next, we need to compile the contract to a Wasm file. cargo odra build -c custom_item  Then, we can deploy the contract using the casper-client tool. casper-client put-deploy \\ --node-address http://localhost:11101 \\ --chain-name casper-net-1 \\ --secret-key path/to/your/secret_key.pem \\ --session-path [PATH_TO_WASM] \\ --payment-amount 100000000000 \\ --session-arg &quot;odra_cfg_package_hash_key_name:string:'test_contract_package_hash'&quot; \\ --session-arg &quot;odra_cfg_allow_key_override:bool:'true'&quot; \\ --session-arg &quot;odra_cfg_is_upgradable:bool:'true'&quot; \\ --session-arg &quot;name:string='My Name'&quot; \\ --session-arg &quot;description:string='My Description'&quot; \\ --session-arg &quot;price_1:u256='101'&quot; \\ --session-arg &quot;price_2:u256='202'&quot;  Finally, we can call the set_data method to set the values of the contract. casper-client put-deploy \\ --node-address http://localhost:11101 \\ --chain-name casper-net-1 \\ --secret-key ./keys/secret_key.pem \\ --payment-amount 2000000000 \\ --session-hash [DEPLOYED_CONTRACT_HASH] \\ --session-entry-point &quot;set_data&quot; \\ --session-arg &quot;value:u32:'666'&quot; \\ --session-arg &quot;name:string='alice'&quot; \\ --session-arg &quot;name2:string='bob'&quot;  ","version":"2.0.1","tagName":"h3"},{"title":"Storage Layout​","type":1,"pageTitle":"Build, Deploy and Read the State of a Contract","url":"/docs/2.0.1/tutorials/build-deploy-read#storage-layout","content":"To read the state of the contract, we need to understand the storage layout. The first step is to calculate the index of the keys. Storage Layout CustomItem: prefix: 0x0..._0000_0000_0000 0 version: u32, 0x0..._0000_0000_0001 1 meta: Metadata, 0x0..._0000_0000_0010 2 data: Data: prefix: 0x0..._0000_0000_0011 3 value: u32, 0x0..._0000_0011_0001 (3 &lt;&lt; 4) + 1 inner: InnerData: prefix: 0x0..._0000_0011_0010 (3 &lt;&lt; 4) + 2 named_values: Mapping 0x0..._0011_0010_0001 ((3 &lt;&lt; 4) + 2) &lt;&lt; 4 + 1  The actual key is obtained as follows: Convert the index to a big-endian byte array.Concatenate the index with the mapping data.Hash the concatenated bytes using blake2b.Return the hex representation of the hash (the stored key must be utf-8 encoded). In more detail, the storage layout is described in the Storage Layout article. ","version":"2.0.1","tagName":"h3"},{"title":"Reading the state​","type":1,"pageTitle":"Build, Deploy and Read the State of a Contract","url":"/docs/2.0.1/tutorials/build-deploy-read#reading-the-state","content":"RustTypeScript main.rs use casper_client::{rpcs::DictionaryItemIdentifier, types::StoredValue, Verbosity}; use casper_types::{ bytesrepr::{FromBytes, ToBytes}, U256, }; // replace with your contract hash const CONTRACT_HASH: &amp;str = &quot;hash-...&quot;; const NODE_ADDRESS: &amp;str = &quot;http://localhost:11101/rpc&quot;; const RPC_ID: &amp;str = &quot;casper-net-1&quot;; const DICTIONARY_NAME: &amp;str = &quot;state&quot;; #[derive(Debug, PartialEq, Eq, Hash)] pub struct Metadata { name: String, description: String, prices: Vec&lt;Price&gt;, } #[derive(Debug, PartialEq, Eq, Hash)] pub struct Price { value: U256, } async fn read_state_key(key: String) -&gt; Vec&lt;u8&gt; { let state_root_hash = casper_client::get_state_root_hash( RPC_ID.to_string().into(), NODE_ADDRESS, Verbosity::Low, None, ) .await .unwrap() .result .state_root_hash .unwrap(); // Read the value from the `state` dictionary. let result = casper_client::get_dictionary_item( RPC_ID.to_string().into(), NODE_ADDRESS, Verbosity::Low, state_root_hash, DictionaryItemIdentifier::ContractNamedKey { key: CONTRACT_HASH.to_string(), dictionary_name: DICTIONARY_NAME.to_string(), dictionary_item_key: key, }, ) .await .unwrap() .result .stored_value; // We expect the value to be a CLValue if let StoredValue::CLValue(cl_value) = result { // Ignore the first 4 bytes, which are the length of the CLType. cl_value.inner_bytes()[4..].to_vec() } else { vec![] } } async fn metadata() -&gt; Metadata { // The key for the metadata is 2, and it has no mapping data let key = key(2, &amp;[]); let bytes = read_state_key(key).await; // Read the name and store the remaining bytes let (name, bytes) = String::from_bytes(&amp;bytes).unwrap(); // Read the description and store the remaining bytes let (description, bytes) = String::from_bytes(&amp;bytes).unwrap(); // A vector is stored as a u32 size followed by the elements // Read the size of the vector and store the remaining bytes let (size, mut bytes) = u32::from_bytes(&amp;bytes).unwrap(); let mut prices = vec![]; // As we know the size of the vector, we can loop over it for _ in 0..size { // Read the value and store the remaining bytes let (value, rem) = U256::from_bytes(&amp;bytes).unwrap(); bytes = rem; prices.push(Price { value }); } // Anytime you finish parsing a value, you should check if there are any remaining bytes // if there are, it means you have a bug in your parsing logic. // For simplicity, we will ignore the remaining bytes here. Metadata { name, description, prices } } async fn value() -&gt; u32 { // The key for the value is (3 &lt;&lt; 4) + 1, and it has no mapping data let key = key((3 &lt;&lt; 4) + 1, &amp;[]); let bytes = read_state_key(key).await; // Read the value and ignore the remaining bytes for simplicity u32::from_bytes(&amp;bytes).unwrap().0 } async fn named_value(name: &amp;str) -&gt; u32 { // The key for the named value is (((3 &lt;&lt; 4) + 2) &lt;&lt; 4) + 1, and the mapping data is the name as bytes let mapping_data = name.to_bytes().unwrap(); let key = key((((3 &lt;&lt; 4) + 2) &lt;&lt; 4) + 1, &amp;mapping_data); let bytes = read_state_key(key).await; // Read the value and ignore the remaining bytes for simplicity u32::from_bytes(&amp;bytes).unwrap().0 } fn main() { let runtime = tokio::runtime::Runtime::new().unwrap(); dbg!(runtime.block_on(metadata())); dbg!(runtime.block_on(value())); dbg!(runtime.block_on(named_value(&quot;alice&quot;))); dbg!(runtime.block_on(named_value(&quot;bob&quot;))); } // The key is a combination of the index and the mapping data // The algorithm is as follows: // 1. Convert the index to a big-endian byte array // 2. Concatenate the index with the mapping data // 3. Hash the concatenated bytes using blake2b // 4. Return the hex representation of the hash (the stored key must be utf-8 encoded) fn key(idx: u32, mapping_data: &amp;[u8]) -&gt; String { let mut key = Vec::new(); key.extend_from_slice(idx.to_be_bytes().as_ref()); key.extend_from_slice(mapping_data); let hashed_key = blake2b(&amp;key); hex::encode(&amp;hashed_key) } fn blake2b(bytes: &amp;[u8]) -&gt; [u8; 32] { let mut result = [0u8; 32]; let mut hasher = &lt;blake2::Blake2bVar as blake2::digest::VariableOutput&gt;::new(32) .expect(&quot;should create hasher&quot;); let _ = std::io::Write::write(&amp;mut hasher, bytes); blake2::digest::VariableOutput::finalize_variable(hasher, &amp;mut result) .expect(&quot;should copy hash to the result array&quot;); result } cargo run [src/main.rs:116:5] runtime.block_on(metadata()) = Metadata { name: &quot;My Contract&quot;, description: &quot;My Description&quot;, prices: [ Price { value: 123, }, Price { value: 321, }, ], } [src/main.rs:117:5] runtime.block_on(value()) = 666 [src/main.rs:118:5] runtime.block_on(named_value(&quot;alice&quot;)) = 20 [src/main.rs:119:5] runtime.block_on(named_value(&quot;bob&quot;)) = 10  ","version":"2.0.1","tagName":"h3"},{"title":"Deploying a Token on Casper Livenet","type":0,"sectionRef":"#","url":"/docs/2.0.1/tutorials/deploying-on-casper","content":"","keywords":"","version":"2.0.1"},{"title":"Casper Wallet​","type":1,"pageTitle":"Deploying a Token on Casper Livenet","url":"/docs/2.0.1/tutorials/deploying-on-casper#casper-wallet","content":"We will be using Casper Wallet to do some tasks in this tutorial. To install it, please follow the instructions on theofficial website. After setting up the wallet, extract the private key of the account you want to use for our testing. You can do this by clicking on the Menu &gt; Download account keys. danger You are solely responsible for the security of your private keys. We recommend creating a new account for the testing purposes. Why do we need the private key? We will use it in Odra to deploy our contract to the Casper network using Livenet backend. ","version":"2.0.1","tagName":"h2"},{"title":"Getting tokens​","type":1,"pageTitle":"Deploying a Token on Casper Livenet","url":"/docs/2.0.1/tutorials/deploying-on-casper#getting-tokens","content":"To deploy the contract on the Livenet, we need to have some CSPR. The easiest way to get them is to use the faucet, which will send us 1000 CSPR for free. Unfortunately, only on the Testnet. To use the faucet, go to the Casper Testnet Faucet. Log in using your Casper Wallet account and click on the &quot;Request Tokens&quot; button. note One account can request tokens only once. If you run out of tokens, you can either ask someone in the Casper community to send you some, or simply create a new account in the wallet. Now, when we have the tokens, we can deploy the contract. Let's do it using Odra! ","version":"2.0.1","tagName":"h2"},{"title":"Odra Livenet​","type":1,"pageTitle":"Deploying a Token on Casper Livenet","url":"/docs/2.0.1/tutorials/deploying-on-casper#odra-livenet","content":"Odra Livenet is described in detail in thebackends section of this documentation. We will then briefly describe how to use set it up in this tutorial. In your contract code, create a new file in the bin folder: bin/our_token_livenet.rs //! Deploys a new OurToken contract on the Casper livenet and mints some tokens for the tutorial //! creator. use std::str::FromStr; use odra::casper_types::U256; use odra::host::{Deployer, HostEnv, HostRef, HostRefLoader}; use odra::prelude::Address; use ourcoin::token::{OurToken, OurToken, OurTokenInitArgs}; fn main() { // Load the Casper livenet environment. let env = odra_casper_livenet_env::env(); // Caller is the deployer and the owner of the private key. let owner = env.caller(); // Just some random address... let recipient = &quot;hash-48bd92253a1370d1d913c56800296145547a243d13ff4f059ba4b985b1e94c26&quot;; let recipient = Address::from_str(recipient).unwrap(); // Deploy new contract. let mut token = deploy_our_token(&amp;env); println!(&quot;Token address: {}&quot;, token.address().to_string()); // Propose minting new tokens. env.set_gas(1_000_000_000u64); token.propose_new_mint(recipient, U256::from(1_000)); // Vote, we are the only voter. env.set_gas(1_000_000_000u64); token.vote(true, U256::from(1_000)); // Let's advance the block time by 11 minutes, as // we set the voting time to 10 minutes. // OH NO! It is the Livenet, so we need to wait real time... // Hopefully you are not in a hurry. env.advance_block_time(11 * 60 * 1000); // Tally the votes. env.set_gas(1_500_000_000u64); token.tally(); // Check the balances. println!(&quot;Owner's balance: {:?}&quot;, token.balance_of(&amp;owner)); println!( &quot;Tutorial creator's balance: {:?}&quot;, token.balance_of(&amp;recipient) ); } /// Deploys a contract. pub fn deploy_our_token(env: &amp;HostEnv) -&gt; OurTokenHostRef { let name = String::from(&quot;OurToken&quot;); let symbol = String::from(&quot;OT&quot;); let decimals = 0; let initial_supply = U256::from(1_000); let init_args = OurTokenInitArgs { name, symbol, decimals, initial_supply, }; env.set_gas(300_000_000_000u64); OurToken::deploy(env, init_args) } /// Loads a contract. Just in case you need to load an existing contract later... fn _load_our_token(env: &amp;HostEnv) -&gt; OurTokenHostRef { let address = &quot;hash-XXXXX&quot;; let address = Address::from_str(address).unwrap(); OurToken::load(env, address) }  In your Cargo.toml file, we need to add a new dependency, a feature and register the new binary. In the end, it should look like this: Cargo.toml [package] name = &quot;ourcoin&quot; version = &quot;0.1.0&quot; edition = &quot;2021&quot; [dependencies] odra = { version = &quot;2.0.1&quot;, features = [], default-features = false } odra-modules = { version = &quot;2.0.1&quot;, features = [], default-features = false } odra-casper-livenet-env = { version = &quot;2.0.1&quot;, optional = true } [dev-dependencies] odra-test = { version = &quot;2.0.1&quot;, features = [], default-features = false } [build-dependencies] odra-build = { version = &quot;2.0.1&quot;, features = [], default-features = false } [features] default = [] livenet = [&quot;odra-casper-livenet-env&quot;] [[bin]] name = &quot;ourcoin_build_contract&quot; path = &quot;bin/build_contract.rs&quot; test = false [[bin]] name = &quot;ourcoin_build_schema&quot; path = &quot;bin/build_schema.rs&quot; test = false [[bin]] name = &quot;our_token_livenet&quot; path = &quot;bin/our_token_livenet.rs&quot; required-features = [&quot;livenet&quot;] [profile.release] codegen-units = 1 lto = true [profile.dev.package.&quot;*&quot;] opt-level = 3  Finally, add the .env file with the following content: .env # Path to the secret key of the account that will be used to deploy the contracts. ODRA_CASPER_LIVENET_SECRET_KEY_PATH=folder_with_your_secret_key/secret_key_file.pem # RPC address of the node that will be used to deploy the contracts. ODRA_CASPER_LIVENET_NODE_ADDRESS=http://138.201.80.141:7777 # Chain name of the network. ODRA_CASPER_LIVENET_CHAIN_NAME=casper-test  Of course, you need to replace the secret key's path with the path to the secret key file you downloaded from the Casper Wallet. note One of the problems you may encounter is that the node you are using will be down or will not accept your calls. In this case, you will have to find and use another node IP address. Now, we will run our code: cargo run --bin our_token_livenet --features livenet  If everything is set up correctly, you should see the output similar to this:  Running `target/debug/our_token_livenet` 💁 INFO : Deploying &quot;OurToken&quot;. 💁 INFO : Found wasm under &quot;wasm/OurToken.wasm&quot;. 🙄 WAIT : Waiting 15s for &quot;e6b34772ebc3682702674102db87c633b0544242eafd5944e680371be4ea1227&quot;. 🙄 WAIT : Waiting 15s for &quot;e6b34772ebc3682702674102db87c633b0544242eafd5944e680371be4ea1227&quot;. 💁 INFO : Deploy &quot;e6b34772ebc3682702674102db87c633b0544242eafd5944e680371be4ea1227&quot; successfully executed. 💁 INFO : Contract &quot;hash-565bd0bde39c8c3dd79e49c037e05eac8add2b2193e86a91a6bac068e0de7857&quot; deployed. Token address: hash-565bd0bde39c8c3dd79e49c037e05eac8add2b2193e86a91a6bac068e0de7857 💁 INFO : Calling &quot;hash-565bd0bde39c8c3dd79e49c037e05eac8add2b2193e86a91a6bac068e0de7857&quot; with entrypoint &quot;propose_new_mint&quot;. 🙄 WAIT : Waiting 15s for &quot;2f89cc96b6f8f05b88f8e75bef3a2f0ba39e9ab761693afff49e4112aa9d7361&quot;. 🙄 WAIT : Waiting 15s for &quot;2f89cc96b6f8f05b88f8e75bef3a2f0ba39e9ab761693afff49e4112aa9d7361&quot;. 💁 INFO : Deploy &quot;2f89cc96b6f8f05b88f8e75bef3a2f0ba39e9ab761693afff49e4112aa9d7361&quot; successfully executed. 💁 INFO : Calling &quot;hash-565bd0bde39c8c3dd79e49c037e05eac8add2b2193e86a91a6bac068e0de7857&quot; with entrypoint &quot;vote&quot;. 🙄 WAIT : Waiting 15s for &quot;aca9ae847cfcb97c81b4c64992515ff14d6f63a60f7c141558463f5b752058a5&quot;. 🙄 WAIT : Waiting 15s for &quot;aca9ae847cfcb97c81b4c64992515ff14d6f63a60f7c141558463f5b752058a5&quot;. 💁 INFO : Deploy &quot;aca9ae847cfcb97c81b4c64992515ff14d6f63a60f7c141558463f5b752058a5&quot; successfully executed. 💁 INFO : advance_block_time called - Waiting for 660000 ms 💁 INFO : Calling &quot;hash-565bd0bde39c8c3dd79e49c037e05eac8add2b2193e86a91a6bac068e0de7857&quot; with entrypoint &quot;tally&quot;. 🙄 WAIT : Waiting 15s for &quot;223b135edbeadd88425183abaec0b0afb7d7770ffc57eba9054e3ea60e9e9cef&quot;. 🙄 WAIT : Waiting 15s for &quot;223b135edbeadd88425183abaec0b0afb7d7770ffc57eba9054e3ea60e9e9cef&quot;. 💁 INFO : Deploy &quot;223b135edbeadd88425183abaec0b0afb7d7770ffc57eba9054e3ea60e9e9cef&quot; successfully executed. Owner's balance: 1000 Tutorial creator's balance: 1000  Congratulations, your contract is now deployed on the Casper network! Before we move on, note the address of the token! We will use it in the next section to interact with the token. In our case it ishash-565bd0bde39c8c3dd79e49c037e05eac8add2b2193e86a91a6bac068e0de7857. ","version":"2.0.1","tagName":"h2"},{"title":"Cspr.live​","type":1,"pageTitle":"Deploying a Token on Casper Livenet","url":"/docs/2.0.1/tutorials/deploying-on-casper#csprlive","content":"The first thing we will do is to explore Casper's network block explorer,cspr.live. We can put the address of our token in the search bar to find it. note If you deployed your contract on the Testnet, remember to make sure that the Testnet network is selected in the dropdown menu in the top right corner. If everything is set up correctly, you should see the contract package's details. Besides the owner, keys etc., you can also see the contract's metdata, if it was developed using a standard that cspr.live supports. Indeed, we can see that it detected that our contract is a CEP-18 token! We see the name, symbol and total supply. All the mentions of the contract on the website will use the token name instead of the contract address.  Additionally, on the Token Txs tab, we can see the transactions that happened with the token. We can see the minting transaction we did in the previous section and transfers done during the voting process.  If we click on one of the accounts that recieved the tokens, we will go to the account page. Here, on the Tokens tab, we can see all the tokens that the account has - and OurToken is one of them! If you wish, you can check the status of the contract deployed during the development of this tutorial here. ","version":"2.0.1","tagName":"h2"},{"title":"Transferring Tokens using Casper Wallet​","type":1,"pageTitle":"Deploying a Token on Casper Livenet","url":"/docs/2.0.1/tutorials/deploying-on-casper#transferring-tokens-using-casper-wallet","content":"Casper wallet can do much more than just logging in to the faucet, exporting the private keys and transferring CSPR. It can also interact with the contracts deployed on the network. If you deployed the contract and left some OT tokens to yourself, you should see them in the Casper Wallet window. You should also be able to transfer them to another account!  ","version":"2.0.1","tagName":"h2"},{"title":"Conclusion​","type":1,"pageTitle":"Deploying a Token on Casper Livenet","url":"/docs/2.0.1/tutorials/deploying-on-casper#conclusion","content":"We've successfully deployed a token on the Casper network and interacted with it using the Odra backend and Casper Wallet. We've also learned how to use the cspr.live block explorer to check the status of your contract. Odra, Cspr.live and Casper Wallet are just a few of the tools that the Casper ecosystem provides. Feel free to explore them on casperecosystem.io. ","version":"2.0.1","tagName":"h2"},{"title":"Migration guide to v0.8.0","type":0,"sectionRef":"#","url":"/docs/2.0.1/migrations/to-0.8.0","content":"","keywords":"","version":"2.0.1"},{"title":"1. Prerequisites​","type":1,"pageTitle":"Migration guide to v0.8.0","url":"/docs/2.0.1/migrations/to-0.8.0#1-prerequisites","content":"","version":"2.0.1","tagName":"h2"},{"title":"1.1. Update cargo-odra​","type":1,"pageTitle":"Migration guide to v0.8.0","url":"/docs/2.0.1/migrations/to-0.8.0#11-update-cargo-odra","content":"Before you begin the migration process, make sure you installed the latest version of the Cargo Odra toolchain. You can install it by running the following command: cargo install cargo-odra --force --locked  ","version":"2.0.1","tagName":"h3"},{"title":"1.2. Review the Changelog​","type":1,"pageTitle":"Migration guide to v0.8.0","url":"/docs/2.0.1/migrations/to-0.8.0#12-review-the-changelog","content":"Before you move to changing your code, start by reviewing the Changelog to understand the changes introduced in v0.8.0. ","version":"2.0.1","tagName":"h3"},{"title":"2. Migration Steps​","type":1,"pageTitle":"Migration guide to v0.8.0","url":"/docs/2.0.1/migrations/to-0.8.0#2-migration-steps","content":"","version":"2.0.1","tagName":"h2"},{"title":"2.1 Add bin directory​","type":1,"pageTitle":"Migration guide to v0.8.0","url":"/docs/2.0.1/migrations/to-0.8.0#21-add-bin-directory","content":"Odra 0.8.0 introduces a new way to build smart contracts. The .builder_casper directory is no longer used. Instead, you should create a new directory called bin in the root of your project and add the build_contract.rs and build_schema.rs files to the bin directory. You can find the build_contract.rs and build_schema.rs files in templates directory in the Odra main repository. You can choose whatever template you want to use and copy the files to your project. In both files, you should replace {{project-name}} with the name of your project. ","version":"2.0.1","tagName":"h3"},{"title":"2.2. Update Cargo.toml​","type":1,"pageTitle":"Migration guide to v0.8.0","url":"/docs/2.0.1/migrations/to-0.8.0#22-update-cargotoml","content":"There a bunch of changes in the Cargo.toml file. You don't have to specify the features anymore - remove the features section and default-features flag from the odra dependency.Register bins you added in the previous step.Add dev-dependencies section with odra-test crate.Add recommended profiles for release and dev to optimize the build process. Below you can compare the Cargo.toml file after and before the migration to v0.8.0: 0.8.0Prev [package] name = &quot;my_project&quot; version = &quot;0.1.0&quot; edition = &quot;2021&quot; [dependencies] odra = &quot;0.8.0&quot; [dev-dependencies] odra-test = &quot;0.8.0&quot; [[bin]] name = &quot;my_project_build_contract&quot; path = &quot;bin/build_contract.rs&quot; test = false [[bin]] name = &quot;my_project_build_schema&quot; path = &quot;bin/build_schema.rs&quot; test = false [profile.release] codegen-units = 1 lto = true [profile.dev.package.&quot;*&quot;] opt-level = 3  ","version":"2.0.1","tagName":"h3"},{"title":"2.2. Update Odra.toml​","type":1,"pageTitle":"Migration guide to v0.8.0","url":"/docs/2.0.1/migrations/to-0.8.0#22-update-odratoml","content":"Due to the changes in cargo-odra, the Odra.toml file has been simplified. The name property is no longer required. 0.8.0Prev [[contracts]] fqn = &quot;my_project::Flipper&quot;  ","version":"2.0.1","tagName":"h3"},{"title":"2.3. Update Smart Contracts​","type":1,"pageTitle":"Migration guide to v0.8.0","url":"/docs/2.0.1/migrations/to-0.8.0#23-update-smart-contracts","content":"The smart contracts themselves will need to be updated to work with the new version of the framework. The changes will depend on the specific features and APIs used in the contracts. Here are some common changes you might need to make: 2.3.1. Update the use statements to reflect the new module structure.​ Big integer types are now located in the odra::casper_types module.odra::types::Address is now odra::Address.Variable is now Var.Remove odra::contract_env.Remove odra::types::event::OdraEvent.Remove odra::types::OdraType as it is no longer required.Change odra::types::casper_types::*; to odra::casper_types::*;. 2.3.2. Some type aliases are no longer in use.​ Balance - use odra::casper_types::U512.BlockTime - use u64.EventData - use odra::casper_types::bytesrepr::Bytes. 2.3.3. Consider import odra::prelude::* in your module files.​ 2.3.4. Flatten nested Mappings.​ // Before #[odra::module(events = [Approval, Transfer])] pub struct Erc20 { ... allowances: Mapping&lt;Address, Mapping&lt;Address, U256&gt;&gt; } // After #[odra::module(events = [Approval, Transfer])] pub struct Erc20 { ... allowances: Mapping&lt;(Address, Address), U256&gt; }  2.3.5. Update errors definitions.​ execution_error! macro has been replace with OdraError derive macro. 0.8.0Prev use odra::OdraError; #[derive(OdraError)] pub enum Error { InsufficientBalance = 30_000, InsufficientAllowance = 30_001, NameNotSet = 30_002, SymbolNotSet = 30_003, DecimalsNotSet = 30_004 }  2.3.6. Update events definitions.​ 0.8.0Prev use odra::prelude::*; use odra::Event; #[derive(Event, Eq, PartialEq, Debug)] pub struct Transfer { pub from: Option&lt;Address&gt;, pub to: Option&lt;Address&gt;, pub amount: U256 } // Emitting the event self.env().emit_event(Transfer { from: None, to: Some(*address), amount: *amount });  2.3.7. Replace contract_env with self.env() in your modules.​ self.env() is a new way to access the contract environment, returns a reference to ContractEnv. The API is similar to the previous contract_env but with some changes. fn get_var&lt;T: FromBytes&gt;(key: &amp;[u8]) -&gt; Option&lt;T&gt; is now fn get_value&lt;T: FromBytes&gt;(&amp;self, key: &amp;[u8]) -&gt; Option&lt;T&gt;.fn set_var&lt;T: CLTyped + ToBytes&gt;(key: &amp;[u8], value: T) is now fn set_value&lt;T: ToBytes + CLTyped&gt;(&amp;self, key: &amp;[u8], value: T).set_dict_value() and get_dict_value() has been removed. All the dictionary operations should be performed using Mapping type, internally using set_var() and get_var() functions. fn hash&lt;T: AsRef&lt;[u8]&gt;&gt;(input: T) -&gt; Vec&lt;u8&gt; is now fn hash&lt;T: ToBytes&gt;(&amp;self, value: T) -&gt; [u8; 32].fn revert&lt;E: Into&lt;ExecutionError&gt;&gt;(error: E) -&gt; ! is now fn revert&lt;E: Into&lt;OdraError&gt;&gt;(&amp;self, error: E) -&gt; !.fn emit_event&lt;T: ToBytes + OdraEvent&gt;(event: T) is now fn emit_event&lt;T: ToBytes&gt;(&amp;self, event: T).fn call_contract&lt;T: CLTyped + FromBytes&gt;(address: Address, entrypoint: &amp;str, args: &amp;RuntimeArgs, amount: Option&lt;U512&gt;) -&gt; T is now fn call_contract&lt;T: FromBytes&gt;(&amp;self, address: Address, call: CallDef) -&gt; T.functions native_token_metadata() and one_token() have been removed. 2.3.8. Wrap submodules of your module with odra::SubModule&lt;T&gt;.​ 0.8.0Prev #[odra::module(events = [Transfer])] pub struct Erc721Token { core: SubModule&lt;Erc721Base&gt;, metadata: SubModule&lt;Erc721MetadataExtension&gt;, ownable: SubModule&lt;Ownable&gt; }  2.3.9. Update external contract calls.​ However the definition of an external contract remains the same, the way you call it has changed. A reference to an external contract is named {{ModuleName}}ContractRef (former {{ModuleName}}Ref) and you can call it using {{ModuleName}}ContractRef::new(env, address) (former {{ModuleName}}Ref::at()). 0.8.0Prev #[odra::external_contract] pub trait Token { fn balance_of(&amp;self, owner: &amp;Address) -&gt; U256; } // Usage TokenContractRef::new(env, token).balance_of(account)  2.3.10. Update constructors.​ Remove the #[odra::init] attribute from the constructor and ensure that the constructor function is named init. 2.3.11. Update UnwrapOrRevert calls.​ The functions unwrap_or_revert and unwrap_or_revert_with now require &amp;HostEnv as the first parameter. 2.3.12. Remove #[odra(using)] attribute from your module definition.​ Sharing the same instance of a module is no longer supported. A redesign of the module structure might be required. ","version":"2.0.1","tagName":"h3"},{"title":"2.4. Update Tests​","type":1,"pageTitle":"Migration guide to v0.8.0","url":"/docs/2.0.1/migrations/to-0.8.0#24-update-tests","content":"Once you've updated your smart contracts, you'll need to update your tests to reflect the changes. The changes will depend on the specific features and APIs used in the tests. Here are some common changes you might need to make: 2.4.1. Contract deployment.​ The way you deploy a contract has changed: You should use {{ModuleName}}HostRef::deploy(&amp;env, args) instead of {{ModuleName}}Deployer::init(). The {{ModuleName}}HostRef implements odra::host::Deployer.Instantiate the HostEnv using odra_test::env(), required by the odra::host::Deployer::deploy() function.If the contract doesn't have init args, you should use odra::host::NoArgs as the second argument of the deploy function.If the contract has init args, you should pass the autogenerated {{ModuleName}}InitArgs as the second argument of the deploy function. 0.8.0Prev // A contract without init args use super::OwnableHostRef; use odra::host::{Deployer, HostEnv, HostRef, NoArgs}; let env: HostEnv = odra_test::env(); let ownable = OwnableHostRef::deploy(&amp;env, NoArgs) // A contract with init args use super::{Erc20HostRef, Erc20InitArgs}; use odra::host::{Deployer, HostEnv}; let env: HostEnv = odra_test::env(); let init_args = Erc20InitArgs { symbol: SYMBOL.to_string(), name: NAME.to_string(), decimals: DECIMALS, initial_supply: Some(INITIAL_SUPPLY.into()) }; let erc20 = Erc20HostRef::deploy(&amp;env, init_args);  2.4.2. Host interactions.​ Replace odra::test_env with odra_test::env().The API of odra::test_env and odra_test::env() are similar, but there are some differences: test_env::advance_block_time_by(BlockTime) is now env.advance_block_time(u64).test_env::token_balance(Address) is now env.balance_of(&amp;Address).functions test_env::last_call_contract_gas_cost(), test_env::last_call_contract_gas_used(), test_env::total_gas_used(Address), test_env::gas_report() have been removed. You should use HostRef::last_call() and extract the data from a odra::ContractCallResult instance. HostRef is a trait implemented by {{ModuleName}}HostRef. 2.4.3. Testing failing scenarios.​ test_env::assert_exception() has been removed. You should use the try_ prefix to call the function and then assert the result.try_ prefix is a new way to call a function that might fail. It returns a OdraResult type, which you can then assert using the standard Rust assert_eq! macro. 0.8.0Prev #[test] fn transfer_from_error() { let (env, mut erc20) = setup(); let (owner, spender, recipient) = (env.get_account(0), env.get_account(1), env.get_account(2)); let amount = 1_000.into(); env.set_caller(spender); assert_eq!( erc20.try_transfer_from(owner, recipient, amount), Err(Error::InsufficientAllowance.into()) ); }  2.4.4. Testing events.​ assert_events! macro has been removed. You should use HostEnv::emitted_event() to assert the emitted events. The new API doesn't allow to assert multiple events at once, but adds alternative ways to assert the emitted events. Check the HostEnv documentation to explore the available options. 0.8.0Prev let env: HostEnv = odra_test::env(); let erc20 = Erc20HostRef::deploy(&amp;env, init_args); ... assert!(env.emitted_event( erc20.address(), &amp;Approval { owner, spender, value: approved_amount - transfer_amount } )); assert!(env.emitted_event( erc20.address(), &amp;Transfer { from: Some(owner), to: Some(recipient), amount: transfer_amount } ));  ","version":"2.0.1","tagName":"h3"},{"title":"3. Code Examples​","type":1,"pageTitle":"Migration guide to v0.8.0","url":"/docs/2.0.1/migrations/to-0.8.0#3-code-examples","content":"Here is a complete example of a smart contract after and before the migration to v0.8.0. 0.8.0Prev src/erc20.rs use crate::erc20::errors::Error::*; use crate::erc20::events::*; use odra::prelude::*; use odra::{casper_types::U256, Address, Mapping, Var}; #[odra::module(events = [Approval, Transfer])] pub struct Erc20 { decimals: Var&lt;u8&gt;, symbol: Var&lt;String&gt;, name: Var&lt;String&gt;, total_supply: Var&lt;U256&gt;, balances: Mapping&lt;Address, U256&gt;, allowances: Mapping&lt;(Address, Address), U256&gt; } #[odra::module] impl Erc20 { pub fn init( &amp;mut self, symbol: String, name: String, decimals: u8, initial_supply: Option&lt;U256&gt; ) { let caller = self.env().caller(); self.symbol.set(symbol); self.name.set(name); self.decimals.set(decimals); if let Some(initial_supply) = initial_supply { self.total_supply.set(initial_supply); self.balances.set(&amp;caller, initial_supply); if !initial_supply.is_zero() { self.env().emit_event(Transfer { from: None, to: Some(caller), amount: initial_supply }); } } } pub fn transfer(&amp;mut self, recipient: &amp;Address, amount: &amp;U256) { let caller = self.env().caller(); self.raw_transfer(&amp;caller, recipient, amount); } pub fn transfer_from(&amp;mut self, owner: &amp;Address, recipient: &amp;Address, amount: &amp;U256) { let spender = self.env().caller(); self.spend_allowance(owner, &amp;spender, amount); self.raw_transfer(owner, recipient, amount); } pub fn approve(&amp;mut self, spender: &amp;Address, amount: &amp;U256) { let owner = self.env().caller(); self.allowances.set(&amp;(owner, *spender), *amount); self.env().emit_event(Approval { owner, spender: *spender, value: *amount }); } pub fn name(&amp;self) -&gt; String { self.name.get_or_revert_with(NameNotSet) } // Other getter functions... pub fn allowance(&amp;self, owner: &amp;Address, spender: &amp;Address) -&gt; U256 { self.allowances.get_or_default(&amp;(*owner, *spender)) } pub fn mint(&amp;mut self, address: &amp;Address, amount: &amp;U256) { self.total_supply.add(*amount); self.balances.add(address, *amount); self.env().emit_event(Transfer { from: None, to: Some(*address), amount: *amount }); } pub fn burn(&amp;mut self, address: &amp;Address, amount: &amp;U256) { if self.balance_of(address) &lt; *amount { self.env().revert(InsufficientBalance); } self.total_supply.subtract(*amount); self.balances.subtract(address, *amount); self.env().emit_event(Transfer { from: Some(*address), to: None, amount: *amount }); } } impl Erc20 { fn raw_transfer(&amp;mut self, owner: &amp;Address, recipient: &amp;Address, amount: &amp;U256) { if *amount &gt; self.balances.get_or_default(owner) { self.env().revert(InsufficientBalance) } self.balances.subtract(owner, *amount); self.balances.add(recipient, *amount); self.env().emit_event(Transfer { from: Some(*owner), to: Some(*recipient), amount: *amount }); } fn spend_allowance(&amp;mut self, owner: &amp;Address, spender: &amp;Address, amount: &amp;U256) { let allowance = self.allowances.get_or_default(&amp;(*owner, *spender)); if allowance &lt; *amount { self.env().revert(InsufficientAllowance) } self.allowances.subtract(&amp;(*owner, *spender), *amount); self.env().emit_event(Approval { owner: *owner, spender: *spender, value: allowance - *amount }); } } pub mod events { use odra::prelude::*; use odra::{casper_types::U256, Address, Event}; #[derive(Event, Eq, PartialEq, Debug)] pub struct Transfer { pub from: Option&lt;Address&gt;, pub to: Option&lt;Address&gt;, pub amount: U256 } #[derive(Event, Eq, PartialEq, Debug)] pub struct Approval { pub owner: Address, pub spender: Address, pub value: U256 } } pub mod errors { use odra::OdraError; #[derive(OdraError)] pub enum Error { InsufficientBalance = 30_000, InsufficientAllowance = 30_001, NameNotSet = 30_002, SymbolNotSet = 30_003, DecimalsNotSet = 30_004 } } #[cfg(test)] mod tests { use super::{ errors::Error, events::{Approval, Transfer}, Erc20HostRef, Erc20InitArgs }; use odra::{ casper_types::U256, host::{Deployer, HostEnv, HostRef}, prelude::* }; const NAME: &amp;str = &quot;Plascoin&quot;; const SYMBOL: &amp;str = &quot;PLS&quot;; const DECIMALS: u8 = 10; const INITIAL_SUPPLY: u32 = 10_000; fn setup() -&gt; (HostEnv, Erc20HostRef) { let env = odra_test::env(); ( env.clone(), Erc20HostRef::deploy( &amp;env, Erc20InitArgs { symbol: SYMBOL.to_string(), name: NAME.to_string(), decimals: DECIMALS, initial_supply: Some(INITIAL_SUPPLY.into()) } ) ) } #[test] fn initialization() { // When deploy a contract with the initial supply. let (env, erc20) = setup(); // Then the contract has the metadata set. assert_eq!(erc20.symbol(), SYMBOL.to_string()); assert_eq!(erc20.name(), NAME.to_string()); assert_eq!(erc20.decimals(), DECIMALS); // Then the total supply is updated. assert_eq!(erc20.total_supply(), INITIAL_SUPPLY.into()); // Then a Transfer event was emitted. assert!(env.emitted_event( erc20.address(), &amp;Transfer { from: None, to: Some(env.get_account(0)), amount: INITIAL_SUPPLY.into() } )); } #[test] fn transfer_works() { // Given a new contract. let (env, mut erc20) = setup(); // When transfer tokens to a recipient. let sender = env.get_account(0); let recipient = env.get_account(1); let amount = 1_000.into(); erc20.transfer(&amp;recipient, &amp;amount); // Then the sender balance is deducted. assert_eq!( erc20.balance_of(&amp;sender), U256::from(INITIAL_SUPPLY) - amount ); // Then the recipient balance is updated. assert_eq!(erc20.balance_of(&amp;recipient), amount); // Then Transfer event was emitted. assert!(env.emitted_event( erc20.address(), &amp;Transfer { from: Some(sender), to: Some(recipient), amount } )); } #[test] fn transfer_error() { // Given a new contract. let (env, mut erc20) = setup(); // When the transfer amount exceeds the sender balance. let recipient = env.get_account(1); let amount = U256::from(INITIAL_SUPPLY) + U256::one(); // Then an error occurs. assert!(erc20.try_transfer(&amp;recipient, &amp;amount).is_err()); } // Other tests... }  ","version":"2.0.1","tagName":"h2"},{"title":"4. Troubleshooting​","type":1,"pageTitle":"Migration guide to v0.8.0","url":"/docs/2.0.1/migrations/to-0.8.0#4-troubleshooting","content":"If you encounter any further issues after completing the migration steps, please don't hesitate to reach out to us on Discord or explore the other sections this documentation. You can also refer to the technical documentation for more detailed information. Additionally, our examples repository offers a wide range of examples to assist you in understanding the new features and APIs. Be sure to carefully review any compilation errors and warnings, as they may provide valuable insights into the necessary adjustments. ","version":"2.0.1","tagName":"h2"},{"title":"5. References​","type":1,"pageTitle":"Migration guide to v0.8.0","url":"/docs/2.0.1/migrations/to-0.8.0#5-references","content":"ChangelogOdra DocumentationDocs.rsExamples ","version":"2.0.1","tagName":"h2"},{"title":"CEP-18","type":0,"sectionRef":"#","url":"/docs/2.0.1/tutorials/cep18","content":"","keywords":"","version":"2.0.1"},{"title":"Self-governing token​","type":1,"pageTitle":"CEP-18","url":"/docs/2.0.1/tutorials/cep18#self-governing-token","content":"There are many ways to implement a governance mechanism for a token, each more complex than the other. In our example, we will use a simple one, where the community of token holders can vote to mint new tokens. ","version":"2.0.1","tagName":"h2"},{"title":"Token implementation​","type":1,"pageTitle":"CEP-18","url":"/docs/2.0.1/tutorials/cep18#token-implementation","content":"Let's start by creating a new project, choosing a clever name and using cep18 as our starting template: cargo odra new --name ourcoin --template cep18  Let's glance at our token code: src/token.rs #[odra::module] pub struct MyToken { token: SubModule&lt;Cep18&gt;, } impl MyToken { // Delegate all Cep18 functions to the token sub-module. delegate! { to self.token { ... fn name(&amp;self) -&gt; String; fn symbol(&amp;self) -&gt; String; ...  As we can see, it indeed uses the Cep18 module and delegates all the methods to it. The only thing to do is to change the name of the struct to more appropriate OurToken, run the provided tests using cargo odra test, and continue with the implementation of the governance. note Remember to change the name of the struct and its usages as well as the struct name in the Odra.toml file! ","version":"2.0.1","tagName":"h2"},{"title":"Governance implementation​","type":1,"pageTitle":"CEP-18","url":"/docs/2.0.1/tutorials/cep18#governance-implementation","content":"Let's go through the process of implementing the governance mechanism. If we don't want to, we don't have to hide entrypoints from the public responsible for minting new tokens. By default, minting Modalityis turned off, so any attempt of direct minting will result in an error. We will however implement a voting mechanism, where the token holders can vote to mint new tokens. ","version":"2.0.1","tagName":"h2"},{"title":"Voting mechanism​","type":1,"pageTitle":"CEP-18","url":"/docs/2.0.1/tutorials/cep18#voting-mechanism","content":"Our voting system will be straightforward: Anyone with the tokens can propose a new mint.Anyone with the tokens can vote for the new mint by staking their tokens.If the majority of the token holders vote for the mint, it is executed. Storage​ We will need to store some additional information about the votes, so let's add some fields to our token struct: src/token.rs #[odra::module] pub struct OurToken { /// A sub-module that implements the CEP-18 token standard. token: SubModule&lt;Cep18&gt;, /// The proposed mint. proposed_mint: Var&lt;(Address, U256)&gt;, /// The list of votes cast in the current vote. votes: List&lt;Ballot&gt;, /// Whether a vote is open. is_vote_open: Var&lt;bool&gt;, /// The time when the vote ends. vote_end_time: Var&lt;u64&gt;, } /// A ballot cast by a voter. #[odra::odra_type] struct Ballot { voter: Address, choice: bool, amount: U256, }  Notice that proposed_mint contains a tuple containing the address of the proposer and the amount of tokens to mint. Moreover, we need to keep track if the vote time has ended, but also if it was already tallied, that's why we need both is_vote_open and vote_end_time. We will also use the power of the Listtype to store the Ballots. Proposing a new mint​ To implement the endpoint that allows token holders to propose a new mint, we need to add a new function to our token module: src/token.rs /// Proposes a new mint for the contract. pub fn propose_new_mint(&amp;mut self, account: Address, amount: U256) { // Only allow proposing a new mint if there is no vote in progress. if self.is_vote_open().get_or_default() { self.env().revert(GovernanceError::VoteAlreadyOpen); } // Only the token holders can propose a new mint. if self.balance_of(&amp;self.env().caller()) == U256::zero() { self.env().revert(GovernanceError::OnlyTokenHoldersCanPropose); } // Set the proposed mint. self.proposed_mint.set((account, amount)); // Open a vote. self.is_vote_open.set(true); // Set the vote end time to 10 minutes from now. self.vote_end_time .set(self.env().get_block_time() + 60 * 10 * 1000); }  As a parameters to the function, we pass the address of the account that should be the receiver of the minted tokens, and the amount. After some validation, we open the vote by setting the is_vote_open to true, and setting the vote_end_time to 10 minutes. In real-world scenarios, the time could be configurable, but for the sake of simplicity, we hardcoded it. Also, it should be quite longer than 10 minutes, but it will come in handy when we test it on Livenet. Voting for the mint​ Next, we need an endpoint that will allow us to cast a ballot: src/token.rs /// Votes on the proposed mint. pub fn vote(&amp;mut self, choice: bool, amount: U256) { // Only allow voting if there is a vote in progress. self.assert_vote_in_progress(); let voter = self.env().caller(); let contract = self.env().self_address(); // Transfer the voting tokens from the voter to the contract. self.token .transfer(&amp;contract, &amp;amount); // Add the vote to the list. self.votes.push(Ballot { voter, choice, amount, }); }  The most interesting thing here is that we are using a mechanism of staking, where we transfer our tokens to the contract, to show that we really mean it. The tokens will be locked until the vote is over, and tallied. Speaking of tallying... Tallying the votes​ The last step is to tally the votes and mint the tokens if the majority of voters agreed to do so: src/token.rs /// Count the votes and perform the action pub fn tally(&amp;mut self) { // Only allow tallying the votes once. if !self.is_vote_open.get_or_default() { self.env().revert(GovernanceError::NoVoteInProgress); } // Only allow tallying the votes after the vote has ended. let finish_time = self .vote_end_time .get_or_revert_with(GovernanceError::NoVoteInProgress); if self.env().get_block_time() &lt; finish_time { self.env().revert(GovernanceError::VoteNotYetEnded); } // Count the votes let mut yes_votes = U256::zero(); let mut no_votes = U256::zero(); let contract = self.env().self_address(); while let Some(vote) = self.votes.pop() { if vote.choice { yes_votes += vote.amount; } else { no_votes += vote.amount; } // Transfer back the voting tokens to the voter. self.token.raw_transfer(&amp;contract, &amp;vote.voter, &amp;vote.amount); } // Perform the action if the vote has passed. if yes_votes &gt; no_votes { let (account, amount) = self .proposed_mint .get_or_revert_with(GovernanceError::NoVoteInProgress); self.token.raw_mint(&amp;account, &amp;amount); } // Close the vote. self.is_vote_open.set(false); }  Notice how we used raw_transfer from the Cep18 module. We used it to set the sender, so the contract's balance will be used, instead of the caller's. Additonally, we used raw_mint to mint the tokens, skipping the security checks. We have no modality for minting, but even if we had, we don't have anyone with permissions! The Contract needs to mint the tokens itself. ","version":"2.0.1","tagName":"h3"},{"title":"Testing​","type":1,"pageTitle":"CEP-18","url":"/docs/2.0.1/tutorials/cep18#testing","content":"Now, we will put our implementation to the test. One unit test, that we can run both on OdraVM and on the CasperVM. src/token.rs #[test] fn it_works() { let env = odra_test::env(); let init_args = OurTokenInitArgs { name: &quot;OurToken&quot;.to_string(), symbol: &quot;OT&quot;.to_string(), decimals: 0, initial_supply: U256::from(1_000u64), }; let mut token = OurToken::deploy(&amp;env, init_args); // The deployer, as the only token holder, // starts a new voting to mint 1000 tokens to account 1. // There is only 1 token holder, so there is one Ballot cast. token.propose_new_mint(env.get_account(1), U256::from(2000)); token.vote(true, U256::from(1000)); // The tokens should now be staked. assert_eq!(token.balance_of(&amp;env.get_account(0)), U256::zero()); // Wait for the vote to end. env.advance_block_time(60 * 11 * 1000); // Finish the vote. token.tally(); // The tokens should now be minted. assert_eq!(token.balance_of(&amp;env.get_account(1)), U256::from(2000)); assert_eq!(token.total_supply(), 3000.into()); // The stake should be returned. assert_eq!(token.balance_of(&amp;env.get_account(0)), U256::from(1000)); // Now account 1 can mint new tokens with their voting power... env.set_caller(env.get_account(1)); token.propose_new_mint(env.get_account(1), U256::from(2000)); token.vote(true, U256::from(2000)); // ...Even if the deployer votes against it. env.set_caller(env.get_account(0)); token.vote(false, U256::from(1000)); env.advance_block_time(60 * 11 * 1000); token.tally(); // The power of community governance! assert_eq!(token.balance_of(&amp;env.get_account(1)), U256::from(4000)); }  We can run the test using both methods: cargo odra test cargo odra test -b casper  It is all nice and green, but it would be really nice to see it in action. How about deploying it on the Casper network? ","version":"2.0.1","tagName":"h3"},{"title":"What's next​","type":1,"pageTitle":"CEP-18","url":"/docs/2.0.1/tutorials/cep18#whats-next","content":"We will se our token in action, by deploying it on the Casper network, and using tools from the Casper Ecosystem to interact with it. ","version":"2.0.1","tagName":"h2"},{"title":"Complete code​","type":1,"pageTitle":"CEP-18","url":"/docs/2.0.1/tutorials/cep18#complete-code","content":"Here is the complete code of the OurToken module: src/token.rs use odra::{casper_types::U256, prelude::*}; use odra_modules::cep18_token::Cep18; /// A ballot cast by a voter. #[odra::odra_type] struct Ballot { voter: Address, choice: bool, amount: U256, } /// Errors for the governed token. #[odra::odra_error] pub enum GovernanceError { /// The vote is already in progress. VoteAlreadyOpen = 0, /// No vote is in progress. NoVoteInProgress = 1, /// Cannot tally votes yet. VoteNotYetEnded = 2, /// Vote ended VoteEnded = 3, /// Only the token holders can propose a new mint. OnlyTokenHoldersCanPropose = 4, } /// A module definition. Each module struct consists of Vars and Mappings /// or/and other modules. #[odra::module] pub struct OurToken { /// A submodule that implements the CEP-18 token standard. token: SubModule&lt;Cep18&gt;, /// The proposed mint. proposed_mint: Var&lt;(Address, U256)&gt;, /// The list of votes cast in the current vote. votes: List&lt;Ballot&gt;, /// Whether a vote is open. is_vote_open: Var&lt;bool&gt;, /// The time when the vote ends. vote_end_time: Var&lt;u64&gt;, } /// Module implementation. /// /// To generate entrypoints, /// an implementation block must be marked as #[odra::module]. #[odra::module] impl OurToken { /// Initializes the contract with the given metadata and initial supply. pub fn init(&amp;mut self, name: String, symbol: String, decimals: u8, initial_supply: U256) { // We put the token address as an admin, so it can govern itself. Self-governing token! self.token.init(symbol, name, decimals, initial_supply); } // Delegate all Cep18 functions to the token submodule. delegate! { to self.token { /// Returns the name of the token. fn name(&amp;self) -&gt; String; /// Returns the symbol of the token. fn symbol(&amp;self) -&gt; String; /// Returns the number of decimals the token uses. fn decimals(&amp;self) -&gt; u8; /// Returns the total supply of the token. fn total_supply(&amp;self) -&gt; U256; /// Returns the balance of the given address. fn balance_of(&amp;self, address: &amp;Address) -&gt; U256; /// Returns the amount of tokens the owner has allowed the spender to spend. fn allowance(&amp;self, owner: &amp;Address, spender: &amp;Address) -&gt; U256; /// Approves the spender to spend the given amount of tokens on behalf of the caller. fn approve(&amp;mut self, spender: &amp;Address, amount: &amp;U256); /// Decreases the allowance of the spender by the given amount. fn decrease_allowance(&amp;mut self, spender: &amp;Address, decr_by: &amp;U256); /// Increases the allowance of the spender by the given amount. fn increase_allowance(&amp;mut self, spender: &amp;Address, inc_by: &amp;U256); /// Transfers tokens from the caller to the recipient. fn transfer(&amp;mut self, recipient: &amp;Address, amount: &amp;U256); /// Transfers tokens from the owner to the recipient using the spender's allowance. fn transfer_from(&amp;mut self, owner: &amp;Address, recipient: &amp;Address, amount: &amp;U256); } } /// Burns the given amount of tokens from the given address. pub fn burn(&amp;mut self, owner: &amp;Address, amount: &amp;U256) { self.token.assert_caller(owner); // Burn the tokens. self.token.raw_burn(owner, amount); } /// Proposes a new mint for the contract. pub fn propose_new_mint(&amp;mut self, account: Address, amount: U256) { // Only allow proposing a new mint if there is no vote in progress. if self.is_vote_open.get_or_default() { self.env().revert(GovernanceError::VoteAlreadyOpen); } // Only the token holders can propose a new mint. if self.balance_of(&amp;self.env().caller()) == U256::zero() { self.env() .revert(GovernanceError::OnlyTokenHoldersCanPropose); } // Set the proposed mint. self.proposed_mint.set((account, amount)); // Open a vote. self.is_vote_open.set(true); // Set the vote end time to 10 minutes from now. self.vote_end_time .set(self.env().get_block_time() + 10 * 60 * 1000); } /// Votes on the proposed mint. pub fn vote(&amp;mut self, choice: bool, amount: U256) { // Only allow voting if there is a vote in progress. self.assert_vote_in_progress(); let voter = self.env().caller(); let contract = self.env().self_address(); // Transfer the voting tokens from the voter to the contract. self.token.transfer(&amp;contract, &amp;amount); // Add the vote to the list. self.votes.push(Ballot { voter, choice, amount, }); } /// Count the votes and perform the action pub fn tally(&amp;mut self) { // Only allow tallying the votes once. if !self.is_vote_open.get_or_default() { self.env().revert(GovernanceError::NoVoteInProgress); } // Only allow tallying the votes after the vote has ended. let finish_time = self .vote_end_time .get_or_revert_with(GovernanceError::NoVoteInProgress); if self.env().get_block_time() &lt; finish_time { self.env().revert(GovernanceError::VoteNotYetEnded); } // Count the votes let mut yes_votes = U256::zero(); let mut no_votes = U256::zero(); let contract = self.env().self_address(); while let Some(vote) = self.votes.pop() { if vote.choice { yes_votes += vote.amount; } else { no_votes += vote.amount; } // Transfer back the voting tokens to the voter. self.token .raw_transfer(&amp;contract, &amp;vote.voter, &amp;vote.amount); } // Perform the action if the vote has passed. if yes_votes &gt; no_votes { let (account, amount) = self .proposed_mint .get_or_revert_with(GovernanceError::NoVoteInProgress); self.token.raw_mint(&amp;account, &amp;amount); } // Close the vote. self.is_vote_open.set(false); } fn assert_vote_in_progress(&amp;self) { if !self.is_vote_open.get_or_default() { self.env().revert(GovernanceError::NoVoteInProgress); } let finish_time = self .vote_end_time .get_or_revert_with(GovernanceError::NoVoteInProgress); if self.env().get_block_time() &gt; finish_time { self.env().revert(GovernanceError::VoteEnded); } } } #[cfg(test)] mod tests { use super::*; use odra::host::Deployer; #[test] fn it_works() { let env = odra_test::env(); let init_args = OurTokenInitArgs { name: &quot;OurToken&quot;.to_string(), symbol: &quot;OT&quot;.to_string(), decimals: 0, initial_supply: U256::from(1_000u64), }; let mut token = OurToken::deploy(&amp;env, init_args); // The deployer, as the only token holder, // starts a new voting to mint 1000 tokens to account 1. // There is only 1 token holder, so there is one Ballot cast. token.propose_new_mint(env.get_account(1), U256::from(2000)); token.vote(true, U256::from(1000)); // The tokens should now be staked. assert_eq!(token.balance_of(&amp;env.get_account(0)), U256::zero()); // Wait for the vote to end. env.advance_block_time(60 * 11 * 1000); // Finish the vote. token.tally(); // The tokens should now be minted. assert_eq!(token.balance_of(&amp;env.get_account(1)), U256::from(2000)); assert_eq!(token.total_supply(), 3000.into()); // The stake should be returned. assert_eq!(token.balance_of(&amp;env.get_account(0)), U256::from(1000)); // Now account 1 can mint new tokens with their voting power... env.set_caller(env.get_account(1)); token.propose_new_mint(env.get_account(1), U256::from(2000)); token.vote(true, U256::from(2000)); // ...Even if the deployer votes against it. env.set_caller(env.get_account(0)); token.vote(false, U256::from(1000)); env.advance_block_time(60 * 11 * 1000); token.tally(); // The power of community governance! assert_eq!(token.balance_of(&amp;env.get_account(1)), U256::from(4000)); } }  ","version":"2.0.1","tagName":"h2"},{"title":"ERC-20","type":0,"sectionRef":"#","url":"/docs/2.0.1/tutorials/erc20","content":"","keywords":"","version":"2.0.1"},{"title":"Framework features​","type":1,"pageTitle":"ERC-20","url":"/docs/2.0.1/tutorials/erc20#framework-features","content":"A module we will write in a minute, will help you master a few Odra features: Advanced storage using key-value pairs,Odra types such as Address,Advanced event assertion. ","version":"2.0.1","tagName":"h2"},{"title":"Code​","type":1,"pageTitle":"ERC-20","url":"/docs/2.0.1/tutorials/erc20#code","content":"Our module features a considerably more complex storage layout compared to the previous example. It is designed to store the following data: Immutable metadata - name, symbol, and decimals.Total supply.Balances of individual users.Allowances, essentially indicating who is permitted to spend tokens on behalf of another user. ","version":"2.0.1","tagName":"h2"},{"title":"Module definition​","type":1,"pageTitle":"ERC-20","url":"/docs/2.0.1/tutorials/erc20#module-definition","content":"erc20.rs use odra::prelude::*; use odra::casper_types::U256; #[odra::module(events = [Transfer, Approval])] pub struct Erc20 { decimals: Var&lt;u8&gt;, symbol: Var&lt;String&gt;, name: Var&lt;String&gt;, total_supply: Var&lt;U256&gt;, balances: Mapping&lt;Address, U256&gt;, allowances: Mapping&lt;(Address, Address), U256&gt; }  L10 - For the first time, we need to store key-value pairs. In order to do that, we use Mapping. The name is taken after Solidity's native type mapping.L11 - Odra does not allows nested Mappings as Solidity does. Instead, you can create a compound key using a tuple of keys. ","version":"2.0.1","tagName":"h2"},{"title":"Metadata​","type":1,"pageTitle":"ERC-20","url":"/docs/2.0.1/tutorials/erc20#metadata","content":"erc20.rs #[odra::module] impl Erc20 { pub fn init(&amp;mut self, name: String, symbol: String, decimals: u8, initial_supply: U256) { let caller = self.env().caller(); self.name.set(name); self.symbol.set(symbol); self.decimals.set(decimals); self.mint(&amp;caller, &amp;initial_supply); } pub fn name(&amp;self) -&gt; String { self.name.get_or_default() } pub fn symbol(&amp;self) -&gt; String { self.symbol.get_or_default() } pub fn decimals(&amp;self) -&gt; u8 { self.decimals.get_or_default() } pub fn total_supply(&amp;self) -&gt; U256 { self.total_supply.get_or_default() } } impl Erc20 { pub fn mint(&amp;mut self, address: &amp;Address, amount: &amp;U256) { self.balances.add(address, *amount); self.total_supply.add(*amount); self.env().emit_event(Transfer { from: None, to: Some(*address), amount: *amount }); } } #[odra::event] pub struct Transfer { pub from: Option&lt;Address&gt;, pub to: Option&lt;Address&gt;, pub amount: U256 }  L1 - The first impl block, marked as a module, contains functions defined in the ERC-20 standard.L3-L9 - A constructor sets the token metadata and mints the initial supply.L28 - The second impl is not an Odra module; in other words, these functions will not be part of the contract's public interface.L29-L38 - The mint function is public, so, like in regular Rust code, it will be accessible from the outside. mint() uses the notation self.balances.add(address, *amount);, which is syntactic sugar for: let current_balance = self.balances.get(address).unwrap_or_default(); let new_balance = &lt;U256 as OverflowingAdd&gt;::overflowing_add(current_balance, current_balance).unwrap_or_revert(&amp;self.env()); self.balances.set(address, new_balance);  ","version":"2.0.1","tagName":"h3"},{"title":"Core​","type":1,"pageTitle":"ERC-20","url":"/docs/2.0.1/tutorials/erc20#core","content":"To ensure comprehensive functionality, let's implement the remaining features such as transfer, transfer_from, and approve. Since they do not introduce any new concepts, we will present them without additional remarks. erc20.rs #[odra::module] impl Erc20 { ... pub fn transfer(&amp;mut self, recipient: &amp;Address, amount: &amp;U256) { let caller = self.env().caller(); self.raw_transfer(&amp;caller, recipient, amount); } pub fn transfer_from(&amp;mut self, owner: &amp;Address, recipient: &amp;Address, amount: &amp;U256) { let spender = self.env().caller(); self.spend_allowance(owner, &amp;spender, amount); self.raw_transfer(owner, recipient, amount); } pub fn approve(&amp;mut self, spender: &amp;Address, amount: &amp;U256) { let owner = self.env().caller(); self.allowances.set(&amp;(owner, *spender), *amount); self.env().emit_event(Approval { owner, spender: *spender, value: *amount }); } pub fn balance_of(&amp;self, address: &amp;Address) -&gt; U256 { self.balances.get_or_default(&amp;address) } pub fn allowance(&amp;self, owner: &amp;Address, spender: &amp;Address) -&gt; U256 { self.allowances.get_or_default(&amp;(*owner, *spender)) } } impl Erc20 { ... fn raw_transfer(&amp;mut self, owner: &amp;Address, recipient: &amp;Address, amount: &amp;U256) { let owner_balance = self.balances.get_or_default(&amp;owner); if *amount &gt; owner_balance { self.env().revert(Error::InsufficientBalance) } self.balances.set(owner, owner_balance - *amount); self.balances.add(recipient, *amount); self.env().emit_event(Transfer { from: Some(*owner), to: Some(*recipient), amount: *amount }); } fn spend_allowance(&amp;mut self, owner: &amp;Address, spender: &amp;Address, amount: &amp;U256) { let allowance = self.allowance(owner, spender); if allowance &lt; *amount { self.env().revert(Error::InsufficientAllowance) } let new_allowance = allowance - *amount; self.allowances .set(&amp;(*owner, *spender), new_allowance); self.env().emit_event(Approval { owner: *owner, spender: *spender, value: allowance - *amount }); } } #[odra::event] pub struct Approval { pub owner: Address, pub spender: Address, pub value: U256 } #[odra::odra_error] pub enum Error { InsufficientBalance = 1, InsufficientAllowance = 2, }  Now, compare the code we have written, with Open Zeppelin code. Out of 10, how Solidity-ish is our implementation? ","version":"2.0.1","tagName":"h3"},{"title":"Test​","type":1,"pageTitle":"ERC-20","url":"/docs/2.0.1/tutorials/erc20#test","content":"erc20.rs #[cfg(test)] pub mod tests { use super::*; use odra::{casper_types::U256, host::{Deployer, HostEnv, HostRef}}; const NAME: &amp;str = &quot;Plascoin&quot;; const SYMBOL: &amp;str = &quot;PLS&quot;; const DECIMALS: u8 = 10; const INITIAL_SUPPLY: u32 = 10_000; fn setup() -&gt; (HostEnv, Erc20HostRef) { let env = odra_test::env(); ( env.clone(), Erc20::deploy( &amp;env, Erc20InitArgs { symbol: SYMBOL.to_string(), name: NAME.to_string(), decimals: DECIMALS, initial_supply: INITIAL_SUPPLY.into() } ) ) } #[test] fn initialization() { // When deploy a contract with the initial supply. let (env, erc20) = setup(); // Then the contract has the metadata set. assert_eq!(erc20.symbol(), SYMBOL.to_string()); assert_eq!(erc20.name(), NAME.to_string()); assert_eq!(erc20.decimals(), DECIMALS); // Then the total supply is updated. assert_eq!(erc20.total_supply(), INITIAL_SUPPLY.into()); // Then a Transfer event was emitted. assert!(env.emitted_event( &amp;erc20, &amp;Transfer { from: None, to: Some(env.get_account(0)), amount: INITIAL_SUPPLY.into() } )); } #[test] fn transfer_works() { // Given a new contract. let (env, mut erc20) = setup(); // When transfer tokens to a recipient. let sender = env.get_account(0); let recipient = env.get_account(1); let amount = 1_000.into(); erc20.transfer(&amp;recipient, &amp;amount); // Then the sender balance is deducted. assert_eq!( erc20.balance_of(&amp;sender), U256::from(INITIAL_SUPPLY) - amount ); // Then the recipient balance is updated. assert_eq!(erc20.balance_of(&amp;recipient), amount); // Then Transfer event was emitted. assert!(env.emitted_event( &amp;erc20, &amp;Transfer { from: Some(sender), to: Some(recipient), amount } )); } #[test] fn transfer_error() { // Given a new contract. let (env, mut erc20) = setup(); // When the transfer amount exceeds the sender balance. let recipient = env.get_account(1); let amount = U256::from(INITIAL_SUPPLY) + U256::one(); // Then an error occurs. assert!(erc20.try_transfer(&amp;recipient, &amp;amount).is_err()); } #[test] fn transfer_from_and_approval_work() { let (env, mut erc20) = setup(); let (owner, recipient, spender) = (env.get_account(0), env.get_account(1), env.get_account(2)); let approved_amount = 3_000.into(); let transfer_amount = 1_000.into(); assert_eq!(erc20.balance_of(&amp;owner), U256::from(INITIAL_SUPPLY)); // Owner approves Spender. erc20.approve(&amp;spender, &amp;approved_amount); // Allowance was recorded. assert_eq!(erc20.allowance(&amp;owner, &amp;spender), approved_amount); assert!(env.emitted_event( &amp;erc20, &amp;Approval { owner, spender, value: approved_amount } )); // Spender transfers tokens from Owner to Recipient. env.set_caller(spender); erc20.transfer_from(&amp;owner, &amp;recipient, &amp;transfer_amount); // Tokens are transferred and allowance decremented. assert_eq!( erc20.balance_of(&amp;owner), U256::from(INITIAL_SUPPLY) - transfer_amount ); assert_eq!(erc20.balance_of(&amp;recipient), transfer_amount); assert!(env.emitted_event( &amp;erc20, &amp;Approval { owner, spender, value: approved_amount - transfer_amount } )); assert!(env.emitted_event( &amp;erc20, &amp;Transfer { from: Some(owner), to: Some(recipient), amount: transfer_amount } )); // assert!(env.emitted(erc20.address(), &quot;Transfer&quot;)); } #[test] fn transfer_from_error() { // Given a new instance. let (env, mut erc20) = setup(); // When the spender's allowance is zero. let (owner, spender, recipient) = (env.get_account(0), env.get_account(1), env.get_account(2)); let amount = 1_000.into(); env.set_caller(spender); // Then transfer fails. assert_eq!( erc20.try_transfer_from(&amp;owner, &amp;recipient, &amp;amount), Err(Error::InsufficientAllowance.into()) ); } }  L146 - Alternatively, if you don't want to check the entire event, you may assert only its type. ","version":"2.0.1","tagName":"h3"},{"title":"What's next​","type":1,"pageTitle":"ERC-20","url":"/docs/2.0.1/tutorials/erc20#whats-next","content":"Having two modules: Ownable and Erc20, let's combine them, and create an ERC-20 on steroids. ","version":"2.0.1","tagName":"h2"},{"title":"Odra CLI","type":0,"sectionRef":"#","url":"/docs/2.0.1/tutorials/odra-cli","content":"","keywords":"","version":"2.0.1"},{"title":"Deploy script​","type":1,"pageTitle":"Odra CLI","url":"/docs/2.0.1/tutorials/odra-cli#deploy-script","content":"Let's go through an example available in the odra repository to see how to use the Odra CLI library. It creates a cli tool for a useful &quot;DogContract&quot;. To use the Odra CLI library in your project, you need to add odra-cli to your Cargo.toml file, alongside a new binary: [dependencies] ... odra-cli = &quot;2&quot; ... [[bin]] name = &quot;odra-cli&quot; path = &quot;src/bin/odra-cli.rs&quot;  Then, create a new file in the src/bin directory named odra-cli.rs: /// Deploys the `DogContract` and adds it to the container. pub struct DeployDogScript; impl DeployScript for DeployDogScript { fn deploy( &amp;self, env: &amp;HostEnv, container: &amp;mut DeployedContractsContainer ) -&gt; Result&lt;(), odra_cli::deploy::Error&gt; { env.set_gas(350_000_000_000); let dog_contract = DogContract::try_deploy( env, DogContractInitArgs { barks: true, weight: 10, name: &quot;Mantus&quot;.to_string() } )?; container.add_contract(&amp;dog_contract)?; Ok(()) } } /// Main function to run the CLI tool. pub fn main() { OdraCli::new() .about(&quot;Dog contract cli tool&quot;) .deploy(DeployDogScript) .contract::&lt;DogContract&gt;() .build() .run(); }  In the example above, we see an implementation of a simple DeployScript for our DogContract. It sets the gas limit, deploys the contract and adds it to a container. The main function creates a new OdraCli instance, and sets the deploy script, making it available for the user. ","version":"2.0.1","tagName":"h2"},{"title":"How to use it​","type":1,"pageTitle":"Odra CLI","url":"/docs/2.0.1/tutorials/odra-cli#how-to-use-it","content":"Assuming the correct livenet environment is set up, you can run the cli tool using the following command: cargo run --bin odra-cli  Which will display all of our options: Dog contract cli tool Usage: odra_cli &lt;COMMAND&gt; Commands: deploy Runs the deploy script contract Commands for interacting with contracts scenario Commands for running user-defined scenarios help Print this message or the help of the given subcommand(s) Options: -h, --help Print help  First, we need to deploy the contract: cargo run --bin odra_cli deploy  Which gives us an output: cargo run --bin odra_cli -- deploy Compiling odra-examples v2.0.0 (/home/kuba/Projekty/odra/odra/examples) Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.65s Running `../target/debug/odra_cli deploy` 💁 INFO : Found wasm under &quot;wasm/DogContract.wasm&quot;. 💁 INFO : Deploying &quot;DogContract&quot;. 🙄 WAIT : Waiting 10 for V1(TransactionV1Hash(10ce0134ac3a67772a668bb6c32a0dc74c09278f44d7896cc5419b8e2b2de33e)). 💁 INFO : Deploy &quot;10ce0134ac3a67772a668bb6c32a0dc74c09278f44d7896cc5419b8e2b2de33e&quot; successfully executed. 💁 INFO : Contract &quot;contract-package-3e1e053c2e9377e823d9156e0663b7614f74eb524d47d9dc4a621f8cd06a357b&quot; deployed. 💁 INFO : Command executed successfully  This will run the deploy script, and create a new file in the resources directory named deployed-contracts.toml: time = &quot;2025-05-22T14:40:31Z&quot; [[contracts]] name = &quot;DogContract&quot; package_hash = &quot;hash-3e1e053c2e9377e823d9156e0663b7614f74eb524d47d9dc4a621f8cd06a357b&quot;  All the calls to the contract will be made using this package hash. ","version":"2.0.1","tagName":"h2"},{"title":"Calling contract methods​","type":1,"pageTitle":"Odra CLI","url":"/docs/2.0.1/tutorials/odra-cli#calling-contract-methods","content":"To call a contract method, we need to use the contract command. The command itself will display all the available contracts: cargo run --bin odra_cli -- contract  Which outputs: Commands for interacting with contracts Usage: odra_cli contract &lt;COMMAND&gt; Commands: DogContract Commands for interacting with the DogContract contract help Print this message or the help of the given subcommand(s)  And when contract is selected, it will show us the available methods: cargo run --bin odra_cli -- contract DogContract  Commands for interacting with the DogContract contract Usage: odra_cli contract DogContract &lt;COMMAND&gt; Commands: barks Returns true if the dog barks. weight Returns the dog's weight. name Returns the dog's name. walks_amount Adds a walk to the dog's walks. walks_total_length Returns the total length of the dog's walks. help Print this message or the help of the given subcommand(s)  To run a command, compose a command like this: cargo run --bin odra_cli -- contract DogContract barks  It will result with: 💁 INFO : true 💁 INFO : Command executed successfully  ","version":"2.0.1","tagName":"h2"},{"title":"Creating and running a scenario​","type":1,"pageTitle":"Odra CLI","url":"/docs/2.0.1/tutorials/odra-cli#creating-and-running-a-scenario","content":"Sometimes we want to run multiple calls one after another. To simplify this, we can create a scenario. To do this implement the Scenario trait in the odra-cli binary:  /// Checks if the name of the deployed dog matches the provided name. pub struct DogCheckScenario; impl Scenario for DogCheckScenario { fn args(&amp;self) -&gt; Vec&lt;CommandArg&gt; { vec![CommandArg::new( &quot;name&quot;, &quot;The name of the dog&quot;, NamedCLType::String, false, false )] } fn run( &amp;self, env: &amp;HostEnv, container: DeployedContractsContainer, args: ScenarioArgs ) -&gt; Result&lt;(), ScenarioError&gt; { let dog_contract = container.get_ref::&lt;DogContract&gt;(env)?; let test_name = args.get_single::&lt;String&gt;(&quot;name&quot;)?; env.set_gas(50_000_000); let actual_name = dog_contract.try_name()?; assert_eq!(test_name, actual_name, &quot;Dog name mismatch&quot;); Ok(()) } } impl ScenarioMetadata for DogCheckScenario { const NAME: &amp;'static str = &quot;check&quot;; const DESCRIPTION: &amp;'static str = &quot;Checks if the name of the deployed dog matches the provided name&quot;; }  The example above performs a simple check on the return value of one of the methods. Of course, there is no limit to how complex a scenario can be. Remember to add the scenario in the main function: /// Main function to run the CLI tool. pub fn main() { OdraCli::new() .about(&quot;Dog contract cli tool&quot;) .deploy(DeployDogScript) .contract::&lt;DogContract&gt;() .scenario::&lt;DogCheckScenario&gt;(DogCheckScenario) // New scenario .build() .run(); }  It will appear in the scenario command: cargo run --bin odra_cli -- scenario  Will output: Commands for running user-defined scenarios Usage: odra_cli scenario &lt;COMMAND&gt; Commands: check Checks if the name of the deployed dog matches the provided name help Print this message or the help of the given subcommand(s)  It can be run like this: cargo run --bin odra_cli -- scenario check --name Doggy  This will output: thread 'main' panicked at examples/bin/odra_cli.rs:59:9: assertion `left == right` failed: Dog name mismatch left: &quot;Doggy&quot; right: &quot;Mantus&quot;  ","version":"2.0.1","tagName":"h2"},{"title":"Ticketing System","type":0,"sectionRef":"#","url":"/docs/2.0.1/tutorials/nft","content":"","keywords":"","version":"2.0.1"},{"title":"Ticket Office Contract​","type":1,"pageTitle":"Ticketing System","url":"/docs/2.0.1/tutorials/nft#ticket-office-contract","content":"Our TicketOffice contract will include the following features: Compliance with the CEP-78 standard.Ownership functionality.Only the owner can issue new event tickets.Users can purchase tickets for events.Tickets are limited to a one-time sale.Public access to view the total income of the TicketOffice. ","version":"2.0.1","tagName":"h2"},{"title":"Setup the project​","type":1,"pageTitle":"Ticketing System","url":"/docs/2.0.1/tutorials/nft#setup-the-project","content":"Creating a new NFT token with Odra is straightforward. Use the cargo odra new command to create a new project with the CEP-95 template: cargo odra new --name ticket-office --template cep95  ","version":"2.0.1","tagName":"h2"},{"title":"Contract implementation​","type":1,"pageTitle":"Ticketing System","url":"/docs/2.0.1/tutorials/nft#contract-implementation","content":"Let's start implementing the TicketOffice contract by modify the code generated from the template. src/token.rs use odra::{casper_types::{U256, U512}, prelude::*}; use odra_modules::access::Ownable; use odra_modules::cep95::{CEP95Interface, Cep95}; pub type TicketId = U256; #[odra::odra_type] pub enum TicketStatus { Available, Sold, } #[odra::odra_type] pub struct TicketInfo { event_name: String, price: U512, status: TicketStatus, } #[odra::event] pub struct OnTicketIssue { ticket_id: TicketId, event_name: String, price: U512, } #[odra::event] pub struct OnTicketSell { ticket_id: TicketId, buyer: Address, } #[odra::odra_error] pub enum Error { TicketNotAvailableForSale = 200, InsufficientFunds = 201, InvalidTicketId = 202, TicketDoesNotExist = 203, } #[odra::module( events = [OnTicketIssue, OnTicketSell], errors = Error )] pub struct TicketOffice { token: SubModule&lt;Cep95&gt;, ownable: SubModule&lt;Ownable&gt;, tickets: Mapping&lt;TicketId, TicketInfo&gt;, token_id_counter: Var&lt;TicketId&gt;, total_supply: Var&lt;u64&gt;, } #[odra::module] impl TicketOffice { pub fn init(&amp;mut self, collection_name: String, collection_symbol: String, total_supply: u64) { let caller = self.env().caller(); self.ownable.init(caller); self.token.init(collection_name, collection_symbol); } pub fn issue_ticket(&amp;mut self, event_name: String, price: U512) { let env = self.env(); let caller = env.caller(); self.ownable.assert_owner(&amp;caller); // mint a new token let ticket_id = self.token_id_counter.get_or_default(); self.token.mint(caller, ticket_id, Default::default()); // store ticket info self.tickets.set( &amp;ticket_id, TicketInfo { event_name: event_name.clone(), price, status: TicketStatus::Available, }, ); self.token_id_counter.set(ticket_id + 1); // emit an event env.emit_event(OnTicketIssue { ticket_id, event_name, price, }); } #[odra(payable)] pub fn buy_ticket(&amp;mut self, ticket_id: TicketId) { let env = self.env(); let owner = self.ownable.get_owner(); let buyer = env.caller(); let value = env.attached_value(); // only tokens owned by the owner can be sold if self.token.owner_of(ticket_id) != Some(owner) { env.revert(Error::TicketNotAvailableForSale); } let mut ticket = self .tickets .get(&amp;ticket_id) .unwrap_or_revert_with(&amp;env, Error::TicketDoesNotExist); // only available tickets can be sold if ticket.status != TicketStatus::Available { env.revert(Error::TicketNotAvailableForSale); } // check if the buyer sends enough funds if value &lt; ticket.price { env.revert(Error::InsufficientFunds); } // transfer csprs to the owner env.transfer_tokens(&amp;owner, &amp;value); // transfer the ticket to the buyer self.token.transfer_from(owner, buyer, ticket_id); ticket.status = TicketStatus::Sold; self.tickets.set(&amp;ticket_id, ticket); env.emit_event(OnTicketSell { ticket_id, buyer }); } pub fn balance_of(&amp;self) -&gt; U512 { self.env().self_balance() } }  L7-L39 - We define structures and enums that will be used in our contract. TicketStatus enum represents the status of a ticket, TicketInfo struct contains information about a ticket that is written to the storage, TicketId is a type alias for u64. OnTicketIssue and OnTicketSell are events that will be emitted when a ticket is issued or sold.L41-L44 - Register errors and events that will be used in our contract, required to produce a complete contract schema.L45-L51 - TicketOffice module definition. The module contains a Cep95 token, an Ownable module, a Mapping that stores information about tickets and Vars token_id_counter and total_supply to keep track of the total number of tickets issued.L55-L59 - The init function has been generated from the template and there is no need to modify it, except the Ownable module initialization.L61-L84 - The issue_ticket function allows the owner to issue a new ticket. The function mints a new token, stores information about the ticket, and emits an OnTicketIssue event.L86 - The payable attribute indicates that the buy_ticket function can receive funds.L87-L116 - The buy_ticket function checks if the ticket is available for sale, if the buyer sends enough funds, and transfers the ticket to the buyer. Finally, the function updates the ticket status and emits an OnTicketSell event. Lets test the contract. The test scenario will be as follows: Deploy the contract.Issue two tickets.Try to buy a ticket with insufficient funds.Buy tickets.Try to buy the same ticket again.Check the balance of the contract. src/tests.rs use odra::{ casper_types::U512, host::{Deployer, HostRef}, }; use crate::token::{Error, TicketOfficeHostRef, TicketOfficeInitArgs}; #[test] fn it_works() { let env = odra_test::env(); let init_args = TicketOfficeInitArgs { collection_name: &quot;Ticket&quot;.to_string(), collection_symbol: &quot;T&quot;.to_string(), total_supply: 100, }; let mut contract = TicketOffice::deploy(&amp;env, init_args); contract.issue_ticket(&quot;Ev&quot;.to_string(), U512::from(100)); contract.issue_ticket(&quot;Ev&quot;.to_string(), U512::from(50)); let buyer = env.get_account(1); env.set_caller(buyer); assert_eq!( contract .with_tokens(U512::from(50)) .try_buy_ticket(0.into()), Err(Error::InsufficientFunds.into()) ); assert_eq!( contract .with_tokens(U512::from(100)) .try_buy_ticket(0.into()), Ok(()) ); assert_eq!( contract .with_tokens(U512::from(50)) .try_buy_ticket(1.into()), Ok(()) ); assert_eq!( contract .with_tokens(U512::from(100)) .try_buy_ticket(0.into()), Err(Error::TicketNotAvailableForSale.into()) ); }  Unfortunately, the test failed. The first assertion succeeds because the buyer sends insufficient funds to buy the ticket. However, the second assertion fails even though the buyer sends enough funds to purchase the ticket. The buy_ticket function reverts with CEP-95 Error::NotAnOwnerOrApproved because the buyer attempts to transfer a token that they do not own, are not approved for, or are not an operator of. odra/modules/src/cep95.rs fn transfer_from(&amp;mut self, from: Address, to: Address, token_id: U256) { self.assert_exists(&amp;token_id); let caller = self.env().caller(); let owner = self .owner_of(token_id) .unwrap_or_revert_with(self, Error::ValueNotSet); // Only the owner or an approved spender can transfer the token. if (owner != from || owner != caller) &amp;&amp; !self.is_approved_for_all(from, caller) { if let Some(approved) = self.approved_for(token_id) { if approved != caller { self.env().revert(Error::NotAnOwnerOrApproved); } } else { self.env().revert(Error::NotAnOwnerOrApproved); } } ... }  Let's fix it by redesigning our little system. ","version":"2.0.1","tagName":"h2"},{"title":"Redesign​","type":1,"pageTitle":"Ticketing System","url":"/docs/2.0.1/tutorials/nft#redesign","content":"Since a buyer cannot purchase a ticket directly, we need to introduce an intermediary — an operator who will be responsible for buying tickets on behalf of the buyer. The operator will be approved by the ticket office to transfer tickets. The sequence diagram below illustrates the new flow: ","version":"2.0.1","tagName":"h2"},{"title":"Ticket Operator Contract​","type":1,"pageTitle":"Ticketing System","url":"/docs/2.0.1/tutorials/nft#ticket-operator-contract","content":"As shown in the sequence diagram, a new contract will act as an operator for the ticket office. To create this new contract, use the cargo odra generate command. cargo odra generate -c ticket_operator  src/ticket_operator.rs use crate::token::{TicketId, TicketOfficeContractRef}; use odra::{casper_types::{U256, U512}, ContractRef, prelude::*}; #[odra::odra_error] pub enum Error { UnknownTicketOffice = 300, } #[odra::module(errors = Error)] pub struct TicketOperator { ticket_office_address: Var&lt;Address&gt;, } #[odra::module] impl TicketOperator { pub fn register(&amp;mut self, ticket_office_address: Address) { self.ticket_office_address.set(ticket_office_address); } // now the operator's `buy_ticket` receives funds. #[odra(payable)] pub fn buy_ticket(&amp;mut self, ticket_id: TicketId) { let env = self.env(); let buyer = env.caller(); let value = env.attached_value(); let center = self .ticket_office_address .get() .unwrap_or_revert_with(&amp;env, Error::UnknownTicketOffice); let mut ticket_contract = TicketOfficeContractRef::new(env, center); // now and approved entity - the operator - buys the ticket on behalf of the buyer ticket_contract.buy_ticket(ticket_id, buyer, value); } pub fn balance_of(&amp;self) -&gt; U512 { self.env().self_balance() } }  L4-L7 - Define errors that will be used in the contract.L9-L13 - Define the TicketOperator module that stores the address of the ticketing office.L16-L18 - The register function sets the address of the ticketing office.L20-L32 - The buy_ticket function buys a ticket on behalf of the buyer using the ticket office address. The function forwards the call to the ticketing office contract. We simply create a TicketOfficeContractRef to interact we the TicketOffice contract. Note that, the operator's buy_ticket now receives funds. Now we need to adjust the TicketOffice contract to use the TicketOperator contract to buy tickets. src/token.rs #[odra::odra_error] pub enum Error { ... MissingOperator = 204, Unauthorized = 205, } #[odra::module] pub struct TicketOffice { ... operator: Var&lt;Address&gt;, } #[odra::module] impl TicketOffice { ... pub fn register_operator(&amp;mut self, operator: Address) { // only the owner can register an operator let caller = self.env().caller(); self.ownable.assert_owner(&amp;caller); // store the ticketing center address in the operator contract TicketOperatorContractRef::new(self.env(), operator).register(self.env().self_address()); self.operator.set(operator); } pub fn issue_ticket(&amp;mut self, event_name: String, price: U512) { // minting logic remains the same... ... // approve the operator to transfer the ticket let operator = self.operator(); self.token.approve(operator, ticket_id); // emit an event ... } pub fn buy_ticket(&amp;mut self, ticket_id: TicketId, buyer: Address, value: U512) { let env = self.env(); let owner = self.ownable.get_owner(); let caller = env.caller(); // make sure the caller is the operator if !self.is_operator(caller) { env.revert(Error::Unauthorized); } ... // the logic remains the same, except for the csprs transfer // it is now handled by the operator contract. // env.transfer_tokens(&amp;owner, &amp;value); } #[inline] fn is_operator(&amp;self, caller: Address) -&gt; bool { Some(caller) == self.operator.get() } #[inline] fn operator(&amp;self) -&gt; Address { self.operator .get() .unwrap_or_revert_with(&amp;self.env(), Error::MissingOperator) } }  L11 - the contract stores the operator address.L18-L25 - a new function register_operator allows the owner to register an operator. Also calls the register entry point on the operator contract.L32-36 - modify the issue_ticket function: once a new token is minted, approves the operator to transfer the ticket later.L40-L53 - modify the buy_ticket function: check if the caller is the operator, do not transfer cspr to the contract - now the operator collect funds.We also added two helper functions: is_operator and operator to check if the caller is the operator and get the operator address. Two new errors were added: MissingOperator and Unauthorized. Now we need to update our tests to create a scenario we presented in the sequence diagram. src/tests.rs use odra::{ casper_types::U512, host::{Deployer, HostRef, NoArgs}, prelude::* }; use crate::{ ticket_operator::TicketOperatorHostRef, token::{Error, TicketId, TicketOfficeContractRef, TicketOfficeInitArgs}, }; #[test] fn it_works() { let env = odra_test::env(); let init_args = TicketOfficeInitArgs { collection_name: &quot;Ticket&quot;.to_string(), collection_symbol: &quot;T&quot;.to_string(), total_supply: 100, }; let operator = TicketOperator::deploy(&amp;env, NoArgs); let mut ticket_office = TicketOfficeContractRef::deploy(&amp;env, init_args); ticket_office.register_operator(operator.address().clone()); ticket_office.issue_ticket(&quot;Ev&quot;.to_string(), U512::from(100)); ticket_office.issue_ticket(&quot;Ev&quot;.to_string(), U512::from(50)); let buyer = env.get_account(1); env.set_caller(buyer); assert_eq!( buy_ticket(&amp;operator, 0.into(), 50), Err(Error::InsufficientFunds.into()) ); assert_eq!(buy_ticket(&amp;operator, 0.into(), 100), Ok(())); assert_eq!(buy_ticket(&amp;operator, 1.into(), 50), Ok(())); assert_eq!( buy_ticket(&amp;operator, 0.into(), 100), Err(Error::TicketNotAvailableForSale.into()) ); assert_eq!(operator.balance_of(), U512::from(150)); } fn buy_ticket(operator: &amp;TicketOperatorHostRef, id: TicketId, price: u64) -&gt; OdraResult&lt;()&gt; { operator.with_tokens(U512::from(price)).try_buy_ticket(id) }  ","version":"2.0.1","tagName":"h3"},{"title":"Conclusion​","type":1,"pageTitle":"Ticketing System","url":"/docs/2.0.1/tutorials/nft#conclusion","content":"In this tutorial, we created a simple ticketing system using the CEP-95 standard. This guide demonstrates how to combine various Odra features, including modules, events, errors, payable functions, and cross-contract calls. ","version":"2.0.1","tagName":"h2"},{"title":"Ownable","type":0,"sectionRef":"#","url":"/docs/2.0.1/tutorials/ownable","content":"","keywords":"","version":"2.0.1"},{"title":"Framework features​","type":1,"pageTitle":"Ownable","url":"/docs/2.0.1/tutorials/ownable#framework-features","content":"A module we will write in a minute, will help you master a few Odra features: storing a single value,defining a constructor,error handling,defining and emitting events.registering a contact in a test environment,interactions with the test environment,assertions (value, events, errors assertions). ","version":"2.0.1","tagName":"h2"},{"title":"Code​","type":1,"pageTitle":"Ownable","url":"/docs/2.0.1/tutorials/ownable#code","content":"Before we write any code, we define functionalities we would like to implement. Module has an initializer that should be called once. Only the current owner can set a new owner.Read the current owner.A function that fails if called by a non-owner account. ","version":"2.0.1","tagName":"h2"},{"title":"Define a module​","type":1,"pageTitle":"Ownable","url":"/docs/2.0.1/tutorials/ownable#define-a-module","content":"ownable.rs use odra::prelude::*; #[odra::module(events = [OwnershipChanged])] pub struct Ownable { owner: Var&lt;Option&lt;Address&gt;&gt; }  That was easy, but it is crucial to understand the basics before we move on. L3 - Firstly, we need to create a struct called Ownable and apply #[odra::module(events = [OwnershipChanged])] attribute to it. The events attribute is optional but informs the Odra toolchain about the events that will be emitted by the module and includes them in the contract's metadata. OwnershipChanged is a type that will be defined later.L5 - Then we can define the layout of our module. It is extremely simple - just a single state value. What is most important is that you can never leave a raw type; you must always wrap it with Var. ","version":"2.0.1","tagName":"h3"},{"title":"Init the module​","type":1,"pageTitle":"Ownable","url":"/docs/2.0.1/tutorials/ownable#init-the-module","content":"ownable.rs #[odra::module] impl Ownable { pub fn init(&amp;mut self, owner: Address) { if self.owner.get_or_default().is_some() { self.env().revert(Error::OwnerIsAlreadyInitialized) } self.owner.set(Some(owner)); self.env().emit_event(OwnershipChanged { prev_owner: None, new_owner: owner }); } } #[odra::odra_error] pub enum Error { OwnerIsAlreadyInitialized = 1, } #[odra::event] pub struct OwnershipChanged { pub prev_owner: Option&lt;Address&gt;, pub new_owner: Address }  Ok, we have done a couple of things, let's analyze them one by one: L1 - The impl should be an Odra module, so add #[odra::module].L3 - The init function is a constructor. This matters if we would like to deploy the Ownable module as a standalone contract.L17-L20 - Before we set a new owner, we must assert there was no owner before and raise an error otherwise. For that purpose, we defined an Error enum. Notice that the #[odra::odra_error] attribute is applied to the enum. It generates, among others, the required Into&lt;odra::OdraError&gt; binding.L4-L6 - If the owner has been set already, we call ContractEnv::revert() function with an Error::OwnerIsAlreadyInitialized argument. L8 - Then we write the owner passed as an argument to the storage. To do so, we call the set() on Var.L22-L26 - Once the owner is set, we would like to inform the outside world. The first step is to define an event struct. The struct annotated with #[odra::event] attribute.L10 - Finally, call ContractEnv::emit_event() passing the OwnershipChanged instance to the function. Hence, we set the first owner, we set the prev_owner value to None.  ","version":"2.0.1","tagName":"h3"},{"title":"Features implementation​","type":1,"pageTitle":"Ownable","url":"/docs/2.0.1/tutorials/ownable#features-implementation","content":"ownable.rs #[odra::module] impl Ownable { ... pub fn ensure_ownership(&amp;self, address: &amp;Address) { if Some(address) != self.owner.get_or_default().as_ref() { self.env().revert(Error::NotOwner) } } pub fn change_ownership(&amp;mut self, new_owner: &amp;Address) { self.ensure_ownership(&amp;self.env().caller()); let current_owner = self.get_owner(); self.owner.set(Some(*new_owner)); self.env().emit_event(OwnershipChanged { prev_owner: Some(current_owner), new_owner: *new_owner }); } pub fn get_owner(&amp;self) -&gt; Address { match self.owner.get_or_default() { Some(owner) =&gt; owner, None =&gt; self.env().revert(Error::OwnerIsNotInitialized) } } } #[odra::odra_error] pub enum Error { NotOwner = 1, OwnerIsAlreadyInitialized = 2, OwnerIsNotInitialized = 3, }  The above implementation relies on the concepts we have already used in this tutorial, so it should be easy for you to get along. L7,L31 - ensure_ownership() reads the current owner and reverts if it does not match the input Address. Also, we need to update our Error enum by adding a new variant NotOwner.L11 - The function defined above can be reused in the change_ownership() implementation. We pass to it the current caller, using the ContractEnv::caller() function. Then we update the state and emit OwnershipChanged.L21,L33 - Lastly, a getter function. Read the owner from storage, if the getter is called on an uninitialized module, it should revert with a new Error variant OwnerIsNotInitialized. There is one worth-mentioning subtlety: Var::get() function returns Option&lt;T&gt;. If the type implements the Default trait, you can call the get_or_default() function, and the contract does not fail even if the value is not initialized. As the owner is of type Option&lt;Address&gt; the Var::get() would return Option&lt;Option&lt;Address&gt;&gt;, we use Var::get_or_default() instead. ","version":"2.0.1","tagName":"h3"},{"title":"Test​","type":1,"pageTitle":"Ownable","url":"/docs/2.0.1/tutorials/ownable#test","content":"ownable.rs #[cfg(test)] mod tests { use super::*; use odra::host::{Deployer, HostEnv, HostRef}; fn setup() -&gt; (OwnableHostRef, HostEnv, Address) { let env: HostEnv = odra_test::env(); let init_args = OwnableInitArgs { owner: env.get_account(0) }; (Ownable::deploy(&amp;env, init_args), env.clone(), env.get_account(0)) } #[test] fn initialization_works() { let (ownable, env, owner) = setup(); assert_eq!(ownable.get_owner(), owner); env.emitted_event( &amp;ownable, &amp;OwnershipChanged { prev_owner: None, new_owner: owner } ); } #[test] fn owner_can_change_ownership() { let (mut ownable, env, owner) = setup(); let new_owner = env.get_account(1); env.set_caller(owner); ownable.change_ownership(&amp;new_owner); assert_eq!(ownable.get_owner(), new_owner); env.emitted_event( &amp;ownable, &amp;OwnershipChanged { prev_owner: Some(owner), new_owner } ); } #[test] fn non_owner_cannot_change_ownership() { let (mut ownable, env, _) = setup(); let new_owner = env.get_account(1); ownable.change_ownership(&amp;new_owner); assert_eq!( ownable.try_change_ownership(&amp;new_owner), Err(Error::NotOwner.into()) ); } }  L6 - Each test case starts with the same initialization process, so for convenience, we have defined the setup() function, which we call in the first statement of each test. Take a look at the signature: fn setup() -&gt; (OwnableHostRef, HostEnv, Address). OwnableHostRef is a contract reference generated by Odra. This reference allows us to call all the defined entrypoints, namely: ensure_ownership(), change_ownership(), get_owner(), but not init(), which is a constructor.L7-L11 - The starting point of every test is getting an instance of HostEnv by calling odra_test::env(). Our function returns a triple: a contract ref, an env, and an address (the initial owner). Odra's #[odra::module] attribute implements a odra::host::Deployer for Ownable, and OwnableInitArgs that we pass as the second argument of the odra::host::Deployer::deploy() function. Lastly, the module needs an owner. The easiest way is to take one from the HostEnv. We choose the address of first account (which is the default one). L14 - It is time to define the first test. As you see, it is a regular Rust test.L16-17 - Using the setup() function, we get the owner and a reference (in this test, we don't use the env, so we ignore it). We make a standard assertion, comparing the owner we know with the value returned from the contract. note You may have noticed, we use here the term module interchangeably with contract. The reason is once we deploy our module onto a virtual blockchain it may be considered a contract. L19-25 - On the contract, only the init() function has been called, so we expect one event to have been emitted. To assert that, let's use HostEnv. To get the env, we call env() on the contract, then call HostEnv::emitted_event. As the first argument, pass the contract you want to read events from, followed by an event as you expect it to have occurred.L31 - Because we know the initial owner is the 0th account, we must select a different account. It could be any index from 1 to 19 - the HostEnv predefines 20 accounts.L33 - As mentioned, the default is the 0th account, if you want to change the executor, call the HostEnv::set_caller() function. note The caller switch applies only the next contract interaction, the second call will be done as the default account. L46-55 - If a non-owner account tries to change ownership, we expect it to fail. To capture the error, call HostEnv::try_change_ownership() instead of HostEnv::change_ownership(). HostEnv provides try_ functions for each contract's entrypoint. The try functions return OdraResult (an alias for Result&lt;T, OdraError&gt;) instead of panicking and halting the execution. In our case, we expect the contract to revert with the Error::NotOwner error. To compare the error, we use the Error::into() function, which converts the error into the OdraError type. ","version":"2.0.1","tagName":"h3"},{"title":"Summary​","type":1,"pageTitle":"Ownable","url":"/docs/2.0.1/tutorials/ownable#summary","content":"The Ownable module is ready, and we can test it against any defined backend. Theoretically it can be deployed as a standalone contract, but in upcoming tutorials you will see how to use it to compose a more complex contract. ","version":"2.0.1","tagName":"h2"},{"title":"What's next​","type":1,"pageTitle":"Ownable","url":"/docs/2.0.1/tutorials/ownable#whats-next","content":"In the next tutorial we will implement a ERC20 standard. ","version":"2.0.1","tagName":"h2"},{"title":"OwnedToken","type":0,"sectionRef":"#","url":"/docs/2.0.1/tutorials/owned-token","content":"","keywords":"","version":"2.0.1"},{"title":"Code​","type":1,"pageTitle":"OwnedToken","url":"/docs/2.0.1/tutorials/owned-token#code","content":"What should our module be capable of? Conform the Erc20 interface.Allow only the module owner to mint tokens.Enable the current owner to designate a new owner. ","version":"2.0.1","tagName":"h2"},{"title":"Module definition​","type":1,"pageTitle":"OwnedToken","url":"/docs/2.0.1/tutorials/owned-token#module-definition","content":"Let's define a module called OwnedToken that is a composition of Ownable and Erc20 modules. owned_token.rs use crate::{erc20::Erc20, ownable::Ownable}; use odra::prelude::*; #[odra::module] pub struct OwnedToken { ownable: SubModule&lt;Ownable&gt;, erc20: SubModule&lt;Erc20&gt; }  As you can see, we do not need any storage definition - we just take advantage of the already-defined modules! ","version":"2.0.1","tagName":"h3"},{"title":"Delegation​","type":1,"pageTitle":"OwnedToken","url":"/docs/2.0.1/tutorials/owned-token#delegation","content":"owned_token.rs ... use odra::casper_types::U256; ... #[odra::module] impl OwnedToken { pub fn init(&amp;mut self, name: String, symbol: String, decimals: u8, initial_supply: U256) { let deployer = self.env().caller(); self.ownable.init(deployer); self.erc20.init(name, symbol, decimals, initial_supply); } pub fn name(&amp;self) -&gt; String { self.erc20.name() } pub fn symbol(&amp;self) -&gt; String { self.erc20.symbol() } pub fn decimals(&amp;self) -&gt; u8 { self.erc20.decimals() } pub fn total_supply(&amp;self) -&gt; U256 { self.erc20.total_supply() } pub fn balance_of(&amp;self, address: &amp;Address) -&gt; U256 { self.erc20.balance_of(address) } pub fn allowance(&amp;self, owner: &amp;Address, spender: &amp;Address) -&gt; U256 { self.erc20.allowance(owner, spender) } pub fn transfer(&amp;mut self, recipient: &amp;Address, amount: &amp;U256) { self.erc20.transfer(recipient, amount); } pub fn transfer_from(&amp;mut self, owner: &amp;Address, recipient: &amp;Address, amount: &amp;U256) { self.erc20.transfer_from(owner, recipient, amount); } pub fn approve(&amp;mut self, spender: &amp;Address, amount: &amp;U256) { self.erc20.approve(spender, amount); } pub fn get_owner(&amp;self) -&gt; Address { self.ownable.get_owner() } pub fn change_ownership(&amp;mut self, new_owner: &amp;Address) { self.ownable.change_ownership(new_owner); } pub fn mint(&amp;mut self, address: &amp;Address, amount: &amp;U256) { self.ownable.ensure_ownership(&amp;self.env().caller()); self.erc20.mint(address, amount); } }  Easy. However, there are a few worth mentioning subtleness: L9-L10 - A constructor is an excellent place to initialize both modules at once.L13-L15 - Most of the entrypoints do not need any modification, so we simply delegate them to the erc20 module.L49-L51 - The same is done with the ownable module.L57-L60 - Minting should not be unconditional, we need some control over it. First, using ownable we make sure the caller really is indeed the owner. ","version":"2.0.1","tagName":"h3"},{"title":"Summary​","type":1,"pageTitle":"OwnedToken","url":"/docs/2.0.1/tutorials/owned-token#summary","content":"The Odra Framework encourages a modularized design of your smart contracts. You can encapsulate features in smaller units and test them in isolation, ensuring your project is easy to maintain. Finally, unleash their full potential by combining modules. You do not need any magic bindings for that. ","version":"2.0.1","tagName":"h2"},{"title":"Pausable","type":0,"sectionRef":"#","url":"/docs/2.0.1/tutorials/pauseable","content":"","keywords":"","version":"2.0.1"},{"title":"Code​","type":1,"pageTitle":"Pausable","url":"/docs/2.0.1/tutorials/pauseable#code","content":"As always, we will start with defining functionalities of our module. Check the state - is it paused or not.State guards - a contract should stop execution if is in a state we don't expect.Switch the state. ","version":"2.0.1","tagName":"h2"},{"title":"Events and Error​","type":1,"pageTitle":"Pausable","url":"/docs/2.0.1/tutorials/pauseable#events-and-error","content":"There just two errors that may occur: PausedRequired, UnpausedRequired. We define them in a standard Odra way. Events definition is highly uncomplicated: Paused and Unpaused events holds only the address of the pauser. pauseable.rs use odra::prelude::*; #[odra::odra_error] pub enum Error { PausedRequired = 1_000, UnpausedRequired = 1_001, } #[odra::event] pub struct Paused { pub account: Address } #[odra::event] pub struct Unpaused { pub account: Address }  ","version":"2.0.1","tagName":"h3"},{"title":"Module definition​","type":1,"pageTitle":"Pausable","url":"/docs/2.0.1/tutorials/pauseable#module-definition","content":"The module storage is extremely simple - has a single Var of type bool, that indicates if a contract is paused. pauseable.rs #[odra::module(events = [Paused, Unpaused])] pub struct Pausable { is_paused: Var&lt;bool&gt; }  ","version":"2.0.1","tagName":"h3"},{"title":"Checks and guards​","type":1,"pageTitle":"Pausable","url":"/docs/2.0.1/tutorials/pauseable#checks-and-guards","content":"Now, let's move to state checks and guards. pauseable.rs impl Pausable { pub fn is_paused(&amp;self) -&gt; bool { self.is_paused.get_or_default() } pub fn require_not_paused(&amp;self) { if self.is_paused() { self.env().revert(Error::UnpausedRequired); } } pub fn require_paused(&amp;self) { if !self.is_paused() { self.env().revert(Error::PausedRequired); } } }  L1 - as mentioned in the intro, the module is not intended to be a standalone contract, so the only impl block is not annotated with odra::module and hence does not expose any entrypoint.L2 - is_paused() checks the contract state, if the Var is_paused has not been initialized, the default value (false) is returned.L6 - to guarantee the code is executed when the contract is not paused, require_not_paused() function reads the state and reverts if the contract is paused. L12 - require_paused() is a mirror function - stops the contract execution if the contract is not paused. ","version":"2.0.1","tagName":"h3"},{"title":"Actions​","type":1,"pageTitle":"Pausable","url":"/docs/2.0.1/tutorials/pauseable#actions","content":"Finally, we will add the ability to switch the module state. pauseable.rs impl Pausable { pub fn pause(&amp;mut self) { self.require_not_paused(); self.is_paused.set(true); self.env().emit_event(Paused { account: self.env().caller() }); } pub fn unpause(&amp;mut self) { self.require_paused(); self.is_paused.set(false); self.env().emit_event(Unpaused { account: self.env().caller() }); } }  pause() and unpause() functions do three things: ensure the contract is the right state (unpaused for pause(), not paused for unpause()), updates the state, and finally emits events (Paused/Unpaused). ","version":"2.0.1","tagName":"h3"},{"title":"Pausable counter​","type":1,"pageTitle":"Pausable","url":"/docs/2.0.1/tutorials/pauseable#pausable-counter","content":"In the end, let's use the module in a contract. For this purpose, we will implement a mock contract called PausableCounter. The contract consists of a Var value and a Pausable module. The counter can only be incremented if the contract is in a normal state (is not paused). pauseable.rs ... #[odra::module] pub struct PausableCounter { value: Var&lt;u32&gt;, pauseable: SubModule&lt;Pausable&gt; } #[odra::module] impl PausableCounter { pub fn increment(&amp;mut self) { self.pauseable.require_not_paused(); let new_value = self.value.get_or_default() + 1; self.value.set(new_value); } pub fn pause(&amp;mut self) { self.pauseable.pause(); } pub fn unpause(&amp;mut self) { self.pauseable.unpause(); } pub fn get_value(&amp;self) -&gt; u32 { self.value.get_or_default() } } #[cfg(test)] mod test { use super::*; use odra::host::{Deployer, NoArgs}; #[test] fn increment_only_if_unpaused() { let test_env = odra_test::env(); let mut contract = PausableCounter::deploy(&amp;test_env, NoArgs); contract.increment(); contract.pause(); assert_eq!( contract.try_increment().unwrap_err(), Error::UnpausedRequired.into() ); assert_eq!(contract.get_value(), 1); } }  As we see in the test, in a simple way, using a single function call we can turn off the counter for a while and freeze the counter. Any time we want we can turn it back on. Easy! ","version":"2.0.1","tagName":"h2"},{"title":"Odra framework","type":0,"sectionRef":"#","url":"/docs/2.1.0/","content":"","keywords":"","version":"2.1.0"},{"title":"What's next​","type":1,"pageTitle":"Odra framework","url":"/docs/2.1.0/#whats-next","content":"See the Installation and our Flipper example to find out how to start your new project with Odra. ","version":"2.1.0","tagName":"h2"},{"title":"Attributes","type":0,"sectionRef":"#","url":"/docs/2.1.0/advanced/attributes","content":"","keywords":"","version":"2.1.0"},{"title":"Payable​","type":1,"pageTitle":"Attributes","url":"/docs/2.1.0/advanced/attributes#payable","content":"When writing a smart contract, you need to make sure that money can be both sent to and extracted from the contract. The 'payable' attribute helps wit this. Any function, except for a constructor, with the #[odra(payable)] attribute can send and take money in the form of native tokens. ","version":"2.1.0","tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"Attributes","url":"/docs/2.1.0/advanced/attributes#example","content":"examples/src/contracts/tlw.rs #[odra(payable)] pub fn deposit(&amp;mut self) { // Extract values let caller: Address = self.env().caller(); let amount: U256 = self.env().attached_value(); let current_block_time: u64 = self.env().get_block_time(); // Multiple lock check if self.balances.get(&amp;caller).is_some() { self.env.revert(Error::CannotLockTwice) } // Update state, emit event self.balances.set(&amp;caller, amount); self.lock_expiration_map .set(&amp;caller, current_block_time + self.lock_duration()); self.env() .emit_event(Deposit { address: caller, amount }); }  If you try to send tokens to a non-payable function, the transaction will be automatically rejected. ","version":"2.1.0","tagName":"h3"},{"title":"Non Reentrant​","type":1,"pageTitle":"Attributes","url":"/docs/2.1.0/advanced/attributes#non-reentrant","content":"Reentrancy attacks in smart contracts exploit the possibility of a function being called multiple times before its initial execution is completed, leading to the repeated unauthorized withdrawal of funds. To prevent such attacks, developers should ensure that all effects on the contract's state and balance checks occur before calling external contracts. They can also use reentrancy guards to block recursive calls to sensitive functions. In Odra you can just apply the #[odra(non_reentrant)] attribute to your function. ","version":"2.1.0","tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"Attributes","url":"/docs/2.1.0/advanced/attributes#example-1","content":"#[odra::module] pub struct NonReentrantCounter { counter: Var&lt;u32&gt; } #[odra::module] impl NonReentrantCounter { #[odra(non_reentrant)] pub fn count_ref_recursive(&amp;mut self, n: u32) { if n &gt; 0 { self.count(); ReentrancyMockRef::new(self.env(), self.env().self_address()).count_ref_recursive(n - 1); } } } impl NonReentrantCounter { fn count(&amp;mut self) { let c = self.counter.get_or_default(); self.counter.set(c + 1); } } #[cfg(test)] mod test { use super::*; use odra::host::{Deployer, NoArgs}; #[test] fn ref_recursion_not_allowed() { let test_env = odra_test::env(); let mut contract = NonReentrantCounter::deploy(&amp;test_env, NoArgs); let result = contract.count_ref_recursive(11); assert_eq!(result, ExecutionError::ReentrantCall.into()); } }  ","version":"2.1.0","tagName":"h3"},{"title":"Mixing attributes​","type":1,"pageTitle":"Attributes","url":"/docs/2.1.0/advanced/attributes#mixing-attributes","content":"A function can accept more than one attribute. The only exclusion is a constructor cannot be payable. To apply multiple attributes, you can write: #[odra(payable, non_reentrant)] fn deposit() { // your logic... }  or #[odra(payable)] #[odra(non_reentrant)] fn deposit() { // your logic... }  In both cases attributes order does not matter. ","version":"2.1.0","tagName":"h2"},{"title":"Advanced Storage Concepts","type":0,"sectionRef":"#","url":"/docs/2.1.0/advanced/advanced-storage","content":"","keywords":"","version":"2.1.0"},{"title":"Recap and Basic Concepts​","type":1,"pageTitle":"Advanced Storage Concepts","url":"/docs/2.1.0/advanced/advanced-storage#recap-and-basic-concepts","content":"Before we delve into the advanced features, let's recap some basic storage concepts in Odra. In the realm of basic storage interaction, Odra provides several types for interacting with contract storage, including Var, Mapping, and List. These types enable contracts to store and retrieve data in a structured manner. The Var type is used to store a single value, while the List and Mapping types store collections of values. Var: A Var in Odra is a fundamental building block used for storing single values. Each Var is uniquely identified by its name in the contract. Mapping: Mapping in Odra serves as a key-value storage system. It stores an association of unique keys to values, and the value can be retrieved using the key. List: Built on top of the Var and Mapping building blocks, List in Odra allows storing an ordered collection of values that can be iterated over. If you need a refresher on these topics, please refer to our guide on basic storage in Odra. ","version":"2.1.0","tagName":"h2"},{"title":"Advanced Storage Concepts​","type":1,"pageTitle":"Advanced Storage Concepts","url":"/docs/2.1.0/advanced/advanced-storage#advanced-storage-concepts-1","content":"","version":"2.1.0","tagName":"h2"},{"title":"Sequence​","type":1,"pageTitle":"Advanced Storage Concepts","url":"/docs/2.1.0/advanced/advanced-storage#sequence","content":"The Sequence in Odra is a basic module that stores a single value in the storage that can be read or incremented. Internally, holds a Var which keeps track of the current value. pub struct Sequence&lt;T&gt; where T: Num + One + ToBytes + FromBytes + CLTyped { value: Var&lt;T&gt; }  The Sequence module provides functions get_current_value and next_value to get the current value and increment the value respectively. ","version":"2.1.0","tagName":"h3"},{"title":"Advanced Mapping​","type":1,"pageTitle":"Advanced Storage Concepts","url":"/docs/2.1.0/advanced/advanced-storage#advanced-mapping","content":"In Odra, a Mapping is a key-value storage system where the key is associated with a value. In previous examples, the value of the Mapping typically comprised a standard serializable type (such as number, string, or bool) or a custom type marked with the #[odra::odra_type] attribute. However, there are more advanced scenarios where the value of the Mapping represents a module itself. This approach is beneficial when managing a collection of modules, each maintaining its unique state. Let's consider the following example: examples/src/features/storage/mapping.rs use odra::casper_types::U256; use odra::prelude::*; use crate::owned_token::OwnedToken; #[odra::module] pub struct Mappings { strings: Mapping&lt;(String, u32, String), String&gt;, tokens: Mapping&lt;String, OwnedToken&gt; } #[odra::module] impl Mappings { ... pub fn total_supply(&amp;mut self, token_name: String) -&gt; U256 { self.tokens.module(&amp;token_name).total_supply() } pub fn get_string_api( &amp;self, key1: String, key2: u32, key3: String ) -&gt; String { let opt_string = self.strings.get(&amp;(key1, key2, key3)); opt_string.unwrap_or_revert(&amp;self.env()) } }  As you can see, a Mapping key can consist of a tuple of values, not limited to a single value. note Accessing Odra modules differs from accessing regular values such as strings or numbers. Firstly, within a Mapping, you don't encapsulate the module with Submodule. Secondly, rather than utilizing the Mapping::get() function, call Mapping::module(), which returns SubModule&lt;T&gt; and sets the appropriate namespace for nested modules. ","version":"2.1.0","tagName":"h3"},{"title":"AdvancedStorage Contract​","type":1,"pageTitle":"Advanced Storage Concepts","url":"/docs/2.1.0/advanced/advanced-storage#advancedstorage-contract","content":"The given code snippet showcases the AdvancedStorage contract that incorporates these storage concepts. use odra::casper_types::U512; use odra::prelude::*; use crate::modules::Token; #[odra::module] pub struct AdvancedStorage { counter: Sequence&lt;u32&gt;, tokens: Mapping&lt;(String, String), Token&gt;, } impl AdvancedStorage { pub fn current_value(&amp;self) -&gt; u32 { self.counter.get_current_value() } pub fn increment_and_get(&amp;mut self) -&gt; u32 { self.counter.next_value() } pub fn balance_of(&amp;mut self, token_name: String, creator: String, address: Address) -&gt; U512 { let token = self.tokens.module(&amp;(token_name, creator)); token.balance_of(&amp;address) } pub fn mint(&amp;self, token_name: String, creator: String, amount: U512, to: Address) { let mut token = self.tokens.module(&amp;(token_name, creator)); token.mint(amount, to); } }  ","version":"2.1.0","tagName":"h2"},{"title":"Conclusion​","type":1,"pageTitle":"Advanced Storage Concepts","url":"/docs/2.1.0/advanced/advanced-storage#conclusion","content":"Advanced storage features in Odra offer robust options for managing contract state. Two key takeaways from this document are: Odra offers a Sequence module, enabling contracts to store and increment a single value.Mappings support composite keys expressed as tuples and can store modules as values. Understanding these concepts can help developers design and implement more efficient and flexible smart contracts. ","version":"2.1.0","tagName":"h2"},{"title":"Building contracts manually","type":0,"sectionRef":"#","url":"/docs/2.1.0/advanced/building-manually","content":"","keywords":"","version":"2.1.0"},{"title":"Building the contract manually​","type":1,"pageTitle":"Building contracts manually","url":"/docs/2.1.0/advanced/building-manually#building-the-contract-manually","content":"To build the contract manually, cargo odra uses the following command: ODRA_MODULE=my_contract cargo build --release --target wasm32-unknown-unknown --bin my_project_build_contract  info Odra uses the environment variable ODRA_MODULE to determine which contract to build. Assuming that project's crate is named my_project, this command will build the my_contract contract in release mode and generate the wasm file. The file will be put into the target/wasm32-unknown-unknown/release directory under the name my_project_build_contract.wasm. The Odra Framework expects the contracts to be placed in the wasm directory, and to be named correctly, so the next step would be to move the file: mv target/wasm32-unknown-unknown/release/my_project_build_contract.wasm wasm/my_contract.wasm  ","version":"2.1.0","tagName":"h2"},{"title":"Optimizing the contract​","type":1,"pageTitle":"Building contracts manually","url":"/docs/2.1.0/advanced/building-manually#optimizing-the-contract","content":"To lower the size of the wasm file, cargo odra uses the wasm-strip tool: wasm-strip wasm/my_contract.wasm  To further optimize the wasm file, the wasm-opt tool is also used. wasm-opt --signext-lowering wasm/my_contract.wasm -o wasm/my_contract.wasm  danger This step is required, as the wasm file generated by the Rust compiler is not fully compatible with the Casper execution engine. ","version":"2.1.0","tagName":"h2"},{"title":"Running the tests manually​","type":1,"pageTitle":"Building contracts manually","url":"/docs/2.1.0/advanced/building-manually#running-the-tests-manually","content":"To run the tests manually, Odra needs to know which backend to use. To run tests against Casper backend, the following command needs to be used: ODRA_BACKEND=casper cargo test  ","version":"2.1.0","tagName":"h2"},{"title":"Wrapping up​","type":1,"pageTitle":"Building contracts manually","url":"/docs/2.1.0/advanced/building-manually#wrapping-up","content":"Let's say we want to build the my_contract in debug mode, run the tests against the casper backend and use the my-own-allocator feature from our my_project project. To do that, we can use the following set of commands: ODRA_MODULE=my_contract cargo build --target wasm32-unknown-unknown --bin my_project_build_contract mv target/wasm32-unknown-unknown/debug/my_project_build_contract.wasm wasm/my_contract.wasm wasm-strip wasm/my_contract.wasm wasm-opt --signext-lowering wasm/my_contract.wasm -o wasm/my_contract.wasm ODRA_BACKEND=casper cargo test --features my-own-allocator  ","version":"2.1.0","tagName":"h2"},{"title":"Using Proxy Caller","type":0,"sectionRef":"#","url":"/docs/2.0.1/tutorials/using-proxy-caller","content":"","keywords":"","version":"2.0.1"},{"title":"Contract​","type":1,"pageTitle":"Using Proxy Caller","url":"/docs/2.0.1/tutorials/using-proxy-caller#contract","content":"For this tutorial, we will use the TimeLockWallet contract from our examples. examples/src/contracts/tlw.rs use odra::prelude::*; use odra::casper_types::U512; #[odra::module(errors = Error, events = [Deposit, Withdrawal])] pub struct TimeLockWallet { balances: Mapping&lt;Address, U512&gt;, lock_expiration_map: Mapping&lt;Address, u64&gt;, lock_duration: Var&lt;u64&gt; } #[odra::module] impl TimeLockWallet { /// Initializes the contract with the lock duration. pub fn init(&amp;mut self, lock_duration: u64) { self.lock_duration.set(lock_duration); } /// Deposits the tokens into the contract. #[odra(payable)] pub fn deposit(&amp;mut self) { // Extract values let caller: Address = self.env().caller(); let amount: U512 = self.env().attached_value(); let current_block_time: u64 = self.env().get_block_time(); // Multiple lock check if self.balances.get(&amp;caller).is_some() { self.env().revert(Error::CannotLockTwice) } // Update state, emit event self.balances.set(&amp;caller, amount); self.lock_expiration_map .set(&amp;caller, current_block_time + self.lock_duration()); self.env().emit_event(Deposit { address: caller, amount }); } /// Withdraws the tokens from the contract. pub fn withdraw(&amp;mut self, amount: &amp;U512) { // code omitted for brevity } /// Returns the balance of the given account. pub fn get_balance(&amp;self, address: &amp;Address) -&gt; U512 { // code omitted for brevity } /// Returns the lock duration. pub fn lock_duration(&amp;self) -&gt; u64 { // code omitted for brevity } } /// Errors that may occur during the contract execution. #[odra::odra_error] pub enum Error { LockIsNotOver = 1, CannotLockTwice = 2, InsufficientBalance = 3 } /// Deposit event. #[odra::event] pub struct Deposit { pub address: Address, pub amount: U512 } /// Withdrawal event. #[odra::event] pub struct Withdrawal { pub address: Address, pub amount: U512 }  Full code can be found here. ","version":"2.0.1","tagName":"h2"},{"title":"Client​","type":1,"pageTitle":"Using Proxy Caller","url":"/docs/2.0.1/tutorials/using-proxy-caller#client","content":"Before we can interact with the node, we need to set it up. We will use the casper-nctl-docker image. docker run --rm -it --name mynctl -d -p 11101:11101 -p 14101:14101 -p 18101:18101 makesoftware/casper-nctl  Make sure you have the contract's wasm file and the secret key. # Build the contract cargo odra build -c TimeLockWallet # Extract secret key docker exec mynctl /bin/bash -c &quot;cat /home/casper/casper-node/utils/nctl/assets/net-1/users/user-1/secret_key.pem&quot; &gt; your/path/secret_key.pem  RustTypeScript To interact with the contract, we use the livenet backend. It allows to write the code in the same manner as the test code, but it interacts with the live network (a local node in our case). Cargo.toml [package] name = &quot;odra-examples&quot; version = &quot;1.4.0&quot; edition = &quot;2021&quot; [dependencies] odra = { path = &quot;../odra&quot;, default-features = false } ... # other dependencies odra-casper-livenet-env = { version = &quot;1.4.0&quot;, optional = true } ... # other sections [features] default = [] livenet = [&quot;odra-casper-livenet-env&quot;] ... # other sections [[bin]] name = &quot;tlw_on_livenet&quot; path = &quot;bin/tlw_on_livenet.rs&quot; required-features = [&quot;livenet&quot;] test = false ... # other sections examples/bin/tlw_on_livenet.rs //! Deploys an [odra_examples::contracts::tlw::TimeLockWallet] contract, then deposits and withdraw some CSPRs. use odra::casper_types::{AsymmetricType, PublicKey, U512}; use odra::host::{Deployer, HostRef}; use odra::prelude::*; use odra_examples::contracts::tlw::{TimeLockWallet, TimeLockWalletInitArgs}; const DEPOSIT: u64 = 100; const WITHDRAWAL: u64 = 99; const GAS: u64 = 20u64.pow(9); fn main() { let env = odra_casper_livenet_env::env(); let caller = env.get_account(0); env.set_caller(caller); env.set_gas(GAS); let mut contract = TimeLockWallet::deploy( &amp;env, TimeLockWalletInitArgs { lock_duration: 60 * 60 } ); // Send 100 CSPRs to the contract. contract .with_tokens(U512::from(DEPOSIT)) .deposit(); println!(&quot;Caller's balance: {:?}&quot;, contract.get_balance(&amp;caller)); // Withdraw 99 CSPRs from the contract. contract.withdraw(&amp;U512::from(WITHDRAWAL)); println!(&quot;Remaining balance: {:?}&quot;, contract.get_balance(&amp;caller)); } To run the code, execute the following command: ODRA_CASPER_LIVENET_SECRET_KEY_PATH=.node-keys/secret_key.pem \\ ODRA_CASPER_LIVENET_NODE_ADDRESS=http://localhost:11101 \\ ODRA_CASPER_LIVENET_CHAIN_NAME=casper-net-1 \\ cargo run --bin tlw_on_livenet --features=livenet # Sample output 💁 INFO : Deploying &quot;TimeLockWallet&quot;. 💁 INFO : Found wasm under &quot;wasm/TimeLockWallet.wasm&quot;. 🙄 WAIT : Waiting 15s for &quot;74f0df4bc65cdf9e05bca70a8b786bd0f528858f26e11f5a9866dfe286551558&quot;. 💁 INFO : Deploy &quot;74f0df4bc65cdf9e05bca70a8b786bd0f528858f26e11f5a9866dfe286551558&quot; successfully executed. 💁 INFO : Contract &quot;hash-cce6a97e0db6feea0c4d99f670196c9462e0789fb3cdedd3dfbc6dfcbf66252e&quot; deployed. 💁 INFO : Calling &quot;hash-cce6a97e0db6feea0c4d99f670196c9462e0789fb3cdedd3dfbc6dfcbf66252e&quot; with entrypoint &quot;deposit&quot; through proxy. 🙄 WAIT : Waiting 15s for &quot;bd571ab64c13d2b2fdb8e0e6dd8473b696349dfb5a891b55dbe9f33d017057d3&quot;. 💁 INFO : Deploy &quot;bd571ab64c13d2b2fdb8e0e6dd8473b696349dfb5a891b55dbe9f33d017057d3&quot; successfully executed. Caller's balance: 100 💁 INFO : Calling &quot;hash-cce6a97e0db6feea0c4d99f670196c9462e0789fb3cdedd3dfbc6dfcbf66252e&quot; with entrypoint &quot;withdraw&quot;. 🙄 WAIT : Waiting 15s for &quot;57f9aadbd77cbfbbe9b2ba54759d025f94203f9230121289fa37585f8b17020e&quot;. 💁 INFO : Deploy &quot;57f9aadbd77cbfbbe9b2ba54759d025f94203f9230121289fa37585f8b17020e&quot; successfully executed. Remaining balance: 1 As observed, the contract was successfully deployed, and the Caller deposited tokens. Subsequently, the caller withdrew 99 CSPRs from the contract, leaving the contract's balance at 1 CSPR. The logs display deploy hashes, the contract's hash, and even indicate if the call was made through the proxy, providing a comprehensive overview of the on-chain activity. ","version":"2.0.1","tagName":"h2"},{"title":"Conclusion​","type":1,"pageTitle":"Using Proxy Caller","url":"/docs/2.0.1/tutorials/using-proxy-caller#conclusion","content":"In this tutorial, we learned how to use the proxy_caller wasm to make a payable function call. We deployed the TimeLockWallet contract, deposited tokens using the proxy_caller with attached CSPRs, and withdrew them. You got to try it out in both Rust and TypeScript, so you can choose whichever you prefer. Rust code seemed simpler, thanks to the Odra livenet backend making chain interactions easier to handle. ","version":"2.0.1","tagName":"h2"},{"title":"Delegate","type":0,"sectionRef":"#","url":"/docs/2.1.0/advanced/delegate","content":"","keywords":"","version":"2.1.0"},{"title":"Overview​","type":1,"pageTitle":"Delegate","url":"/docs/2.1.0/advanced/delegate#overview","content":"To utilize the delegate feature in your contract, use the delegate! macro provided by Odra. This macro allows you to list the functions you wish to delegate to the child modules. By using the delegate! macro, your parent module remains clean and easy to understand. You can delegate functions to as many child modules as you like. The functions will be available as if they were implemented in the parent module itself. ","version":"2.1.0","tagName":"h2"},{"title":"Code Examples​","type":1,"pageTitle":"Delegate","url":"/docs/2.1.0/advanced/delegate#code-examples","content":"Consider the following basic example for better understanding: use crate::{erc20::Erc20, ownable::Ownable}; use odra::{casper_types::U256, prelude::*}; #[odra::module] pub struct OwnedToken { ownable: SubModule&lt;Ownable&gt;, erc20: SubModule&lt;Erc20&gt; } #[odra::module] impl OwnedToken { pub fn init(&amp;mut self, name: String, symbol: String, decimals: u8, initial_supply: U256) { let deployer = self.env().caller(); self.ownable.init(deployer); self.erc20.init(name, symbol, decimals, initial_supply); } delegate! { to self.erc20 { fn transfer(&amp;mut self, recipient: Address, amount: U256); fn transfer_from(&amp;mut self, owner: Address, recipient: Address, amount: U256); fn approve(&amp;mut self, spender: Address, amount: U256); fn name(&amp;self) -&gt; String; fn symbol(&amp;self) -&gt; String; fn decimals(&amp;self) -&gt; u8; fn total_supply(&amp;self) -&gt; U256; fn balance_of(&amp;self, owner: Address) -&gt; U256; fn allowance(&amp;self, owner: Address, spender: Address) -&gt; U256; } to self.ownable { fn get_owner(&amp;self) -&gt; Address; fn change_ownership(&amp;mut self, new_owner: Address); } } pub fn mint(&amp;mut self, address: Address, amount: U256) { self.ownable.ensure_ownership(self.env().caller()); self.erc20.mint(address, amount); } }  This OwnedToken contract includes two modules: Erc20 and Ownable. We delegate various functions from both modules using the delegate! macro. As a result, the contract retains its succinctness without compromising on functionality. The above example basically merges the functionalities of modules and adds some control over the minting process. But you can use delegation to build more complex contracts, cherry-picking just a few module functionalities. Let's take a look at another example. use crate::{erc20::Erc20, ownable::Ownable, exchange::Exchange}; use odra::{casper_types::U256, prelude::*}; #[odra::module] pub struct DeFiPlatform { ownable: SubModule&lt;Ownable&gt;, erc20: SubModule&lt;Erc20&gt;, exchange: SubModule&lt;Exchange&gt; } #[odra::module] impl DeFiPlatform { pub fn init(&amp;mut self, name: String, symbol: String, decimals: u8, initial_supply: U256, exchange_rate: u64) { let deployer = self.env().caller(); self.ownable.init(deployer); self.erc20.init(name, symbol, decimals, initial_supply); self.exchange.init(exchange_rate); } delegate! { to self.erc20 { fn transfer(&amp;mut self, recipient: Address, amount: U256); fn balance_of(&amp;self, owner: Address) -&gt; U256; } to self.ownable { fn get_owner(&amp;self) -&gt; Address; } to self.exchange { fn swap(&amp;mut self, sender: Address, recipient: Address); fn set_exchange_rate(&amp;mut self, new_rate: u64); } } pub fn mint(&amp;mut self, address: Address, amount: U256) { self.ownable.ensure_ownership(self.env().caller()); self.erc20.mint(address, amount); } }  In this DeFiPlatform contract, we include Erc20, Ownable, and Exchange modules. By delegating functions from these modules, the parent contract becomes a powerhouse of functionality while retaining its readability and structure. Remember, the possibilities are endless with Odra's. By leveraging this feature, you can write cleaner, more efficient, and modular smart contracts. ","version":"2.1.0","tagName":"h2"},{"title":"Signatures","type":0,"sectionRef":"#","url":"/docs/2.1.0/advanced/signatures","content":"","keywords":"","version":"2.1.0"},{"title":"Signature verification​","type":1,"pageTitle":"Signatures","url":"/docs/2.1.0/advanced/signatures#signature-verification","content":"Signature verification is conducted by a function in contract's env(): pub fn verify_signature(message: &amp;Bytes, signature: &amp;Bytes, public_key: &amp;PublicKey) -&gt; bool;  Here's the simplest example of this function used in a contract: examples/src/features/signature_verifier.rs #[odra::module] impl SignatureVerifier { pub fn verify_signature( &amp;self, message: &amp;Bytes, signature: &amp;Bytes, public_key: &amp;PublicKey ) -&gt; bool { self.env().verify_signature(message, signature, public_key) } }  ","version":"2.1.0","tagName":"h2"},{"title":"Testing​","type":1,"pageTitle":"Signatures","url":"/docs/2.1.0/advanced/signatures#testing","content":"Besides the above function in the contract context, Odra provides corresponding functions in the HostEnv: pub fn sign_message(message: &amp;Bytes, address: &amp;Address) -&gt; Bytes; pub fn public_key(address: &amp;Address) -&gt; PublicKey;  sign_message will return a signed message. The signing itself will be performed using a private key of an account behind the address. public_key returns the PublicKey of an address account. Here's a complete example of how to test the signature verification in the contract: examples/src/features/signature_verifier.rs #[test] fn signature_verification_works() { let test_env = odra_test::env(); let message = &quot;Message to be signed&quot;; let message_bytes = Bytes::from(message.as_bytes()); let account = test_env.get_account(0); let signature = test_env.sign_message(&amp;message_bytes, &amp;account); let public_key = test_env.public_key(&amp;account); let signature_verifier = SignatureVerifier::deploy(&amp;test_env, NoArgs); assert!(signature_verifier.verify_signature(&amp;message_bytes, &amp;signature, &amp;public_key)); }  If you want, you can also test signatures created outside Odra: examples/src/features/signature_verifier.rs #[test] fn verify_signature_casper_wallet() { // Casper Wallet for the message &quot;Ahoj przygodo!&quot; signed using SECP256K1 key // produces the following signature: // 1e87e186238fa1df9c222b387a79910388c6ef56285924c7e4f6d7e77ed1d6c61815312cf66a5318db204c693b79e020b1d392dafe8c1b3841e1f6b4c41ca0fa // Casper Wallet adds &quot;Casper Message:\\n&quot; prefix to the message: let message = &quot;Casper Message:\\nAhoj przygodo!&quot;; let message_bytes = Bytes::from(message.as_bytes()); // Depending on the type of the key, we need to prefix the signature with a tag: // 0x01 for ED25519 // 0x02 for SECP256K1 let signature_hex = &quot;021e87e186238fa1df9c222b387a79910388c6ef56285924c7e4f6d7e77ed1d6c61815312cf66a5318db204c693b79e020b1d392dafe8c1b3841e1f6b4c41ca0fa&quot;; let signature: [u8; 65] = hex::decode(signature_hex).unwrap().try_into().unwrap(); let signature_bytes = Bytes::from(signature.as_slice()); // Similar to the above, the public key is tagged: let public_key_hex = &quot;02036d9b880e44254afaf34330e57703a63aec53b5918d4470059b67a4a906350105&quot;; let public_key_decoded = hex::decode(public_key_hex).unwrap(); let (public_key, _) = PublicKey::from_bytes(public_key_decoded.as_slice()).unwrap(); let signature_verifier = SignatureVerifier::deploy(&amp;odra_test::env(), NoArgs); assert!(signature_verifier.verify_signature(&amp;message_bytes, &amp;signature_bytes, &amp;public_key)); }  ","version":"2.1.0","tagName":"h2"},{"title":"Delegating CSPR to Validators","type":0,"sectionRef":"#","url":"/docs/2.1.0/advanced/delegating-cspr","content":"","keywords":"","version":"2.1.0"},{"title":"Sample implementation​","type":1,"pageTitle":"Delegating CSPR to Validators","url":"/docs/2.1.0/advanced/delegating-cspr#sample-implementation","content":"The following code shows how to implement a simple contract that allows delegating CSPR tokens to a validator. examples/src/features/validators.rs use odra::{ casper_types::{PublicKey, U512}, prelude::* }; #[odra::module] pub struct ValidatorsContract { /// In this variable we store the validator's public key, this is the only way we can identify the validator validator: Var&lt;PublicKey&gt; } /// Implementation of the TestingContract #[odra::module] impl ValidatorsContract { /// Initializes the contract with the validator's public key pub fn init(&amp;mut self, validator: PublicKey) { self.validator.set(validator); } /// Stake the amount of tokens #[odra(payable)] pub fn stake(&amp;mut self) { // Get the amount of tokens attached to the call let amount = self.env().attached_value(); if amount.is_zero() { self.env().revert(ValError::InsufficientBalance); } // Use the ContractEnv's delegate method to delegate the tokens to the validator self.env().delegate(self.validator.get().unwrap(), amount); } /// Undelegate the amount from the validator pub fn unstake(&amp;mut self, amount: U512) { self.env().undelegate(self.validator.get().unwrap(), amount); } /// Withdraw the amount from the validator pub fn withdraw(&amp;mut self, amount: U512) { self.env().transfer_tokens(&amp;self.env().caller(), &amp;amount); } ... }  ","version":"2.1.0","tagName":"h2"},{"title":"Explanation​","type":1,"pageTitle":"Delegating CSPR to Validators","url":"/docs/2.1.0/advanced/delegating-cspr#explanation","content":"The above example can be a good starting point for implementing a liquid staking solution. The main things to remember are the new api methods in ContractEnv: pub fn delegate(&amp;self, validator: PublicKey, amount: U512); pub fn undelegate(&amp;self, validator: PublicKey, amount: U512); pub fn delegated_amount(&amp;self, validator: PublicKey) -&gt; U512;  As you can see, we identify the validator by its public key. Funds delegated to the validator are assigned to the calling contract. Remember, that the delegation and undelegation takes some time, depending on the configuration of the blockchain - it's not instant. For example in the Casper mainnet, the delegation takes 1 era and the undelegation takes 7 eras. ","version":"2.1.0","tagName":"h2"},{"title":"Testing​","type":1,"pageTitle":"Delegating CSPR to Validators","url":"/docs/2.1.0/advanced/delegating-cspr#testing","content":"It is possible to test the delegation and undelegation of tokens in the contract. The following code shows how to do it: examples/src/features/validators.rs ... let test_env = odra_test::env(); let auction_delay = test_env.auction_delay(); let unbonding_delay = test_env.unbonding_delay(); test_env.set_caller(test_env.get_account(0)); let mut staking = ValidatorsContract::deploy( &amp;test_env, ValidatorsContractInitArgs { validator: test_env.get_validator(0) } ); let initial_account_balance = test_env.balance_of(&amp;test_env.get_account(0)); // Stake some amount let staking_amount = U512::from(1_000_000_000_000u64); staking.with_tokens(staking_amount).stake(); assert_eq!(staking.currently_delegated_amount(), staking_amount); assert_eq!( test_env.balance_of(&amp;test_env.get_account(0)), initial_account_balance - staking_amount ); // Advance time, run auctions and give off rewards test_env.advance_with_auctions(auction_delay * 2); // Check that the amount is greater than the staking amount let staking_with_reward = staking.currently_delegated_amount(); assert!(staking_with_reward &gt; staking_amount); ...  You can see, that we use the new methods from HostEnv, namely:  fn advance_with_auctions(&amp;self, time_diff: u64); fn auction_delay(&amp;self) -&gt; u64; fn unbonding_delay(&amp;self) -&gt; u64; fn delegated_amount(&amp;self, delegator: Address, validator: PublicKey) -&gt; U512;  advance_with_auctions works in a similar way to advance_block_time, but it also runs the auctions and gives off rewards. The auction_delay and unbonding_delay methods return the values of the auction and unbonding delays specific to the network or backend. We used currently_delegated_amount in the example, it uses delegated_amount method from ContractEnv, but it is also possible to query this information from the HostEnv using delegated_amount method. ","version":"2.1.0","tagName":"h2"},{"title":"Memory allocators","type":0,"sectionRef":"#","url":"/docs/2.1.0/advanced/using-different-allocator","content":"","keywords":"","version":"2.1.0"},{"title":"Using a different allocator​","type":1,"pageTitle":"Memory allocators","url":"/docs/2.1.0/advanced/using-different-allocator#using-a-different-allocator","content":"If the default allocator does not suit your needs, or you use a crate that already provides an allocator, you can disable the default allocator by enabling the disable-allocator feature in the odra dependency in your project: [dependencies] odra = { path = &quot;../odra&quot;, features = [&quot;disable-allocator&quot;] }  If you want to have a better control over the features that are enabled during the building and tests, see the next article on building manually. ","version":"2.1.0","tagName":"h2"},{"title":"Storage Layout","type":0,"sectionRef":"#","url":"/docs/2.1.0/advanced/storage-layout","content":"","keywords":"","version":"2.1.0"},{"title":"Casper VM Perspective​","type":1,"pageTitle":"Storage Layout","url":"/docs/2.1.0/advanced/storage-layout#casper-vm-perspective","content":"The Casper Execution Engine (VM) enables the storage of data in named keys or dictionaries. However, a smart contract has a limited number of named keys, making it unsuitable for storing substantial data volumes. Odra resolves this issue by storing all user-generated data in a dictionary called state. This dictionary operates as a key-value store, where keys are strings with a maximum length of 64 characters, and values are arbitrary byte arrays. Here is an example of what the interface for reading and writing data could look like: pub trait CasperStorage { fn read(key: &amp;str) -&gt; Option&lt;Vec&lt;u8&gt;&gt;; fn write(key: &amp;str, value: Vec&lt;u8&gt;); }  ","version":"2.1.0","tagName":"h2"},{"title":"Odra Perspective​","type":1,"pageTitle":"Storage Layout","url":"/docs/2.1.0/advanced/storage-layout#odra-perspective","content":"Odra was conceived with modularity and code reusability in mind. Additionally, we aimed to streamline storage definition through the struct object. Consider this straightforward storage definition: #[odra::module] pub struct Token { name: Var&lt;String&gt;, balances: Mapping&lt;Address, U256&gt; }  The Token structure contains two fields: name of type String andbalances, which functions as a key-value store with Address as keys andU256 as values. The Token module can be reused in another module, as demonstrated in a more complex example: #[odra::module] pub struct Loans { lenders: SubModule&lt;Token&gt;, borrowers: SubModule&lt;Token&gt;, }  The Loans module has two fields: lenders and borrowers, both of which have the same storage layout as defined by the Token module. Odra guarantees thatlenders and borrowers are stored under distinct keys within the storage dictionary. Both Token and Loans serve as examples to show how Odra's storage layout operates. ","version":"2.1.0","tagName":"h2"},{"title":"Key generation.​","type":1,"pageTitle":"Storage Layout","url":"/docs/2.1.0/advanced/storage-layout#key-generation","content":"Every element of a module (struct) with N elements is associated with an index ranging from 0 to N-1, represented as a u8 with a maximum of 256 elements. If an element of a module is another module (SubModule&lt;...&gt;), the associated index serves as a prefix for the indexes of the inner module. While this may initially appear complex, it is easily understood through an example. In the example, indexes are presented as bytes, reflecting the actual implementation. Loans { lenders: Token { // prefix: 0x0001 name: 1, // key: 0x0001_0001 balances: 2 // key: 0x0001_0010 }, borrowers: Token { // prefix: 0x0010 name: 1, // key: 0x0010_0001 balances: 2 // key: 0x0010_0010 } }  Additionally, it's worth mentioning how Mapping's keys are used in thestorage. They are simply concatenated with the index of the module, as demonstrated in the example. For instance, triggering borrowers.balances.get(0x1234abcd) would result in a key: 0x0001_0001_1234_abcd  Finally, the key must be hashed to fit within the 64-character limit and then encoded in hexadecimal format. ","version":"2.1.0","tagName":"h2"},{"title":"Value serialization​","type":1,"pageTitle":"Storage Layout","url":"/docs/2.1.0/advanced/storage-layout#value-serialization","content":"Before being stored in the storage, each value is serialized into bytes using the CLType serialization method and subsequently encapsulated with Casper'sBytes types. ","version":"2.1.0","tagName":"h2"},{"title":"OdraVM","type":0,"sectionRef":"#","url":"/docs/2.1.0/backends/odra-vm","content":"","keywords":"","version":"2.1.0"},{"title":"Usage​","type":1,"pageTitle":"OdraVM","url":"/docs/2.1.0/backends/odra-vm#usage","content":"The OdraVM is the default backend for Odra framework, so each time you run cargo odra test  You are running your code against it. ","version":"2.1.0","tagName":"h2"},{"title":"Architecture​","type":1,"pageTitle":"OdraVM","url":"/docs/2.1.0/backends/odra-vm#architecture","content":"OdraVM consists of two main parts: the Contract Register and the State. The Contract Register is a list of contracts deployed onto the OdraVM, identified by an Address. Contracts and Test Env functions can modify the State of the OdraVM. Contrary to the &quot;real&quot; backend, which holds the whole history of the blockchain, the OdraVM State holds only the current state of the OdraVM. Thanks to this and the fact that we do not need the blockchain itself, OdraVM starts instantly and runs the tests in the native speed. ","version":"2.1.0","tagName":"h2"},{"title":"Execution​","type":1,"pageTitle":"OdraVM","url":"/docs/2.1.0/backends/odra-vm#execution","content":"When the OdraVM backend is enabled, the #[odra::module] attribute is responsible for converting your pub functions into a list of Entrypoints, which are put into a Contract Container. When the contract is deployed, its Container registered into a Registry under an address. During the contract call, OdraVM finds an Entrypoint and executes the code. ","version":"2.1.0","tagName":"h2"},{"title":"Casper","type":0,"sectionRef":"#","url":"/docs/2.1.0/backends/casper","content":"","keywords":"","version":"2.1.0"},{"title":"Contract Env​","type":1,"pageTitle":"Casper","url":"/docs/2.1.0/backends/casper#contract-env","content":"As with any other backend, Casper Backend must implement the same features, but some do not have native support. Let's take a closer look at how Odra overcomes these hindrances. ","version":"2.1.0","tagName":"h2"},{"title":"Events​","type":1,"pageTitle":"Casper","url":"/docs/2.1.0/backends/casper#events","content":"An event is not a first-class citizen in Casper like in Ethereum, so Odra mimics it. As you've already learned from the events article, in Odra you emit an event, similarly, you would do it in Solidity. Under the hood, Odra integrates with Casper Event Standard and creates a few URefs in the global state when a contract is being installed: __events - a dictionary that stores events' data.__events_length - the evens count.__events_ces_version - the version of Casper Event Standard. __events_schema - a dictionary that stores event schemas. Besides that, all the events the contract emits are registered - events schemas are written to the storage under the __events_schema key. So, Events are nothing different from any other data stored by a contract. A struct to be an event must implement traits defined by Casper Event Standard, thankfully you can derive them using #[odra::event]. note Don't forget to expose events in the module using #[odra::module(events = [...])]. ","version":"2.1.0","tagName":"h3"},{"title":"Payable​","type":1,"pageTitle":"Casper","url":"/docs/2.1.0/backends/casper#payable","content":"The first Odra idiom is a Contract Main Purse. It is a purse associated with a contract. The purse is created lazily - when the first transfer to the contract occurs, a proper URef and a purse are created and stored under the __contract_main_purse key. Casper does not allow direct transfers from an account to a contract, so Odra comes up with the second idiom - a Cargo Purse. It is a one-time-use purse proxy between an account and a contract. First, motes go from the account to the cargo purse and then to the contract's main purse. Behind the scenes, Odra handles an account-contract transfer via a cargo purse when a function is marked as payable. If under the way something goes wrong with the transfer, the contract reverts. The transferred amount can be read inside the contract by calling self.env().attached_value(). note Odra expects the cargo_purse runtime argument to be attached to a contract call. In case of its absence, the contract_env::attached_value() returns zero. ","version":"2.1.0","tagName":"h3"},{"title":"Revert​","type":1,"pageTitle":"Casper","url":"/docs/2.1.0/backends/casper#revert","content":"In Casper, we can stop the execution pretty straightforwardly - call the runtime::revert(). Odra adds an extra abstraction layer - in a contract ExecutionErrors are defined, which ultimately are transformed into Casper's ApiError::User. ","version":"2.1.0","tagName":"h3"},{"title":"Context​","type":1,"pageTitle":"Casper","url":"/docs/2.1.0/backends/casper#context","content":"Casper equips developers with very low-level tooling, which can be cumbersome for newcomers. If you want to check who called the contract or its address, you can not do it off-hand - you must analyze the call stack. The self.env().self_address() function takes the first element of the callstack (runtime::get_call_stack()) and casts it to Address. The self.env().caller() function takes the second element of the call stack (runtime::get_call_stack()) and casts it to Address. As mentioned in the [Payable] section, to store CSPR, each contract creates its purse. To read the contract balance, you call self.env().self_balance(), which checks the balance of the purse stored under __contract_main_purse. ","version":"2.1.0","tagName":"h3"},{"title":"Test Env​","type":1,"pageTitle":"Casper","url":"/docs/2.1.0/backends/casper#test-env","content":"Test environment allows you to test wasm contracts before you deploy them onto the testnet or livenet. It is built on top of the Casper Execution Engine. In your test, you can freely switch execution context by setting as a caller (test_env::set_caller()) one of the 20 predefined accounts. Each account possesses the default amount of Motes (100_000_000_000_000_000). The Test Env internally keeps track of the current block time, error and attached value. Each test is executed on a fresh instance of the Test Env. ","version":"2.1.0","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"Casper","url":"/docs/2.1.0/backends/casper#usage","content":"Name of the Casper backend in Odra is casper, so to run the tests against it, simply pass it as a -bparameter: cargo odra test -b casper  If you want to just generate a wasm file, simply run: cargo odra build -b casper  ","version":"2.1.0","tagName":"h2"},{"title":"Deploying a contract to Casper network​","type":1,"pageTitle":"Casper","url":"/docs/2.1.0/backends/casper#deploying-a-contract-to-casper-network","content":"There would be no point in writing a contract if you couldn't deploy it to the blockchain. You can do it in two ways: provided by the Casper itself: using the casper-client tool or using the Odra's Livenet integration. Let's explore the first option to better understand the process. note If you wish, you can skip the following section and jump to the Livenet integration. ","version":"2.1.0","tagName":"h2"},{"title":"WASM arguments​","type":1,"pageTitle":"Casper","url":"/docs/2.1.0/backends/casper#wasm-arguments","content":"When deploying a new contract you can pass some arguments to it. Every contract written in Odra expects those arguments to be set: odra_cfg_package_hash_key_name - String type. The key under which the package hash of the contract will be stored.odra_cfg_allow_key_override - Bool type. If true and the key specified in odra_cfg_package_hash_key_name already exists, it will be overwritten.odra_cfg_is_upgradable - Bool type. If true, the contract will be deployed as upgradable. Additionally, if required by the contract, you can pass constructor arguments. When working with the test env via cargo odra or when usingLivenet integration this is handled automatically. However, if you rather usecasper-client directly, you have to pass them manually: ","version":"2.1.0","tagName":"h3"},{"title":"Example: Deploy Counter​","type":1,"pageTitle":"Casper","url":"/docs/2.1.0/backends/casper#example-deploy-counter","content":"To deploy your contract with a constructor using casper-client, you need to pass the above arguments. Additionally, you need to pass the value argument, which sets the arbitrary initial value for the counter. casper-client put-deploy \\ --node-address [NODE_ADDRESS] \\ --chain-name casper-test \\ --secret-key [PATH_TO_YOUR_KEY]/secret_key.pem \\ --payment-amount 5000000000000 \\ --session-path ./wasm/counter.wasm \\ --session-arg &quot;odra_cfg_package_hash_key_name:string:'counter_package_hash'&quot; \\ --session-arg &quot;odra_cfg_allow_key_override:bool:'true'&quot; \\ --session-arg &quot;odra_cfg_is_upgradable:bool:'true'&quot; \\ --session-arg &quot;value:u32:42&quot;  For a more in-depth tutorial, please refer to the Casper's 'Writing On-Chain Code'. ","version":"2.1.0","tagName":"h3"},{"title":"Example: Deploy ERC721​","type":1,"pageTitle":"Casper","url":"/docs/2.1.0/backends/casper#example-deploy-erc721","content":"Odra comes with a standard ERC721 token implementation. Clone the main Odra repo and navigate to the modules directory. Firstly contract needs to be compiled. cargo odra build -b casper -c erc721_token  It produces the erc721_token.wasm file in the wasm directory. Now it's time to deploy the contract. casper-client put-deploy \\ --node-address [NODE_ADDRESS] \\ --chain-name casper-test \\ --secret-key [PATH_TO_YOUR_KEY]/secret_key.pem \\ --payment-amount 300000000000 \\ --session-path ./wasm/erc721_token.wasm \\ --session-arg &quot;odra_cfg_package_hash_key_name:string:'my_nft'&quot; \\ --session-arg &quot;odra_cfg_allow_key_override:bool:'false'&quot; \\ --session-arg &quot;odra_cfg_is_upgradable:bool:'true'&quot; \\ --session-arg &quot;name:string:'MyNFT'&quot; \\ --session-arg &quot;symbol:string:'NFT'&quot; \\ --session-arg &quot;base_uri:string:'https://example.com/'&quot;  It's done. The contract is deployed and ready to use. Your account is the owner of the contract and you can mint and burn tokens. For more details see the code of the ERC721 module. To obtain the package hash of the contract search for my_nft key in your account's named keys. ","version":"2.1.0","tagName":"h3"},{"title":"Example: Deploy ERC1155​","type":1,"pageTitle":"Casper","url":"/docs/2.1.0/backends/casper#example-deploy-erc1155","content":"The process is similar to the one described in the previous section. Contract compilation: cargo odra build -b casper -c erc1155_token  Contract deployment: casper-client put-deploy \\ --node-address [NODE_ADDRESS] \\ --chain-name casper-test \\ --secret-key [PATH_TO_YOUR_KEY]/secret_key.pem \\ --payment-amount 300000000000 \\ --session-path ./wasm/erc1155_token.wasm \\ --session-arg &quot;odra_cfg_package_hash_key_name:string:'my_tokens'&quot; \\ --session-arg &quot;odra_cfg_allow_key_override:bool:'false'&quot; \\ --session-arg &quot;odra_cfg_is_upgradable:bool:'true'&quot; \\ --session-arg &quot;odra_cfg_constructor:string:'init'&quot; \\  As previously, your account is the owner and can mint and burn tokens. For more details see the code of the ERC1155 module. ","version":"2.1.0","tagName":"h3"},{"title":"Sending CSPR to a contract​","type":1,"pageTitle":"Casper","url":"/docs/2.1.0/backends/casper#sending-cspr-to-a-contract","content":"Defining payable entry points is described in Native Token section. What is happening under the hood is that Odra creates a new cargo_purse argument for each payable entry point. The cargo_purse needs to be top-upped with CSPR before calling the contract. When a contract adds CSPR to another contract call, Odra handles it for you. The problem arises when you want to call an entry point and attach CSPR as an account. The only way of doing that is by executing code in the sessions context, that top-ups the cargo_purse and then calls the contract. Odra provides a generic proxy_caller.wasm that does exactly that. You can build it by yourself from the main Odra repository, or use the proxy_caller.wasmwe maintain. ","version":"2.1.0","tagName":"h2"},{"title":"Using proxy_caller.wasm​","type":1,"pageTitle":"Casper","url":"/docs/2.1.0/backends/casper#using-proxy_callerwasm","content":"To use the proxy_caller.wasm you need to attach the following arguments: contract_package_hash - BytesArray(32) type. The package hash of the contract you want to call. Result of to_bytes on CasperPackageHash.entry_point - String type. The name of the entry point you want to call.args - Bytes type. It is a serialized RuntimeArgs with the arguments you want to pass to the entry point. To be specific it is the result of to_bytes method wrapped with Bytes type.attached_value. U512 type. The amount of CSPR you want to attach to the call.amount. U512 type. Should be the same value as attached_value if not None. It is a special Casper argument that enables the access to account's main purse. Currently casper-client doesn't allow building such arguments. You have to build it using your SDK. See an example in the Tutorial section. ","version":"2.1.0","tagName":"h3"},{"title":"Execution​","type":1,"pageTitle":"Casper","url":"/docs/2.1.0/backends/casper#execution","content":"First thing Odra does with your code, is similar to the one used in OdraVM - a list of entrypoints is generated, thanks to the #[odra::module] attribute. ","version":"2.1.0","tagName":"h2"},{"title":"Livenet","type":0,"sectionRef":"#","url":"/docs/2.1.0/backends/livenet","content":"","keywords":"","version":"2.1.0"},{"title":"Setup​","type":1,"pageTitle":"Livenet","url":"/docs/2.1.0/backends/livenet#setup","content":"To use Livenet backend, we need to provide Odra with some information - the network address, our private key and the name of the chain we want to use. Optionally, we can add multiple private keys to use more than one account in our tests. Those values are passed using environment variables. We can use .env file to store them - let's take a look at an example .env file, created from the .env.sample file from the examples folder: # Path to the secret key of the account that will be used # to deploy the contracts. # We're using .keys folder so we don't accidentally commit # the secret key to the repository. ODRA_CASPER_LIVENET_SECRET_KEY_PATH=.keys/secret_key.pem # RPC address of the node that will be used to deploy the contracts. ODRA_CASPER_LIVENET_NODE_ADDRESS=localhost:7777 # Chain name of the network. Known values: # - integration-test ODRA_CASPER_LIVENET_CHAIN_NAME=integration-test # Paths to the secret keys of the additional accounts. # Main secret key will be 0th account. ODRA_CASPER_LIVENET_KEY_1=.keys/secret_key_1.pem ODRA_CASPER_LIVENET_KEY_2=.keys/secret_key_2.pem # If using CSPR.cloud, you can set the auth token here. # CSPR_CLOUD_AUTH_TOKEN=  note CSPR.cloud is a service that provides mainnet and testnet Casper nodes on demand. With the proper value in place, we can write our tests or deploy scenarios. In the examples, we can find a simple binary that deploys a contract and calls it. The test is located in the erc20_on_livenet.rs file. Let's go through the code: fn main() { // Similar to the OdraVM backend, we need to initialize // the environment: let env = odra_casper_livenet_env::env(); // Most of the host env works the same as in the // OdraVM backend. let owner = env.caller(); // Addresses are the real addresses on the blockchain, // so we need to provide them // if we did not import their secret keys. let recipient = &quot;hash-2c4a6ce0da5d175e9638ec0830e01dd6cf5f4b1fbb0724f7d2d9de12b1e0f840&quot;; let recipient = Address::from_str(recipient).unwrap(); // Arguments for the contract init method. let name = String::from(&quot;Plascoin&quot;); let symbol = String::from(&quot;PLS&quot;); let decimals = 10u8; let initial_supply: U256 = U256::from(10_000); // The main difference between other backends - we need to specify // the gas limit for each action. // The limit will be used for every consecutive action // until we change it. env.set_gas(100_000_000_000u64); // Deploy the contract. The API is the same as in the OdraVM backend. let init_args = Erc20InitArgs { name, symbol, decimals, initial_supply: Some(initial_supply) }; let mut token = Erc20::deploy(env, init_args); // We can now use the contract as we would in the OdraVM backend. println!(&quot;Token address: {}&quot;, token.address().to_string()); // Uncomment to load existing contract. // let address = &quot;hash-d26fcbd2106e37be975d2045c580334a6d7b9d0a241c2358a4db970dfd516945&quot;; // let address = Address::from_str(address).unwrap(); // We use the Livenet-specific `load` method to load the contract // that is already deployed. // let mut token = Erc20Deployer::load(env, address); // Non-mutable calls are free! Neat, huh? More on that later. println!(&quot;Token name: {}&quot;, token.name()); // The next call is mutable, but the cost is lower than the deployment, // so we change the amount of gas env.set_gas(3_000_000_000u64); token.transfer(recipient, U256::from(1000)); println!(&quot;Owner's balance: {:?}&quot;, token.balance_of(owner)); println!(&quot;Recipient's balance: {:?}&quot;, token.balance_of(recipient)); }  note The above example is a rust binary, not a test. Note that it is also added as a section of theCargo.toml file: [bin] name = &quot;erc20_on_livenet&quot; path = &quot;src/bin/erc20_on_livenet.rs&quot; required-features = [&quot;livenet&quot;] test = false  ","version":"2.1.0","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"Livenet","url":"/docs/2.1.0/backends/livenet#usage","content":"To run the above code, we simply need to run the binary with the livenet feature enabled: cargo run --bin erc20_on_livenet --features=livenet  note Before executing the binary, make sure you built a wasm file. A part of a sample output should look like this: ... 💁 INFO : Calling &quot;hash-d26fcbd210...&quot; with entrypoint &quot;transfer&quot;. 🙄 WAIT : Waiting 15s for &quot;65b1a5d21...&quot;. 🙄 WAIT : Waiting 15s for &quot;65b1a5d21...&quot;. 💁 INFO : Deploy &quot;65b1a5d21...&quot; successfully executed. Owner's balance: 4004 Recipient's balance: 4000  Those logs are a result of the last 4 lines of the above listing. Each deployment or a call to the blockchain will be noted and will take some time to execute. We can see that the transfer call took over 15 seconds to execute. But calling balance_of was nearly instant and cost us nothing. How it is possible? info You can see the deployment on http://cspr.live/ - the transfer from the example can be seen here. ","version":"2.1.0","tagName":"h2"},{"title":"How Livenet backend works​","type":1,"pageTitle":"Livenet","url":"/docs/2.1.0/backends/livenet#how-livenet-backend-works","content":"All calls of entrypoints executed on a Casper blockchain cost gas - even if they do not change the state. It is possible, however, to query the state of the blockchain for free. This principle is used in the Livenet backend - all calls that do not change the state of the blockchain are really executed offline - the only thing that is requested from the node is the current state. This is why the balance_of call was almost instant and free. Basically, if the entrypoint function is not mutable or does not make a call to an unknown external contract (see Cross Calls), it is executed offline and node is used for the state query only. However, the Livenet needs to know the connection between the contracts and the code, so make sure to deploy or load already deployed contracts ","version":"2.1.0","tagName":"h2"},{"title":"Multiple environments​","type":1,"pageTitle":"Livenet","url":"/docs/2.1.0/backends/livenet#multiple-environments","content":"It is possible to have multiple environments for the Livenet backend. This is useful if we want to easily switch between multiple accounts, multiple nodes or even multiple chains. To do this, simply create a new .env file with a different prefix - for example, integration.env and mainnet.env. Then, pass the ODRA_CASPER_LIVENET_ENV variable with value either integration or mainnet to select which file has to be used first. If your integration.env file has a value that IS present in the .env file, it will override the value from the .env file. ODRA_CASPER_LIVENET_ENV=integration cargo run --bin erc20_on_livenet --features=livenet  To sum up - this command will firstly load the integration.env file and then load the missing values from .env file. ","version":"2.1.0","tagName":"h2"},{"title":"What is a backend?","type":0,"sectionRef":"#","url":"/docs/2.1.0/backends/what-is-a-backend","content":"","keywords":"","version":"2.1.0"},{"title":"Contract Env​","type":1,"pageTitle":"What is a backend?","url":"/docs/2.1.0/backends/what-is-a-backend#contract-env","content":"The Contract Env is a simple interface that each backend needs to implement, exposing features of the blockchain from the perspective of the contract. It gives Odra a set of functions, which allows implementing more complex concepts - for example, to implement Mapping, Odra requires some kind of storage integration. The exact implementation of those functions is a responsibility of a backend, making Odra and its user free to implement the contract logic, instead of messing with the blockchain internals. Other functions from Contract Env include handling transfers, addresses, block time, errors and events. ","version":"2.1.0","tagName":"h2"},{"title":"Host Env​","type":1,"pageTitle":"What is a backend?","url":"/docs/2.1.0/backends/what-is-a-backend#host-env","content":"Similarly to the Contract Env, the Host Env exposes a set of functions that allows the communication with the backend from the outside world - really useful for implementing tests. This ranges from interacting with the blockchain - like deploying new, loading existing and calling the contracts, to the more test-oriented - handling errors, forwarding the block time, etc. ","version":"2.1.0","tagName":"h2"},{"title":"What's next​","type":1,"pageTitle":"What is a backend?","url":"/docs/2.1.0/backends/what-is-a-backend#whats-next","content":"We will take a look at backends Odra implements in more detail. ","version":"2.1.0","tagName":"h2"},{"title":"Cargo Odra","type":0,"sectionRef":"#","url":"/docs/2.1.0/basics/cargo-odra","content":"","keywords":"","version":"2.1.0"},{"title":"Managing projects​","type":1,"pageTitle":"Cargo Odra","url":"/docs/2.1.0/basics/cargo-odra#managing-projects","content":"Two commands help you create a new project. The first one is cargo odra new. You need to pass one parameter, namely --name {PROJECT_NAME}: cargo odra new --name my-project  This creates a new project in the my_project folder and name it my_project. You can see it for yourself, for example by taking a look into a Cargo.toml file created in your project's folder: [package] name = &quot;my_project&quot; version = &quot;0.1.0&quot; edition = &quot;2021&quot;  The project is created using the template located in Odra's main repository. By default it uses full template, if you want, you can use minimalistic blank by running: cargo odra new -t blank --name my-project  The third available template is workspace, which creates a workspace with two projects, similar to the one created with the full template. There are also two templates which create a project with a sample tokens native to Casper Network: cep18 and cep78. By default, the latest release of Odra will be used for the template and as a dependency. You can pass a source of Odra you want to use, by using -s parameter: cargo odra new -n my-project -s ../odra # will use local folder of odra cargo odra new -n my-project -s release/0.9.0 # will use github branch, e.g. if you want to test new release cargo odra new -n my-project -s 1.1.0 # will use a version released on crates.io  The second way of creating a project is by using init command: cargo odra init --name my-project  It works in the same way as new, but instead of creating a new folder, it creates a project in the current, empty directory. ","version":"2.1.0","tagName":"h2"},{"title":"Generating code​","type":1,"pageTitle":"Cargo Odra","url":"/docs/2.1.0/basics/cargo-odra#generating-code","content":"If you want to quickly create a new contract code, you can use the generate command: cargo odra generate -c counter  This creates a new file src/counter.rs with sample code, add appropriate use and mod sections to src/lib.rs and update the Odra.toml file accordingly. To learn more about Odra.toml file, visit Odra.toml. ","version":"2.1.0","tagName":"h2"},{"title":"Testing​","type":1,"pageTitle":"Cargo Odra","url":"/docs/2.1.0/basics/cargo-odra#testing","content":"The most used command during the development of your project should be this one: cargo odra test  It runs your tests against Odra's MockVM. It is substantially faster than CasperVMand implements all the features Odra uses. When you want to run tests against a &quot;real&quot; VM, just provide the name of the backend using -boption: cargo odra test -b casper  In the example above, Cargo Odra builds the project, generates the wasm files, spin up CasperVM instance, deploys the contracts onto it and runs the tests against it. Pretty neat. Keep in mind that this is a lot slower than OdraVM and you cannot use the debugger. This is why OdraVM was created and should be your first choice when developing contracts. Of course, testing all of your code against a blockchain VM is a must in the end. If you want to run only some of the tests, you can pass arguments to the cargo test command (which is run in the background obviously): cargo odra test -- this-will-be-passed-to-cargo-test  If you want to run tests which names contain the word two, you can execute: cargo odra test -- two  Of course, you can do the same when using the backend: cargo odra test -b casper -- two  ","version":"2.1.0","tagName":"h2"},{"title":"Building code​","type":1,"pageTitle":"Cargo Odra","url":"/docs/2.1.0/basics/cargo-odra#building-code","content":"You can also build the code itself and generate the output contracts without running the tests. To do so, simply run: cargo odra build  If the build process finishes successfully, wasm files will be located in wasm folder. Notice, that this command does not require the -b option. If you want to build specific contract, you can use -c option: cargo odra build -c counter # you pass many comma separated contracts  ","version":"2.1.0","tagName":"h2"},{"title":"Skipping building​","type":1,"pageTitle":"Cargo Odra","url":"/docs/2.1.0/basics/cargo-odra#skipping-building","content":"As building wasm files can take a long time, especially if you have a lot of contracts. If you did not change anything in your contracts and you just want to rerun the tests for the casper backend, use the -s option: cargo odra test -b casper -s  ","version":"2.1.0","tagName":"h2"},{"title":"Generating contract schema​","type":1,"pageTitle":"Cargo Odra","url":"/docs/2.1.0/basics/cargo-odra#generating-contract-schema","content":"If you want to generate a schema (including the name, entrypoints, events, etc.) for your contract, you can use the schema command: cargo odra schema  This generates a schema file in JSON format for all your contracts and places them in the resources folder. If the resources folder does not exist, it creates the folder for you. Like with the build command, you can use the -c option to generate a schema for a specific contract. ","version":"2.1.0","tagName":"h2"},{"title":"What's next​","type":1,"pageTitle":"Cargo Odra","url":"/docs/2.1.0/basics/cargo-odra#whats-next","content":"In the next section, we will take a look at all the files and directories that cargo odra created for us and explain their purpose. ","version":"2.1.0","tagName":"h2"},{"title":"Host Communication","type":0,"sectionRef":"#","url":"/docs/2.1.0/basics/communicating-with-host","content":"","keywords":"","version":"2.1.0"},{"title":"What's next​","type":1,"pageTitle":"Host Communication","url":"/docs/2.1.0/basics/communicating-with-host#whats-next","content":"In the next article, we'll dive into testing your contracts with Odra, so you can check that the code we presented in fact works! ","version":"2.1.0","tagName":"h2"},{"title":"directory-structure","type":0,"sectionRef":"#","url":"/docs/2.1.0/basics/directory-structure","content":"","keywords":"","version":"2.1.0"},{"title":"Directory structure​","type":1,"pageTitle":"directory-structure","url":"/docs/2.1.0/basics/directory-structure#directory-structure","content":"After creating a new project using Odra and running the tests, you will be presented with the following files and directories: . ├── Cargo.lock ├── Cargo.toml ├── CHANGELOG.md ├── Odra.toml ├── README.md ├── rust-toolchain ├── src/ │ ├── flipper.rs │ └── lib.rs ├── bin/ | |── build_contract.rs | └── build_schema.rs ├── target/ └── wasm/  ","version":"2.1.0","tagName":"h2"},{"title":"Cargo.toml​","type":1,"pageTitle":"directory-structure","url":"/docs/2.1.0/basics/directory-structure#cargotoml","content":"Let's first take a look at Cargo.toml file: [package] name = &quot;sample&quot; version = &quot;0.1.0&quot; edition = &quot;2021&quot; [dependencies] odra = &quot;2.2.0&quot; [dev-dependencies] odra-test = &quot;2.2.0&quot; [build-dependencies] odra-build = &quot;2.2.0&quot; [[bin]] name = &quot;sample_build_contract&quot; path = &quot;bin/build_contract.rs&quot; test = false [[bin]] name = &quot;sample_build_schema&quot; path = &quot;bin/build_schema.rs&quot; test = false [profile.release] codegen-units = 1 lto = true [profile.dev.package.&quot;*&quot;] opt-level = 3  By default, your project will use the latest odra version available at crates.io. For testing purposes,odra-test is also added as a dev dependency. ","version":"2.1.0","tagName":"h3"},{"title":"Odra.toml​","type":1,"pageTitle":"directory-structure","url":"/docs/2.1.0/basics/directory-structure#odratoml","content":"This is the file that holds information about contracts that will be generated when running cargo odra build andcargo odra test: [[contracts]] fqn = &quot;sample::Flipper&quot;  As we can see, we have a single contract, its fqn (Fully Qualified Name) corresponds to the contract is located in src/flipper.rs. More contracts can be added here by hand, or by using cargo odra generate command. ","version":"2.1.0","tagName":"h3"},{"title":"src/​","type":1,"pageTitle":"directory-structure","url":"/docs/2.1.0/basics/directory-structure#src","content":"This is the folder where your smart contract files live. ","version":"2.1.0","tagName":"h3"},{"title":"bin/​","type":1,"pageTitle":"directory-structure","url":"/docs/2.1.0/basics/directory-structure#bin","content":"This is the folder where scripts that will be used to generate code or schemas live. You don't need to modify those files, they are generated by cargo odra new command and are used by cargo odra build, cargo odra test and cargo odra schema commands. ","version":"2.1.0","tagName":"h3"},{"title":"target/​","type":1,"pageTitle":"directory-structure","url":"/docs/2.1.0/basics/directory-structure#target","content":"Files generated by cargo during the build process are put here. ","version":"2.1.0","tagName":"h3"},{"title":"wasm/​","type":1,"pageTitle":"directory-structure","url":"/docs/2.1.0/basics/directory-structure#wasm","content":"WASM files generated by cargo odra build and cargo odra test are put here. You can grab those WASM files and deploy them on the blockchain. ","version":"2.1.0","tagName":"h3"},{"title":"What's next​","type":1,"pageTitle":"directory-structure","url":"/docs/2.1.0/basics/directory-structure#whats-next","content":"Now, let's take a look at one of the files mentioned above in more detail, namely the Odra.toml file. ","version":"2.1.0","tagName":"h2"},{"title":"Cross calls","type":0,"sectionRef":"#","url":"/docs/2.1.0/basics/cross-calls","content":"","keywords":"","version":"2.1.0"},{"title":"Contract Ref​","type":1,"pageTitle":"Cross calls","url":"/docs/2.1.0/basics/cross-calls#contract-ref","content":"We mentioned HostRef already in our Testing article - a host side reference to already deployed contract. In the module context we use a ContractRef instead, to call other contracts. Similarly to the HostRef trait implemetation for the module, the {{ModuleName}}ContractRef is generated automatically, by the #[odra::module] attribute. The reference implements all the public endpoints to the contract (those marked as pub in #[odra::module]impl), and the {{ModuleName}}ContractRef::address() function, which returns the address of the contract. External Contracts Sometimes in our contract, we would like to interact with a someone else's contract, already deployed onto the blockchain. The only thing we know about the contract is the ABI. For that purpose, we use #[odra:external_contract] attribute. This attribute should be applied to a trait. The trait defines the part of the ABI we would like to take advantage of. Let's pretend the MathEngine we defined is an external contract. There is a contract with add() function that adds two numbers somewhere. #[odra::external_contract] pub trait Adder { fn add(&amp;self, n1: u32, n2: u32) -&gt; u32; }  Odra automatically creates the AdderContractRef struct. Having an address, in the module context we can call: struct Contract { adder: External&lt;AdderContractRef&gt; } // in some function self.adder.add(3, 5) // or struct Contract { adder: Var&lt;Address&gt; } // in some function AdderContractRef::new(self.env(), address).add(3, 5)  ","version":"2.1.0","tagName":"h2"},{"title":"Loading the contract​","type":1,"pageTitle":"Cross calls","url":"/docs/2.1.0/basics/cross-calls#loading-the-contract","content":"Sometimes it is useful to load the deployed contract instead of deploying it by ourselves. This is especially useful when we want to test our contracts in Livenet backend. We can load the contract using load method on the Deployer: examples/bin/erc20_on_livenet.rs fn _load_erc20(env: &amp;HostEnv) -&gt; Erc20HostRef { let address = &quot;hash-d26fcbd2106e37be975d2045c580334a6d7b9d0a241c2358a4db970dfd516945&quot;; let address = Address::from_str(address).unwrap(); Erc20::load(env, address) }  ","version":"2.1.0","tagName":"h3"},{"title":"Testing​","type":1,"pageTitle":"Cross calls","url":"/docs/2.1.0/basics/cross-calls#testing","content":"Let's see how we can test our cross calls using this knowledge: examples/src/features/cross_calls.rs #[cfg(test)] mod tests { use super::{CrossContract, CrossContractInitArgs, MathEngineHostRef}; use odra::host::{Deployer, NoArgs}; use odra::prelude::*; #[test] fn test_cross_calls() { let test_env = odra_test::env(); let math_engine_contract = MathEngine::deploy(&amp;test_env, NoArgs); let cross_contract = CrossContract::deploy( &amp;test_env, CrossContractInitArgs { math_engine_address: *math_engine_contract.address() } ); assert_eq!(cross_contract.add_using_another(), 8); } }  Each test begins with a clean instance of the blockchain, with no contracts deployed. To test an external contract, we first deploy a MathEngine contract, although we won't directly utilize it. Instead, we only extract its address. Let's continue assuming there is a contract featuring the add() function that we intend to utilize. #[cfg(test)] mod tests { use super::*; use odra::host::{Deployer, NoArgs}; use odra::prelude::*; #[test] fn test_ext() { let test_env = odra_test::env(); let adder = Adder::new(&amp;test_env, get_adder_address(&amp;test_env)).add(3, 5) assert_eq!(adder.add(1, 2), 3); } fn get_adder_address(test_env: &amp;HostEnv) -&gt; Address { let contract = MathEngine::deploy(test_env, NoArgs); contract.address() } }  ","version":"2.1.0","tagName":"h2"},{"title":"Casper Contract Schema","type":0,"sectionRef":"#","url":"/docs/2.1.0/basics/casper-contract-schema","content":"","keywords":"","version":"2.1.0"},{"title":"Odra and CCS​","type":1,"pageTitle":"Casper Contract Schema","url":"/docs/2.1.0/basics/casper-contract-schema#odra-and-ccs","content":"There is almost nothing you need to do to use CCS in your Odra project. The only thing to be taken care of is using odra attributes namely: module, event, odra_error and odra_type. The schema will be generated for you and available in the resources directory. note If you forget to register events and errors in the module attribute, the definition remains valid; however, the errors and events will not be incorporated into the schema. src/contract.rs use odra::prelude::*; #[odra::module( // the name of the contract, default is the module name name = &quot;MyContract&quot;, // the version of the contract, default is the version of the crate version = &quot;0.1.0&quot;, // events that the contract can emit, collected recursively if submodules are used events = [ Created, Updated ], // the error enum the contract can revert with, collected recursively if submodules are used errors = MyErrors )] pub struct MyContract { name: Var&lt;String&gt;, owner: Var&lt;Address&gt;, } #[odra::module] impl MyContract { /// Initializes the contract, sets the name and owner and emits an event pub fn init(&amp;mut self, name: String, owner: Address) { self.name.set(name.clone()); self.owner.set(owner.clone()); self.env().emit_event(Created { name }); } /// Updates the name of the contract and emits an event pub fn update(&amp;mut self, name: String) { self.name.set(name.clone()); self.env().emit_event(Updated { name }); } /// Returns the data of the contract pub fn get_data(&amp;self) -&gt; Data { Data { name: self.name.get_or_default(), owner: self.owner.get_or_revert_with(MyErrors::InvalidOwner), } } } // The struct will we visible in the schema in the types section #[odra::odra_type] pub struct Data { name: String, owner: Address, } // The enum variants will we visible in the schema in the errors section #[odra::odra_error] pub enum MyErrors { /// The owner is invalid InvalidOwner, /// The name is invalid InvalidName, } // The struct will we visible in the schema in the types and events section #[odra::event] pub struct Updated { name: String, } // The struct will we visible in the schema in the types section and events section #[odra::event] pub struct Created { name: String, }  ","version":"2.1.0","tagName":"h2"},{"title":"Generating the Schema​","type":1,"pageTitle":"Casper Contract Schema","url":"/docs/2.1.0/basics/casper-contract-schema#generating-the-schema","content":"To generate the schema run the following cargo-odra command: cargo odra schema # or pass -c flag to generate the schema for a specific contract  ","version":"2.1.0","tagName":"h2"},{"title":"Schema Output​","type":1,"pageTitle":"Casper Contract Schema","url":"/docs/2.1.0/basics/casper-contract-schema#schema-output","content":"The generated schema will be available in the resources directory. The schema is a JSON file that contains all the information about the contract. Here is an example of the generated schema: resources/my_contract_schema.json { &quot;casper_contract_schema_version&quot;: 1, &quot;toolchain&quot;: &quot;rustc 1.77.0-nightly (5bd5d214e 2024-01-25)&quot;, &quot;authors&quot;: [], &quot;repository&quot;: null, &quot;homepage&quot;: null, &quot;contract_name&quot;: &quot;MyContract&quot;, &quot;contract_version&quot;: &quot;0.1.0&quot;, &quot;types&quot;: [ { &quot;struct&quot;: { &quot;name&quot;: &quot;Created&quot;, &quot;description&quot;: null, &quot;members&quot;: [ { &quot;name&quot;: &quot;name&quot;, &quot;description&quot;: null, &quot;ty&quot;: &quot;String&quot; } ] } }, { &quot;struct&quot;: { &quot;name&quot;: &quot;Data&quot;, &quot;description&quot;: null, &quot;members&quot;: [ { &quot;name&quot;: &quot;name&quot;, &quot;description&quot;: null, &quot;ty&quot;: &quot;String&quot; }, { &quot;name&quot;: &quot;owner&quot;, &quot;description&quot;: null, &quot;ty&quot;: &quot;Key&quot; } ] } }, { &quot;struct&quot;: { &quot;name&quot;: &quot;Updated&quot;, &quot;description&quot;: null, &quot;members&quot;: [ { &quot;name&quot;: &quot;name&quot;, &quot;description&quot;: null, &quot;ty&quot;: &quot;String&quot; } ] } } ], &quot;errors&quot;: [ { &quot;name&quot;: &quot;InvalidName&quot;, &quot;description&quot;: &quot;The name is invalid&quot;, &quot;discriminant&quot;: 1 }, { &quot;name&quot;: &quot;InvalidOwner&quot;, &quot;description&quot;: &quot;The owner is invalid&quot;, &quot;discriminant&quot;: 0 } ], &quot;entry_points&quot;: [ { &quot;name&quot;: &quot;update&quot;, &quot;description&quot;: &quot;Updates the name of the contract and emits an event&quot;, &quot;is_mutable&quot;: true, &quot;arguments&quot;: [ { &quot;name&quot;: &quot;name&quot;, &quot;description&quot;: null, &quot;ty&quot;: &quot;String&quot;, &quot;optional&quot;: false } ], &quot;return_ty&quot;: &quot;Unit&quot;, &quot;is_contract_context&quot;: true, &quot;access&quot;: &quot;public&quot; }, { &quot;name&quot;: &quot;get_data&quot;, &quot;description&quot;: &quot;Returns the data of the contract&quot;, &quot;is_mutable&quot;: false, &quot;arguments&quot;: [], &quot;return_ty&quot;: &quot;Data&quot;, &quot;is_contract_context&quot;: true, &quot;access&quot;: &quot;public&quot; } ], &quot;events&quot;: [ { &quot;name&quot;: &quot;Created&quot;, &quot;ty&quot;: &quot;Created&quot; }, { &quot;name&quot;: &quot;Updated&quot;, &quot;ty&quot;: &quot;Updated&quot; } ], &quot;call&quot;: { &quot;wasm_file_name&quot;: &quot;MyContract.wasm&quot;, &quot;description&quot;: &quot;Initializes the contract, sets the name and owner and emits an event&quot;, &quot;arguments&quot;: [ { &quot;name&quot;: &quot;odra_cfg_package_hash_key_name&quot;, &quot;description&quot;: &quot;The arg name for the package hash key name.&quot;, &quot;ty&quot;: &quot;String&quot;, &quot;optional&quot;: false }, { &quot;name&quot;: &quot;odra_cfg_allow_key_override&quot;, &quot;description&quot;: &quot;The arg name for the allow key override.&quot;, &quot;ty&quot;: &quot;Bool&quot;, &quot;optional&quot;: false }, { &quot;name&quot;: &quot;odra_cfg_is_upgradable&quot;, &quot;description&quot;: &quot;The arg name for the contract upgradeability setting.&quot;, &quot;ty&quot;: &quot;Bool&quot;, &quot;optional&quot;: false }, { &quot;name&quot;: &quot;name&quot;, &quot;description&quot;: null, &quot;ty&quot;: &quot;String&quot;, &quot;optional&quot;: false }, { &quot;name&quot;: &quot;owner&quot;, &quot;description&quot;: null, &quot;ty&quot;: &quot;Key&quot;, &quot;optional&quot;: false } ] } }  ","version":"2.1.0","tagName":"h2"},{"title":"Schema Fields​","type":1,"pageTitle":"Casper Contract Schema","url":"/docs/2.1.0/basics/casper-contract-schema#schema-fields","content":"casper_contract_schema_version is the version of the schema.toolchain is the version of the Rust compiler used to compile the contract.Fields authors, repository, and homepage are optional and can be set in the Cargo.toml file.contract_name is the name of the contract - by default is the module name, may be overriden by the module attribute.contract_version denotes the version of the contract, defaulting to the version specified in the Cargo.toml file, but can be overridden by the module attribute.types comprises a list of custom structs and enums defined within the contract. Each struct or enum includes a name, description (not currently supported, with the value set to null), and a list of members.errors is a list of error enums defined within the contract. Each error includes a name, description (the first line of the variant documentation), and a discriminant.entry_points is a list of contract functions that can be called from the outside. Each entry point includes a name, description (not currently supported, with the value set to null), whether the function is mutable, a list of arguments, the return type, whether the function is called in the contract context, and the access level.events is a list of events that the contract can emit. Each event includes a name and the type (earlier defined in types) of the event.The call section provides details regarding the contract's call function, which executes upon contract deployment. It includes the name of the Wasm file, a description (reflecting the constructor's description, typically the init function), and a list of arguments. These arguments are a combination of Odra configuration arguments and constructor arguments. ","version":"2.1.0","tagName":"h2"},{"title":"Errors","type":0,"sectionRef":"#","url":"/docs/2.1.0/basics/errors","content":"","keywords":"","version":"2.1.0"},{"title":"Testing errors​","type":1,"pageTitle":"Errors","url":"/docs/2.1.0/basics/errors#testing-errors","content":"Okay, but how about testing it? Let's write a test that will check if the error is thrown when the caller is not an owner: examples/src/features/handling_errors.rs #[cfg(test)] mod tests { use super::{Error, OwnedContract, OwnedContractInitArgs}; use odra::{host::Deployer, prelude::*}; #[test] fn test_owner_error() { let test_env = odra_test::env(); let owner = test_env.get_account(0); let not_an_owner = test_env.get_account(1); test_env.set_caller(owner); let init_args = OwnedContractInitArgs { name: &quot;OwnedContract&quot;.to_string() }; let mut owned_contract = OwnedContract::deploy(&amp;test_env, init_args); test_env.set_caller(not_an_owner); assert_eq!( owned_contract .try_change_name(&quot;NewName&quot;.to_string()) .unwrap_err(), Error::NotAnOwner.into() ); } }  Each deployed contract is of {{ModuleName}}HostRef type and has try_{{entry_point_name}} functions that return an OdraResult.OwnedContractHostRef implements regular entrypoints: name, owner, change_name, and and safe its safe version: try_name, try_owner, try_change_name. In our example, we are calling try_change_name and expecting an error to be thrown. For assertions, we are using a standard assert_eq! macro. As the contract call returns an OdraError, we need to convert our custom error to OdraError using Into::into(). ","version":"2.1.0","tagName":"h2"},{"title":"What's next​","type":1,"pageTitle":"Errors","url":"/docs/2.1.0/basics/errors#whats-next","content":"We will learn how to emit and test events using Odra. ","version":"2.1.0","tagName":"h2"},{"title":"Events","type":0,"sectionRef":"#","url":"/docs/2.1.0/basics/events","content":"","keywords":"","version":"2.1.0"},{"title":"Testing events​","type":1,"pageTitle":"Events","url":"/docs/2.1.0/basics/events#testing-events","content":"Odra's HostEnv comes with a few functions which lets you easily test the events that a given contract has emitted: examples/src/features/events.rs use super::{PartyContract, PartyStarted}; use odra::host::{Deployer, HostEnv, NoArgs}; #[test] fn test_party() { let test_env: HostEnv = odra_test::env(); let party_contract = PartyContract::deploy(&amp;test_env, NoArgs); assert!(test_env.emitted_event( &amp;party_contract, PartyStarted { caller: test_env.get_account(0), block_time: 0 } )); assert!(test_env.emitted_native_event( &amp;party_contract, NativePartyStarted { caller: test_env.get_account(0), block_time: 0 } )); // If you do not want to check the exact event, you can use `emitted` function assert!(test_env.emitted(&amp;party_contract, &quot;PartyStarted&quot;)); // Or `emitted_native` for the native events assert!(test_env.emitted_native(&amp;party_contract, &quot;NativePartyStarted&quot;)); // You can also check how many events were emitted: assert_eq!(test_env.events_count(&amp;party_contract), 1); assert_eq!(test_env.native_events_count(&amp;party_contract), 1); }  To explore more event testing functions, check the HostEnv documentation. ","version":"2.1.0","tagName":"h2"},{"title":"What's next​","type":1,"pageTitle":"Events","url":"/docs/2.1.0/basics/events#whats-next","content":"Read the next article to learn how to call other contracts from the contract context. ","version":"2.1.0","tagName":"h2"},{"title":"Flipper Internals","type":0,"sectionRef":"#","url":"/docs/2.1.0/basics/flipper-internals","content":"","keywords":"","version":"2.1.0"},{"title":"Header​","type":1,"pageTitle":"Flipper Internals","url":"/docs/2.1.0/basics/flipper-internals#header","content":"flipper.rs use odra::prelude::*;  The first line of the file imports the odra crate. The prelude module contains all the necessary types and traits that you will need to write your contract. It is a good practice to import theodra::prelude::* module in every file that contains Odra code. This way, you will not have to import each type or trait separately. ","version":"2.1.0","tagName":"h2"},{"title":"Struct​","type":1,"pageTitle":"Flipper Internals","url":"/docs/2.1.0/basics/flipper-internals#struct","content":"flipper.rs /// A module definition. Each module struct consists of Vars and Mappings /// or/and other modules. #[odra::module] pub struct Flipper { /// The module itself does not store the value, /// it's a proxy that writes/reads value to/from the host. value: Var&lt;bool&gt;, }  In Odra, all contracts are also modules, which can be reused between contracts. That's why we need to mark the struct with the #[odra::module] attribute. In the struct definition itself, we state all the fields of the contract. Those fields can be regular Rust data types, however - those will not be persisted on the blockchain. They can also be Odra modules - defined in your project or coming from Odra itself. Finally, to make the data persistent on the blockchain, you can use something likeVar&lt;T&gt; showed above. To learn more about storage interaction, take a look at thenext article. ","version":"2.1.0","tagName":"h2"},{"title":"Impl​","type":1,"pageTitle":"Flipper Internals","url":"/docs/2.1.0/basics/flipper-internals#impl","content":"flipper.rs /// Module implementation. /// /// To generate entrypoints, /// an implementation block must be marked as #[odra::module]. #[odra::module] impl Flipper { /// Odra constructor. /// /// Initializes the contract with the value of value. pub fn init(&amp;mut self) { self.value.set(false); } ...  Similarly to the struct, we mark the impl section with the #[odra::module] attribute. Odra will take allpub functions from this section and create contract endpoints from them. So, if you wish to have functions that are not available for calling outside the contract, do not make them public. Alternatively, you can create a separate impl section without the attribute - all functions defined there, even marked with pub will be not callable. The function named init is the constructor of the contract. This function will be limited only to a single call, all further calls to it will result in an error. The init function is optional, if your contract does not need any initialization, you can skip it. flipper.rs ... /// Replaces the current value with the passed argument. pub fn set(&amp;mut self, value: bool) { self.value.set(value); } /// Replaces the current value with the opposite value. pub fn flip(&amp;mut self) { self.value.set(!self.get()); } ...  The endpoints above show you how to interact with the simplest type of storage - Var&lt;T&gt;. The data saved there using set function will be persisted in the blockchain. ","version":"2.1.0","tagName":"h2"},{"title":"Tests​","type":1,"pageTitle":"Flipper Internals","url":"/docs/2.1.0/basics/flipper-internals#tests","content":"flipper.rs #[cfg(test)] mod tests { use crate::flipper::Flipper; use odra::host::{Deployer, NoArgs}; #[test] fn flipping() { let env = odra_test::env(); // To test a module we need to deploy it. `Flipper` implements `Deployer` trait, // so we can use it to deploy the module. let mut contract = Flipper::deploy(&amp;env, NoArgs); assert!(!contract.get()); contract.flip(); assert!(contract.get()); } ...  You can write tests in any way you prefer and know in Rust. In the example above we are deploying the contract using Deployer::deploy function called on Flipper - a piece of code generated by the #[odra::module]. Because the module implements the constructor but does not accept any arguments, as the second argument of the deploy function, we pass NoArgs - one of the implementations of the InitArgs trait provided with the framework. The contract will be deployed on the VM you chose while running cargo odra test. ","version":"2.1.0","tagName":"h2"},{"title":"What's next​","type":1,"pageTitle":"Flipper Internals","url":"/docs/2.1.0/basics/flipper-internals#whats-next","content":"Now let's take a look at the different types of storage that Odra provides and how to use them. ","version":"2.1.0","tagName":"h2"},{"title":"Native token","type":0,"sectionRef":"#","url":"/docs/2.1.0/basics/native-token","content":"","keywords":"","version":"2.1.0"},{"title":"Testing​","type":1,"pageTitle":"Native token","url":"/docs/2.1.0/basics/native-token#testing","content":"To be able to test how many tokens a contract (or any address) has, HostEnv comes with a function -balance_of: examples/src/features/native_token.rs #[cfg(test)] mod tests { use super::PublicWallet; use odra::{casper_types::U512, host::{Deployer, HostRef, NoArgs}}; #[test] fn test_modules() { let test_env = odra_test::env(); let mut my_contract = PublicWallet::deploy(&amp;test_env, NoArgs); assert_eq!(test_env.balance_of(&amp;my_contract), U512::zero()); my_contract.with_tokens(U512::from(100)).deposit(); assert_eq!(test_env.balance_of(&amp;my_contract), U512::from(100)); my_contract.withdraw(U512::from(25)); assert_eq!(test_env.balance_of(&amp;my_contract), U512::from(75)); } }  ","version":"2.1.0","tagName":"h2"},{"title":"HostEnv​","type":1,"pageTitle":"Native token","url":"/docs/2.1.0/basics/native-token#hostenv","content":"In a broader context of the host environment (test, livenet), you can also transfer CSPR tokens between accounts: let env = odra_casper_livenet_env::env(); //let env = odra_test::env(); let (alice, bob) = (env.get_account(0), env.get_account(1)); env.set_caller(alice); let result = env.transfer_tokens(bob, odra::casper_types::U512::from(100));  ","version":"2.1.0","tagName":"h2"},{"title":"Odra.toml","type":0,"sectionRef":"#","url":"/docs/2.1.0/basics/odra-toml","content":"","keywords":"","version":"2.1.0"},{"title":"Adding a new contract manually​","type":1,"pageTitle":"Odra.toml","url":"/docs/2.1.0/basics/odra-toml#adding-a-new-contract-manually","content":"Besides using the cargo odra generate command, you can add a new contract to be compiled by hand. To do this, add another [[contracts]] element, name it and make sure that the fqn is set correctly. For example, if you want to create a new contract called counter, your Odra.toml file should finally look like this: [[contracts]] fqn = &quot;sample::Flipper&quot; [[contracts]] fqn = &quot;sample::Counter&quot;  ","version":"2.1.0","tagName":"h2"},{"title":"What's next​","type":1,"pageTitle":"Odra.toml","url":"/docs/2.1.0/basics/odra-toml#whats-next","content":"In the next section, we'll take a closer look at the code that was generated by Odra by default - the famousFlipper contract. ","version":"2.1.0","tagName":"h2"},{"title":"Modules","type":0,"sectionRef":"#","url":"/docs/2.1.0/basics/modules","content":"","keywords":"","version":"2.1.0"},{"title":"Testing​","type":1,"pageTitle":"Modules","url":"/docs/2.1.0/basics/modules#testing","content":"As we don't need to hold addresses, the test is really simple: examples/src/features/modules.rs #[cfg(test)] mod tests { use super::ModulesContract; use odra::host::{Deployer, NoArgs}; #[test] fn test_modules() { let test_env = odra_test::env(); let modules_contract = ModulesContract::deploy(&amp;test_env, NoArgs); assert_eq!(modules_contract.add_using_module(), 8); } }  ","version":"2.1.0","tagName":"h2"},{"title":"What's next​","type":1,"pageTitle":"Modules","url":"/docs/2.1.0/basics/modules#whats-next","content":"We will see how to handle native token transfers. ","version":"2.1.0","tagName":"h2"},{"title":"Testing","type":0,"sectionRef":"#","url":"/docs/2.1.0/basics/testing","content":"","keywords":"","version":"2.1.0"},{"title":"HostEnv​","type":1,"pageTitle":"Testing","url":"/docs/2.1.0/basics/testing#hostenv","content":"Odra gives us some additional functions that we can use to communicate with the host (outside the contract context) and to configure how the contracts are deployed and called. Let's revisit the example from the previous article about host communication and implement the tests that prove it works: examples/src/features/testing.rs #[cfg(test)] mod tests { use crate::features::testing::{TestingContract, TestingContractInitArgs}; use odra::{host::{Deployer, HostEnv}, prelude::*}; #[test] fn env() { let test_env: HostEnv = odra_test::env(); test_env.set_caller(test_env.get_account(0)); let init_args = TestingContractInitArgs { name: &quot;MyContract&quot;.to_string() }; let testing_contract = TestingContract::deploy(&amp;test_env, init_args); let creator = testing_contract.created_by(); test_env.set_caller(test_env.get_account(1)); let init_args = TestingContractInitArgs { name: &quot;MyContract2&quot;.to_string() }; let testing_contract2 = TestingContract::deploy(&amp;test_env, init_args); let creator2 = testing_contract2.created_by(); assert_ne!(creator, creator2); } }  In the code above, at the beginning of the test, we are obtaining a HostEnv instance using odra_test::env(). Next, we are deploying two instances of the same contract, but we're using HostEnv::set_callerto change the caller - so the Address which is deploying the contract. This changes the result of the odra::ContractEnv::caller()the function we are calling inside the contract. HostEnv comes with a set of functions that will let you write better tests: fn set_caller(&amp;self, address: Address) - you've seen it in action just nowfn balance_of&lt;T: Addressable&gt;(&amp;self, addr: &amp;T) -&gt; U512 - returns the balance of the account associated with the given addressfn advance_block_time(&amp;self, time_diff: u64) - increases the current value of block_timefn get_account(&amp;self, n: usize) -&gt; Address - returns an n-th address that was prepared for you by Odra in advance; by default, you start with the 0-th accountfn emitted_event&lt;T: ToBytes + EventInstance, R: Addressable&gt;(&amp;self, contract_address: &amp;R, event: T) -&gt; bool - verifies if the event was emitted by the contract Full list of functions can be found in the HostEnv documentation. ","version":"2.1.0","tagName":"h2"},{"title":"What's next​","type":1,"pageTitle":"Testing","url":"/docs/2.1.0/basics/testing#whats-next","content":"We take a look at how Odra handles errors! ","version":"2.1.0","tagName":"h2"},{"title":"Storage interaction","type":0,"sectionRef":"#","url":"/docs/2.1.0/basics/storage-interaction","content":"","keywords":"","version":"2.1.0"},{"title":"Var​","type":1,"pageTitle":"Storage interaction","url":"/docs/2.1.0/basics/storage-interaction#var","content":"The Var is the simplest storage type available in the Odra framework. It serializes the data and stores it under a single key in the blockchain storage. To use it, just wrap your variable in the Var type. Let's look at a &quot;real world&quot; example of a contract that represents a dog: examples/src/features/storage/variable.rs use odra::prelude::*; #[odra::module] pub struct DogContract { barks: Var&lt;bool&gt;, weight: Var&lt;u32&gt;, name: Var&lt;String&gt;, walks: Var&lt;Vec&lt;u32&gt;&gt;, }  You can see the Var wrapping the data. Even complex types like Vec can be wrapped (with some caveats)! Let's make this contract usable, by providing a constructor and some getter functions: examples/src/features/storage/variable.rs #[odra::module] impl DogContract { pub fn init(&amp;mut self, barks: bool, weight: u32, name: String) { self.barks.set(barks); self.weight.set(weight); self.name.set(name); self.walks.set(Vec::&lt;u32&gt;::default()); } pub fn barks(&amp;self) -&gt; bool { self.barks.get_or_default() } pub fn weight(&amp;self) -&gt; u32 { self.weight.get_or_default() } pub fn name(&amp;self) -&gt; String { self.name.get_or_default() } pub fn walks_amount(&amp;self) -&gt; u32 { let walks = self.walks.get_or_default(); walks.len() as u32 } pub fn walks_total_length(&amp;self) -&gt; u32 { let walks = self.walks.get_or_default(); walks.iter().sum() } }  As you can see, you can access the data, by using get_or_default function: examples/src/features/storage/variable.rs ... self.barks.get_or_default() ...  note Keep in mind that using get() will result in an Option that you'll need to unwrap - the variable doesn't have to be initialized! To modify the data, use the set() function: examples/src/features/storage/variable.rs self.barks.set(barks);  A Var is easy to use and efficient for simple data types. One of its downsides is that it serializes the data as a whole, so when you're using complex types like Vec or HashMap, each time you get or set the whole data is read and written to the blockchain storage. In the example above, if we want to see how many walks our dog had, we would use the function: examples/src/features/storage/variable.rs pub fn walks_amount(&amp;self) -&gt; usize { let walks = self.walks.get_or_default(); walks.len() }  But to do so, we need to extract the whole serialized vector from the storage, which would inefficient, especially for larger sets of data. To tackle this issue following two types were created. ","version":"2.1.0","tagName":"h2"},{"title":"Mapping​","type":1,"pageTitle":"Storage interaction","url":"/docs/2.1.0/basics/storage-interaction#mapping","content":"The Mapping is used to store and access data as key-value pairs. To define a Mapping, you need to pass two values - the key type and the value type. Let's look at the variation of the Dog contract, that uses Mapping to store information about our dog's friends and how many times they visited: examples/src/features/storage/mapping.rs use odra::prelude::*; #[odra::module] pub struct DogContract2 { name: Var&lt;String&gt;, friends: Mapping&lt;String, u32&gt;, }  In the example above, our key is a String (it is a name of the friend) and we are storing u32 values (amount of visits). To read and write values from and into a Mapping we use a similar approach to the one shown in the Vars section with one difference - we need to pass a key: examples/src/features/storage/mapping.rs pub fn visit(&amp;mut self, friend_name: String) { let visits = self.visits(friend_name.clone()); self.friends.set(&amp;friend_name, visits + 1); } pub fn visits(&amp;self, friend_name: String) -&gt; u32 { self.friends.get_or_default(&amp;friend_name) }  The biggest improvement over a Var is that we can model functionality of a HashMap using Mapping. The amount of data written to and read from the storage is minimal. However, we cannot iterate over Mapping. We could implement such behavior by using a numeric type key and saving the length of the set in a separate variable. Thankfully Odra comes with a prepared solution - the List type. note If you take a look into List implementation in Odra, you'll see that in fact it is just a Mapping with a Var working together: core/src/list.rs use odra::prelude::*; pub struct List&lt;T&gt; { values: Mapping&lt;u32, T&gt;, index: Var&lt;u32&gt; }  ","version":"2.1.0","tagName":"h2"},{"title":"List​","type":1,"pageTitle":"Storage interaction","url":"/docs/2.1.0/basics/storage-interaction#list","content":"Going back to our DogContract example - let's revisit the walk case. This time, instead of Vec, we'll use the list: examples/src/features/storage/list.rs use odra::prelude::*; #[odra::module] pub struct DogContract3 { name: Var&lt;String&gt;, walks: List&lt;u32&gt;, }  As you can see, the notation is very similar to the Vec. To understand the usage, take a look at the reimplementation of the functions with an additional function that takes our dog for a walk (it writes the data to the storage): examples/src/features/storage/list.rs #[odra::module] impl DogContract3 { pub fn init(&amp;mut self, name: String) { self.name.set(name); } pub fn name(&amp;self) -&gt; String { self.name.get_or_default() } pub fn walks_amount(&amp;self) -&gt; u32 { self.walks.len() } pub fn walks_total_length(&amp;self) -&gt; u32 { self.walks.iter().sum() } pub fn walk_the_dog(&amp;mut self, length: u32) { self.walks.push(length); } }  Now, we can know how many walks our dog had without loading the whole vector from the storage. We need to do this to sum the length of all the walks, but the Odra framework cannot (yet) handle all the cases for you. info All of the above examples, alongside the tests, are available in the Odra repository in the examples/src/features/ folder. ","version":"2.1.0","tagName":"h2"},{"title":"Custom Types​","type":1,"pageTitle":"Storage interaction","url":"/docs/2.1.0/basics/storage-interaction#custom-types","content":"By default you can store only built-in types like numbers, Options, Results, Strings, Vectors. Implementing custom types is straightforward, your type must add #[odra::odra_type] attribute. Let's see how to implement a Dog type: use odra::prelude::*; #[odra::odra_type] pub struct Dog { pub name: String, pub age: u8, pub owner: Option&lt;Address&gt; }  #[odra_type] is applicable to named field structs and enums. It generates serialization, deserialization and schema code for your type.CLType of a custom type is CLType::Any, except for an unit-only enum, which is CLType::U8. unit_only_enum.rs enum Enum { Foo = 3, Bar = 2, Baz = 1, }  note Each custom typed field of your struct must be marked with the #[odra::odra_type] attribute . ","version":"2.1.0","tagName":"h2"},{"title":"What's next​","type":1,"pageTitle":"Storage interaction","url":"/docs/2.1.0/basics/storage-interaction#whats-next","content":"In the next article, we'll see how to query the host for information about the world and our contract. ","version":"2.1.0","tagName":"h2"},{"title":"odra-examples","type":0,"sectionRef":"#","url":"/docs/2.1.0/examples/odra-examples","content":"","keywords":"","version":"2.1.0"},{"title":"What's next​","type":1,"pageTitle":"odra-examples","url":"/docs/2.1.0/examples/odra-examples#whats-next","content":"Read the next article to learn about reusable Odra components encapsulated in odra-modules. ","version":"2.1.0","tagName":"h2"},{"title":"Odra for Solidity developers","type":0,"sectionRef":"#","url":"/docs/2.0.1/tutorials/odra-solidity","content":"","keywords":"","version":"2.0.1"},{"title":"Introduction​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.0.1/tutorials/odra-solidity#introduction","content":"Hi, stranger Solidity developer! If you are looking to expand your horizons into Rust-based smart contract development, you've come to the right place. Odra is a high-level framework designed to simplify the development of smart contracts for the Casper Network. This tutorial will guide you through the basics of transitioning from Solidity to Odra, highlighting key differences and providing practical examples. Before we delve into the details, we have great news for you. From the very beginning, we have been thinking of you. Our main goal was to design the framework in a way that flattens the learning curve, especially for Solidity developers. ","version":"2.0.1","tagName":"h2"},{"title":"Prerequisites​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.0.1/tutorials/odra-solidity#prerequisites","content":"To follow this guide, you should have: Knowledge of Solidity.Familiarity with Ethereum and smart contract concepts.Basic understanding of Rust, as Odra is based on it. ","version":"2.0.1","tagName":"h2"},{"title":"Hello World​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.0.1/tutorials/odra-solidity#hello-world","content":"Let's start with a simple &quot;Hello World&quot; contract in Odra. The following code snippet demonstrates a basic smart contract that stores a greeting message. OdraSolidity use odra::prelude::*; #[odra::module] pub struct HelloWorld { greet: Var&lt;String&gt;, } #[odra::module] impl HelloWorld { pub fn init(&amp;mut self, message: String) { self.greet.set(message); } pub fn get(&amp;self) -&gt; String { self.greet.get_or_default() } }  As you may have noticed, the Odra code is slightly more verbose than the Solidity code. To define a contract in Odra, you need to create a struct and implement a module for it, both annotated with the odra::module attribute. The struct contains the contract's state variables, while the module defines the contract's functions. In this example, the HelloWorld struct has a single state variable greet, which stores the greeting message. The module contains two functions: init to set the greeting message and get to retrieve it. Two key differences are: Odra does not generate getters for public state variables automatically, so you need to define them explicitly.To initialize values, you must do it in the init function, which is the contract constructor. You can't assign defaults outside the constructor. ","version":"2.0.1","tagName":"h2"},{"title":"Variable Storage and State Management​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.0.1/tutorials/odra-solidity#variable-storage-and-state-management","content":"","version":"2.0.1","tagName":"h2"},{"title":"Data Types​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.0.1/tutorials/odra-solidity#data-types","content":"OdraSolidity use core::str::FromStr; use odra::{casper_types::{bytesrepr::Bytes, U256}, prelude::*}; #[odra::module] pub struct Primitives { boo: Var&lt;bool&gt;, u: Var&lt;u8&gt;, // u8 is the smallest unsigned integer type u2: Var&lt;U256&gt;, // U256 is the biggest unsigned integer type i: Var&lt;i32&gt;, // i32 is the smallest signed integer type i2: Var&lt;i64&gt;, // i64 is the biggest signed integer type address: Var&lt;Address&gt;, bytes: Var&lt;Bytes&gt;, default_boo: Var&lt;bool&gt;, default_uint: Var&lt;U256&gt;, default_int: Var&lt;i64&gt;, default_addr: Var&lt;Address&gt;, } #[odra::module] impl Primitives { pub fn init(&amp;mut self) { self.boo.set(true); self.u.set(1); self.u2.set(U256::from(456)); self.i.set(-1); self.i2.set(456); self.address.set( Address::from_str( &quot;hash-d4b8fa492d55ac7a515c0c6043d72ba43c49cd120e7ba7eec8c0a330dedab3fb&quot;, ) .unwrap_or_revert(&amp;self.env()), ); self.bytes.set(Bytes::from(vec![0xb5])); let _min_int = U256::zero(); let _max_int = U256::MAX; } // For the types that have default values, we can use the get_or_default method pub fn get_default_boo(&amp;self) -&gt; bool { self.default_boo.get_or_default() } pub fn get_default_uint(&amp;self) -&gt; U256 { self.default_uint.get_or_default() } pub fn get_default_int(&amp;self) -&gt; i64 { self.default_int.get_or_default() } // Does not compile - Address does not have the default value pub fn get_default_addr(&amp;self) -&gt; Address { self.default_addr.get_or_default() } }  The range of integer types in Odra is slightly different from Solidity. Odra provides a wide range of integer types: u8, u16, u32, u64, U128, and U256 for unsigned integers, and i32 and i64 for signed integers. The Address type in Odra is used to represent account and contract addresses. In Odra, there is no default/zero value for the Address type; the workaround is to use Option&lt;Address&gt;. The Bytes type is used to store byte arrays. Values are stored in units called Named Keys and Dictionaries. Additionally, local variables are available within the entry points and can be used to perform necessary actions or computations within the scope of each entry point. ","version":"2.0.1","tagName":"h3"},{"title":"Constants and Immutability​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.0.1/tutorials/odra-solidity#constants-and-immutability","content":"OdraSolidity use odra::{casper_types::{account::AccountHash, U256}, prelude::*}; #[odra::module] pub struct Constants; #[odra::module] impl Constants { pub const MY_UINT: U256 = U256([123, 0, 0, 0]); pub const MY_ADDRESS: Address = Address::Account( AccountHash([0u8; 32]) ); }  In Odra, you can define constants using the const keyword. Constants are immutable and can be of any type, including custom types. In addition to constants, Solidity also supports the immutable keyword, which is used to set the value of a variable once, in the constructor. Further attempts to alter this value result in a compile error. Odra/Rust does not have an equivalent to Solidity's immutable keyword. ","version":"2.0.1","tagName":"h3"},{"title":"Variables​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.0.1/tutorials/odra-solidity#variables","content":"OdraSolidity use odra::{casper_types::U256, prelude::*}; #[odra::module] pub struct Variables { text: Var&lt;String&gt;, my_uint: Var&lt;U256&gt;, } #[odra::module] impl Variables { pub fn init(&amp;mut self) { self.text.set(&quot;Hello&quot;.to_string()); self.my_uint.set(U256::from(123)); } pub fn do_something(&amp;self) { // Local variables let i = 456; // Env variables let timestamp = self.env().get_block_time(); let sender = self.env().caller(); } }  In Solidity there are three types of variables: state variables, local variables, and global variables. State variables are stored on the blockchain and are accessible by all functions within the contract. Local variables are not stored on the blockchain and are only available within the function in which they are declared. Global variables provide information about the blockchain. Odra uses very similar concepts, but with some differences. In Odra, state variables are a part of a module definition, and local variables are available within the entry points and can be used to perform necessary actions or computations within the scope of each entry point. Global variables are accessed using an instance of ContractEnv retrieved using the env() function. ","version":"2.0.1","tagName":"h3"},{"title":"Arrays and Mappings​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.0.1/tutorials/odra-solidity#arrays-and-mappings","content":"OdraSolidity use odra::{casper_types::U256, prelude::*}; #[odra::module] pub struct MappingContract { my_map: Mapping&lt;Address, Option&lt;U256&gt;&gt; } #[odra::module] impl MappingContract { pub fn get(&amp;self, addr: Address) -&gt; U256 { // self.my_map.get(&amp;addr) would return Option&lt;Option&lt;U256&gt;&gt; // so we use get_or_default instead and unwrap the inner Option self.my_map.get_or_default(&amp;addr).unwrap_or_default() } pub fn set(&amp;mut self, addr: Address, i: U256) { self.my_map.set(&amp;addr, Some(i)); } pub fn remove(&amp;mut self, addr: Address) { self.my_map.set(&amp;addr, None); } } #[odra::module] pub struct NestedMapping { my_map: Mapping&lt;(Address, U256), Option&lt;bool&gt;&gt; } #[odra::module] impl NestedMapping { pub fn get(&amp;self, addr: Address, i: U256) -&gt; bool { self.my_map.get_or_default(&amp;(addr, i)).unwrap_or_default() } pub fn set(&amp;mut self, addr: Address, i: U256, boo: bool) { self.my_map.set(&amp;(addr, i), Some(boo)); } pub fn remove(&amp;mut self, addr: Address, i: U256) { self.my_map.set(&amp;(addr, i), None); } }  OdraSolidity use odra::prelude::*; #[odra::module] pub struct Array { // the size of the array must be known at compile time arr: Var&lt;[u8; 10]&gt;, vec: Var&lt;Vec&lt;u32&gt;&gt;, } #[odra::module] impl Array { pub fn init(&amp;mut self) { self.arr.set([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]); self.vec.set(vec![1, 2, 3, 4, 5]); } pub fn get_arr(&amp;self) -&gt; [u8; 10] { self.arr.get_or_default() } pub fn push_vec(&amp;mut self, value: u32) { let mut vec = self.vec.get_or_default(); vec.push(value); self.vec.set(vec); } pub fn pop_vec(&amp;mut self) { let mut vec = self.vec.get_or_default(); vec.pop(); self.vec.set(vec); } pub fn update_arr(&amp;mut self, index: u8, value: u8) { let mut arr = self.arr.get_or_default(); arr[index as usize] = value; self.arr.set(arr); } }  For storing a collection of data as a single unit, Odra uses the Vec type for dynamic arrays and fixed-size arrays, both wrapped with the Var container. As in Solidity, you must be aware that reading the entire array in one go can be expensive, so it's better to avoid it for large arrays. In many cases, you can use a Mapping or List instead of an array or vector to store data. ","version":"2.0.1","tagName":"h3"},{"title":"Custom types​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.0.1/tutorials/odra-solidity#custom-types","content":"OdraSolidity use odra::prelude::*; #[odra::odra_type] #[derive(Default)] pub enum Status { #[default] Pending, Shipped, Accepted, Rejected, Canceled, } #[odra::module] pub struct Enum { status: Var&lt;Status&gt;, } #[odra::module] impl Enum { pub fn get(&amp;self) -&gt; Status { self.status.get_or_default() } pub fn set(&amp;mut self, status: Status) { self.status.set(status); } pub fn cancel(&amp;mut self) { self.status.set(Status::Canceled); } pub fn reset(&amp;mut self) { self.status.set(Default::default()); } }  In Odra, custom types are defined using the #[odra::odra_type] attribute. The enum can have a default value specified using the #[default] attribute if derived from the Default trait. The enum can be used as a state variable in a contract, and its value can be set and retrieved using the set and get functions. The value cannot be deleted; however, it can be set using the Default::default() function. OdraSolidity use odra::prelude::*; #[odra::odra_type] pub struct Todo { text: String, completed: bool, } #[odra::module] pub struct Enum { // You could also use Var&lt;Vec&lt;Todo&gt;&gt; instead of List&lt;Todo&gt;, // but List is more efficient for large arrays, // it loads items lazily. todos: List&lt;Todo&gt;, } #[odra::module] impl Enum { pub fn create(&amp;mut self, text: String) { self.todos.push(Todo { text, completed: false, }); } pub fn update_text(&amp;mut self, index: u32, text: String) { if let Some(mut todo) = self.todos.get(index) { todo.text = text; self.todos.replace(index, todo); } } pub fn toggle_complete(&amp;mut self, index: u32) { if let Some(mut todo) = self.todos.get(index) { todo.completed = !todo.completed; self.todos.replace(index, todo); } } // Odra does not create getters by default pub fn get(&amp;self, index: u32) -&gt; Option&lt;Todo&gt; { self.todos.get(index) } }  Similarly to enums, custom structs are defined using the #[odra::odra_type] attribute. The struct can be used to define a list of items in a contract. The list can be created using the List type, which is more efficient for large arrays as it loads items lazily. ","version":"2.0.1","tagName":"h3"},{"title":"Data Location​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.0.1/tutorials/odra-solidity#data-location","content":"In Solidity, data location is an important concept that determines where the data is stored and how it can be accessed. The data location can be memory, storage, or calldata. In Odra, data location is not explicitly defined, but whenever interacting with storage primitives (e.g., Var, Mapping, List), the data is stored in the contract's storage. ","version":"2.0.1","tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.0.1/tutorials/odra-solidity#functions","content":"Odra contracts define their entry point and internal functions within the impl block. Here's an example of a transfer function: impl Erc20 { pub fn transfer(&amp;mut self, recipient: &amp;Address, amount: &amp;U256) { self.internal_transfer(&amp;self.env().caller(), recipient, amount); // Transfer logic goes here } fn internal_transfer(&amp;mut self, sender: &amp;Address, recipient: &amp;Address, amount: &amp;U256) { // Internal transfer logic goes here } }  Functions can modify contract state and emit events using the ContractEnv function. ","version":"2.0.1","tagName":"h2"},{"title":"View and Pure​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.0.1/tutorials/odra-solidity#view-and-pure","content":"OdraSolidity use odra::prelude::*; #[odra::module] pub struct ViewAndPure { x: Var&lt;u32&gt; } #[odra::module] impl ViewAndPure { pub fn add_to_x(&amp;self, y: u32) -&gt; u32 { self.x.get_or_default() + y } } pub fn add(i: u32, j: u32) -&gt; u32 { i + j }  In Odra, you don't need to specify view or pure functions explicitly. All functions are considered view functions by default, meaning they can read contract state but not modify it. To modify the state, the first parameter (called the receiver parameter) should be &amp;mut self. If you want to create a pure function that doesn't read or modify state, you can define it as a regular Rust function without any side effects. ","version":"2.0.1","tagName":"h3"},{"title":"Modifiers​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.0.1/tutorials/odra-solidity#modifiers","content":"OdraSolidity use odra::prelude::*; #[odra::module] pub struct FunctionModifier { x: Var&lt;u32&gt;, locked: Var&lt;bool&gt;, } #[odra::module] impl FunctionModifier { pub fn decrement(&amp;mut self, i: u32) { self.lock(); self.x.set(self.x.get_or_default() - i); if i &gt; 1 { self.decrement(i - 1); } self.unlock(); } #[inline] fn lock(&amp;mut self) { if self.locked.get_or_default() { self.env().revert(Error::NoReentrancy); } self.locked.set(true); } #[inline] fn unlock(&amp;mut self) { self.locked.set(false); } } #[odra::odra_error] pub enum Error { NoReentrancy = 1, }  In Odra, there is no direct equivalent to Solidity's function modifiers. Instead, you can define functions that perform certain actions before or after the main function logic. In the example above, the lock and unlock functions are called before and after the decrement function, respectively, but they must be called explicitly. As often as practicable, developers should inline functions by including the body of the function within their code using the #[inline] attribute. In the context of coding for Casper blockchain purposes, this reduces the overhead of executed Wasm and prevents unexpected errors due to exceeding resource tolerances. ","version":"2.0.1","tagName":"h3"},{"title":"Visibility​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.0.1/tutorials/odra-solidity#visibility","content":"Functions and state variables have to declare whether they are accessible by other contracts. Functions can be declared as: OdraSolidity `pub` inside `#[odra::module]` impl block - any contract/submodule and account can call. `pub` inside a regular impl block - any submodule can call. `default/no modifier/private` - only inside the contract that defines the function.  ","version":"2.0.1","tagName":"h3"},{"title":"Payable​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.0.1/tutorials/odra-solidity#payable","content":"OdraSolidity use odra::{casper_types::U512, prelude::*}; #[odra::module] pub struct Payable { owner: Var&lt;Address&gt;, } #[odra::module] impl Payable { pub fn init(&amp;mut self) { self.owner.set(self.env().caller()); } #[odra(payable)] pub fn deposit(&amp;self) { } pub fn not_payable(&amp;self) { } pub fn withdraw(&amp;self) { let amount = self.env().self_balance(); self.env().transfer_tokens(&amp;self.owner.get_or_revert_with(ExecutionError::UnwrapError), &amp;amount); } pub fn transfer(&amp;self, to: Address, amount: U512) { self.env().transfer_tokens(&amp;to, &amp;amount); } }  In Odra, you can define a function with the #[odra(payable)] attribute to indicate that the function can receive CSPRs. In Solidity, the payable keyword is used to define functions that can receive Ether. ","version":"2.0.1","tagName":"h3"},{"title":"Selectors​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.0.1/tutorials/odra-solidity#selectors","content":"In Solidity, when a function is called, the first 4 bytes of calldata specify which function to call. This is called a function selector. contract_addr.call( abi.encodeWithSignature(&quot;transfer(address,uint256)&quot;, address, 1234) )  Odra does not support such a mechanism. You must have access to the contract interface to call a function. ","version":"2.0.1","tagName":"h3"},{"title":"Events and Logging​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.0.1/tutorials/odra-solidity#events-and-logging","content":"OdraSolidity use odra::prelude::*; #[odra::event] pub struct Log { sender: Address, message: String, } #[odra::event] pub struct AnotherLog {} #[odra::module] struct Event; #[odra::module] impl Event { pub fn test(&amp;self) { let env = self.env(); env.emit_event(Log { sender: env.caller(), message: &quot;Hello World!&quot;.to_string(), }); env.emit_event(Log { sender: env.caller(), message: &quot;Hello Casper!&quot;.to_string(), }); env.emit_event(AnotherLog {}); } }  In Odra, events are regular structs defined using the #[odra::event] attribute. The event struct can contain multiple fields, which can be of any type (primitive or custom Odra type). To emit an event, use the env's emit_event() function, passing the event struct as an argument. note Events in Solidity are used to emit logs that off-chain services can capture. However, Casper does not support events natively. Odra mimics this feature. Read more about it in the Basics section. ","version":"2.0.1","tagName":"h2"},{"title":"Error Handling​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.0.1/tutorials/odra-solidity#error-handling","content":"OdraSolidity use odra::{prelude::*, casper_types::{U256, U512}}; #[odra::odra_error] pub enum CustomError { InsufficientBalance = 1, InputLowerThanTen = 2, } #[odra::module] pub struct Error; #[odra::module] impl Error { pub fn test_require(&amp;mut self, i: U256) { if i &lt;= 10.into() { self.env().revert(CustomError::InputLowerThanTen); } } pub fn execute_external_call(&amp;self, withdraw_amount: U512) { let balance = self.env().self_balance(); if balance &lt; withdraw_amount { self.env().revert(CustomError::InsufficientBalance); } } }  In Solidity, there are four ways to handle errors: require, revert, assert, and custom errors. In Odra, there is only one way to revert the execution of a function - by using the env().revert() function. The function takes an error type as an argument and stops the execution of the function. You define an error type using the #[odra::odra_error] attribute. On Casper, an error is only a number, so you can't pass a message with the error. ","version":"2.0.1","tagName":"h2"},{"title":"Composition vs. Inheritance​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.0.1/tutorials/odra-solidity#composition-vs-inheritance","content":"In Solidity, developers often use inheritance to reuse code and establish relationships between contracts. However, Odra and Rust follow a different paradigm known as composition. Instead of inheriting behavior from parent contracts, Odra encourages the composition of contracts by embedding one contract within another. Let's take a look at the difference between inheritance in Solidity and composition in Odra. OdraSolidity use odra::prelude::*; #[odra::module] pub struct A; #[odra::module] impl A { pub fn foo(&amp;self) -&gt; String { &quot;A&quot;.to_string() } } #[odra::module] pub struct B { a: SubModule&lt;A&gt; } #[odra::module] impl B { pub fn foo(&amp;self) -&gt; String { &quot;B&quot;.to_string() } } #[odra::module] pub struct C { a: SubModule&lt;A&gt; } #[odra::module] impl C { pub fn foo(&amp;self) -&gt; String { &quot;C&quot;.to_string() } } #[odra::module] pub struct D { b: SubModule&lt;B&gt;, c: SubModule&lt;C&gt; } #[odra::module] impl D { pub fn foo(&amp;self) -&gt; String { self.c.foo() } } #[odra::module] pub struct E { b: SubModule&lt;B&gt;, c: SubModule&lt;C&gt; } #[odra::module] impl E { pub fn foo(&amp;self) -&gt; String { self.b.foo() } } #[odra::module] pub struct F { a: SubModule&lt;A&gt;, b: SubModule&lt;B&gt;, } #[odra::module] impl F { pub fn foo(&amp;self) -&gt; String { self.a.foo() } }  Solidity supports both single and multiple inheritance. This means a contract can inherit from one or more contracts. Solidity uses a technique called &quot;C3 linearization&quot; to resolve the order in which base contracts are inherited in the case of multiple inheritance. This helps to ensure a consistent method resolution order. However, multiple inheritance can lead to complex code and potential issues, especially for inexperienced developers. In contrast, Rust does not have a direct equivalent to the inheritance model, but it achieves similar goals through composition. Each contract is defined as a struct, and contracts can be composed by embedding one struct within another. This approach provides a more flexible and modular way to reuse code and establish relationships between contracts. ","version":"2.0.1","tagName":"h2"},{"title":"Libraries and Utility​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.0.1/tutorials/odra-solidity#libraries-and-utility","content":"OdraSolidity use odra::{casper_types::U256, prelude::*}; mod math { use odra::casper_types::U256; pub fn sqrt(y: U256) -&gt; U256 { let mut z = y; if y &gt; 3.into() { let mut x = y / 2 + 1; while x &lt; z { z = x; x = (y / x + x) / 2; } } else if y != U256::zero() { z = U256::one(); } z } } #[odra::module] struct TestMath; #[odra::module] impl TestMath { pub fn test_square_root(&amp;self, x: U256) -&gt; U256 { math::sqrt(x) } } #[odra::odra_error] enum Error { EmptyArray = 100, } trait Removable { fn remove(&amp;mut self, index: usize); } impl Removable for Var&lt;Vec&lt;U256&gt;&gt; { fn remove(&amp;mut self, index: usize) { let env = self.env(); let mut vec = self.get_or_default(); if vec.is_empty() { env.revert(Error::EmptyArray); } vec[index] = vec.pop().unwrap_or_revert(&amp;env); self.set(vec); } } #[odra::module] struct TestArray { arr: Var&lt;Vec&lt;U256&gt;&gt;, } #[odra::module] impl TestArray { pub fn test_array_remove(&amp;mut self) { let mut arr = self.arr.get_or_default(); for i in 0..3 { arr.push(i.into()); } self.arr.set(arr); self.arr.remove(1); let arr = self.arr.get_or_default(); assert_eq!(arr.len(), 2); assert_eq!(arr[0], 0.into()); assert_eq!(arr[1], 2.into()); } }  In Solidity, libraries are similar to contracts but can't declare any state variables and can't receive Ether. In the sample code above, the Math library contains a square root function, while the Array library provides a function to remove an element from an array. Both libraries are consumed in different ways: the TestMath contract calls the sqrt function directly, while the TestArray contract uses the using keyword, which extends the type uint256[] by adding the remove function. In Odra, you use language-level features: modules and traits. The mod keyword defines a module, which is similar to a library in Solidity. Modules can contain functions, types, and other items that can be reused across multiple contracts. Traits are similar to interfaces in other programming languages, defining a set of functions that a type must implement. Implementing the Removable trait for the Var&lt;Vec&lt;U256&gt;&gt; type allows the remove function to be called on a variable that stores a vector of U256 values. ","version":"2.0.1","tagName":"h2"},{"title":"Fallback and Receive Functions​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.0.1/tutorials/odra-solidity#fallback-and-receive-functions","content":"In Solidity, a contract receiving Ether must implement a receive() and/or fallback() function. The receive() function is called when Ether is sent to the contract with no data, while the fallback() function is called when the contract receives Ether with data or when a function that does not exist is called. Odra does not have a direct equivalent to the receive() and fallback() functions. Instead, you can define a function with the #[odra(payable)] attribute to indicate that the function can receive CSPRs. ","version":"2.0.1","tagName":"h2"},{"title":"Miscellaneous​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.0.1/tutorials/odra-solidity#miscellaneous","content":"","version":"2.0.1","tagName":"h2"},{"title":"Hashing​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.0.1/tutorials/odra-solidity#hashing","content":"OdraSolidity use odra::{casper_types::{bytesrepr::ToBytes, U256}, prelude::*}; #[odra::module] pub struct HashFunction; #[odra::module] impl HashFunction { pub fn hash(&amp;self, text: String, num: U256, addr: Address) -&gt; [u8; 32] { let env = self.env(); let mut data = Vec::new(); data.extend(text.to_bytes().unwrap_or_revert(&amp;env)); data.extend(num.to_bytes().unwrap_or_revert(&amp;env)); data.extend(addr.to_bytes().unwrap_or_revert(&amp;env)); env.hash(data) } } #[odra::module] pub struct GuessTheMagicWord { answer: Var&lt;[u8; 32]&gt;, } #[odra::module] impl GuessTheMagicWord { /// Initializes the contract with the magic word hash. pub fn init(&amp;mut self) { self.answer.set([ 0x86, 0x67, 0x15, 0xbb, 0x0b, 0x96, 0xf1, 0x06, 0xe0, 0x68, 0x07, 0x89, 0x22, 0x84, 0x42, 0x81, 0x19, 0x6b, 0x1e, 0x61, 0x45, 0x50, 0xa5, 0x70, 0x4a, 0xb0, 0xa7, 0x55, 0xbe, 0xd7, 0x56, 0x08, ]); } /// Checks if the `word` is the magic word. pub fn guess(&amp;self, word: String) -&gt; bool { let env = self.env(); let hash = env.hash(word.to_bytes().unwrap_or_revert(&amp;env)); hash == self.answer.get_or_default() } }  The key difference between the two is that in Solidity, the keccak256 function is used to hash data, while in Odra, the env.hash() function is used, which implements the blake2b algorithm. Both functions take a byte array as input and return a 32-byte hash. ","version":"2.0.1","tagName":"h3"},{"title":"Try-catch​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.0.1/tutorials/odra-solidity#try-catch","content":"OdraSolidity use odra::prelude::*; #[odra::module] pub struct Example { other_contract: External&lt;OtherContractContractRef&gt;, } #[odra::module] impl Example { pub fn init(&amp;mut self, other_contract: Address) { self.other_contract.set(other_contract); } pub fn execute_external_call(&amp;self) { let result = self.other_contract.some_function(); match result { Ok(success) =&gt; { // Code to execute if the external call was successful } Err(reason) =&gt; { // Code to execute if the external call failed } } } } #[odra::module] pub struct OtherContract; #[odra::module] impl OtherContract { pub fn some_function(&amp;self) -&gt; Result&lt;bool, ()&gt; { Ok(true) } }  In Solidity, try/catch is a feature that allows developers to handle exceptions and errors more gracefully. The try/catch statement allows developers to catch and handle exceptions that occur during external function calls and contract creation. In Odra, there is no direct equivalent to the try/catch statement in Solidity. However, you can use the Result type to handle errors in a similar way. The Result type is an enum that represents either success (Ok) or failure (Err). You can use the match statement to handle the Result type and execute different code based on the result. However, if an unexpected error occurs on the way, the whole transaction reverts. ","version":"2.0.1","tagName":"h3"},{"title":"Conclusion​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.0.1/tutorials/odra-solidity#conclusion","content":"Congratulations! You've now learned the main differences in writing smart contracts with the Odra Framework. By understanding the structure, initialization, error handling, and the composition pattern in Odra, you can effectively transition from Solidity to Odra for Casper blockchain development. Experiment with the provided code samples, explore more advanced features, and unleash the full potential of the Odra Framework. Read more about the Odra Framework in the Basics and Advanced sections. Learn by example with our Tutorial series, you will find there a contract you likely familiar with - the Erc20 standard implementation. If you have any further questions or need clarification on specific topics, feel free to join our Discord! ","version":"2.0.1","tagName":"h2"},{"title":"Installation","type":0,"sectionRef":"#","url":"/docs/2.1.0/getting-started/installation","content":"","keywords":"","version":"2.1.0"},{"title":"Prerequisites​","type":1,"pageTitle":"Installation","url":"/docs/2.1.0/getting-started/installation#prerequisites","content":"To start working with Odra, you need to have the following installed on your machine: Rust toolchain installed (see rustup.rs)wasmstrip tool installed (see wabt)wasm-opt tool installed (see binaryen) We do not provide exact commands for installing these tools, as they are different for different operating systems. Please refer to the documentation of the tools themselves. With Rust toolchain ready, you can add a new target: rustup target add wasm32-unknown-unknown  note wasm32-unknown-unknown is a target that will be used by Odra to compile your smart contracts to WASM files. ","version":"2.1.0","tagName":"h2"},{"title":"Installing Cargo Odra​","type":1,"pageTitle":"Installation","url":"/docs/2.1.0/getting-started/installation#installing-cargo-odra","content":"Cargo Odra is a helpful tool that will help you to build and test your smart contracts. It is not required to use Odra, but the documentation will assume that you have it installed. To install it, simply execute the following command: cargo install cargo-odra --locked  To check if it was installed correctly and see available commands, type: cargo odra --help  If everything went fine, we can proceed to the next step. ","version":"2.1.0","tagName":"h2"},{"title":"Creating a new Odra project​","type":1,"pageTitle":"Installation","url":"/docs/2.1.0/getting-started/installation#creating-a-new-odra-project","content":"To create a new project, simply execute: cargo odra new --name my-project &amp;&amp; cd my_project  This will create a new folder called my_project and initialize Odra there. Cargo Odra will create a sample contract for you in src directory. You can run the tests of this contract by executing: cargo odra test  This will run tests using Odra's internal OdraVM. You can run those tests against a real backend, let's use CasperVM: cargo odra test -b casper  Congratulations! Now you are ready to create contracts using Odra framework! If you had any problems during the installation process, feel free to ask for help on our Discord. ","version":"2.1.0","tagName":"h2"},{"title":"What's next?​","type":1,"pageTitle":"Installation","url":"/docs/2.1.0/getting-started/installation#whats-next","content":"If you want to see the code that you just tested, continue to the description of Flipper example. ","version":"2.1.0","tagName":"h2"},{"title":"Flipper example","type":0,"sectionRef":"#","url":"/docs/2.1.0/getting-started/flipper","content":"","keywords":"","version":"2.1.0"},{"title":"Let's flip​","type":1,"pageTitle":"Flipper example","url":"/docs/2.1.0/getting-started/flipper#lets-flip","content":"flipper.rs use odra::prelude::*; /// A module definition. Each module struct consists Vars and Mappings /// or/and another modules. #[odra::module] pub struct Flipper { /// The module itself does not store the value, /// it's a proxy that writes/reads value to/from the host. value: Var&lt;bool&gt;, } /// Module implementation. /// /// To generate entrypoints, /// an implementation block must be marked as #[odra::module]. #[odra::module] impl Flipper { /// Odra constructor. /// /// Initializes the contract. pub fn init(&amp;mut self) { self.value.set(false); } /// Replaces the current value with the passed argument. pub fn set(&amp;mut self, value: bool) { self.value.set(value); } /// Replaces the current value with the opposite value. pub fn flip(&amp;mut self) { self.value.set(!self.get()); } /// Retrieves value from the storage. /// If the value has never been set, the default value is returned. pub fn get(&amp;self) -&gt; bool { self.value.get_or_default() } } #[cfg(test)] mod tests { use crate::flipper::Flipper; use odra::host::{Deployer, NoArgs}; #[test] fn flipping() { let env = odra_test::env(); // To test a module we need to deploy it. `Flipper` implements `Deployer` trait, // so we can use it to deploy the module. let mut contract = Flipper::deploy(&amp;env, NoArgs); assert!(!contract.get()); contract.flip(); assert!(contract.get()); } }  ","version":"2.1.0","tagName":"h2"},{"title":"Testing​","type":1,"pageTitle":"Flipper example","url":"/docs/2.1.0/getting-started/flipper#testing","content":"To run the tests, execute the following command: cargo odra test # or add the `-b casper` flag to run tests on the CasperVM  ","version":"2.1.0","tagName":"h2"},{"title":"What's next​","type":1,"pageTitle":"Flipper example","url":"/docs/2.1.0/getting-started/flipper#whats-next","content":"In the next category of articles, we will go through basic concepts of Odra. ","version":"2.1.0","tagName":"h2"},{"title":"Using odra-modules","type":0,"sectionRef":"#","url":"/docs/2.1.0/examples/using-odra-modules","content":"","keywords":"","version":"2.1.0"},{"title":"Available modules​","type":1,"pageTitle":"Using odra-modules","url":"/docs/2.1.0/examples/using-odra-modules#available-modules","content":"Odra modules comes with couple of ready-to-use modules and reusable extensions. ","version":"2.1.0","tagName":"h2"},{"title":"Tokens​","type":1,"pageTitle":"Using odra-modules","url":"/docs/2.1.0/examples/using-odra-modules#tokens","content":"CEP-18​ Casper Ecosystem Proposal 18 (CEP-18) is a standard interface for the CSPR and the custom made tokens. Inspired by the ERC20 standard. Read more about the CEP-18 here. CEP-95​ Casper Ecosystem Proposal 95 (CEP-95) is a Casper NFT Standard. It aims to replace CEP-47 and CEP-78, which have flaws that complicate their support in the ecosystem. This standard is aligned with Ethereum's ERC-721, but makes adjustments relevant for the Casper Ecosystem. Similarly to ERC-721, this standard can be used to represent a various range of tokenized assets Read more about the CEP-95 here. Erc20​ The Erc20 module implements the ERC20 standard. Erc721​ The Erc721Base module implements the ERC721 standard, adjusted for the Odra framework. The Erc721Token module implements the ERC721Base and additionally uses the Erc721Metadata and Ownable extensions. The Erc721Receiver trait lets you implement your own logic for receiving NFTs. The OwnedErc721WithMetadata trait is a combination of Erc721Token, Erc721Metadata and Ownable modules. Erc1155​ The Erc1155Base module implements the ERC1155 standard, adjusted for the Odra framework. The Erc1155Token module implements the ERC1155Base and additionally uses the Ownable extension. The OwnedErc1155 trait is a combination of Erc1155Token and Ownable modules. Wrapped native token​ The WrappedNativeToken module implements the Wrapper for the native token, it was inspired by the WETH. ","version":"2.1.0","tagName":"h3"},{"title":"Access​","type":1,"pageTitle":"Using odra-modules","url":"/docs/2.1.0/examples/using-odra-modules#access","content":"AccessControl​ This module enables the implementation of role-based access control mechanisms for children modules. Roles are identified by their 32-bytes identifier, which should be unique and exposed in the external API. Ownable​ This module provides a straightforward access control feature that enables exclusive access to particular functions by an account, known as the owner. The account that initiates the module is automatically assigned as the owner. However, ownership can be transferred later by using thetransfer_ownership() function. Ownable2Step​ An extension of the Ownable module. Ownership can be transferred in a two-step process by using transfer_ownership() and accept_ownership() functions. ","version":"2.1.0","tagName":"h3"},{"title":"Security​","type":1,"pageTitle":"Using odra-modules","url":"/docs/2.1.0/examples/using-odra-modules#security","content":"Pausable​ A module allowing to implement an emergency stop mechanism that can be triggered by any account. ","version":"2.1.0","tagName":"h3"},{"title":"Migration guide to v1.3.0","type":0,"sectionRef":"#","url":"/docs/2.1.0/migrations/to-1.3.0","content":"","keywords":"","version":"2.1.0"},{"title":"Migrating to Odra v1.3.0​","type":1,"pageTitle":"Migration guide to v1.3.0","url":"/docs/2.1.0/migrations/to-1.3.0#migrating-to-odra-v130","content":"To migrate your smart contracts to Odra v1.3.0, remove the use the deploy method from the module instead of the {{ModuleName}}HostRef struct: before.rs let token = TokenHostRef::deploy(env, init_args); let another_token = AnotherTokenHostRef::load(env, address);  after.rs let token = Token::deploy(env, init_args); let another_token = AnotherToken::load(env, address);  ","version":"2.1.0","tagName":"h2"},{"title":"Migration guide to v2.0.0 from 1.*","type":0,"sectionRef":"#","url":"/docs/2.1.0/migrations/to-2.0.0","content":"","keywords":"","version":"2.1.0"},{"title":"Updating rustc version​","type":1,"pageTitle":"Migration guide to v2.0.0 from 1.*","url":"/docs/2.1.0/migrations/to-2.0.0#updating-rustc-version","content":"Update rust-toolchain file in your project: nightly-2024-07-31  ","version":"2.1.0","tagName":"h2"},{"title":"Migration guide to v2.1.0 from 2.0.*","type":0,"sectionRef":"#","url":"/docs/2.1.0/migrations/to-2.1.0","content":"","keywords":"","version":"2.1.0"},{"title":"Updating the test code​","type":1,"pageTitle":"Migration guide to v2.1.0 from 2.0.*","url":"/docs/2.1.0/migrations/to-2.1.0#updating-the-test-code","content":"Function that required an event reference as an argument has been changed to accept an event type instead. before.rs assert!(test_env.emitted_event( &amp;party_contract, &amp;PartyStarted { caller: test_env.get_account(0), block_time: 0 } ));  after.rs assert!(test_env.emitted_event( &amp;party_contract, PartyStarted { caller: test_env.get_account(0), block_time: 0 } ));  In the previous version, the HostRef and Addressable traits both included a function called address, which may have caused confusion and led to exporting the address function from the wrong trait. In the updated version, address is now defined only in the Addressable trait, while the HostRef trait provides a separate function called contract_address instead. ","version":"2.1.0","tagName":"h2"},{"title":"Access Control","type":0,"sectionRef":"#","url":"/docs/2.1.0/tutorials/access-control","content":"","keywords":"","version":"2.1.0"},{"title":"Code​","type":1,"pageTitle":"Access Control","url":"/docs/2.1.0/tutorials/access-control#code","content":"Before we start writing code, we list the functionalities of our access control layer. A Role type is used across the module.A Role can be assigned to many Addresses.Each Role may have a corresponding admin role.Only an admin can grant/revoke a Role.A Role can be renounced.A Role cannot be renounced on someone's behalf.Each action triggers an event.Unauthorized access stops contract execution. ","version":"2.1.0","tagName":"h2"},{"title":"Project Structure​","type":1,"pageTitle":"Access Control","url":"/docs/2.1.0/tutorials/access-control#project-structure","content":"access-control ├── src │ ├── access │ │ ├── access_control.rs │ │ ├── events.rs │ │ └── errors.rs │ └── lib.rs |── build.rs |── Cargo.toml └── Odra.toml  ","version":"2.1.0","tagName":"h3"},{"title":"Events and Errors​","type":1,"pageTitle":"Access Control","url":"/docs/2.1.0/tutorials/access-control#events-and-errors","content":"There are three actions that can be performed concerning a Role: granting, revoking, and altering the admin role. Let us establish standard Odra events for each of these actions. events.rs use odra::prelude::*; use super::access_control::Role; #[odra::event] pub struct RoleGranted { pub role: Role, pub address: Address, pub sender: Address } #[odra::event] pub struct RoleRevoked { pub role: Role, pub address: Address, pub sender: Address } #[odra::event] pub struct RoleAdminChanged { pub role: Role, pub previous_admin_role: Role, pub new_admin_role: Role }  L4-L16 - to describe the grant or revoke actions, our events specify the Role, and Addresses indicating who receives or loses access and who provides or withdraws it.L18-L23 - the event describing the admin role change, requires the subject Role, the previous and the current admin Role. errors.rs #[odra::odra_error] pub enum Error { MissingRole = 20_000, RoleRenounceForAnotherAddress = 20_001, }  Errors definition is straightforward - there are only two invalid states: An action is triggered by an unauthorized actor.The caller is attempting to resign the Role on someone's behalf.  ","version":"2.1.0","tagName":"h3"},{"title":"Module​","type":1,"pageTitle":"Access Control","url":"/docs/2.1.0/tutorials/access-control#module","content":"Now, we are stepping into the most interesting part: the module definition and implementation. access_control.rs use super::events::*; use super::errors::Error; use odra::prelude::*; pub type Role = [u8; 32]; pub const DEFAULT_ADMIN_ROLE: Role = [0u8; 32]; #[odra::module(events = [RoleAdminChanged, RoleGranted, RoleRevoked], errors = Error)] pub struct AccessControl { roles: Mapping&lt;(Role, Address), bool&gt;, role_admin: Mapping&lt;Role, Role&gt; } #[odra::module] impl AccessControl { pub fn has_role(&amp;self, role: &amp;Role, address: &amp;Address) -&gt; bool { self.roles.get_or_default(&amp;(*role, *address)) } pub fn get_role_admin(&amp;self, role: &amp;Role) -&gt; Role { let admin_role = self.role_admin.get(role); if let Some(admin) = admin_role { admin } else { DEFAULT_ADMIN_ROLE } } pub fn grant_role(&amp;mut self, role: &amp;Role, address: &amp;Address) { self.check_role(&amp;self.get_role_admin(role), &amp;self.env().caller()); self.unchecked_grant_role(role, address); } pub fn revoke_role(&amp;mut self, role: &amp;Role, address: &amp;Address) { self.check_role(&amp;self.get_role_admin(role), &amp;self.env().caller()); self.unchecked_revoke_role(role, address); } pub fn renounce_role(&amp;mut self, role: &amp;Role, address: &amp;Address) { if address != &amp;self.env().caller() { self.env().revert(Error::RoleRenounceForAnotherAddress); } self.unchecked_revoke_role(role, address); } } impl AccessControl { pub fn check_role(&amp;self, role: &amp;Role, address: &amp;Address) { if !self.has_role(role, address) { self.env().revert(Error::MissingRole); } } pub fn set_admin_role(&amp;mut self, role: &amp;Role, admin_role: &amp;Role) { let previous_admin_role = self.get_role_admin(role); self.role_admin.set(role, *admin_role); self.env().emit_event(RoleAdminChanged { role: *role, previous_admin_role, new_admin_role: *admin_role }); } pub fn unchecked_grant_role(&amp;mut self, role: &amp;Role, address: &amp;Address) { if !self.has_role(role, address) { self.roles.set(&amp;(*role, *address), true); self.env().emit_event(RoleGranted { role: *role, address: *address, sender: self.env().caller() }); } } pub fn unchecked_revoke_role(&amp;mut self, role: &amp;Role, address: &amp;Address) { if self.has_role(role, address) { self.roles.set(&amp;(*role, *address), false); self.env().emit_event(RoleRevoked { role: *role, address: *address, sender: self.env().caller() }); } } }  L5 - Firstly, we need the Role type. It is simply an alias for a 32-byte array.L7 - The default role is an array filled with zeros.L10-L13 - The storage consists of two mappings: roles - a nested mapping that stores information about whether a certain Role is granted to a given Address.role_admin - each Role can have a single admin Role. L17-L19 - This is a simple check to determine if a Role has been granted to a given Address. It is an exposed entry point and an important building block widely used throughout the entire module.L48 - This is a non-exported block containing helper functions.L49-L53 - The check_role() function serves as a guard function. Before a Role is granted or revoked, we must ensure that the caller is allowed to do so. For this purpose, the function reads the roles mapping. If the role has not been granted to the address, the contract reverts with Error::MissingRole.L55-L63 - The set_admin_role() function simply updates the role_admin mapping and emits the RoleAdminChanged event.L65-L85 - The unchecked_grant_role() and unchecked_revoke_role() functions are mirror functions that update the roles mapping and post RoleGranted or RoleRevoked events. If the role is already granted, unchecked_grant_role() has no effect (the opposite check is made in the case of revoking a role).L21-L28 - The get_role_admin() entry point reads the role_admin. If there is no admin role for a given role, it returns the default role.L30-L45 - This is a combination of check_role() and unchecked_*_role(). Entry points fail on unauthorized access. ","version":"2.1.0","tagName":"h3"},{"title":"Migration guide to v0.9.0","type":0,"sectionRef":"#","url":"/docs/2.1.0/migrations/to-0.9.0","content":"","keywords":"","version":"2.1.0"},{"title":"1. Prerequisites​","type":1,"pageTitle":"Migration guide to v0.9.0","url":"/docs/2.1.0/migrations/to-0.9.0#1-prerequisites","content":"","version":"2.1.0","tagName":"h2"},{"title":"1.1. Update cargo-odra​","type":1,"pageTitle":"Migration guide to v0.9.0","url":"/docs/2.1.0/migrations/to-0.9.0#11-update-cargo-odra","content":"Before you begin the migration process, make sure you installed the latest version of the Cargo Odra toolchain. You can install it by running the following command: cargo install cargo-odra --force --locked  ","version":"2.1.0","tagName":"h3"},{"title":"1.2. Review the Changelog​","type":1,"pageTitle":"Migration guide to v0.9.0","url":"/docs/2.1.0/migrations/to-0.9.0#12-review-the-changelog","content":"Before you move to changing your code, start by reviewing the Changelog to understand the changes introduced in v0.9.0. ","version":"2.1.0","tagName":"h3"},{"title":"2. Migration Steps​","type":1,"pageTitle":"Migration guide to v0.9.0","url":"/docs/2.1.0/migrations/to-0.9.0#2-migration-steps","content":"","version":"2.1.0","tagName":"h2"},{"title":"2.1 Update build_schema.rs bin​","type":1,"pageTitle":"Migration guide to v0.9.0","url":"/docs/2.1.0/migrations/to-0.9.0#21-update-build_schemars-bin","content":"Odra 0.9.0 adds a new standardized way of generating contract schema - Casper Contract Schema. You can find the updated build_schema.rs file in templates directory in the Odra main repository. You can choose whatever template you want to use and copy the files to your project. In both files, you should replace {{project-name}} with the name of your project. ","version":"2.1.0","tagName":"h3"},{"title":"2.2 Update smart contract code​","type":1,"pageTitle":"Migration guide to v0.9.0","url":"/docs/2.1.0/migrations/to-0.9.0#22-update-smart-contract-code","content":"The main changes in the smart contract code are related to the way of defining custom types, events and errors. The following sections will guide you through the necessary changes. 2.2.1. Update custom types definitions.​ #[derive(OdraType)] attribute has been replace with #[odra::odra_type] attribute. 0.9.00.8.0 use odra::Address; #[odra::odra_type] pub struct Dog { pub name: String, pub age: u8, pub owner: Option&lt;Address&gt; }  2.2.2. Update errors definitions.​ #[derive(OdraError)] attribute has been replace with #[odra::odra_error] attribute. Error enum should be passed as a parameter to the #[odra::module] attribute. 0.9.00.8.0 #[odra::module(events = [/* events go here */], errors = Error)] pub struct Erc20 { // fields } #[odra::odra_error] pub enum Error { InsufficientBalance = 30_000, InsufficientAllowance = 30_001, NameNotSet = 30_002, SymbolNotSet = 30_003, DecimalsNotSet = 30_004 }  2.2.3. Update events definitions.​ #[derive(Event)] attribute has been replace with #[odra::event] attribute. 0.9.00.8.0 use odra::prelude::*; use odra::{Address, casper_types::U256}; #[odra::event] pub struct Transfer { pub from: Option&lt;Address&gt;, pub to: Option&lt;Address&gt;, pub amount: U256 }  ","version":"2.1.0","tagName":"h3"},{"title":"3. Code Examples​","type":1,"pageTitle":"Migration guide to v0.9.0","url":"/docs/2.1.0/migrations/to-0.9.0#3-code-examples","content":"Here is a complete example of a smart contract after and before the migration to v0.9.0. 0.9.0Prev src/erc20.rs use crate::erc20::errors::Error; use crate::erc20::events::*; use odra::prelude::*; use odra::{casper_types::U256, Address, Mapping, Var}; #[odra::module(events = [Approval, Transfer], errors = Error)] pub struct Erc20 { decimals: Var&lt;u8&gt;, symbol: Var&lt;String&gt;, name: Var&lt;String&gt;, total_supply: Var&lt;U256&gt;, balances: Mapping&lt;Address, U256&gt;, allowances: Mapping&lt;(Address, Address), U256&gt; } #[odra::module] impl Erc20 { pub fn init( &amp;mut self, symbol: String, name: String, decimals: u8, initial_supply: Option&lt;U256&gt; ) { let caller = self.env().caller(); self.symbol.set(symbol); self.name.set(name); self.decimals.set(decimals); if let Some(initial_supply) = initial_supply { self.total_supply.set(initial_supply); self.balances.set(&amp;caller, initial_supply); if !initial_supply.is_zero() { self.env().emit_event(Transfer { from: None, to: Some(caller), amount: initial_supply }); } } } pub fn transfer(&amp;mut self, recipient: &amp;Address, amount: &amp;U256) { let caller = self.env().caller(); self.raw_transfer(&amp;caller, recipient, amount); } pub fn transfer_from(&amp;mut self, owner: &amp;Address, recipient: &amp;Address, amount: &amp;U256) { let spender = self.env().caller(); self.spend_allowance(owner, &amp;spender, amount); self.raw_transfer(owner, recipient, amount); } pub fn approve(&amp;mut self, spender: &amp;Address, amount: &amp;U256) { let owner = self.env().caller(); self.allowances.set(&amp;(owner, *spender), *amount); self.env().emit_event(Approval { owner, spender: *spender, value: *amount }); } pub fn name(&amp;self) -&gt; String { self.name.get_or_revert_with(Error::NameNotSet) } // Other getter functions... pub fn allowance(&amp;self, owner: &amp;Address, spender: &amp;Address) -&gt; U256 { self.allowances.get_or_default(&amp;(*owner, *spender)) } pub fn mint(&amp;mut self, address: &amp;Address, amount: &amp;U256) { self.total_supply.add(*amount); self.balances.add(address, *amount); self.env().emit_event(Transfer { from: None, to: Some(*address), amount: *amount }); } pub fn burn(&amp;mut self, address: &amp;Address, amount: &amp;U256) { if self.balance_of(address) &lt; *amount { self.env().revert(Error::InsufficientBalance); } self.total_supply.subtract(*amount); self.balances.subtract(address, *amount); self.env().emit_event(Transfer { from: Some(*address), to: None, amount: *amount }); } } impl Erc20 { fn raw_transfer(&amp;mut self, owner: &amp;Address, recipient: &amp;Address, amount: &amp;U256) { if *amount &gt; self.balances.get_or_default(owner) { self.env().revert(Error::InsufficientBalance) } self.balances.subtract(owner, *amount); self.balances.add(recipient, *amount); self.env().emit_event(Transfer { from: Some(*owner), to: Some(*recipient), amount: *amount }); } fn spend_allowance(&amp;mut self, owner: &amp;Address, spender: &amp;Address, amount: &amp;U256) { let allowance = self.allowances.get_or_default(&amp;(*owner, *spender)); if allowance &lt; *amount { self.env().revert(Error::InsufficientAllowance) } self.allowances.subtract(&amp;(*owner, *spender), *amount); self.env().emit_event(Approval { owner: *owner, spender: *spender, value: allowance - *amount }); } } pub mod events { use odra::prelude::*; use odra::{casper_types::U256, Address}; #[odra::event] pub struct Transfer { pub from: Option&lt;Address&gt;, pub to: Option&lt;Address&gt;, pub amount: U256 } #[odra::event] pub struct Approval { pub owner: Address, pub spender: Address, pub value: U256 } } pub mod errors { #[odra::odra_error] pub enum Error { InsufficientBalance = 30_000, InsufficientAllowance = 30_001, NameNotSet = 30_002, SymbolNotSet = 30_003, DecimalsNotSet = 30_004 } } #[cfg(test)] mod tests { // nothing changed in the tests }  ","version":"2.1.0","tagName":"h2"},{"title":"4. Troubleshooting​","type":1,"pageTitle":"Migration guide to v0.9.0","url":"/docs/2.1.0/migrations/to-0.9.0#4-troubleshooting","content":"If you encounter any further issues after completing the migration steps, please don't hesitate to reach out to us on Discord or explore the other sections this documentation. You can also refer to the technical documentation for more detailed information. Additionally, our examples repository offers a wide range of examples to assist you in understanding the new features and APIs. Be sure to carefully review any compilation errors and warnings, as they may provide valuable insights into the necessary adjustments. ","version":"2.1.0","tagName":"h2"},{"title":"5. References​","type":1,"pageTitle":"Migration guide to v0.9.0","url":"/docs/2.1.0/migrations/to-0.9.0#5-references","content":"ChangelogOdra DocumentationDocs.rsExamples ","version":"2.1.0","tagName":"h2"},{"title":"Build, Deploy and Read the State of a Contract","type":0,"sectionRef":"#","url":"/docs/2.1.0/tutorials/build-deploy-read","content":"","keywords":"","version":"2.1.0"},{"title":"Contract​","type":1,"pageTitle":"Build, Deploy and Read the State of a Contract","url":"/docs/2.1.0/tutorials/build-deploy-read#contract","content":"Let's write a contract with complex storage layout. The contract stores a plain numeric value, a custom nested type and a submodule with another submodule with stores a Mapping. We will expose two methods: The constructor init which sets the metadata and the version of the contract.The method set_data which sets the value of the numeric field and the values of the mapping. custom_item.rs use odra::{casper_types::U256, prelude::*}; // A custom type with a vector of another custom type #[odra::odra_type] pub struct Metadata { name: String, description: String, prices: Vec&lt;Price&gt;, } #[odra::odra_type] pub struct Price { value: U256, } // The main contract with a version, metadata and a submodule #[odra::module] pub struct CustomItem { version: Var&lt;u32&gt;, meta: Var&lt;Metadata&gt;, data: SubModule&lt;Data&gt; } #[odra::module] impl CustomItem { pub fn init(&amp;mut self, name: String, description: String, price_1: U256, price_2: U256) { let meta = Metadata { name, description, prices: vec![ Price { value: price_1 }, Price { value: price_2 } ] }; self.meta.set(meta); self.version.set(self.version.get_or_default() + 1); } pub fn set_data(&amp;mut self, value: u32, name: String, name2: String) { self.data.value.set(value); self.data.inner.named_values.set(&amp;name, 10); self.data.inner.named_values.set(&amp;name2, 20); } } // A submodule with a numeric value and another submodule #[odra::module] struct Data { value: Var&lt;u32&gt;, inner: SubModule&lt;InnerData&gt;, } // A submodule with a mapping #[odra::module] struct InnerData { named_values: Mapping&lt;String, u32&gt;, }  ","version":"2.1.0","tagName":"h3"},{"title":"Deploying the contract​","type":1,"pageTitle":"Build, Deploy and Read the State of a Contract","url":"/docs/2.1.0/tutorials/build-deploy-read#deploying-the-contract","content":"First, we need to setup the chain. We will use the NCTL docker image to run a local network. docker run --rm -it --name mynctl -d -p 11101:11101 -p 14101:14101 -p 18101:18101 makesoftware/casper-nctl  Next, we need to compile the contract to a Wasm file. cargo odra build -c custom_item  Then, we can deploy the contract using the casper-client tool. casper-client put-deploy \\ --node-address http://localhost:11101 \\ --chain-name casper-net-1 \\ --secret-key path/to/your/secret_key.pem \\ --session-path [PATH_TO_WASM] \\ --payment-amount 100000000000 \\ --session-arg &quot;odra_cfg_package_hash_key_name:string:'test_contract_package_hash'&quot; \\ --session-arg &quot;odra_cfg_allow_key_override:bool:'true'&quot; \\ --session-arg &quot;odra_cfg_is_upgradable:bool:'true'&quot; \\ --session-arg &quot;name:string='My Name'&quot; \\ --session-arg &quot;description:string='My Description'&quot; \\ --session-arg &quot;price_1:u256='101'&quot; \\ --session-arg &quot;price_2:u256='202'&quot;  Finally, we can call the set_data method to set the values of the contract. casper-client put-deploy \\ --node-address http://localhost:11101 \\ --chain-name casper-net-1 \\ --secret-key ./keys/secret_key.pem \\ --payment-amount 2000000000 \\ --session-hash [DEPLOYED_CONTRACT_HASH] \\ --session-entry-point &quot;set_data&quot; \\ --session-arg &quot;value:u32:'666'&quot; \\ --session-arg &quot;name:string='alice'&quot; \\ --session-arg &quot;name2:string='bob'&quot;  ","version":"2.1.0","tagName":"h3"},{"title":"Storage Layout​","type":1,"pageTitle":"Build, Deploy and Read the State of a Contract","url":"/docs/2.1.0/tutorials/build-deploy-read#storage-layout","content":"To read the state of the contract, we need to understand the storage layout. The first step is to calculate the index of the keys. Storage Layout CustomItem: prefix: 0x0..._0000_0000_0000 0 version: u32, 0x0..._0000_0000_0001 1 meta: Metadata, 0x0..._0000_0000_0010 2 data: Data: prefix: 0x0..._0000_0000_0011 3 value: u32, 0x0..._0000_0011_0001 (3 &lt;&lt; 4) + 1 inner: InnerData: prefix: 0x0..._0000_0011_0010 (3 &lt;&lt; 4) + 2 named_values: Mapping 0x0..._0011_0010_0001 ((3 &lt;&lt; 4) + 2) &lt;&lt; 4 + 1  The actual key is obtained as follows: Convert the index to a big-endian byte array.Concatenate the index with the mapping data.Hash the concatenated bytes using blake2b.Return the hex representation of the hash (the stored key must be utf-8 encoded). In more detail, the storage layout is described in the Storage Layout article. ","version":"2.1.0","tagName":"h3"},{"title":"Reading the state​","type":1,"pageTitle":"Build, Deploy and Read the State of a Contract","url":"/docs/2.1.0/tutorials/build-deploy-read#reading-the-state","content":"RustTypeScript main.rs use casper_client::{rpcs::DictionaryItemIdentifier, types::StoredValue, Verbosity}; use casper_types::{ bytesrepr::{FromBytes, ToBytes}, U256, }; // replace with your contract hash const CONTRACT_HASH: &amp;str = &quot;hash-...&quot;; const NODE_ADDRESS: &amp;str = &quot;http://localhost:11101/rpc&quot;; const RPC_ID: &amp;str = &quot;casper-net-1&quot;; const DICTIONARY_NAME: &amp;str = &quot;state&quot;; #[derive(Debug, PartialEq, Eq, Hash)] pub struct Metadata { name: String, description: String, prices: Vec&lt;Price&gt;, } #[derive(Debug, PartialEq, Eq, Hash)] pub struct Price { value: U256, } async fn read_state_key(key: String) -&gt; Vec&lt;u8&gt; { let state_root_hash = casper_client::get_state_root_hash( RPC_ID.to_string().into(), NODE_ADDRESS, Verbosity::Low, None, ) .await .unwrap() .result .state_root_hash .unwrap(); // Read the value from the `state` dictionary. let result = casper_client::get_dictionary_item( RPC_ID.to_string().into(), NODE_ADDRESS, Verbosity::Low, state_root_hash, DictionaryItemIdentifier::ContractNamedKey { key: CONTRACT_HASH.to_string(), dictionary_name: DICTIONARY_NAME.to_string(), dictionary_item_key: key, }, ) .await .unwrap() .result .stored_value; // We expect the value to be a CLValue if let StoredValue::CLValue(cl_value) = result { // Ignore the first 4 bytes, which are the length of the CLType. cl_value.inner_bytes()[4..].to_vec() } else { vec![] } } async fn metadata() -&gt; Metadata { // The key for the metadata is 2, and it has no mapping data let key = key(2, &amp;[]); let bytes = read_state_key(key).await; // Read the name and store the remaining bytes let (name, bytes) = String::from_bytes(&amp;bytes).unwrap(); // Read the description and store the remaining bytes let (description, bytes) = String::from_bytes(&amp;bytes).unwrap(); // A vector is stored as a u32 size followed by the elements // Read the size of the vector and store the remaining bytes let (size, mut bytes) = u32::from_bytes(&amp;bytes).unwrap(); let mut prices = vec![]; // As we know the size of the vector, we can loop over it for _ in 0..size { // Read the value and store the remaining bytes let (value, rem) = U256::from_bytes(&amp;bytes).unwrap(); bytes = rem; prices.push(Price { value }); } // Anytime you finish parsing a value, you should check if there are any remaining bytes // if there are, it means you have a bug in your parsing logic. // For simplicity, we will ignore the remaining bytes here. Metadata { name, description, prices } } async fn value() -&gt; u32 { // The key for the value is (3 &lt;&lt; 4) + 1, and it has no mapping data let key = key((3 &lt;&lt; 4) + 1, &amp;[]); let bytes = read_state_key(key).await; // Read the value and ignore the remaining bytes for simplicity u32::from_bytes(&amp;bytes).unwrap().0 } async fn named_value(name: &amp;str) -&gt; u32 { // The key for the named value is (((3 &lt;&lt; 4) + 2) &lt;&lt; 4) + 1, and the mapping data is the name as bytes let mapping_data = name.to_bytes().unwrap(); let key = key((((3 &lt;&lt; 4) + 2) &lt;&lt; 4) + 1, &amp;mapping_data); let bytes = read_state_key(key).await; // Read the value and ignore the remaining bytes for simplicity u32::from_bytes(&amp;bytes).unwrap().0 } fn main() { let runtime = tokio::runtime::Runtime::new().unwrap(); dbg!(runtime.block_on(metadata())); dbg!(runtime.block_on(value())); dbg!(runtime.block_on(named_value(&quot;alice&quot;))); dbg!(runtime.block_on(named_value(&quot;bob&quot;))); } // The key is a combination of the index and the mapping data // The algorithm is as follows: // 1. Convert the index to a big-endian byte array // 2. Concatenate the index with the mapping data // 3. Hash the concatenated bytes using blake2b // 4. Return the hex representation of the hash (the stored key must be utf-8 encoded) fn key(idx: u32, mapping_data: &amp;[u8]) -&gt; String { let mut key = Vec::new(); key.extend_from_slice(idx.to_be_bytes().as_ref()); key.extend_from_slice(mapping_data); let hashed_key = blake2b(&amp;key); hex::encode(&amp;hashed_key) } fn blake2b(bytes: &amp;[u8]) -&gt; [u8; 32] { let mut result = [0u8; 32]; let mut hasher = &lt;blake2::Blake2bVar as blake2::digest::VariableOutput&gt;::new(32) .expect(&quot;should create hasher&quot;); let _ = std::io::Write::write(&amp;mut hasher, bytes); blake2::digest::VariableOutput::finalize_variable(hasher, &amp;mut result) .expect(&quot;should copy hash to the result array&quot;); result } cargo run [src/main.rs:116:5] runtime.block_on(metadata()) = Metadata { name: &quot;My Contract&quot;, description: &quot;My Description&quot;, prices: [ Price { value: 123, }, Price { value: 321, }, ], } [src/main.rs:117:5] runtime.block_on(value()) = 666 [src/main.rs:118:5] runtime.block_on(named_value(&quot;alice&quot;)) = 20 [src/main.rs:119:5] runtime.block_on(named_value(&quot;bob&quot;)) = 10  ","version":"2.1.0","tagName":"h3"},{"title":"Deploying a Token on Casper Livenet","type":0,"sectionRef":"#","url":"/docs/2.1.0/tutorials/deploying-on-casper","content":"","keywords":"","version":"2.1.0"},{"title":"Casper Wallet​","type":1,"pageTitle":"Deploying a Token on Casper Livenet","url":"/docs/2.1.0/tutorials/deploying-on-casper#casper-wallet","content":"We will be using Casper Wallet to do some tasks in this tutorial. To install it, please follow the instructions on theofficial website. After setting up the wallet, extract the private key of the account you want to use for our testing. You can do this by clicking on the Menu &gt; Download account keys. danger You are solely responsible for the security of your private keys. We recommend creating a new account for the testing purposes. Why do we need the private key? We will use it in Odra to deploy our contract to the Casper network using Livenet backend. ","version":"2.1.0","tagName":"h2"},{"title":"Getting tokens​","type":1,"pageTitle":"Deploying a Token on Casper Livenet","url":"/docs/2.1.0/tutorials/deploying-on-casper#getting-tokens","content":"To deploy the contract on the Livenet, we need to have some CSPR. The easiest way to get them is to use the faucet, which will send us 1000 CSPR for free. Unfortunately, only on the Testnet. To use the faucet, go to the Casper Testnet Faucet. Log in using your Casper Wallet account and click on the &quot;Request Tokens&quot; button. note One account can request tokens only once. If you run out of tokens, you can either ask someone in the Casper community to send you some, or simply create a new account in the wallet. Now, when we have the tokens, we can deploy the contract. Let's do it using Odra! ","version":"2.1.0","tagName":"h2"},{"title":"Odra Livenet​","type":1,"pageTitle":"Deploying a Token on Casper Livenet","url":"/docs/2.1.0/tutorials/deploying-on-casper#odra-livenet","content":"Odra Livenet is described in detail in thebackends section of this documentation. We will then briefly describe how to use set it up in this tutorial. In your contract code, create a new file in the bin folder: bin/our_token_livenet.rs //! Deploys a new OurToken contract on the Casper livenet and mints some tokens for the tutorial //! creator. use std::str::FromStr; use odra::casper_types::U256; use odra::host::{Deployer, HostEnv, HostRef, HostRefLoader}; use odra::prelude::Address; use ourcoin::token::{OurToken, OurToken, OurTokenInitArgs}; fn main() { // Load the Casper livenet environment. let env = odra_casper_livenet_env::env(); // Caller is the deployer and the owner of the private key. let owner = env.caller(); // Just some random address... let recipient = &quot;hash-48bd92253a1370d1d913c56800296145547a243d13ff4f059ba4b985b1e94c26&quot;; let recipient = Address::from_str(recipient).unwrap(); // Deploy new contract. let mut token = deploy_our_token(&amp;env); println!(&quot;Token address: {}&quot;, token.address().to_string()); // Propose minting new tokens. env.set_gas(1_000_000_000u64); token.propose_new_mint(recipient, U256::from(1_000)); // Vote, we are the only voter. env.set_gas(1_000_000_000u64); token.vote(true, U256::from(1_000)); // Let's advance the block time by 11 minutes, as // we set the voting time to 10 minutes. // OH NO! It is the Livenet, so we need to wait real time... // Hopefully you are not in a hurry. env.advance_block_time(11 * 60 * 1000); // Tally the votes. env.set_gas(1_500_000_000u64); token.tally(); // Check the balances. println!(&quot;Owner's balance: {:?}&quot;, token.balance_of(&amp;owner)); println!( &quot;Tutorial creator's balance: {:?}&quot;, token.balance_of(&amp;recipient) ); } /// Deploys a contract. pub fn deploy_our_token(env: &amp;HostEnv) -&gt; OurTokenHostRef { let name = String::from(&quot;OurToken&quot;); let symbol = String::from(&quot;OT&quot;); let decimals = 0; let initial_supply = U256::from(1_000); let init_args = OurTokenInitArgs { name, symbol, decimals, initial_supply, }; env.set_gas(300_000_000_000u64); OurToken::deploy(env, init_args) } /// Loads a contract. Just in case you need to load an existing contract later... fn _load_our_token(env: &amp;HostEnv) -&gt; OurTokenHostRef { let address = &quot;hash-XXXXX&quot;; let address = Address::from_str(address).unwrap(); OurToken::load(env, address) }  In your Cargo.toml file, we need to add a new dependency, a feature and register the new binary. In the end, it should look like this: Cargo.toml [package] name = &quot;ourcoin&quot; version = &quot;0.1.0&quot; edition = &quot;2021&quot; [dependencies] odra = { version = &quot;2.2.0&quot;, features = [], default-features = false } odra-modules = { version = &quot;2.2.0&quot;, features = [], default-features = false } odra-casper-livenet-env = { version = &quot;2.2.0&quot;, optional = true } [dev-dependencies] odra-test = { version = &quot;2.2.0&quot;, features = [], default-features = false } [build-dependencies] odra-build = { version = &quot;2.2.0&quot;, features = [], default-features = false } [features] default = [] livenet = [&quot;odra-casper-livenet-env&quot;] [[bin]] name = &quot;ourcoin_build_contract&quot; path = &quot;bin/build_contract.rs&quot; test = false [[bin]] name = &quot;ourcoin_build_schema&quot; path = &quot;bin/build_schema.rs&quot; test = false [[bin]] name = &quot;our_token_livenet&quot; path = &quot;bin/our_token_livenet.rs&quot; required-features = [&quot;livenet&quot;] [profile.release] codegen-units = 1 lto = true [profile.dev.package.&quot;*&quot;] opt-level = 3  Finally, add the .env file with the following content: .env # Path to the secret key of the account that will be used to deploy the contracts. ODRA_CASPER_LIVENET_SECRET_KEY_PATH=folder_with_your_secret_key/secret_key_file.pem # RPC address of the node that will be used to deploy the contracts. ODRA_CASPER_LIVENET_NODE_ADDRESS=http://138.201.80.141:7777 # Chain name of the network. ODRA_CASPER_LIVENET_CHAIN_NAME=casper-test  Of course, you need to replace the secret key's path with the path to the secret key file you downloaded from the Casper Wallet. note One of the problems you may encounter is that the node you are using will be down or will not accept your calls. In this case, you will have to find and use another node IP address. Now, we will run our code: cargo run --bin our_token_livenet --features livenet  If everything is set up correctly, you should see the output similar to this:  Running `target/debug/our_token_livenet` 💁 INFO : Deploying &quot;OurToken&quot;. 💁 INFO : Found wasm under &quot;wasm/OurToken.wasm&quot;. 🙄 WAIT : Waiting 15s for &quot;e6b34772ebc3682702674102db87c633b0544242eafd5944e680371be4ea1227&quot;. 🙄 WAIT : Waiting 15s for &quot;e6b34772ebc3682702674102db87c633b0544242eafd5944e680371be4ea1227&quot;. 💁 INFO : Deploy &quot;e6b34772ebc3682702674102db87c633b0544242eafd5944e680371be4ea1227&quot; successfully executed. 💁 INFO : Contract &quot;hash-565bd0bde39c8c3dd79e49c037e05eac8add2b2193e86a91a6bac068e0de7857&quot; deployed. Token address: hash-565bd0bde39c8c3dd79e49c037e05eac8add2b2193e86a91a6bac068e0de7857 💁 INFO : Calling &quot;hash-565bd0bde39c8c3dd79e49c037e05eac8add2b2193e86a91a6bac068e0de7857&quot; with entrypoint &quot;propose_new_mint&quot;. 🙄 WAIT : Waiting 15s for &quot;2f89cc96b6f8f05b88f8e75bef3a2f0ba39e9ab761693afff49e4112aa9d7361&quot;. 🙄 WAIT : Waiting 15s for &quot;2f89cc96b6f8f05b88f8e75bef3a2f0ba39e9ab761693afff49e4112aa9d7361&quot;. 💁 INFO : Deploy &quot;2f89cc96b6f8f05b88f8e75bef3a2f0ba39e9ab761693afff49e4112aa9d7361&quot; successfully executed. 💁 INFO : Calling &quot;hash-565bd0bde39c8c3dd79e49c037e05eac8add2b2193e86a91a6bac068e0de7857&quot; with entrypoint &quot;vote&quot;. 🙄 WAIT : Waiting 15s for &quot;aca9ae847cfcb97c81b4c64992515ff14d6f63a60f7c141558463f5b752058a5&quot;. 🙄 WAIT : Waiting 15s for &quot;aca9ae847cfcb97c81b4c64992515ff14d6f63a60f7c141558463f5b752058a5&quot;. 💁 INFO : Deploy &quot;aca9ae847cfcb97c81b4c64992515ff14d6f63a60f7c141558463f5b752058a5&quot; successfully executed. 💁 INFO : advance_block_time called - Waiting for 660000 ms 💁 INFO : Calling &quot;hash-565bd0bde39c8c3dd79e49c037e05eac8add2b2193e86a91a6bac068e0de7857&quot; with entrypoint &quot;tally&quot;. 🙄 WAIT : Waiting 15s for &quot;223b135edbeadd88425183abaec0b0afb7d7770ffc57eba9054e3ea60e9e9cef&quot;. 🙄 WAIT : Waiting 15s for &quot;223b135edbeadd88425183abaec0b0afb7d7770ffc57eba9054e3ea60e9e9cef&quot;. 💁 INFO : Deploy &quot;223b135edbeadd88425183abaec0b0afb7d7770ffc57eba9054e3ea60e9e9cef&quot; successfully executed. Owner's balance: 1000 Tutorial creator's balance: 1000  Congratulations, your contract is now deployed on the Casper network! Before we move on, note the address of the token! We will use it in the next section to interact with the token. In our case it ishash-565bd0bde39c8c3dd79e49c037e05eac8add2b2193e86a91a6bac068e0de7857. ","version":"2.1.0","tagName":"h2"},{"title":"Cspr.live​","type":1,"pageTitle":"Deploying a Token on Casper Livenet","url":"/docs/2.1.0/tutorials/deploying-on-casper#csprlive","content":"The first thing we will do is to explore Casper's network block explorer,cspr.live. We can put the address of our token in the search bar to find it. note If you deployed your contract on the Testnet, remember to make sure that the Testnet network is selected in the dropdown menu in the top right corner. If everything is set up correctly, you should see the contract package's details. Besides the owner, keys etc., you can also see the contract's metdata, if it was developed using a standard that cspr.live supports. Indeed, we can see that it detected that our contract is a CEP-18 token! We see the name, symbol and total supply. All the mentions of the contract on the website will use the token name instead of the contract address.  Additionally, on the Token Txs tab, we can see the transactions that happened with the token. We can see the minting transaction we did in the previous section and transfers done during the voting process.  If we click on one of the accounts that recieved the tokens, we will go to the account page. Here, on the Tokens tab, we can see all the tokens that the account has - and OurToken is one of them! If you wish, you can check the status of the contract deployed during the development of this tutorial here. ","version":"2.1.0","tagName":"h2"},{"title":"Transferring Tokens using Casper Wallet​","type":1,"pageTitle":"Deploying a Token on Casper Livenet","url":"/docs/2.1.0/tutorials/deploying-on-casper#transferring-tokens-using-casper-wallet","content":"Casper wallet can do much more than just logging in to the faucet, exporting the private keys and transferring CSPR. It can also interact with the contracts deployed on the network. If you deployed the contract and left some OT tokens to yourself, you should see them in the Casper Wallet window. You should also be able to transfer them to another account!  ","version":"2.1.0","tagName":"h2"},{"title":"Conclusion​","type":1,"pageTitle":"Deploying a Token on Casper Livenet","url":"/docs/2.1.0/tutorials/deploying-on-casper#conclusion","content":"We've successfully deployed a token on the Casper network and interacted with it using the Odra backend and Casper Wallet. We've also learned how to use the cspr.live block explorer to check the status of your contract. Odra, Cspr.live and Casper Wallet are just a few of the tools that the Casper ecosystem provides. Feel free to explore them on casperecosystem.io. ","version":"2.1.0","tagName":"h2"},{"title":"CEP-18","type":0,"sectionRef":"#","url":"/docs/2.1.0/tutorials/cep18","content":"","keywords":"","version":"2.1.0"},{"title":"Self-governing token​","type":1,"pageTitle":"CEP-18","url":"/docs/2.1.0/tutorials/cep18#self-governing-token","content":"There are many ways to implement a governance mechanism for a token, each more complex than the other. In our example, we will use a simple one, where the community of token holders can vote to mint new tokens. ","version":"2.1.0","tagName":"h2"},{"title":"Token implementation​","type":1,"pageTitle":"CEP-18","url":"/docs/2.1.0/tutorials/cep18#token-implementation","content":"Let's start by creating a new project, choosing a clever name and using cep18 as our starting template: cargo odra new --name ourcoin --template cep18  Let's glance at our token code: src/token.rs #[odra::module] pub struct MyToken { token: SubModule&lt;Cep18&gt;, } impl MyToken { // Delegate all Cep18 functions to the token sub-module. delegate! { to self.token { ... fn name(&amp;self) -&gt; String; fn symbol(&amp;self) -&gt; String; ...  As we can see, it indeed uses the Cep18 module and delegates all the methods to it. The only thing to do is to change the name of the struct to more appropriate OurToken, run the provided tests using cargo odra test, and continue with the implementation of the governance. note Remember to change the name of the struct and its usages as well as the struct name in the Odra.toml file! ","version":"2.1.0","tagName":"h2"},{"title":"Governance implementation​","type":1,"pageTitle":"CEP-18","url":"/docs/2.1.0/tutorials/cep18#governance-implementation","content":"Let's go through the process of implementing the governance mechanism. If we don't want to, we don't have to hide entrypoints from the public responsible for minting new tokens. By default, minting Modalityis turned off, so any attempt of direct minting will result in an error. We will however implement a voting mechanism, where the token holders can vote to mint new tokens. ","version":"2.1.0","tagName":"h2"},{"title":"Voting mechanism​","type":1,"pageTitle":"CEP-18","url":"/docs/2.1.0/tutorials/cep18#voting-mechanism","content":"Our voting system will be straightforward: Anyone with the tokens can propose a new mint.Anyone with the tokens can vote for the new mint by staking their tokens.If the majority of the token holders vote for the mint, it is executed. Storage​ We will need to store some additional information about the votes, so let's add some fields to our token struct: src/token.rs #[odra::module] pub struct OurToken { /// A sub-module that implements the CEP-18 token standard. token: SubModule&lt;Cep18&gt;, /// The proposed mint. proposed_mint: Var&lt;(Address, U256)&gt;, /// The list of votes cast in the current vote. votes: List&lt;Ballot&gt;, /// Whether a vote is open. is_vote_open: Var&lt;bool&gt;, /// The time when the vote ends. vote_end_time: Var&lt;u64&gt;, } /// A ballot cast by a voter. #[odra::odra_type] struct Ballot { voter: Address, choice: bool, amount: U256, }  Notice that proposed_mint contains a tuple containing the address of the proposer and the amount of tokens to mint. Moreover, we need to keep track if the vote time has ended, but also if it was already tallied, that's why we need both is_vote_open and vote_end_time. We will also use the power of the Listtype to store the Ballots. Proposing a new mint​ To implement the endpoint that allows token holders to propose a new mint, we need to add a new function to our token module: src/token.rs /// Proposes a new mint for the contract. pub fn propose_new_mint(&amp;mut self, account: Address, amount: U256) { // Only allow proposing a new mint if there is no vote in progress. if self.is_vote_open().get_or_default() { self.env().revert(GovernanceError::VoteAlreadyOpen); } // Only the token holders can propose a new mint. if self.balance_of(&amp;self.env().caller()) == U256::zero() { self.env().revert(GovernanceError::OnlyTokenHoldersCanPropose); } // Set the proposed mint. self.proposed_mint.set((account, amount)); // Open a vote. self.is_vote_open.set(true); // Set the vote end time to 10 minutes from now. self.vote_end_time .set(self.env().get_block_time() + 60 * 10 * 1000); }  As a parameters to the function, we pass the address of the account that should be the receiver of the minted tokens, and the amount. After some validation, we open the vote by setting the is_vote_open to true, and setting the vote_end_time to 10 minutes. In real-world scenarios, the time could be configurable, but for the sake of simplicity, we hardcoded it. Also, it should be quite longer than 10 minutes, but it will come in handy when we test it on Livenet. Voting for the mint​ Next, we need an endpoint that will allow us to cast a ballot: src/token.rs /// Votes on the proposed mint. pub fn vote(&amp;mut self, choice: bool, amount: U256) { // Only allow voting if there is a vote in progress. self.assert_vote_in_progress(); let voter = self.env().caller(); let contract = self.env().self_address(); // Transfer the voting tokens from the voter to the contract. self.token .transfer(&amp;contract, &amp;amount); // Add the vote to the list. self.votes.push(Ballot { voter, choice, amount, }); }  The most interesting thing here is that we are using a mechanism of staking, where we transfer our tokens to the contract, to show that we really mean it. The tokens will be locked until the vote is over, and tallied. Speaking of tallying... Tallying the votes​ The last step is to tally the votes and mint the tokens if the majority of voters agreed to do so: src/token.rs /// Count the votes and perform the action pub fn tally(&amp;mut self) { // Only allow tallying the votes once. if !self.is_vote_open.get_or_default() { self.env().revert(GovernanceError::NoVoteInProgress); } // Only allow tallying the votes after the vote has ended. let finish_time = self .vote_end_time .get_or_revert_with(GovernanceError::NoVoteInProgress); if self.env().get_block_time() &lt; finish_time { self.env().revert(GovernanceError::VoteNotYetEnded); } // Count the votes let mut yes_votes = U256::zero(); let mut no_votes = U256::zero(); let contract = self.env().self_address(); while let Some(vote) = self.votes.pop() { if vote.choice { yes_votes += vote.amount; } else { no_votes += vote.amount; } // Transfer back the voting tokens to the voter. self.token.raw_transfer(&amp;contract, &amp;vote.voter, &amp;vote.amount); } // Perform the action if the vote has passed. if yes_votes &gt; no_votes { let (account, amount) = self .proposed_mint .get_or_revert_with(GovernanceError::NoVoteInProgress); self.token.raw_mint(&amp;account, &amp;amount); } // Close the vote. self.is_vote_open.set(false); }  Notice how we used raw_transfer from the Cep18 module. We used it to set the sender, so the contract's balance will be used, instead of the caller's. Additonally, we used raw_mint to mint the tokens, skipping the security checks. We have no modality for minting, but even if we had, we don't have anyone with permissions! The Contract needs to mint the tokens itself. ","version":"2.1.0","tagName":"h3"},{"title":"Testing​","type":1,"pageTitle":"CEP-18","url":"/docs/2.1.0/tutorials/cep18#testing","content":"Now, we will put our implementation to the test. One unit test, that we can run both on OdraVM and on the CasperVM. src/token.rs #[test] fn it_works() { let env = odra_test::env(); let init_args = OurTokenInitArgs { name: &quot;OurToken&quot;.to_string(), symbol: &quot;OT&quot;.to_string(), decimals: 0, initial_supply: U256::from(1_000u64), }; let mut token = OurToken::deploy(&amp;env, init_args); // The deployer, as the only token holder, // starts a new voting to mint 1000 tokens to account 1. // There is only 1 token holder, so there is one Ballot cast. token.propose_new_mint(env.get_account(1), U256::from(2000)); token.vote(true, U256::from(1000)); // The tokens should now be staked. assert_eq!(token.balance_of(&amp;env.get_account(0)), U256::zero()); // Wait for the vote to end. env.advance_block_time(60 * 11 * 1000); // Finish the vote. token.tally(); // The tokens should now be minted. assert_eq!(token.balance_of(&amp;env.get_account(1)), U256::from(2000)); assert_eq!(token.total_supply(), 3000.into()); // The stake should be returned. assert_eq!(token.balance_of(&amp;env.get_account(0)), U256::from(1000)); // Now account 1 can mint new tokens with their voting power... env.set_caller(env.get_account(1)); token.propose_new_mint(env.get_account(1), U256::from(2000)); token.vote(true, U256::from(2000)); // ...Even if the deployer votes against it. env.set_caller(env.get_account(0)); token.vote(false, U256::from(1000)); env.advance_block_time(60 * 11 * 1000); token.tally(); // The power of community governance! assert_eq!(token.balance_of(&amp;env.get_account(1)), U256::from(4000)); }  We can run the test using both methods: cargo odra test cargo odra test -b casper  It is all nice and green, but it would be really nice to see it in action. How about deploying it on the Casper network? ","version":"2.1.0","tagName":"h3"},{"title":"What's next​","type":1,"pageTitle":"CEP-18","url":"/docs/2.1.0/tutorials/cep18#whats-next","content":"We will se our token in action, by deploying it on the Casper network, and using tools from the Casper Ecosystem to interact with it. ","version":"2.1.0","tagName":"h2"},{"title":"Complete code​","type":1,"pageTitle":"CEP-18","url":"/docs/2.1.0/tutorials/cep18#complete-code","content":"Here is the complete code of the OurToken module: src/token.rs use odra::{casper_types::U256, prelude::*}; use odra_modules::cep18_token::Cep18; /// A ballot cast by a voter. #[odra::odra_type] struct Ballot { voter: Address, choice: bool, amount: U256, } /// Errors for the governed token. #[odra::odra_error] pub enum GovernanceError { /// The vote is already in progress. VoteAlreadyOpen = 0, /// No vote is in progress. NoVoteInProgress = 1, /// Cannot tally votes yet. VoteNotYetEnded = 2, /// Vote ended VoteEnded = 3, /// Only the token holders can propose a new mint. OnlyTokenHoldersCanPropose = 4, } /// A module definition. Each module struct consists of Vars and Mappings /// or/and other modules. #[odra::module(errors = GovernanceError)] pub struct OurToken { /// A submodule that implements the CEP-18 token standard. token: SubModule&lt;Cep18&gt;, /// The proposed mint. proposed_mint: Var&lt;(Address, U256)&gt;, /// The list of votes cast in the current vote. votes: List&lt;Ballot&gt;, /// Whether a vote is open. is_vote_open: Var&lt;bool&gt;, /// The time when the vote ends. vote_end_time: Var&lt;u64&gt;, } /// Module implementation. /// /// To generate entrypoints, /// an implementation block must be marked as #[odra::module]. #[odra::module] impl OurToken { /// Initializes the contract with the given metadata and initial supply. pub fn init(&amp;mut self, name: String, symbol: String, decimals: u8, initial_supply: U256) { // We put the token address as an admin, so it can govern itself. Self-governing token! self.token.init(symbol, name, decimals, initial_supply); } // Delegate all Cep18 functions to the token submodule. delegate! { to self.token { /// Returns the name of the token. fn name(&amp;self) -&gt; String; /// Returns the symbol of the token. fn symbol(&amp;self) -&gt; String; /// Returns the number of decimals the token uses. fn decimals(&amp;self) -&gt; u8; /// Returns the total supply of the token. fn total_supply(&amp;self) -&gt; U256; /// Returns the balance of the given address. fn balance_of(&amp;self, address: &amp;Address) -&gt; U256; /// Returns the amount of tokens the owner has allowed the spender to spend. fn allowance(&amp;self, owner: &amp;Address, spender: &amp;Address) -&gt; U256; /// Approves the spender to spend the given amount of tokens on behalf of the caller. fn approve(&amp;mut self, spender: &amp;Address, amount: &amp;U256); /// Decreases the allowance of the spender by the given amount. fn decrease_allowance(&amp;mut self, spender: &amp;Address, decr_by: &amp;U256); /// Increases the allowance of the spender by the given amount. fn increase_allowance(&amp;mut self, spender: &amp;Address, inc_by: &amp;U256); /// Transfers tokens from the caller to the recipient. fn transfer(&amp;mut self, recipient: &amp;Address, amount: &amp;U256); /// Transfers tokens from the owner to the recipient using the spender's allowance. fn transfer_from(&amp;mut self, owner: &amp;Address, recipient: &amp;Address, amount: &amp;U256); } } /// Burns the given amount of tokens from the given address. pub fn burn(&amp;mut self, owner: &amp;Address, amount: &amp;U256) { self.token.assert_caller(owner); // Burn the tokens. self.token.raw_burn(owner, amount); } /// Proposes a new mint for the contract. pub fn propose_new_mint(&amp;mut self, account: Address, amount: U256) { // Only allow proposing a new mint if there is no vote in progress. if self.is_vote_open.get_or_default() { self.env().revert(GovernanceError::VoteAlreadyOpen); } // Only the token holders can propose a new mint. if self.balance_of(&amp;self.env().caller()) == U256::zero() { self.env() .revert(GovernanceError::OnlyTokenHoldersCanPropose); } // Set the proposed mint. self.proposed_mint.set((account, amount)); // Open a vote. self.is_vote_open.set(true); // Set the vote end time to 10 minutes from now. self.vote_end_time .set(self.env().get_block_time() + 10 * 60 * 1000); } /// Votes on the proposed mint. pub fn vote(&amp;mut self, choice: bool, amount: U256) { // Only allow voting if there is a vote in progress. self.assert_vote_in_progress(); let voter = self.env().caller(); let contract = self.env().self_address(); // Transfer the voting tokens from the voter to the contract. self.token.transfer(&amp;contract, &amp;amount); // Add the vote to the list. self.votes.push(Ballot { voter, choice, amount, }); } /// Count the votes and perform the action pub fn tally(&amp;mut self) { // Only allow tallying the votes once. if !self.is_vote_open.get_or_default() { self.env().revert(GovernanceError::NoVoteInProgress); } // Only allow tallying the votes after the vote has ended. let finish_time = self .vote_end_time .get_or_revert_with(GovernanceError::NoVoteInProgress); if self.env().get_block_time() &lt; finish_time { self.env().revert(GovernanceError::VoteNotYetEnded); } // Count the votes let mut yes_votes = U256::zero(); let mut no_votes = U256::zero(); let contract = self.env().self_address(); while let Some(vote) = self.votes.pop() { if vote.choice { yes_votes += vote.amount; } else { no_votes += vote.amount; } // Transfer back the voting tokens to the voter. self.token .raw_transfer(&amp;contract, &amp;vote.voter, &amp;vote.amount); } // Perform the action if the vote has passed. if yes_votes &gt; no_votes { let (account, amount) = self .proposed_mint .get_or_revert_with(GovernanceError::NoVoteInProgress); self.token.raw_mint(&amp;account, &amp;amount); } // Close the vote. self.is_vote_open.set(false); } fn assert_vote_in_progress(&amp;self) { if !self.is_vote_open.get_or_default() { self.env().revert(GovernanceError::NoVoteInProgress); } let finish_time = self .vote_end_time .get_or_revert_with(GovernanceError::NoVoteInProgress); if self.env().get_block_time() &gt; finish_time { self.env().revert(GovernanceError::VoteEnded); } } } #[cfg(test)] mod tests { use super::*; use odra::host::Deployer; #[test] fn it_works() { let env = odra_test::env(); let init_args = OurTokenInitArgs { name: &quot;OurToken&quot;.to_string(), symbol: &quot;OT&quot;.to_string(), decimals: 0, initial_supply: U256::from(1_000u64), }; let mut token = OurToken::deploy(&amp;env, init_args); // The deployer, as the only token holder, // starts a new voting to mint 1000 tokens to account 1. // There is only 1 token holder, so there is one Ballot cast. token.propose_new_mint(env.get_account(1), U256::from(2000)); token.vote(true, U256::from(1000)); // The tokens should now be staked. assert_eq!(token.balance_of(&amp;env.get_account(0)), U256::zero()); // Wait for the vote to end. env.advance_block_time(60 * 11 * 1000); // Finish the vote. token.tally(); // The tokens should now be minted. assert_eq!(token.balance_of(&amp;env.get_account(1)), U256::from(2000)); assert_eq!(token.total_supply(), 3000.into()); // The stake should be returned. assert_eq!(token.balance_of(&amp;env.get_account(0)), U256::from(1000)); // Now account 1 can mint new tokens with their voting power... env.set_caller(env.get_account(1)); token.propose_new_mint(env.get_account(1), U256::from(2000)); token.vote(true, U256::from(2000)); // ...Even if the deployer votes against it. env.set_caller(env.get_account(0)); token.vote(false, U256::from(1000)); env.advance_block_time(60 * 11 * 1000); token.tally(); // The power of community governance! assert_eq!(token.balance_of(&amp;env.get_account(1)), U256::from(4000)); } }  ","version":"2.1.0","tagName":"h2"},{"title":"Migration guide to v0.8.0","type":0,"sectionRef":"#","url":"/docs/2.1.0/migrations/to-0.8.0","content":"","keywords":"","version":"2.1.0"},{"title":"1. Prerequisites​","type":1,"pageTitle":"Migration guide to v0.8.0","url":"/docs/2.1.0/migrations/to-0.8.0#1-prerequisites","content":"","version":"2.1.0","tagName":"h2"},{"title":"1.1. Update cargo-odra​","type":1,"pageTitle":"Migration guide to v0.8.0","url":"/docs/2.1.0/migrations/to-0.8.0#11-update-cargo-odra","content":"Before you begin the migration process, make sure you installed the latest version of the Cargo Odra toolchain. You can install it by running the following command: cargo install cargo-odra --force --locked  ","version":"2.1.0","tagName":"h3"},{"title":"1.2. Review the Changelog​","type":1,"pageTitle":"Migration guide to v0.8.0","url":"/docs/2.1.0/migrations/to-0.8.0#12-review-the-changelog","content":"Before you move to changing your code, start by reviewing the Changelog to understand the changes introduced in v0.8.0. ","version":"2.1.0","tagName":"h3"},{"title":"2. Migration Steps​","type":1,"pageTitle":"Migration guide to v0.8.0","url":"/docs/2.1.0/migrations/to-0.8.0#2-migration-steps","content":"","version":"2.1.0","tagName":"h2"},{"title":"2.1 Add bin directory​","type":1,"pageTitle":"Migration guide to v0.8.0","url":"/docs/2.1.0/migrations/to-0.8.0#21-add-bin-directory","content":"Odra 0.8.0 introduces a new way to build smart contracts. The .builder_casper directory is no longer used. Instead, you should create a new directory called bin in the root of your project and add the build_contract.rs and build_schema.rs files to the bin directory. You can find the build_contract.rs and build_schema.rs files in templates directory in the Odra main repository. You can choose whatever template you want to use and copy the files to your project. In both files, you should replace {{project-name}} with the name of your project. ","version":"2.1.0","tagName":"h3"},{"title":"2.2. Update Cargo.toml​","type":1,"pageTitle":"Migration guide to v0.8.0","url":"/docs/2.1.0/migrations/to-0.8.0#22-update-cargotoml","content":"There a bunch of changes in the Cargo.toml file. You don't have to specify the features anymore - remove the features section and default-features flag from the odra dependency.Register bins you added in the previous step.Add dev-dependencies section with odra-test crate.Add recommended profiles for release and dev to optimize the build process. Below you can compare the Cargo.toml file after and before the migration to v0.8.0: 0.8.0Prev [package] name = &quot;my_project&quot; version = &quot;0.1.0&quot; edition = &quot;2021&quot; [dependencies] odra = &quot;0.8.0&quot; [dev-dependencies] odra-test = &quot;0.8.0&quot; [[bin]] name = &quot;my_project_build_contract&quot; path = &quot;bin/build_contract.rs&quot; test = false [[bin]] name = &quot;my_project_build_schema&quot; path = &quot;bin/build_schema.rs&quot; test = false [profile.release] codegen-units = 1 lto = true [profile.dev.package.&quot;*&quot;] opt-level = 3  ","version":"2.1.0","tagName":"h3"},{"title":"2.2. Update Odra.toml​","type":1,"pageTitle":"Migration guide to v0.8.0","url":"/docs/2.1.0/migrations/to-0.8.0#22-update-odratoml","content":"Due to the changes in cargo-odra, the Odra.toml file has been simplified. The name property is no longer required. 0.8.0Prev [[contracts]] fqn = &quot;my_project::Flipper&quot;  ","version":"2.1.0","tagName":"h3"},{"title":"2.3. Update Smart Contracts​","type":1,"pageTitle":"Migration guide to v0.8.0","url":"/docs/2.1.0/migrations/to-0.8.0#23-update-smart-contracts","content":"The smart contracts themselves will need to be updated to work with the new version of the framework. The changes will depend on the specific features and APIs used in the contracts. Here are some common changes you might need to make: 2.3.1. Update the use statements to reflect the new module structure.​ Big integer types are now located in the odra::casper_types module.odra::types::Address is now odra::Address.Variable is now Var.Remove odra::contract_env.Remove odra::types::event::OdraEvent.Remove odra::types::OdraType as it is no longer required.Change odra::types::casper_types::*; to odra::casper_types::*;. 2.3.2. Some type aliases are no longer in use.​ Balance - use odra::casper_types::U512.BlockTime - use u64.EventData - use odra::casper_types::bytesrepr::Bytes. 2.3.3. Consider import odra::prelude::* in your module files.​ 2.3.4. Flatten nested Mappings.​ // Before #[odra::module(events = [Approval, Transfer])] pub struct Erc20 { ... allowances: Mapping&lt;Address, Mapping&lt;Address, U256&gt;&gt; } // After #[odra::module(events = [Approval, Transfer])] pub struct Erc20 { ... allowances: Mapping&lt;(Address, Address), U256&gt; }  2.3.5. Update errors definitions.​ execution_error! macro has been replace with OdraError derive macro. 0.8.0Prev use odra::OdraError; #[derive(OdraError)] pub enum Error { InsufficientBalance = 30_000, InsufficientAllowance = 30_001, NameNotSet = 30_002, SymbolNotSet = 30_003, DecimalsNotSet = 30_004 }  2.3.6. Update events definitions.​ 0.8.0Prev use odra::prelude::*; use odra::Event; #[derive(Event, Eq, PartialEq, Debug)] pub struct Transfer { pub from: Option&lt;Address&gt;, pub to: Option&lt;Address&gt;, pub amount: U256 } // Emitting the event self.env().emit_event(Transfer { from: None, to: Some(*address), amount: *amount });  2.3.7. Replace contract_env with self.env() in your modules.​ self.env() is a new way to access the contract environment, returns a reference to ContractEnv. The API is similar to the previous contract_env but with some changes. fn get_var&lt;T: FromBytes&gt;(key: &amp;[u8]) -&gt; Option&lt;T&gt; is now fn get_value&lt;T: FromBytes&gt;(&amp;self, key: &amp;[u8]) -&gt; Option&lt;T&gt;.fn set_var&lt;T: CLTyped + ToBytes&gt;(key: &amp;[u8], value: T) is now fn set_value&lt;T: ToBytes + CLTyped&gt;(&amp;self, key: &amp;[u8], value: T).set_dict_value() and get_dict_value() has been removed. All the dictionary operations should be performed using Mapping type, internally using set_var() and get_var() functions. fn hash&lt;T: AsRef&lt;[u8]&gt;&gt;(input: T) -&gt; Vec&lt;u8&gt; is now fn hash&lt;T: ToBytes&gt;(&amp;self, value: T) -&gt; [u8; 32].fn revert&lt;E: Into&lt;ExecutionError&gt;&gt;(error: E) -&gt; ! is now fn revert&lt;E: Into&lt;OdraError&gt;&gt;(&amp;self, error: E) -&gt; !.fn emit_event&lt;T: ToBytes + OdraEvent&gt;(event: T) is now fn emit_event&lt;T: ToBytes&gt;(&amp;self, event: T).fn call_contract&lt;T: CLTyped + FromBytes&gt;(address: Address, entrypoint: &amp;str, args: &amp;RuntimeArgs, amount: Option&lt;U512&gt;) -&gt; T is now fn call_contract&lt;T: FromBytes&gt;(&amp;self, address: Address, call: CallDef) -&gt; T.functions native_token_metadata() and one_token() have been removed. 2.3.8. Wrap submodules of your module with odra::SubModule&lt;T&gt;.​ 0.8.0Prev #[odra::module(events = [Transfer])] pub struct Erc721Token { core: SubModule&lt;Erc721Base&gt;, metadata: SubModule&lt;Erc721MetadataExtension&gt;, ownable: SubModule&lt;Ownable&gt; }  2.3.9. Update external contract calls.​ However the definition of an external contract remains the same, the way you call it has changed. A reference to an external contract is named {{ModuleName}}ContractRef (former {{ModuleName}}Ref) and you can call it using {{ModuleName}}ContractRef::new(env, address) (former {{ModuleName}}Ref::at()). 0.8.0Prev #[odra::external_contract] pub trait Token { fn balance_of(&amp;self, owner: &amp;Address) -&gt; U256; } // Usage TokenContractRef::new(env, token).balance_of(account)  2.3.10. Update constructors.​ Remove the #[odra::init] attribute from the constructor and ensure that the constructor function is named init. 2.3.11. Update UnwrapOrRevert calls.​ The functions unwrap_or_revert and unwrap_or_revert_with now require &amp;HostEnv as the first parameter. 2.3.12. Remove #[odra(using)] attribute from your module definition.​ Sharing the same instance of a module is no longer supported. A redesign of the module structure might be required. ","version":"2.1.0","tagName":"h3"},{"title":"2.4. Update Tests​","type":1,"pageTitle":"Migration guide to v0.8.0","url":"/docs/2.1.0/migrations/to-0.8.0#24-update-tests","content":"Once you've updated your smart contracts, you'll need to update your tests to reflect the changes. The changes will depend on the specific features and APIs used in the tests. Here are some common changes you might need to make: 2.4.1. Contract deployment.​ The way you deploy a contract has changed: You should use {{ModuleName}}HostRef::deploy(&amp;env, args) instead of {{ModuleName}}Deployer::init(). The {{ModuleName}}HostRef implements odra::host::Deployer.Instantiate the HostEnv using odra_test::env(), required by the odra::host::Deployer::deploy() function.If the contract doesn't have init args, you should use odra::host::NoArgs as the second argument of the deploy function.If the contract has init args, you should pass the autogenerated {{ModuleName}}InitArgs as the second argument of the deploy function. 0.8.0Prev // A contract without init args use super::OwnableHostRef; use odra::host::{Deployer, HostEnv, HostRef, NoArgs}; let env: HostEnv = odra_test::env(); let ownable = OwnableHostRef::deploy(&amp;env, NoArgs) // A contract with init args use super::{Erc20HostRef, Erc20InitArgs}; use odra::host::{Deployer, HostEnv}; let env: HostEnv = odra_test::env(); let init_args = Erc20InitArgs { symbol: SYMBOL.to_string(), name: NAME.to_string(), decimals: DECIMALS, initial_supply: Some(INITIAL_SUPPLY.into()) }; let erc20 = Erc20HostRef::deploy(&amp;env, init_args);  2.4.2. Host interactions.​ Replace odra::test_env with odra_test::env().The API of odra::test_env and odra_test::env() are similar, but there are some differences: test_env::advance_block_time_by(BlockTime) is now env.advance_block_time(u64).test_env::token_balance(Address) is now env.balance_of(&amp;Address).functions test_env::last_call_contract_gas_cost(), test_env::last_call_contract_gas_used(), test_env::total_gas_used(Address), test_env::gas_report() have been removed. You should use HostRef::last_call() and extract the data from a odra::ContractCallResult instance. HostRef is a trait implemented by {{ModuleName}}HostRef. 2.4.3. Testing failing scenarios.​ test_env::assert_exception() has been removed. You should use the try_ prefix to call the function and then assert the result.try_ prefix is a new way to call a function that might fail. It returns a OdraResult type, which you can then assert using the standard Rust assert_eq! macro. 0.8.0Prev #[test] fn transfer_from_error() { let (env, mut erc20) = setup(); let (owner, spender, recipient) = (env.get_account(0), env.get_account(1), env.get_account(2)); let amount = 1_000.into(); env.set_caller(spender); assert_eq!( erc20.try_transfer_from(owner, recipient, amount), Err(Error::InsufficientAllowance.into()) ); }  2.4.4. Testing events.​ assert_events! macro has been removed. You should use HostEnv::emitted_event() to assert the emitted events. The new API doesn't allow to assert multiple events at once, but adds alternative ways to assert the emitted events. Check the HostEnv documentation to explore the available options. 0.8.0Prev let env: HostEnv = odra_test::env(); let erc20 = Erc20HostRef::deploy(&amp;env, init_args); ... assert!(env.emitted_event( erc20.address(), &amp;Approval { owner, spender, value: approved_amount - transfer_amount } )); assert!(env.emitted_event( erc20.address(), &amp;Transfer { from: Some(owner), to: Some(recipient), amount: transfer_amount } ));  ","version":"2.1.0","tagName":"h3"},{"title":"3. Code Examples​","type":1,"pageTitle":"Migration guide to v0.8.0","url":"/docs/2.1.0/migrations/to-0.8.0#3-code-examples","content":"Here is a complete example of a smart contract after and before the migration to v0.8.0. 0.8.0Prev src/erc20.rs use crate::erc20::errors::Error::*; use crate::erc20::events::*; use odra::prelude::*; use odra::{casper_types::U256, Address, Mapping, Var}; #[odra::module(events = [Approval, Transfer])] pub struct Erc20 { decimals: Var&lt;u8&gt;, symbol: Var&lt;String&gt;, name: Var&lt;String&gt;, total_supply: Var&lt;U256&gt;, balances: Mapping&lt;Address, U256&gt;, allowances: Mapping&lt;(Address, Address), U256&gt; } #[odra::module] impl Erc20 { pub fn init( &amp;mut self, symbol: String, name: String, decimals: u8, initial_supply: Option&lt;U256&gt; ) { let caller = self.env().caller(); self.symbol.set(symbol); self.name.set(name); self.decimals.set(decimals); if let Some(initial_supply) = initial_supply { self.total_supply.set(initial_supply); self.balances.set(&amp;caller, initial_supply); if !initial_supply.is_zero() { self.env().emit_event(Transfer { from: None, to: Some(caller), amount: initial_supply }); } } } pub fn transfer(&amp;mut self, recipient: &amp;Address, amount: &amp;U256) { let caller = self.env().caller(); self.raw_transfer(&amp;caller, recipient, amount); } pub fn transfer_from(&amp;mut self, owner: &amp;Address, recipient: &amp;Address, amount: &amp;U256) { let spender = self.env().caller(); self.spend_allowance(owner, &amp;spender, amount); self.raw_transfer(owner, recipient, amount); } pub fn approve(&amp;mut self, spender: &amp;Address, amount: &amp;U256) { let owner = self.env().caller(); self.allowances.set(&amp;(owner, *spender), *amount); self.env().emit_event(Approval { owner, spender: *spender, value: *amount }); } pub fn name(&amp;self) -&gt; String { self.name.get_or_revert_with(NameNotSet) } // Other getter functions... pub fn allowance(&amp;self, owner: &amp;Address, spender: &amp;Address) -&gt; U256 { self.allowances.get_or_default(&amp;(*owner, *spender)) } pub fn mint(&amp;mut self, address: &amp;Address, amount: &amp;U256) { self.total_supply.add(*amount); self.balances.add(address, *amount); self.env().emit_event(Transfer { from: None, to: Some(*address), amount: *amount }); } pub fn burn(&amp;mut self, address: &amp;Address, amount: &amp;U256) { if self.balance_of(address) &lt; *amount { self.env().revert(InsufficientBalance); } self.total_supply.subtract(*amount); self.balances.subtract(address, *amount); self.env().emit_event(Transfer { from: Some(*address), to: None, amount: *amount }); } } impl Erc20 { fn raw_transfer(&amp;mut self, owner: &amp;Address, recipient: &amp;Address, amount: &amp;U256) { if *amount &gt; self.balances.get_or_default(owner) { self.env().revert(InsufficientBalance) } self.balances.subtract(owner, *amount); self.balances.add(recipient, *amount); self.env().emit_event(Transfer { from: Some(*owner), to: Some(*recipient), amount: *amount }); } fn spend_allowance(&amp;mut self, owner: &amp;Address, spender: &amp;Address, amount: &amp;U256) { let allowance = self.allowances.get_or_default(&amp;(*owner, *spender)); if allowance &lt; *amount { self.env().revert(InsufficientAllowance) } self.allowances.subtract(&amp;(*owner, *spender), *amount); self.env().emit_event(Approval { owner: *owner, spender: *spender, value: allowance - *amount }); } } pub mod events { use odra::prelude::*; use odra::{casper_types::U256, Address, Event}; #[derive(Event, Eq, PartialEq, Debug)] pub struct Transfer { pub from: Option&lt;Address&gt;, pub to: Option&lt;Address&gt;, pub amount: U256 } #[derive(Event, Eq, PartialEq, Debug)] pub struct Approval { pub owner: Address, pub spender: Address, pub value: U256 } } pub mod errors { use odra::OdraError; #[derive(OdraError)] pub enum Error { InsufficientBalance = 30_000, InsufficientAllowance = 30_001, NameNotSet = 30_002, SymbolNotSet = 30_003, DecimalsNotSet = 30_004 } } #[cfg(test)] mod tests { use super::{ errors::Error, events::{Approval, Transfer}, Erc20HostRef, Erc20InitArgs }; use odra::{ casper_types::U256, host::{Deployer, HostEnv, HostRef}, prelude::* }; const NAME: &amp;str = &quot;Plascoin&quot;; const SYMBOL: &amp;str = &quot;PLS&quot;; const DECIMALS: u8 = 10; const INITIAL_SUPPLY: u32 = 10_000; fn setup() -&gt; (HostEnv, Erc20HostRef) { let env = odra_test::env(); ( env.clone(), Erc20HostRef::deploy( &amp;env, Erc20InitArgs { symbol: SYMBOL.to_string(), name: NAME.to_string(), decimals: DECIMALS, initial_supply: Some(INITIAL_SUPPLY.into()) } ) ) } #[test] fn initialization() { // When deploy a contract with the initial supply. let (env, erc20) = setup(); // Then the contract has the metadata set. assert_eq!(erc20.symbol(), SYMBOL.to_string()); assert_eq!(erc20.name(), NAME.to_string()); assert_eq!(erc20.decimals(), DECIMALS); // Then the total supply is updated. assert_eq!(erc20.total_supply(), INITIAL_SUPPLY.into()); // Then a Transfer event was emitted. assert!(env.emitted_event( erc20.address(), &amp;Transfer { from: None, to: Some(env.get_account(0)), amount: INITIAL_SUPPLY.into() } )); } #[test] fn transfer_works() { // Given a new contract. let (env, mut erc20) = setup(); // When transfer tokens to a recipient. let sender = env.get_account(0); let recipient = env.get_account(1); let amount = 1_000.into(); erc20.transfer(&amp;recipient, &amp;amount); // Then the sender balance is deducted. assert_eq!( erc20.balance_of(&amp;sender), U256::from(INITIAL_SUPPLY) - amount ); // Then the recipient balance is updated. assert_eq!(erc20.balance_of(&amp;recipient), amount); // Then Transfer event was emitted. assert!(env.emitted_event( erc20.address(), &amp;Transfer { from: Some(sender), to: Some(recipient), amount } )); } #[test] fn transfer_error() { // Given a new contract. let (env, mut erc20) = setup(); // When the transfer amount exceeds the sender balance. let recipient = env.get_account(1); let amount = U256::from(INITIAL_SUPPLY) + U256::one(); // Then an error occurs. assert!(erc20.try_transfer(&amp;recipient, &amp;amount).is_err()); } // Other tests... }  ","version":"2.1.0","tagName":"h2"},{"title":"4. Troubleshooting​","type":1,"pageTitle":"Migration guide to v0.8.0","url":"/docs/2.1.0/migrations/to-0.8.0#4-troubleshooting","content":"If you encounter any further issues after completing the migration steps, please don't hesitate to reach out to us on Discord or explore the other sections this documentation. You can also refer to the technical documentation for more detailed information. Additionally, our examples repository offers a wide range of examples to assist you in understanding the new features and APIs. Be sure to carefully review any compilation errors and warnings, as they may provide valuable insights into the necessary adjustments. ","version":"2.1.0","tagName":"h2"},{"title":"5. References​","type":1,"pageTitle":"Migration guide to v0.8.0","url":"/docs/2.1.0/migrations/to-0.8.0#5-references","content":"ChangelogOdra DocumentationDocs.rsExamples ","version":"2.1.0","tagName":"h2"},{"title":"ERC-20","type":0,"sectionRef":"#","url":"/docs/2.1.0/tutorials/erc20","content":"","keywords":"","version":"2.1.0"},{"title":"Framework features​","type":1,"pageTitle":"ERC-20","url":"/docs/2.1.0/tutorials/erc20#framework-features","content":"A module we will write in a minute, will help you master a few Odra features: Advanced storage using key-value pairs,Odra types such as Address,Advanced event assertion. ","version":"2.1.0","tagName":"h2"},{"title":"Code​","type":1,"pageTitle":"ERC-20","url":"/docs/2.1.0/tutorials/erc20#code","content":"Our module features a considerably more complex storage layout compared to the previous example. It is designed to store the following data: Immutable metadata - name, symbol, and decimals.Total supply.Balances of individual users.Allowances, essentially indicating who is permitted to spend tokens on behalf of another user. ","version":"2.1.0","tagName":"h2"},{"title":"Module definition​","type":1,"pageTitle":"ERC-20","url":"/docs/2.1.0/tutorials/erc20#module-definition","content":"erc20.rs use odra::prelude::*; use odra::casper_types::U256; #[odra::module(events = [Transfer, Approval], errors = Error)] pub struct Erc20 { decimals: Var&lt;u8&gt;, symbol: Var&lt;String&gt;, name: Var&lt;String&gt;, total_supply: Var&lt;U256&gt;, balances: Mapping&lt;Address, U256&gt;, allowances: Mapping&lt;(Address, Address), U256&gt; }  L10 - For the first time, we need to store key-value pairs. In order to do that, we use Mapping. The name is taken after Solidity's native type mapping.L11 - Odra does not allows nested Mappings as Solidity does. Instead, you can create a compound key using a tuple of keys. ","version":"2.1.0","tagName":"h2"},{"title":"Metadata​","type":1,"pageTitle":"ERC-20","url":"/docs/2.1.0/tutorials/erc20#metadata","content":"erc20.rs #[odra::module] impl Erc20 { pub fn init(&amp;mut self, name: String, symbol: String, decimals: u8, initial_supply: U256) { let caller = self.env().caller(); self.name.set(name); self.symbol.set(symbol); self.decimals.set(decimals); self.mint(&amp;caller, &amp;initial_supply); } pub fn name(&amp;self) -&gt; String { self.name.get_or_default() } pub fn symbol(&amp;self) -&gt; String { self.symbol.get_or_default() } pub fn decimals(&amp;self) -&gt; u8 { self.decimals.get_or_default() } pub fn total_supply(&amp;self) -&gt; U256 { self.total_supply.get_or_default() } } impl Erc20 { pub fn mint(&amp;mut self, address: &amp;Address, amount: &amp;U256) { self.balances.add(address, *amount); self.total_supply.add(*amount); self.env().emit_event(Transfer { from: None, to: Some(*address), amount: *amount }); } } #[odra::event] pub struct Transfer { pub from: Option&lt;Address&gt;, pub to: Option&lt;Address&gt;, pub amount: U256 }  L1 - The first impl block, marked as a module, contains functions defined in the ERC-20 standard.L3-L9 - A constructor sets the token metadata and mints the initial supply.L28 - The second impl is not an Odra module; in other words, these functions will not be part of the contract's public interface.L29-L38 - The mint function is public, so, like in regular Rust code, it will be accessible from the outside. mint() uses the notation self.balances.add(address, *amount);, which is syntactic sugar for: let current_balance = self.balances.get(address).unwrap_or_default(); let new_balance = &lt;U256 as OverflowingAdd&gt;::overflowing_add(current_balance, current_balance).unwrap_or_revert(&amp;self.env()); self.balances.set(address, new_balance);  ","version":"2.1.0","tagName":"h3"},{"title":"Core​","type":1,"pageTitle":"ERC-20","url":"/docs/2.1.0/tutorials/erc20#core","content":"To ensure comprehensive functionality, let's implement the remaining features such as transfer, transfer_from, and approve. Since they do not introduce any new concepts, we will present them without additional remarks. erc20.rs #[odra::module] impl Erc20 { ... pub fn transfer(&amp;mut self, recipient: &amp;Address, amount: &amp;U256) { let caller = self.env().caller(); self.raw_transfer(&amp;caller, recipient, amount); } pub fn transfer_from(&amp;mut self, owner: &amp;Address, recipient: &amp;Address, amount: &amp;U256) { let spender = self.env().caller(); self.spend_allowance(owner, &amp;spender, amount); self.raw_transfer(owner, recipient, amount); } pub fn approve(&amp;mut self, spender: &amp;Address, amount: &amp;U256) { let owner = self.env().caller(); self.allowances.set(&amp;(owner, *spender), *amount); self.env().emit_event(Approval { owner, spender: *spender, value: *amount }); } pub fn balance_of(&amp;self, address: &amp;Address) -&gt; U256 { self.balances.get_or_default(&amp;address) } pub fn allowance(&amp;self, owner: &amp;Address, spender: &amp;Address) -&gt; U256 { self.allowances.get_or_default(&amp;(*owner, *spender)) } } impl Erc20 { ... fn raw_transfer(&amp;mut self, owner: &amp;Address, recipient: &amp;Address, amount: &amp;U256) { let owner_balance = self.balances.get_or_default(&amp;owner); if *amount &gt; owner_balance { self.env().revert(Error::InsufficientBalance) } self.balances.set(owner, owner_balance - *amount); self.balances.add(recipient, *amount); self.env().emit_event(Transfer { from: Some(*owner), to: Some(*recipient), amount: *amount }); } fn spend_allowance(&amp;mut self, owner: &amp;Address, spender: &amp;Address, amount: &amp;U256) { let allowance = self.allowance(owner, spender); if allowance &lt; *amount { self.env().revert(Error::InsufficientAllowance) } let new_allowance = allowance - *amount; self.allowances .set(&amp;(*owner, *spender), new_allowance); self.env().emit_event(Approval { owner: *owner, spender: *spender, value: allowance - *amount }); } } #[odra::event] pub struct Approval { pub owner: Address, pub spender: Address, pub value: U256 } #[odra::odra_error] pub enum Error { InsufficientBalance = 1, InsufficientAllowance = 2, }  Now, compare the code we have written, with Open Zeppelin code. Out of 10, how Solidity-ish is our implementation? ","version":"2.1.0","tagName":"h3"},{"title":"Test​","type":1,"pageTitle":"ERC-20","url":"/docs/2.1.0/tutorials/erc20#test","content":"erc20.rs #[cfg(test)] pub mod tests { use super::*; use odra::{ casper_types::U256, host::{Deployer, HostEnv}, prelude::* }; const NAME: &amp;str = &quot;Plascoin&quot;; const SYMBOL: &amp;str = &quot;PLS&quot;; const DECIMALS: u8 = 10; const INITIAL_SUPPLY: u32 = 10_000; fn setup() -&gt; (HostEnv, Erc20HostRef) { let env = odra_test::env(); ( env.clone(), Erc20::deploy( &amp;env, Erc20InitArgs { symbol: SYMBOL.to_string(), name: NAME.to_string(), decimals: DECIMALS, initial_supply: INITIAL_SUPPLY.into() } ) ) } #[test] fn initialization() { // When deploy a contract with the initial supply. let (env, erc20) = setup(); // Then the contract has the metadata set. assert_eq!(erc20.symbol(), SYMBOL.to_string()); assert_eq!(erc20.name(), NAME.to_string()); assert_eq!(erc20.decimals(), DECIMALS); // Then the total supply is updated. assert_eq!(erc20.total_supply(), INITIAL_SUPPLY.into()); // Then a Transfer event was emitted. assert!(env.emitted_event( &amp;erc20, &amp;Transfer { from: None, to: Some(env.get_account(0)), amount: INITIAL_SUPPLY.into() } )); } #[test] fn transfer_works() { // Given a new contract. let (env, mut erc20) = setup(); // When transfer tokens to a recipient. let sender = env.get_account(0); let recipient = env.get_account(1); let amount = 1_000.into(); erc20.transfer(&amp;recipient, &amp;amount); // Then the sender balance is deducted. assert_eq!( erc20.balance_of(&amp;sender), U256::from(INITIAL_SUPPLY) - amount ); // Then the recipient balance is updated. assert_eq!(erc20.balance_of(&amp;recipient), amount); // Then Transfer event was emitted. assert!(env.emitted_event( &amp;erc20, &amp;Transfer { from: Some(sender), to: Some(recipient), amount } )); } #[test] fn transfer_error() { // Given a new contract. let (env, mut erc20) = setup(); // When the transfer amount exceeds the sender balance. let recipient = env.get_account(1); let amount = U256::from(INITIAL_SUPPLY) + U256::one(); // Then an error occurs. assert!(erc20.try_transfer(&amp;recipient, &amp;amount).is_err()); } #[test] fn transfer_from_and_approval_work() { let (env, mut erc20) = setup(); let (owner, recipient, spender) = (env.get_account(0), env.get_account(1), env.get_account(2)); let approved_amount = 3_000.into(); let transfer_amount = 1_000.into(); assert_eq!(erc20.balance_of(&amp;owner), U256::from(INITIAL_SUPPLY)); // Owner approves Spender. erc20.approve(&amp;spender, &amp;approved_amount); // Allowance was recorded. assert_eq!(erc20.allowance(&amp;owner, &amp;spender), approved_amount); assert!(env.emitted_event( &amp;erc20, Approval { owner, spender, value: approved_amount } )); // Spender transfers tokens from Owner to Recipient. env.set_caller(spender); erc20.transfer_from(&amp;owner, &amp;recipient, &amp;transfer_amount); // Tokens are transferred and allowance decremented. assert_eq!( erc20.balance_of(&amp;owner), U256::from(INITIAL_SUPPLY) - transfer_amount ); assert_eq!(erc20.balance_of(&amp;recipient), transfer_amount); assert!(env.emitted_event( &amp;erc20, Approval { owner, spender, value: approved_amount - transfer_amount } )); assert!(env.emitted_event( &amp;erc20, Transfer { from: Some(owner), to: Some(recipient), amount: transfer_amount } )); // assert!(env.emitted(&amp;erc20, &quot;Transfer&quot;)); } #[test] fn transfer_from_error() { // Given a new instance. let (env, mut erc20) = setup(); // When the spender's allowance is zero. let (owner, spender, recipient) = (env.get_account(0), env.get_account(1), env.get_account(2)); let amount = 1_000.into(); env.set_caller(spender); // Then transfer fails. assert_eq!( erc20.try_transfer_from(&amp;owner, &amp;recipient, &amp;amount), Err(Error::InsufficientAllowance.into()) ); } }  L146 - Alternatively, if you don't want to check the entire event, you may assert only its type. ","version":"2.1.0","tagName":"h3"},{"title":"What's next​","type":1,"pageTitle":"ERC-20","url":"/docs/2.1.0/tutorials/erc20#whats-next","content":"Having two modules: Ownable and Erc20, let's combine them, and create an ERC-20 on steroids. ","version":"2.1.0","tagName":"h2"},{"title":"Odra CLI","type":0,"sectionRef":"#","url":"/docs/2.1.0/tutorials/odra-cli","content":"","keywords":"","version":"2.1.0"},{"title":"Example​","type":1,"pageTitle":"Odra CLI","url":"/docs/2.1.0/tutorials/odra-cli#example","content":"Let's go through an example available in the odra repository to see how to use the Odra CLI library. It creates a CLI tool for a useful DogContract. ","version":"2.1.0","tagName":"h2"},{"title":"Cargo.toml​","type":1,"pageTitle":"Odra CLI","url":"/docs/2.1.0/tutorials/odra-cli#cargotoml","content":"To use the Odra CLI library in your project, you need to add odra-cli to your Cargo.toml file, alongside a new binary: [dependencies] ... odra-cli = &quot;2&quot; ... [[bin]] name = &quot;odra-cli&quot; path = &quot;bin/odra-cli.rs&quot;  Then, create an empty file in the bin directory named odra-cli.rs. ","version":"2.1.0","tagName":"h3"},{"title":"Deploy script​","type":1,"pageTitle":"Odra CLI","url":"/docs/2.1.0/tutorials/odra-cli#deploy-script","content":"The first type of script we can create is a deploy script. It is used to deploy the contract to the network and store the address of the deployed contract in a container for later use. Only one deploy script can be used in a single CLI tool, and it is executed when the user runs the deploy command. bin/odra-cli.rs use odra::host::HostEnv; use odra_cli::{ deploy::DeployScript, DeployerExt, DeployedContractsContainer, }; use odra_examples::features::storage::variable::{DogContract, DogContractInitArgs}; /// Deploys the `DogContract` and adds it to the container. pub struct DeployDogScript; impl DeployScript for DeployDogScript { fn deploy( &amp;self, env: &amp;HostEnv, container: &amp;mut DeployedContractsContainer ) -&gt; Result&lt;(), odra_cli::deploy::Error&gt; { env.set_gas(350_000_000_000); let dog_contract = DogContract::try_deploy( env, DogContractInitArgs { barks: true, weight: 10, name: &quot;Mantus&quot;.to_string() } )?; container.add_contract(&amp;dog_contract)?; // Alternatively, you can use the `DeployerExt` trait to deploy the contract: _ = DogContract::load_or_deploy( env, DogContractInitArgs { barks: true, weight: 10, name: &quot;Mantus&quot;.to_string() }, container, 350_000_000_000 )?; Ok(()) } }  In the example above, we see two alternative implementations of a simple DeployScript for our DogContract. Both set the gas limit, deploy the contract and adds it to a container. The first one uses the DogContract::try_deploy method, which deploys the contract every time the script is run. The second one uses the DeployerExt trait, which checks if the contract is already deployed and returns the existing instance if it is, or deploys it if it is not. It is a convenient way to ensure that the contract is deployed only once. It is useful when you want to add more contracts to the script in the future and avoid redeploying previously deployed contracts. The address of the deployed contract is stored in a TOML file in the resources directory, which is created automatically by the Odra CLI library. ","version":"2.1.0","tagName":"h3"},{"title":"Scenarios​","type":1,"pageTitle":"Odra CLI","url":"/docs/2.1.0/tutorials/odra-cli#scenarios","content":"Scenarios are a way to run multiple calls one after another, and can be used to test the contract or perform complex operations like setting up the dependencies between contracts. To create a scenario, you need to implement the Scenario trait and add it to the OdraCli instance in the main function. A scenario also implements the ScenarioMetadata trait, which provides metadata about the scenario, such as its name and description. You can use this metadata to display the scenario in the CLI tool and provide a description of what it does. bin/odra-cli.rs use odra_cli::{ scenario::{Args, Error, Scenario, ScenarioMetadata}, CommandArg, ContractProvider, DeployedContractsContainer, }; use std::vec; pub struct DogCheckScenario; impl Scenario for DogCheckScenario { fn args(&amp;self) -&gt; Vec&lt;CommandArg&gt; { vec![CommandArg::new( &quot;name&quot;, &quot;The name of the dog&quot;, NamedCLType::String, ).required()] } fn run( &amp;self, env: &amp;HostEnv, container: &amp;DeployedContractsContainer, args: Args ) -&gt; Result&lt;(), Error&gt; { let dog_contract = container.contract_ref::&lt;DogContract&gt;(env)?; let test_name = args.get_single::&lt;String&gt;(&quot;name&quot;)?; env.set_gas(50_000_000); let actual_name = dog_contract.try_name()?; assert_eq!(test_name, actual_name, &quot;Dog name mismatch&quot;); Ok(()) } } impl ScenarioMetadata for DogCheckScenario { const NAME: &amp;'static str = &quot;check&quot;; const DESCRIPTION: &amp;'static str = &quot;Checks if the name of the deployed dog matches the provided name&quot;; }  A scenario must implement the Scenario trait, which requires defining the args and run methods. The args method returns a vector of CommandArg that defines the arguments that the scenario accepts. In this case, we define a single argument name of type String, which is required - the program will fail at parse time if the argument is not provided. The run method is where the scenario logic is implemented. It receives the HostEnv, a container with deployed contracts, and the arguments passed to the scenario. To load the contract, we use the ContractProvider trait, which allows us to get a reference to the contract by its type. The trait is implemented for the DeployedContractsContainer, which is passed to the run method. To read the arguments, we use the Args type, which provides two methods: get_single and get_many. In this case, we use get_single to get the value of the name argument. If we want to get multiple values for an argument, we must define the argument as CommandArg::new(&quot;name&quot;, &quot;The name of the dog&quot;, NamedCLType::String).list(), where list() indicates that the argument can be provided multiple times. The example above performs a simple check on the return value of one of the methods. Of course, there is no limit to how complex a scenario can be. ","version":"2.1.0","tagName":"h3"},{"title":"Contract methods​","type":1,"pageTitle":"Odra CLI","url":"/docs/2.1.0/tutorials/odra-cli#contract-methods","content":"To interact with the contract methods, we can use the contract command. The Odra CLI automatically generates commands for each contract method, allowing us to call them directly by name. But first, we need to register the contract in the OdraCli instance. ","version":"2.1.0","tagName":"h3"},{"title":"Builder​","type":1,"pageTitle":"Odra CLI","url":"/docs/2.1.0/tutorials/odra-cli#builder","content":"Now, let's put everything together in the main function. We will use the OdraCli builder to create a CLI tool that can deploy the contract, call its methods, and run scenarios. bin/odra-cli.rs use odra_cli::OdraCli; /// Main function to run the CLI tool. pub fn main() { OdraCli::new() .about(&quot;Dog contract cli tool&quot;) .deploy(DeployDogScript) .contract::&lt;DogContract&gt;() .scenario(DogCheckScenario) .build() .run(); }  This code creates a new OdraCli instance, sets the description of the tool, adds the deploy script, registers the DogContract, and adds the scenario. Finally, it builds the CLI tool and runs it. ","version":"2.1.0","tagName":"h3"},{"title":"How to use it​","type":1,"pageTitle":"Odra CLI","url":"/docs/2.1.0/tutorials/odra-cli#how-to-use-it","content":"Assuming the correct livenet environment is set up, you can run the CLI tool using the following command: cargo run --bin odra-cli  This will display all of our options: Dog contract cli tool Usage: odra_cli [OPTIONS] &lt;COMMAND&gt; Commands: deploy Runs the deploy script contract Commands for interacting with contracts scenario Commands for interacting with scenarios print-events Prints the most recent events emitted by a contract help Print this message or the help of the given subcommand(s) Options: -c, --contracts-toml &lt;PathBuf&gt; The path to the file with the deployed contracts. Relative to the project root. -h, --help Print help  By default, contracts are written/read to/from the contracts.toml file, which is located in the resources directory, but you can specify a different path using the -c or --contracts-toml option. ","version":"2.1.0","tagName":"h2"},{"title":"Deploy command​","type":1,"pageTitle":"Odra CLI","url":"/docs/2.1.0/tutorials/odra-cli#deploy-command","content":"First, we need to deploy the contract: cargo run --bin odra_cli deploy  This gives us the following output: cargo run --bin odra_cli -- deploy Compiling odra-examples v2.1.0 (/home/kuba/Projekty/odra/odra/examples) Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.65s Running `../target/debug/odra_cli deploy` 💁 INFO : Found wasm under &quot;wasm/DogContract.wasm&quot;. 💁 INFO : Deploying &quot;DogContract&quot;. 🙄 WAIT : Waiting 10 for V1(TransactionV1Hash(4230d5ca3113d87190e4136cefe097bd08fea03c841ce5e4df73a049e10208f1)). 💁 INFO : Transaction &quot;4230d5ca3113d87190e4136cefe097bd08fea03c841ce5e4df73a049e10208f1&quot; successfully executed. 🔗 LINK : 💁 INFO : Contract &quot;contract-package-53b3486180b2a9506fbb0523ed159b1908cec628d091b19cbe74e057e7ebbc8b&quot; deployed. 💁 INFO : Command executed successfully  This will run the deploy script and create a new file in the resources directory named contracts.toml: last_updated = &quot;2025-07-03T10:33:55Z&quot; [[contracts]] name = &quot;DogContract&quot; package_hash = &quot;hash-53b3486180b2a9506fbb0523ed159b1908cec628d091b19cbe74e057e7ebbc8b&quot;  All the calls to the contract will be made using this package hash, unless you specify a different one using the -c or --contracts-toml option. ","version":"2.1.0","tagName":"h3"},{"title":"Contract command​","type":1,"pageTitle":"Odra CLI","url":"/docs/2.1.0/tutorials/odra-cli#contract-command","content":"To call a contract method, we need to use the contract command. The command itself will display all the available contracts: cargo run --bin odra_cli -- contract  This outputs: Commands for interacting with contracts Usage: odra_cli contract &lt;COMMAND&gt; Commands: DogContract Commands for interacting with the DogContract contract help Print this message or the help of the given subcommand(s)  And when a contract is selected, it will show us the available methods: cargo run --bin odra_cli -- contract DogContract  Commands for interacting with the DogContract contract Usage: odra_cli contract DogContract &lt;COMMAND&gt; Commands: barks Returns true if the dog barks. weight Returns the dog's weight. name Returns the dog's name. walks_amount Adds a walk to the dog's walks. walks_total_length Returns the total length of the dog's walks. help Print this message or the help of the given subcommand(s)  To run a command, compose a command like this: cargo run --bin odra_cli -- contract DogContract barks  This will result in: 💁 INFO : Call result: true 💁 INFO : Command executed successfully  If you run a command that requires arguments, it will display an error message: cargo run --bin odra_cli -- contract DogContract rename error: the following required arguments were not provided: --new_name &lt;String&gt; --gas &lt;U64&gt; Usage: odra_cli contract DogContract rename --new_name &lt;String&gt; --gas &lt;U64&gt; For more information, try '--help'.  The error message above indicates that the rename method requires two arguments: new_name and gas. In the code, the rename method is mutable and takes a single argument new_name of type String. As the entry point is mutable and requires a real transaction, the gas argument is also required to specify how much gas to use for the call. The gas amount is denominated in motes. Let's run the command with the required arguments: cargo run --bin odra_cli -- contract DogContract rename --new_name &quot;Doggy&quot; --gas 200000000 error: invalid value '200000000' for '--gas &lt;U64&gt;': 200000000 is not in 2500000000..18446744073709551615  As the minimum gas amount for a transaction is 2.5 CSPRs, we need to increase the gas amount to at least that value: cargo run --bin odra_cli -- contract DogContract rename --new_name &quot;Doggy&quot; --gas 2500000000 💁 INFO : Calling &quot;contract-package-0eda9544d667775d8e5503543dd8ba0996d439fd9ded79cfe28454d07f42df3a&quot; directly with entrypoint &quot;rename&quot;. 🙄 WAIT : Waiting 10 for V1(TransactionV1Hash(e9d2e7f9d7d832cbf64e6e9eb09404423757e354a1ed7420c0398d851fea3a40)). 💁 INFO : Transaction &quot;e9d2e7f9d7d832cbf64e6e9eb09404423757e354a1ed7420c0398d851fea3a40&quot; successfully executed. 🔗 LINK : 💁 INFO : Call executed successfully, but no result was returned. 💁 INFO : Command executed successfully # Verifying the name change cargo run --bin odra_cli -- contract DogContract name 💁 INFO : Call result: Doggy 💁 INFO : Command executed successfully  There are more options available for the contract command that we can discover by running the help command: cargo run --bin odra_cli -- contract DogContract rename --help It is uncommon but you can change the dog's name. Usage: odra_cli contract DogContract rename [OPTIONS] --new_name &lt;String&gt; --gas &lt;U64&gt; Options: --new_name &lt;String&gt; --attached_value &lt;U512&gt; The amount of CSPRs attached to the call --gas &lt;U64&gt; The amount of gas to attach to the call -p, --print-events Print events emitted by the contract -h, --help  If you want to print the events emitted by the contract, you can use the --print-events option. This will print all the events emitted by the contract during the call. cargo run --bin odra_cli -- contract DogContract rename --new_name &quot;Doggy&quot; --gas 2500000000 --print-events 💁 INFO : Syncing events for the call... 💁 INFO : Calling &quot;contract-package-0eda9544d667775d8e5503543dd8ba0996d439fd9ded79cfe28454d07f42df3a&quot; directly with entrypoint &quot;rename&quot;. 🙄 WAIT : Waiting 10 for V1(TransactionV1Hash(f2f473d46b59c136052f687539ab76e5fbb3af958c483e3a382b5a0e498227c4)). 💁 INFO : Transaction &quot;f2f473d46b59c136052f687539ab76e5fbb3af958c483e3a382b5a0e498227c4&quot; successfully executed. 🔗 LINK : 💁 INFO : Captured 1 events for contract 'DogContract' 💁 INFO : Event 1: 'NamedChanged': 'old_name': Mantus 'new_name': Doggy 💁 INFO : Call executed successfully, but no result was returned. 💁 INFO : Command executed successfully  For a payable method, you can use the --attached_value option to specify the amount of CSPRs to attach to the call. The value is denominated in motes. ","version":"2.1.0","tagName":"h3"},{"title":"Print-events command​","type":1,"pageTitle":"Odra CLI","url":"/docs/2.1.0/tutorials/odra-cli#print-events-command","content":"The print-events command allows you to print the most recent events emitted by a contract. It is useful for debugging and understanding what is happening in the contract. You can run it like this: cargo run --bin odra_cli -- print-events DogContract --help Print events of the DogContract contract Usage: odra_cli print-events DogContract [OPTIONS] Options: -n, --number &lt;N&gt; Number of events to print [default: 10] -h, --help Print help cargo run --bin odra_cli -- print-events DogContract -n 2 💁 INFO : Printing 4 the most recent events for contract 'DogContract' 💁 INFO : Event 1: 'NamedChanged': 'old_name': Mantus 'new_name': Doggy 💁 INFO : Event 2: 'NamedChanged': 'old_name': Rex 'new_name': Mantus 💁 INFO : Command executed successfully  By default, it prints the last 10 events, but you can specify a different number using the -n or --number option. ","version":"2.1.0","tagName":"h3"},{"title":"Scenario command​","type":1,"pageTitle":"Odra CLI","url":"/docs/2.1.0/tutorials/odra-cli#scenario-command","content":"Scenarios registered in the OdraCli instance can be run using the scenario command. It displays all the available scenarios: cargo run --bin odra_cli -- scenario  This will output: Commands for running user-defined scenarios Usage: odra_cli scenario &lt;COMMAND&gt; Commands: check Checks if the name of the deployed dog matches the provided name help Print this message or the help of the given subcommand(s)  It can be run like this: cargo run --bin odra_cli -- scenario check --name Doggy  This will output: thread 'main' panicked at examples/bin/odra_cli.rs:59:9: assertion `left == right` failed: Dog name mismatch left: &quot;Doggy&quot; right: &quot;Mantus&quot; ## Conclusion The Odra CLI library provides a powerful and convenient way to create command-line tools for your Odra contracts. It simplifies the process of deploying, interacting with, and testing your contracts, allowing you to focus on the business logic of your application. By following the examples in this tutorial, you can create your own CLI tools and streamline your development workflow.  ","version":"2.1.0","tagName":"h3"},{"title":"Ticketing System","type":0,"sectionRef":"#","url":"/docs/2.1.0/tutorials/nft","content":"","keywords":"","version":"2.1.0"},{"title":"Ticket Office Contract​","type":1,"pageTitle":"Ticketing System","url":"/docs/2.1.0/tutorials/nft#ticket-office-contract","content":"Our TicketOffice contract will include the following features: Compliance with the CEP-78 standard.Ownership functionality.Only the owner can issue new event tickets.Users can purchase tickets for events.Tickets are limited to a one-time sale.Public access to view the total income of the TicketOffice. ","version":"2.1.0","tagName":"h2"},{"title":"Setup the project​","type":1,"pageTitle":"Ticketing System","url":"/docs/2.1.0/tutorials/nft#setup-the-project","content":"Creating a new NFT token with Odra is straightforward. Use the cargo odra new command to create a new project with the CEP-95 template: cargo odra new --name ticket-office --template cep95  ","version":"2.1.0","tagName":"h2"},{"title":"Contract implementation​","type":1,"pageTitle":"Ticketing System","url":"/docs/2.1.0/tutorials/nft#contract-implementation","content":"Let's start implementing the TicketOffice contract by modify the code generated from the template. src/token.rs use odra::{casper_types::{U256, U512}, prelude::*}; use odra_modules::access::Ownable; use odra_modules::cep95::{CEP95Interface, Cep95}; pub type TicketId = U256; #[odra::odra_type] pub enum TicketStatus { Available, Sold, } #[odra::odra_type] pub struct TicketInfo { event_name: String, price: U512, status: TicketStatus, } #[odra::event] pub struct OnTicketIssue { ticket_id: TicketId, event_name: String, price: U512, } #[odra::event] pub struct OnTicketSell { ticket_id: TicketId, buyer: Address, } #[odra::odra_error] pub enum Error { TicketNotAvailableForSale = 200, InsufficientFunds = 201, InvalidTicketId = 202, TicketDoesNotExist = 203, } #[odra::module( events = [OnTicketIssue, OnTicketSell], errors = Error )] pub struct TicketOffice { token: SubModule&lt;Cep95&gt;, ownable: SubModule&lt;Ownable&gt;, tickets: Mapping&lt;TicketId, TicketInfo&gt;, token_id_counter: Var&lt;TicketId&gt;, total_supply: Var&lt;u64&gt;, } #[odra::module] impl TicketOffice { pub fn init(&amp;mut self, collection_name: String, collection_symbol: String, total_supply: u64) { let caller = self.env().caller(); self.ownable.init(caller); self.token.init(collection_name, collection_symbol); } pub fn issue_ticket(&amp;mut self, event_name: String, price: U512) { let env = self.env(); let caller = env.caller(); self.ownable.assert_owner(&amp;caller); // mint a new token let ticket_id = self.token_id_counter.get_or_default(); self.token.mint(caller, ticket_id, Default::default()); // store ticket info self.tickets.set( &amp;ticket_id, TicketInfo { event_name: event_name.clone(), price, status: TicketStatus::Available, }, ); self.token_id_counter.set(ticket_id + 1); // emit an event env.emit_event(OnTicketIssue { ticket_id, event_name, price, }); } #[odra(payable)] pub fn buy_ticket(&amp;mut self, ticket_id: TicketId) { let env = self.env(); let owner = self.ownable.get_owner(); let buyer = env.caller(); let value = env.attached_value(); // only tokens owned by the owner can be sold if self.token.owner_of(ticket_id) != Some(owner) { env.revert(Error::TicketNotAvailableForSale); } let mut ticket = self .tickets .get(&amp;ticket_id) .unwrap_or_revert_with(&amp;env, Error::TicketDoesNotExist); // only available tickets can be sold if ticket.status != TicketStatus::Available { env.revert(Error::TicketNotAvailableForSale); } // check if the buyer sends enough funds if value &lt; ticket.price { env.revert(Error::InsufficientFunds); } // transfer csprs to the owner env.transfer_tokens(&amp;owner, &amp;value); // transfer the ticket to the buyer self.token.transfer_from(owner, buyer, ticket_id); ticket.status = TicketStatus::Sold; self.tickets.set(&amp;ticket_id, ticket); env.emit_event(OnTicketSell { ticket_id, buyer }); } pub fn balance_of(&amp;self) -&gt; U512 { self.env().self_balance() } }  L7-L39 - We define structures and enums that will be used in our contract. TicketStatus enum represents the status of a ticket, TicketInfo struct contains information about a ticket that is written to the storage, TicketId is a type alias for u64. OnTicketIssue and OnTicketSell are events that will be emitted when a ticket is issued or sold.L41-L44 - Register errors and events that will be used in our contract, required to produce a complete contract schema.L45-L51 - TicketOffice module definition. The module contains a Cep95 token, an Ownable module, a Mapping that stores information about tickets and Vars token_id_counter and total_supply to keep track of the total number of tickets issued.L55-L59 - The init function has been generated from the template and there is no need to modify it, except the Ownable module initialization.L61-L84 - The issue_ticket function allows the owner to issue a new ticket. The function mints a new token, stores information about the ticket, and emits an OnTicketIssue event.L86 - The payable attribute indicates that the buy_ticket function can receive funds.L87-L116 - The buy_ticket function checks if the ticket is available for sale, if the buyer sends enough funds, and transfers the ticket to the buyer. Finally, the function updates the ticket status and emits an OnTicketSell event. Lets test the contract. The test scenario will be as follows: Deploy the contract.Issue two tickets.Try to buy a ticket with insufficient funds.Buy tickets.Try to buy the same ticket again.Check the balance of the contract. src/tests.rs use odra::{ casper_types::U512, host::{Deployer, HostRef}, }; use crate::token::{Error, TicketOfficeHostRef, TicketOfficeInitArgs}; #[test] fn it_works() { let env = odra_test::env(); let init_args = TicketOfficeInitArgs { collection_name: &quot;Ticket&quot;.to_string(), collection_symbol: &quot;T&quot;.to_string(), total_supply: 100, }; let mut contract = TicketOffice::deploy(&amp;env, init_args); contract.issue_ticket(&quot;Ev&quot;.to_string(), U512::from(100)); contract.issue_ticket(&quot;Ev&quot;.to_string(), U512::from(50)); let buyer = env.get_account(1); env.set_caller(buyer); assert_eq!( contract .with_tokens(U512::from(50)) .try_buy_ticket(0.into()), Err(Error::InsufficientFunds.into()) ); assert_eq!( contract .with_tokens(U512::from(100)) .try_buy_ticket(0.into()), Ok(()) ); assert_eq!( contract .with_tokens(U512::from(50)) .try_buy_ticket(1.into()), Ok(()) ); assert_eq!( contract .with_tokens(U512::from(100)) .try_buy_ticket(0.into()), Err(Error::TicketNotAvailableForSale.into()) ); }  Unfortunately, the test failed. The first assertion succeeds because the buyer sends insufficient funds to buy the ticket. However, the second assertion fails even though the buyer sends enough funds to purchase the ticket. The buy_ticket function reverts with CEP-95 Error::NotAnOwnerOrApproved because the buyer attempts to transfer a token that they do not own, are not approved for, or are not an operator of. odra/modules/src/cep95.rs fn transfer_from(&amp;mut self, from: Address, to: Address, token_id: U256) { self.assert_exists(&amp;token_id); let caller = self.env().caller(); let owner = self .owner_of(token_id) .unwrap_or_revert_with(self, Error::ValueNotSet); // Only the owner or an approved spender can transfer the token. if (owner != from || owner != caller) &amp;&amp; !self.is_approved_for_all(from, caller) { if let Some(approved) = self.approved_for(token_id) { if approved != caller { self.env().revert(Error::NotAnOwnerOrApproved); } } else { self.env().revert(Error::NotAnOwnerOrApproved); } } ... }  Let's fix it by redesigning our little system. ","version":"2.1.0","tagName":"h2"},{"title":"Redesign​","type":1,"pageTitle":"Ticketing System","url":"/docs/2.1.0/tutorials/nft#redesign","content":"Since a buyer cannot purchase a ticket directly, we need to introduce an intermediary — an operator who will be responsible for buying tickets on behalf of the buyer. The operator will be approved by the ticket office to transfer tickets. The sequence diagram below illustrates the new flow: ","version":"2.1.0","tagName":"h2"},{"title":"Ticket Operator Contract​","type":1,"pageTitle":"Ticketing System","url":"/docs/2.1.0/tutorials/nft#ticket-operator-contract","content":"As shown in the sequence diagram, a new contract will act as an operator for the ticket office. To create this new contract, use the cargo odra generate command. cargo odra generate -c ticket_operator  src/ticket_operator.rs use crate::token::{TicketId, TicketOfficeContractRef}; use odra::{casper_types::{U256, U512}, ContractRef, prelude::*}; #[odra::odra_error] pub enum Error { UnknownTicketOffice = 300, } #[odra::module(errors = Error)] pub struct TicketOperator { ticket_office_address: Var&lt;Address&gt;, } #[odra::module] impl TicketOperator { pub fn register(&amp;mut self, ticket_office_address: Address) { self.ticket_office_address.set(ticket_office_address); } // now the operator's `buy_ticket` receives funds. #[odra(payable)] pub fn buy_ticket(&amp;mut self, ticket_id: TicketId) { let env = self.env(); let buyer = env.caller(); let value = env.attached_value(); let center = self .ticket_office_address .get() .unwrap_or_revert_with(&amp;env, Error::UnknownTicketOffice); let mut ticket_contract = TicketOfficeContractRef::new(env, center); // now and approved entity - the operator - buys the ticket on behalf of the buyer ticket_contract.buy_ticket(ticket_id, buyer, value); } pub fn balance_of(&amp;self) -&gt; U512 { self.env().self_balance() } }  L4-L7 - Define errors that will be used in the contract.L9-L13 - Define the TicketOperator module that stores the address of the ticketing office.L16-L18 - The register function sets the address of the ticketing office.L20-L32 - The buy_ticket function buys a ticket on behalf of the buyer using the ticket office address. The function forwards the call to the ticketing office contract. We simply create a TicketOfficeContractRef to interact we the TicketOffice contract. Note that, the operator's buy_ticket now receives funds. Now we need to adjust the TicketOffice contract to use the TicketOperator contract to buy tickets. src/token.rs #[odra::odra_error] pub enum Error { ... MissingOperator = 204, Unauthorized = 205, } #[odra::module] pub struct TicketOffice { ... operator: Var&lt;Address&gt;, } #[odra::module] impl TicketOffice { ... pub fn register_operator(&amp;mut self, operator: Address) { // only the owner can register an operator let caller = self.env().caller(); self.ownable.assert_owner(&amp;caller); // store the ticketing center address in the operator contract TicketOperatorContractRef::new(self.env(), operator).register(self.env().self_address()); self.operator.set(operator); } pub fn issue_ticket(&amp;mut self, event_name: String, price: U512) { // minting logic remains the same... ... // approve the operator to transfer the ticket let operator = self.operator(); self.token.approve(operator, ticket_id); // emit an event ... } pub fn buy_ticket(&amp;mut self, ticket_id: TicketId, buyer: Address, value: U512) { let env = self.env(); let owner = self.ownable.get_owner(); let caller = env.caller(); // make sure the caller is the operator if !self.is_operator(caller) { env.revert(Error::Unauthorized); } ... // the logic remains the same, except for the csprs transfer // it is now handled by the operator contract. // env.transfer_tokens(&amp;owner, &amp;value); } #[inline] fn is_operator(&amp;self, caller: Address) -&gt; bool { Some(caller) == self.operator.get() } #[inline] fn operator(&amp;self) -&gt; Address { self.operator .get() .unwrap_or_revert_with(&amp;self.env(), Error::MissingOperator) } }  L11 - the contract stores the operator address.L18-L25 - a new function register_operator allows the owner to register an operator. Also calls the register entry point on the operator contract.L32-36 - modify the issue_ticket function: once a new token is minted, approves the operator to transfer the ticket later.L40-L53 - modify the buy_ticket function: check if the caller is the operator, do not transfer cspr to the contract - now the operator collect funds.We also added two helper functions: is_operator and operator to check if the caller is the operator and get the operator address. Two new errors were added: MissingOperator and Unauthorized. Now we need to update our tests to create a scenario we presented in the sequence diagram. src/tests.rs use odra::{ casper_types::U512, host::{Deployer, HostRef, NoArgs}, prelude::* }; use crate::{ ticket_operator::TicketOperatorHostRef, token::{Error, TicketId, TicketOfficeContractRef, TicketOfficeInitArgs}, }; #[test] fn it_works() { let env = odra_test::env(); let init_args = TicketOfficeInitArgs { collection_name: &quot;Ticket&quot;.to_string(), collection_symbol: &quot;T&quot;.to_string(), total_supply: 100, }; let operator = TicketOperator::deploy(&amp;env, NoArgs); let mut ticket_office = TicketOfficeContractRef::deploy(&amp;env, init_args); ticket_office.register_operator(operator.address().clone()); ticket_office.issue_ticket(&quot;Ev&quot;.to_string(), U512::from(100)); ticket_office.issue_ticket(&quot;Ev&quot;.to_string(), U512::from(50)); let buyer = env.get_account(1); env.set_caller(buyer); assert_eq!( buy_ticket(&amp;operator, 0.into(), 50), Err(Error::InsufficientFunds.into()) ); assert_eq!(buy_ticket(&amp;operator, 0.into(), 100), Ok(())); assert_eq!(buy_ticket(&amp;operator, 1.into(), 50), Ok(())); assert_eq!( buy_ticket(&amp;operator, 0.into(), 100), Err(Error::TicketNotAvailableForSale.into()) ); assert_eq!(operator.balance_of(), U512::from(150)); } fn buy_ticket(operator: &amp;TicketOperatorHostRef, id: TicketId, price: u64) -&gt; OdraResult&lt;()&gt; { operator.with_tokens(U512::from(price)).try_buy_ticket(id) }  ","version":"2.1.0","tagName":"h3"},{"title":"Conclusion​","type":1,"pageTitle":"Ticketing System","url":"/docs/2.1.0/tutorials/nft#conclusion","content":"In this tutorial, we created a simple ticketing system using the CEP-95 standard. This guide demonstrates how to combine various Odra features, including modules, events, errors, payable functions, and cross-contract calls. ","version":"2.1.0","tagName":"h2"},{"title":"Ownable","type":0,"sectionRef":"#","url":"/docs/2.1.0/tutorials/ownable","content":"","keywords":"","version":"2.1.0"},{"title":"Framework features​","type":1,"pageTitle":"Ownable","url":"/docs/2.1.0/tutorials/ownable#framework-features","content":"A module we will write in a minute, will help you master a few Odra features: storing a single value,defining a constructor,error handling,defining and emitting events.registering a contact in a test environment,interactions with the test environment,assertions (value, events, errors assertions). ","version":"2.1.0","tagName":"h2"},{"title":"Code​","type":1,"pageTitle":"Ownable","url":"/docs/2.1.0/tutorials/ownable#code","content":"Before we write any code, we define functionalities we would like to implement. Module has an initializer that should be called once. Only the current owner can set a new owner.Read the current owner.A function that fails if called by a non-owner account. ","version":"2.1.0","tagName":"h2"},{"title":"Define a module​","type":1,"pageTitle":"Ownable","url":"/docs/2.1.0/tutorials/ownable#define-a-module","content":"ownable.rs use odra::prelude::*; #[odra::module(events = [OwnershipChanged])] pub struct Ownable { owner: Var&lt;Option&lt;Address&gt;&gt; }  That was easy, but it is crucial to understand the basics before we move on. L3 - Firstly, we need to create a struct called Ownable and apply #[odra::module(events = [OwnershipChanged])] attribute to it. The events attribute is optional but informs the Odra toolchain about the events that will be emitted by the module and includes them in the contract's metadata. OwnershipChanged is a type that will be defined later.L5 - Then we can define the layout of our module. It is extremely simple - just a single state value. What is most important is that you can never leave a raw type; you must always wrap it with Var. ","version":"2.1.0","tagName":"h3"},{"title":"Init the module​","type":1,"pageTitle":"Ownable","url":"/docs/2.1.0/tutorials/ownable#init-the-module","content":"ownable.rs #[odra::module] impl Ownable { pub fn init(&amp;mut self, owner: Address) { if self.owner.get_or_default().is_some() { self.env().revert(Error::OwnerIsAlreadyInitialized) } self.owner.set(Some(owner)); self.env().emit_event(OwnershipChanged { prev_owner: None, new_owner: owner }); } } #[odra::odra_error] pub enum Error { OwnerIsAlreadyInitialized = 1, } #[odra::event] pub struct OwnershipChanged { pub prev_owner: Option&lt;Address&gt;, pub new_owner: Address }  Ok, we have done a couple of things, let's analyze them one by one: L1 - The impl should be an Odra module, so add #[odra::module].L3 - The init function is a constructor. This matters if we would like to deploy the Ownable module as a standalone contract.L17-L20 - Before we set a new owner, we must assert there was no owner before and raise an error otherwise. For that purpose, we defined an Error enum. Notice that the #[odra::odra_error] attribute is applied to the enum. It generates, among others, the required Into&lt;odra::OdraError&gt; binding.L4-L6 - If the owner has been set already, we call ContractEnv::revert() function with an Error::OwnerIsAlreadyInitialized argument. L8 - Then we write the owner passed as an argument to the storage. To do so, we call the set() on Var.L22-L26 - Once the owner is set, we would like to inform the outside world. The first step is to define an event struct. The struct annotated with #[odra::event] attribute.L10 - Finally, call ContractEnv::emit_event() passing the OwnershipChanged instance to the function. Hence, we set the first owner, we set the prev_owner value to None.  ","version":"2.1.0","tagName":"h3"},{"title":"Features implementation​","type":1,"pageTitle":"Ownable","url":"/docs/2.1.0/tutorials/ownable#features-implementation","content":"ownable.rs #[odra::module] impl Ownable { ... pub fn ensure_ownership(&amp;self, address: &amp;Address) { if Some(address) != self.owner.get_or_default().as_ref() { self.env().revert(Error::NotOwner) } } pub fn change_ownership(&amp;mut self, new_owner: &amp;Address) { self.ensure_ownership(&amp;self.env().caller()); let current_owner = self.get_owner(); self.owner.set(Some(*new_owner)); self.env().emit_event(OwnershipChanged { prev_owner: Some(current_owner), new_owner: *new_owner }); } pub fn get_owner(&amp;self) -&gt; Address { match self.owner.get_or_default() { Some(owner) =&gt; owner, None =&gt; self.env().revert(Error::OwnerIsNotInitialized) } } } #[odra::odra_error] pub enum Error { NotOwner = 1, OwnerIsAlreadyInitialized = 2, OwnerIsNotInitialized = 3, }  The above implementation relies on the concepts we have already used in this tutorial, so it should be easy for you to get along. L7,L31 - ensure_ownership() reads the current owner and reverts if it does not match the input Address. Also, we need to update our Error enum by adding a new variant NotOwner.L11 - The function defined above can be reused in the change_ownership() implementation. We pass to it the current caller, using the ContractEnv::caller() function. Then we update the state and emit OwnershipChanged.L21,L33 - Lastly, a getter function. Read the owner from storage, if the getter is called on an uninitialized module, it should revert with a new Error variant OwnerIsNotInitialized. There is one worth-mentioning subtlety: Var::get() function returns Option&lt;T&gt;. If the type implements the Default trait, you can call the get_or_default() function, and the contract does not fail even if the value is not initialized. As the owner is of type Option&lt;Address&gt; the Var::get() would return Option&lt;Option&lt;Address&gt;&gt;, we use Var::get_or_default() instead. ","version":"2.1.0","tagName":"h3"},{"title":"Test​","type":1,"pageTitle":"Ownable","url":"/docs/2.1.0/tutorials/ownable#test","content":"ownable.rs #[cfg(test)] mod tests { use super::*; use odra::host::{Deployer, HostEnv}; fn setup() -&gt; (OwnableHostRef, HostEnv, Address) { let env: HostEnv = odra_test::env(); let init_args = OwnableInitArgs { owner: env.get_account(0) }; (Ownable::deploy(&amp;env, init_args), env.clone(), env.get_account(0)) } #[test] fn initialization_works() { let (ownable, env, owner) = setup(); assert_eq!(ownable.get_owner(), owner); env.emitted_event( &amp;ownable, OwnershipChanged { prev_owner: None, new_owner: owner } ); } #[test] fn owner_can_change_ownership() { let (mut ownable, env, owner) = setup(); let new_owner = env.get_account(1); env.set_caller(owner); ownable.change_ownership(&amp;new_owner); assert_eq!(ownable.get_owner(), new_owner); env.emitted_event( &amp;ownable, OwnershipChanged { prev_owner: Some(owner), new_owner } ); } #[test] fn non_owner_cannot_change_ownership() { let (mut ownable, env, _) = setup(); let new_owner = env.get_account(1); ownable.change_ownership(&amp;new_owner); assert_eq!( ownable.try_change_ownership(&amp;new_owner), Err(Error::NotOwner.into()) ); } }  L6 - Each test case starts with the same initialization process, so for convenience, we have defined the setup() function, which we call in the first statement of each test. Take a look at the signature: fn setup() -&gt; (OwnableHostRef, HostEnv, Address). OwnableHostRef is a contract reference generated by Odra. This reference allows us to call all the defined entrypoints, namely: ensure_ownership(), change_ownership(), get_owner(), but not init(), which is a constructor.L7-L11 - The starting point of every test is getting an instance of HostEnv by calling odra_test::env(). Our function returns a triple: a contract ref, an env, and an address (the initial owner). Odra's #[odra::module] attribute implements a odra::host::Deployer for Ownable, and OwnableInitArgs that we pass as the second argument of the odra::host::Deployer::deploy() function. Lastly, the module needs an owner. The easiest way is to take one from the HostEnv. We choose the address of first account (which is the default one). L14 - It is time to define the first test. As you see, it is a regular Rust test.L16-17 - Using the setup() function, we get the owner and a reference (in this test, we don't use the env, so we ignore it). We make a standard assertion, comparing the owner we know with the value returned from the contract. note You may have noticed, we use here the term module interchangeably with contract. The reason is once we deploy our module onto a virtual blockchain it may be considered a contract. L19-25 - On the contract, only the init() function has been called, so we expect one event to have been emitted. To assert that, let's use HostEnv. To get the env, we call env() on the contract, then call HostEnv::emitted_event. As the first argument, pass the contract you want to read events from, followed by an event as you expect it to have occurred.L31 - Because we know the initial owner is the 0th account, we must select a different account. It could be any index from 1 to 19 - the HostEnv predefines 20 accounts.L33 - As mentioned, the default is the 0th account, if you want to change the executor, call the HostEnv::set_caller() function. note The caller switch applies only the next contract interaction, the second call will be done as the default account. L46-55 - If a non-owner account tries to change ownership, we expect it to fail. To capture the error, call HostEnv::try_change_ownership() instead of HostEnv::change_ownership(). HostEnv provides try_ functions for each contract's entrypoint. The try functions return OdraResult (an alias for Result&lt;T, OdraError&gt;) instead of panicking and halting the execution. In our case, we expect the contract to revert with the Error::NotOwner error. To compare the error, we use the Error::into() function, which converts the error into the OdraError type. ","version":"2.1.0","tagName":"h3"},{"title":"Summary​","type":1,"pageTitle":"Ownable","url":"/docs/2.1.0/tutorials/ownable#summary","content":"The Ownable module is ready, and we can test it against any defined backend. Theoretically it can be deployed as a standalone contract, but in upcoming tutorials you will see how to use it to compose a more complex contract. ","version":"2.1.0","tagName":"h2"},{"title":"What's next​","type":1,"pageTitle":"Ownable","url":"/docs/2.1.0/tutorials/ownable#whats-next","content":"In the next tutorial we will implement a ERC20 standard. ","version":"2.1.0","tagName":"h2"},{"title":"OwnedToken","type":0,"sectionRef":"#","url":"/docs/2.1.0/tutorials/owned-token","content":"","keywords":"","version":"2.1.0"},{"title":"Code​","type":1,"pageTitle":"OwnedToken","url":"/docs/2.1.0/tutorials/owned-token#code","content":"What should our module be capable of? Conform the Erc20 interface.Allow only the module owner to mint tokens.Enable the current owner to designate a new owner. ","version":"2.1.0","tagName":"h2"},{"title":"Module definition​","type":1,"pageTitle":"OwnedToken","url":"/docs/2.1.0/tutorials/owned-token#module-definition","content":"Let's define a module called OwnedToken that is a composition of Ownable and Erc20 modules. owned_token.rs use crate::{erc20::Erc20, ownable::Ownable}; use odra::prelude::*; #[odra::module] pub struct OwnedToken { ownable: SubModule&lt;Ownable&gt;, erc20: SubModule&lt;Erc20&gt; }  As you can see, we do not need any storage definition - we just take advantage of the already-defined modules! ","version":"2.1.0","tagName":"h3"},{"title":"Delegation​","type":1,"pageTitle":"OwnedToken","url":"/docs/2.1.0/tutorials/owned-token#delegation","content":"owned_token.rs ... use odra::casper_types::U256; ... #[odra::module] impl OwnedToken { pub fn init(&amp;mut self, name: String, symbol: String, decimals: u8, initial_supply: U256) { let deployer = self.env().caller(); self.ownable.init(deployer); self.erc20.init(name, symbol, decimals, initial_supply); } pub fn name(&amp;self) -&gt; String { self.erc20.name() } pub fn symbol(&amp;self) -&gt; String { self.erc20.symbol() } pub fn decimals(&amp;self) -&gt; u8 { self.erc20.decimals() } pub fn total_supply(&amp;self) -&gt; U256 { self.erc20.total_supply() } pub fn balance_of(&amp;self, address: &amp;Address) -&gt; U256 { self.erc20.balance_of(address) } pub fn allowance(&amp;self, owner: &amp;Address, spender: &amp;Address) -&gt; U256 { self.erc20.allowance(owner, spender) } pub fn transfer(&amp;mut self, recipient: &amp;Address, amount: &amp;U256) { self.erc20.transfer(recipient, amount); } pub fn transfer_from(&amp;mut self, owner: &amp;Address, recipient: &amp;Address, amount: &amp;U256) { self.erc20.transfer_from(owner, recipient, amount); } pub fn approve(&amp;mut self, spender: &amp;Address, amount: &amp;U256) { self.erc20.approve(spender, amount); } pub fn get_owner(&amp;self) -&gt; Address { self.ownable.get_owner() } pub fn change_ownership(&amp;mut self, new_owner: &amp;Address) { self.ownable.change_ownership(new_owner); } pub fn mint(&amp;mut self, address: &amp;Address, amount: &amp;U256) { self.ownable.ensure_ownership(&amp;self.env().caller()); self.erc20.mint(address, amount); } }  Easy. However, there are a few worth mentioning subtleness: L9-L10 - A constructor is an excellent place to initialize both modules at once.L13-L15 - Most of the entrypoints do not need any modification, so we simply delegate them to the erc20 module.L49-L51 - The same is done with the ownable module.L57-L60 - Minting should not be unconditional, we need some control over it. First, using ownable we make sure the caller really is indeed the owner. ","version":"2.1.0","tagName":"h3"},{"title":"Summary​","type":1,"pageTitle":"OwnedToken","url":"/docs/2.1.0/tutorials/owned-token#summary","content":"The Odra Framework encourages a modularized design of your smart contracts. You can encapsulate features in smaller units and test them in isolation, ensuring your project is easy to maintain. Finally, unleash their full potential by combining modules. You do not need any magic bindings for that. ","version":"2.1.0","tagName":"h2"},{"title":"Pausable","type":0,"sectionRef":"#","url":"/docs/2.1.0/tutorials/pauseable","content":"","keywords":"","version":"2.1.0"},{"title":"Code​","type":1,"pageTitle":"Pausable","url":"/docs/2.1.0/tutorials/pauseable#code","content":"As always, we will start with defining functionalities of our module. Check the state - is it paused or not.State guards - a contract should stop execution if is in a state we don't expect.Switch the state. ","version":"2.1.0","tagName":"h2"},{"title":"Events and Error​","type":1,"pageTitle":"Pausable","url":"/docs/2.1.0/tutorials/pauseable#events-and-error","content":"There just two errors that may occur: PausedRequired, UnpausedRequired. We define them in a standard Odra way. Events definition is highly uncomplicated: Paused and Unpaused events holds only the address of the pauser. pauseable.rs use odra::prelude::*; #[odra::odra_error] pub enum Error { PausedRequired = 1_000, UnpausedRequired = 1_001, } #[odra::event] pub struct Paused { pub account: Address } #[odra::event] pub struct Unpaused { pub account: Address }  ","version":"2.1.0","tagName":"h3"},{"title":"Module definition​","type":1,"pageTitle":"Pausable","url":"/docs/2.1.0/tutorials/pauseable#module-definition","content":"The module storage is extremely simple - has a single Var of type bool, that indicates if a contract is paused. pauseable.rs #[odra::module(events = [Paused, Unpaused], errors = Error)] pub struct Pausable { is_paused: Var&lt;bool&gt; }  ","version":"2.1.0","tagName":"h3"},{"title":"Checks and guards​","type":1,"pageTitle":"Pausable","url":"/docs/2.1.0/tutorials/pauseable#checks-and-guards","content":"Now, let's move to state checks and guards. pauseable.rs impl Pausable { pub fn is_paused(&amp;self) -&gt; bool { self.is_paused.get_or_default() } pub fn require_not_paused(&amp;self) { if self.is_paused() { self.env().revert(Error::UnpausedRequired); } } pub fn require_paused(&amp;self) { if !self.is_paused() { self.env().revert(Error::PausedRequired); } } }  L1 - as mentioned in the intro, the module is not intended to be a standalone contract, so the only impl block is not annotated with odra::module and hence does not expose any entrypoint.L2 - is_paused() checks the contract state, if the Var is_paused has not been initialized, the default value (false) is returned.L6 - to guarantee the code is executed when the contract is not paused, require_not_paused() function reads the state and reverts if the contract is paused. L12 - require_paused() is a mirror function - stops the contract execution if the contract is not paused. ","version":"2.1.0","tagName":"h3"},{"title":"Actions​","type":1,"pageTitle":"Pausable","url":"/docs/2.1.0/tutorials/pauseable#actions","content":"Finally, we will add the ability to switch the module state. pauseable.rs impl Pausable { pub fn pause(&amp;mut self) { self.require_not_paused(); self.is_paused.set(true); self.env().emit_event(Paused { account: self.env().caller() }); } pub fn unpause(&amp;mut self) { self.require_paused(); self.is_paused.set(false); self.env().emit_event(Unpaused { account: self.env().caller() }); } }  pause() and unpause() functions do three things: ensure the contract is the right state (unpaused for pause(), not paused for unpause()), updates the state, and finally emits events (Paused/Unpaused). ","version":"2.1.0","tagName":"h3"},{"title":"Pausable counter​","type":1,"pageTitle":"Pausable","url":"/docs/2.1.0/tutorials/pauseable#pausable-counter","content":"In the end, let's use the module in a contract. For this purpose, we will implement a mock contract called PausableCounter. The contract consists of a Var value and a Pausable module. The counter can only be incremented if the contract is in a normal state (is not paused). pauseable.rs ... #[odra::module] pub struct PausableCounter { value: Var&lt;u32&gt;, pauseable: SubModule&lt;Pausable&gt; } #[odra::module] impl PausableCounter { pub fn increment(&amp;mut self) { self.pauseable.require_not_paused(); let new_value = self.value.get_or_default() + 1; self.value.set(new_value); } pub fn pause(&amp;mut self) { self.pauseable.pause(); } pub fn unpause(&amp;mut self) { self.pauseable.unpause(); } pub fn get_value(&amp;self) -&gt; u32 { self.value.get_or_default() } } #[cfg(test)] mod test { use super::*; use odra::host::{Deployer, NoArgs}; #[test] fn increment_only_if_unpaused() { let test_env = odra_test::env(); let mut contract = PausableCounter::deploy(&amp;test_env, NoArgs); contract.increment(); contract.pause(); assert_eq!( contract.try_increment().unwrap_err(), Error::UnpausedRequired.into() ); assert_eq!(contract.get_value(), 1); } }  As we see in the test, in a simple way, using a single function call we can turn off the counter for a while and freeze the counter. Any time we want we can turn it back on. Easy! ","version":"2.1.0","tagName":"h2"},{"title":"Odra framework","type":0,"sectionRef":"#","url":"/docs/2.2.0/","content":"","keywords":"","version":"2.2.0"},{"title":"What's next​","type":1,"pageTitle":"Odra framework","url":"/docs/2.2.0/#whats-next","content":"See the Installation and our Flipper example to find out how to start your new project with Odra. ","version":"2.2.0","tagName":"h2"},{"title":"Attributes","type":0,"sectionRef":"#","url":"/docs/2.2.0/advanced/attributes","content":"","keywords":"","version":"2.2.0"},{"title":"Payable​","type":1,"pageTitle":"Attributes","url":"/docs/2.2.0/advanced/attributes#payable","content":"When writing a smart contract, you need to make sure that money can be both sent to and extracted from the contract. The 'payable' attribute helps wit this. Any function, except for a constructor, with the #[odra(payable)] attribute can send and take money in the form of native tokens. ","version":"2.2.0","tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"Attributes","url":"/docs/2.2.0/advanced/attributes#example","content":"examples/src/contracts/tlw.rs #[odra(payable)] pub fn deposit(&amp;mut self) { // Extract values let caller: Address = self.env().caller(); let amount: U256 = self.env().attached_value(); let current_block_time: u64 = self.env().get_block_time(); // Multiple lock check if self.balances.get(&amp;caller).is_some() { self.env.revert(Error::CannotLockTwice) } // Update state, emit event self.balances.set(&amp;caller, amount); self.lock_expiration_map .set(&amp;caller, current_block_time + self.lock_duration()); self.env() .emit_event(Deposit { address: caller, amount }); }  If you try to send tokens to a non-payable function, the transaction will be automatically rejected. ","version":"2.2.0","tagName":"h3"},{"title":"Non Reentrant​","type":1,"pageTitle":"Attributes","url":"/docs/2.2.0/advanced/attributes#non-reentrant","content":"Reentrancy attacks in smart contracts exploit the possibility of a function being called multiple times before its initial execution is completed, leading to the repeated unauthorized withdrawal of funds. To prevent such attacks, developers should ensure that all effects on the contract's state and balance checks occur before calling external contracts. They can also use reentrancy guards to block recursive calls to sensitive functions. In Odra you can just apply the #[odra(non_reentrant)] attribute to your function. ","version":"2.2.0","tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"Attributes","url":"/docs/2.2.0/advanced/attributes#example-1","content":"#[odra::module] pub struct NonReentrantCounter { counter: Var&lt;u32&gt; } #[odra::module] impl NonReentrantCounter { #[odra(non_reentrant)] pub fn count_ref_recursive(&amp;mut self, n: u32) { if n &gt; 0 { self.count(); ReentrancyMockRef::new(self.env(), self.env().self_address()).count_ref_recursive(n - 1); } } } impl NonReentrantCounter { fn count(&amp;mut self) { let c = self.counter.get_or_default(); self.counter.set(c + 1); } } #[cfg(test)] mod test { use super::*; use odra::host::{Deployer, NoArgs}; #[test] fn ref_recursion_not_allowed() { let test_env = odra_test::env(); let mut contract = NonReentrantCounter::deploy(&amp;test_env, NoArgs); let result = contract.count_ref_recursive(11); assert_eq!(result, ExecutionError::ReentrantCall.into()); } }  ","version":"2.2.0","tagName":"h3"},{"title":"Mixing attributes​","type":1,"pageTitle":"Attributes","url":"/docs/2.2.0/advanced/attributes#mixing-attributes","content":"A function can accept more than one attribute. The only exclusion is a constructor cannot be payable. To apply multiple attributes, you can write: #[odra(payable, non_reentrant)] fn deposit() { // your logic... }  or #[odra(payable)] #[odra(non_reentrant)] fn deposit() { // your logic... }  In both cases attributes order does not matter. ","version":"2.2.0","tagName":"h2"},{"title":"Advanced Storage Concepts","type":0,"sectionRef":"#","url":"/docs/2.2.0/advanced/advanced-storage","content":"","keywords":"","version":"2.2.0"},{"title":"Recap and Basic Concepts​","type":1,"pageTitle":"Advanced Storage Concepts","url":"/docs/2.2.0/advanced/advanced-storage#recap-and-basic-concepts","content":"Before we delve into the advanced features, let's recap some basic storage concepts in Odra. In the realm of basic storage interaction, Odra provides several types for interacting with contract storage, including Var, Mapping, and List. These types enable contracts to store and retrieve data in a structured manner. The Var type is used to store a single value, while the List and Mapping types store collections of values. Var: A Var in Odra is a fundamental building block used for storing single values. Each Var is uniquely identified by its name in the contract. Mapping: Mapping in Odra serves as a key-value storage system. It stores an association of unique keys to values, and the value can be retrieved using the key. List: Built on top of the Var and Mapping building blocks, List in Odra allows storing an ordered collection of values that can be iterated over. If you need a refresher on these topics, please refer to our guide on basic storage in Odra. ","version":"2.2.0","tagName":"h2"},{"title":"Advanced Storage Concepts​","type":1,"pageTitle":"Advanced Storage Concepts","url":"/docs/2.2.0/advanced/advanced-storage#advanced-storage-concepts-1","content":"","version":"2.2.0","tagName":"h2"},{"title":"Sequence​","type":1,"pageTitle":"Advanced Storage Concepts","url":"/docs/2.2.0/advanced/advanced-storage#sequence","content":"The Sequence in Odra is a basic module that stores a single value in the storage that can be read or incremented. Internally, holds a Var which keeps track of the current value. pub struct Sequence&lt;T&gt; where T: Num + One + ToBytes + FromBytes + CLTyped { value: Var&lt;T&gt; }  The Sequence module provides functions get_current_value and next_value to get the current value and increment the value respectively. ","version":"2.2.0","tagName":"h3"},{"title":"Advanced Mapping​","type":1,"pageTitle":"Advanced Storage Concepts","url":"/docs/2.2.0/advanced/advanced-storage#advanced-mapping","content":"In Odra, a Mapping is a key-value storage system where the key is associated with a value. In previous examples, the value of the Mapping typically comprised a standard serializable type (such as number, string, or bool) or a custom type marked with the #[odra::odra_type] attribute. However, there are more advanced scenarios where the value of the Mapping represents a module itself. This approach is beneficial when managing a collection of modules, each maintaining its unique state. Let's consider the following example: examples/src/features/storage/mapping.rs use odra::casper_types::U256; use odra::prelude::*; use crate::owned_token::OwnedToken; #[odra::module] pub struct Mappings { strings: Mapping&lt;(String, u32, String), String&gt;, tokens: Mapping&lt;String, OwnedToken&gt; } #[odra::module] impl Mappings { ... pub fn total_supply(&amp;mut self, token_name: String) -&gt; U256 { self.tokens.module(&amp;token_name).total_supply() } pub fn get_string_api( &amp;self, key1: String, key2: u32, key3: String ) -&gt; String { let opt_string = self.strings.get(&amp;(key1, key2, key3)); opt_string.unwrap_or_revert(&amp;self.env()) } }  As you can see, a Mapping key can consist of a tuple of values, not limited to a single value. note Accessing Odra modules differs from accessing regular values such as strings or numbers. Firstly, within a Mapping, you don't encapsulate the module with Submodule. Secondly, rather than utilizing the Mapping::get() function, call Mapping::module(), which returns SubModule&lt;T&gt; and sets the appropriate namespace for nested modules. ","version":"2.2.0","tagName":"h3"},{"title":"AdvancedStorage Contract​","type":1,"pageTitle":"Advanced Storage Concepts","url":"/docs/2.2.0/advanced/advanced-storage#advancedstorage-contract","content":"The given code snippet showcases the AdvancedStorage contract that incorporates these storage concepts. use odra::casper_types::U512; use odra::prelude::*; use crate::modules::Token; #[odra::module] pub struct AdvancedStorage { counter: Sequence&lt;u32&gt;, tokens: Mapping&lt;(String, String), Token&gt;, } impl AdvancedStorage { pub fn current_value(&amp;self) -&gt; u32 { self.counter.get_current_value() } pub fn increment_and_get(&amp;mut self) -&gt; u32 { self.counter.next_value() } pub fn balance_of(&amp;mut self, token_name: String, creator: String, address: Address) -&gt; U512 { let token = self.tokens.module(&amp;(token_name, creator)); token.balance_of(&amp;address) } pub fn mint(&amp;self, token_name: String, creator: String, amount: U512, to: Address) { let mut token = self.tokens.module(&amp;(token_name, creator)); token.mint(amount, to); } }  ","version":"2.2.0","tagName":"h2"},{"title":"Conclusion​","type":1,"pageTitle":"Advanced Storage Concepts","url":"/docs/2.2.0/advanced/advanced-storage#conclusion","content":"Advanced storage features in Odra offer robust options for managing contract state. Two key takeaways from this document are: Odra offers a Sequence module, enabling contracts to store and increment a single value.Mappings support composite keys expressed as tuples and can store modules as values. Understanding these concepts can help developers design and implement more efficient and flexible smart contracts. ","version":"2.2.0","tagName":"h2"},{"title":"Building contracts manually","type":0,"sectionRef":"#","url":"/docs/2.2.0/advanced/building-manually","content":"","keywords":"","version":"2.2.0"},{"title":"Building the contract manually​","type":1,"pageTitle":"Building contracts manually","url":"/docs/2.2.0/advanced/building-manually#building-the-contract-manually","content":"To build the contract manually, cargo odra uses the following command: ODRA_MODULE=my_contract cargo build --release --target wasm32-unknown-unknown --bin my_project_build_contract  info Odra uses the environment variable ODRA_MODULE to determine which contract to build. Assuming that project's crate is named my_project, this command will build the my_contract contract in release mode and generate the wasm file. The file will be put into the target/wasm32-unknown-unknown/release directory under the name my_project_build_contract.wasm. The Odra Framework expects the contracts to be placed in the wasm directory, and to be named correctly, so the next step would be to move the file: mv target/wasm32-unknown-unknown/release/my_project_build_contract.wasm wasm/my_contract.wasm  ","version":"2.2.0","tagName":"h2"},{"title":"Optimizing the contract​","type":1,"pageTitle":"Building contracts manually","url":"/docs/2.2.0/advanced/building-manually#optimizing-the-contract","content":"To lower the size of the wasm file, cargo odra uses the wasm-strip tool: wasm-strip wasm/my_contract.wasm  To further optimize the wasm file, the wasm-opt tool is also used. wasm-opt --signext-lowering wasm/my_contract.wasm -o wasm/my_contract.wasm  danger This step is required, as the wasm file generated by the Rust compiler is not fully compatible with the Casper execution engine. ","version":"2.2.0","tagName":"h2"},{"title":"Running the tests manually​","type":1,"pageTitle":"Building contracts manually","url":"/docs/2.2.0/advanced/building-manually#running-the-tests-manually","content":"To run the tests manually, Odra needs to know which backend to use. To run tests against Casper backend, the following command needs to be used: ODRA_BACKEND=casper cargo test  ","version":"2.2.0","tagName":"h2"},{"title":"Wrapping up​","type":1,"pageTitle":"Building contracts manually","url":"/docs/2.2.0/advanced/building-manually#wrapping-up","content":"Let's say we want to build the my_contract in debug mode, run the tests against the casper backend and use the my-own-allocator feature from our my_project project. To do that, we can use the following set of commands: ODRA_MODULE=my_contract cargo build --target wasm32-unknown-unknown --bin my_project_build_contract mv target/wasm32-unknown-unknown/debug/my_project_build_contract.wasm wasm/my_contract.wasm wasm-strip wasm/my_contract.wasm wasm-opt --signext-lowering wasm/my_contract.wasm -o wasm/my_contract.wasm ODRA_BACKEND=casper cargo test --features my-own-allocator  ","version":"2.2.0","tagName":"h2"},{"title":"Using Proxy Caller","type":0,"sectionRef":"#","url":"/docs/2.1.0/tutorials/using-proxy-caller","content":"","keywords":"","version":"2.1.0"},{"title":"Contract​","type":1,"pageTitle":"Using Proxy Caller","url":"/docs/2.1.0/tutorials/using-proxy-caller#contract","content":"For this tutorial, we will use the TimeLockWallet contract from our examples. examples/src/contracts/tlw.rs use odra::prelude::*; use odra::casper_types::U512; #[odra::module(errors = Error, events = [Deposit, Withdrawal])] pub struct TimeLockWallet { balances: Mapping&lt;Address, U512&gt;, lock_expiration_map: Mapping&lt;Address, u64&gt;, lock_duration: Var&lt;u64&gt; } #[odra::module] impl TimeLockWallet { /// Initializes the contract with the lock duration. pub fn init(&amp;mut self, lock_duration: u64) { self.lock_duration.set(lock_duration); } /// Deposits the tokens into the contract. #[odra(payable)] pub fn deposit(&amp;mut self) { // Extract values let caller: Address = self.env().caller(); let amount: U512 = self.env().attached_value(); let current_block_time: u64 = self.env().get_block_time(); // Multiple lock check if self.balances.get(&amp;caller).is_some() { self.env().revert(Error::CannotLockTwice) } // Update state, emit event self.balances.set(&amp;caller, amount); self.lock_expiration_map .set(&amp;caller, current_block_time + self.lock_duration()); self.env().emit_event(Deposit { address: caller, amount }); } /// Withdraws the tokens from the contract. pub fn withdraw(&amp;mut self, amount: &amp;U512) { // code omitted for brevity } /// Returns the balance of the given account. pub fn get_balance(&amp;self, address: &amp;Address) -&gt; U512 { // code omitted for brevity } /// Returns the lock duration. pub fn lock_duration(&amp;self) -&gt; u64 { // code omitted for brevity } } /// Errors that may occur during the contract execution. #[odra::odra_error] pub enum Error { LockIsNotOver = 1, CannotLockTwice = 2, InsufficientBalance = 3 } /// Deposit event. #[odra::event] pub struct Deposit { pub address: Address, pub amount: U512 } /// Withdrawal event. #[odra::event] pub struct Withdrawal { pub address: Address, pub amount: U512 }  Full code can be found here. ","version":"2.1.0","tagName":"h2"},{"title":"Client​","type":1,"pageTitle":"Using Proxy Caller","url":"/docs/2.1.0/tutorials/using-proxy-caller#client","content":"Before we can interact with the node, we need to set it up. We will use the casper-nctl-docker image. docker run --rm -it --name mynctl -d -p 11101:11101 -p 14101:14101 -p 18101:18101 makesoftware/casper-nctl  Make sure you have the contract's wasm file and the secret key. # Build the contract cargo odra build -c TimeLockWallet # Extract secret key docker exec mynctl /bin/bash -c &quot;cat /home/casper/casper-node/utils/nctl/assets/net-1/users/user-1/secret_key.pem&quot; &gt; your/path/secret_key.pem  RustTypeScript To interact with the contract, we use the livenet backend. It allows to write the code in the same manner as the test code, but it interacts with the live network (a local node in our case). Cargo.toml [package] name = &quot;odra-examples&quot; version = &quot;2.2.0&quot; edition = &quot;2021&quot; [dependencies] odra = { path = &quot;../odra&quot;, default-features = false } ... # other dependencies odra-casper-livenet-env = { version = &quot;2.2.0&quot;, optional = true } ... # other sections [features] default = [] livenet = [&quot;odra-casper-livenet-env&quot;] ... # other sections [[bin]] name = &quot;tlw_on_livenet&quot; path = &quot;bin/tlw_on_livenet.rs&quot; required-features = [&quot;livenet&quot;] test = false ... # other sections examples/bin/tlw_on_livenet.rs //! Deploys an [odra_examples::contracts::tlw::TimeLockWallet] contract, then deposits and withdraw some CSPRs. use odra::casper_types::{AsymmetricType, PublicKey, U512}; use odra::host::{Deployer, HostRef}; use odra::prelude::*; use odra_examples::contracts::tlw::{TimeLockWallet, TimeLockWalletInitArgs}; const DEPOSIT: u64 = 100; const WITHDRAWAL: u64 = 99; const GAS: u64 = 20u64.pow(9); fn main() { let env = odra_casper_livenet_env::env(); let caller = env.get_account(0); env.set_caller(caller); env.set_gas(GAS); let mut contract = TimeLockWallet::deploy( &amp;env, TimeLockWalletInitArgs { lock_duration: 60 * 60 } ); // Send 100 CSPRs to the contract. contract .with_tokens(U512::from(DEPOSIT)) .deposit(); println!(&quot;Caller's balance: {:?}&quot;, contract.get_balance(&amp;caller)); // Withdraw 99 CSPRs from the contract. contract.withdraw(&amp;U512::from(WITHDRAWAL)); println!(&quot;Remaining balance: {:?}&quot;, contract.get_balance(&amp;caller)); } To run the code, execute the following command: ODRA_CASPER_LIVENET_SECRET_KEY_PATH=.node-keys/secret_key.pem \\ ODRA_CASPER_LIVENET_NODE_ADDRESS=http://localhost:11101 \\ ODRA_CASPER_LIVENET_CHAIN_NAME=casper-net-1 \\ cargo run --bin tlw_on_livenet --features=livenet # Sample output 💁 INFO : Deploying &quot;TimeLockWallet&quot;. 💁 INFO : Found wasm under &quot;wasm/TimeLockWallet.wasm&quot;. 🙄 WAIT : Waiting 15s for &quot;74f0df4bc65cdf9e05bca70a8b786bd0f528858f26e11f5a9866dfe286551558&quot;. 💁 INFO : Deploy &quot;74f0df4bc65cdf9e05bca70a8b786bd0f528858f26e11f5a9866dfe286551558&quot; successfully executed. 💁 INFO : Contract &quot;hash-cce6a97e0db6feea0c4d99f670196c9462e0789fb3cdedd3dfbc6dfcbf66252e&quot; deployed. 💁 INFO : Calling &quot;hash-cce6a97e0db6feea0c4d99f670196c9462e0789fb3cdedd3dfbc6dfcbf66252e&quot; with entrypoint &quot;deposit&quot; through proxy. 🙄 WAIT : Waiting 15s for &quot;bd571ab64c13d2b2fdb8e0e6dd8473b696349dfb5a891b55dbe9f33d017057d3&quot;. 💁 INFO : Deploy &quot;bd571ab64c13d2b2fdb8e0e6dd8473b696349dfb5a891b55dbe9f33d017057d3&quot; successfully executed. Caller's balance: 100 💁 INFO : Calling &quot;hash-cce6a97e0db6feea0c4d99f670196c9462e0789fb3cdedd3dfbc6dfcbf66252e&quot; with entrypoint &quot;withdraw&quot;. 🙄 WAIT : Waiting 15s for &quot;57f9aadbd77cbfbbe9b2ba54759d025f94203f9230121289fa37585f8b17020e&quot;. 💁 INFO : Deploy &quot;57f9aadbd77cbfbbe9b2ba54759d025f94203f9230121289fa37585f8b17020e&quot; successfully executed. Remaining balance: 1 As observed, the contract was successfully deployed, and the Caller deposited tokens. Subsequently, the caller withdrew 99 CSPRs from the contract, leaving the contract's balance at 1 CSPR. The logs display deploy hashes, the contract's hash, and even indicate if the call was made through the proxy, providing a comprehensive overview of the on-chain activity. ","version":"2.1.0","tagName":"h2"},{"title":"Conclusion​","type":1,"pageTitle":"Using Proxy Caller","url":"/docs/2.1.0/tutorials/using-proxy-caller#conclusion","content":"In this tutorial, we learned how to use the proxy_caller wasm to make a payable function call. We deployed the TimeLockWallet contract, deposited tokens using the proxy_caller with attached CSPRs, and withdrew them. You got to try it out in both Rust and TypeScript, so you can choose whichever you prefer. Rust code seemed simpler, thanks to the Odra livenet backend making chain interactions easier to handle. ","version":"2.1.0","tagName":"h2"},{"title":"Delegate","type":0,"sectionRef":"#","url":"/docs/2.2.0/advanced/delegate","content":"","keywords":"","version":"2.2.0"},{"title":"Overview​","type":1,"pageTitle":"Delegate","url":"/docs/2.2.0/advanced/delegate#overview","content":"To utilize the delegate feature in your contract, use the delegate! macro provided by Odra. This macro allows you to list the functions you wish to delegate to the child modules. By using the delegate! macro, your parent module remains clean and easy to understand. You can delegate functions to as many child modules as you like. The functions will be available as if they were implemented in the parent module itself. ","version":"2.2.0","tagName":"h2"},{"title":"Code Examples​","type":1,"pageTitle":"Delegate","url":"/docs/2.2.0/advanced/delegate#code-examples","content":"Consider the following basic example for better understanding: use crate::{erc20::Erc20, ownable::Ownable}; use odra::{casper_types::U256, prelude::*}; #[odra::module] pub struct OwnedToken { ownable: SubModule&lt;Ownable&gt;, erc20: SubModule&lt;Erc20&gt; } #[odra::module] impl OwnedToken { pub fn init(&amp;mut self, name: String, symbol: String, decimals: u8, initial_supply: U256) { let deployer = self.env().caller(); self.ownable.init(deployer); self.erc20.init(name, symbol, decimals, initial_supply); } delegate! { to self.erc20 { fn transfer(&amp;mut self, recipient: Address, amount: U256); fn transfer_from(&amp;mut self, owner: Address, recipient: Address, amount: U256); fn approve(&amp;mut self, spender: Address, amount: U256); fn name(&amp;self) -&gt; String; fn symbol(&amp;self) -&gt; String; fn decimals(&amp;self) -&gt; u8; fn total_supply(&amp;self) -&gt; U256; fn balance_of(&amp;self, owner: Address) -&gt; U256; fn allowance(&amp;self, owner: Address, spender: Address) -&gt; U256; } to self.ownable { fn get_owner(&amp;self) -&gt; Address; fn change_ownership(&amp;mut self, new_owner: Address); } } pub fn mint(&amp;mut self, address: Address, amount: U256) { self.ownable.ensure_ownership(self.env().caller()); self.erc20.mint(address, amount); } }  This OwnedToken contract includes two modules: Erc20 and Ownable. We delegate various functions from both modules using the delegate! macro. As a result, the contract retains its succinctness without compromising on functionality. The above example basically merges the functionalities of modules and adds some control over the minting process. But you can use delegation to build more complex contracts, cherry-picking just a few module functionalities. Let's take a look at another example. use crate::{erc20::Erc20, ownable::Ownable, exchange::Exchange}; use odra::{casper_types::U256, prelude::*}; #[odra::module] pub struct DeFiPlatform { ownable: SubModule&lt;Ownable&gt;, erc20: SubModule&lt;Erc20&gt;, exchange: SubModule&lt;Exchange&gt; } #[odra::module] impl DeFiPlatform { pub fn init(&amp;mut self, name: String, symbol: String, decimals: u8, initial_supply: U256, exchange_rate: u64) { let deployer = self.env().caller(); self.ownable.init(deployer); self.erc20.init(name, symbol, decimals, initial_supply); self.exchange.init(exchange_rate); } delegate! { to self.erc20 { fn transfer(&amp;mut self, recipient: Address, amount: U256); fn balance_of(&amp;self, owner: Address) -&gt; U256; } to self.ownable { fn get_owner(&amp;self) -&gt; Address; } to self.exchange { fn swap(&amp;mut self, sender: Address, recipient: Address); fn set_exchange_rate(&amp;mut self, new_rate: u64); } } pub fn mint(&amp;mut self, address: Address, amount: U256) { self.ownable.ensure_ownership(self.env().caller()); self.erc20.mint(address, amount); } }  In this DeFiPlatform contract, we include Erc20, Ownable, and Exchange modules. By delegating functions from these modules, the parent contract becomes a powerhouse of functionality while retaining its readability and structure. Remember, the possibilities are endless with Odra's. By leveraging this feature, you can write cleaner, more efficient, and modular smart contracts. ","version":"2.2.0","tagName":"h2"},{"title":"Signatures","type":0,"sectionRef":"#","url":"/docs/2.2.0/advanced/signatures","content":"","keywords":"","version":"2.2.0"},{"title":"Signature verification​","type":1,"pageTitle":"Signatures","url":"/docs/2.2.0/advanced/signatures#signature-verification","content":"Signature verification is conducted by a function in contract's env(): pub fn verify_signature(message: &amp;Bytes, signature: &amp;Bytes, public_key: &amp;PublicKey) -&gt; bool;  Here's the simplest example of this function used in a contract: examples/src/features/signature_verifier.rs #[odra::module] impl SignatureVerifier { pub fn verify_signature( &amp;self, message: &amp;Bytes, signature: &amp;Bytes, public_key: &amp;PublicKey ) -&gt; bool { self.env().verify_signature(message, signature, public_key) } }  ","version":"2.2.0","tagName":"h2"},{"title":"Testing​","type":1,"pageTitle":"Signatures","url":"/docs/2.2.0/advanced/signatures#testing","content":"Besides the above function in the contract context, Odra provides corresponding functions in the HostEnv: pub fn sign_message(message: &amp;Bytes, address: &amp;Address) -&gt; Bytes; pub fn public_key(address: &amp;Address) -&gt; PublicKey;  sign_message will return a signed message. The signing itself will be performed using a private key of an account behind the address. public_key returns the PublicKey of an address account. Here's a complete example of how to test the signature verification in the contract: examples/src/features/signature_verifier.rs #[test] fn signature_verification_works() { let test_env = odra_test::env(); let message = &quot;Message to be signed&quot;; let message_bytes = Bytes::from(message.as_bytes()); let account = test_env.get_account(0); let signature = test_env.sign_message(&amp;message_bytes, &amp;account); let public_key = test_env.public_key(&amp;account); let signature_verifier = SignatureVerifier::deploy(&amp;test_env, NoArgs); assert!(signature_verifier.verify_signature(&amp;message_bytes, &amp;signature, &amp;public_key)); }  If you want, you can also test signatures created outside Odra: examples/src/features/signature_verifier.rs #[test] fn verify_signature_casper_wallet() { // Casper Wallet for the message &quot;Ahoj przygodo!&quot; signed using SECP256K1 key // produces the following signature: // 1e87e186238fa1df9c222b387a79910388c6ef56285924c7e4f6d7e77ed1d6c61815312cf66a5318db204c693b79e020b1d392dafe8c1b3841e1f6b4c41ca0fa // Casper Wallet adds &quot;Casper Message:\\n&quot; prefix to the message: let message = &quot;Casper Message:\\nAhoj przygodo!&quot;; let message_bytes = Bytes::from(message.as_bytes()); // Depending on the type of the key, we need to prefix the signature with a tag: // 0x01 for ED25519 // 0x02 for SECP256K1 let signature_hex = &quot;021e87e186238fa1df9c222b387a79910388c6ef56285924c7e4f6d7e77ed1d6c61815312cf66a5318db204c693b79e020b1d392dafe8c1b3841e1f6b4c41ca0fa&quot;; let signature: [u8; 65] = hex::decode(signature_hex).unwrap().try_into().unwrap(); let signature_bytes = Bytes::from(signature.as_slice()); // Similar to the above, the public key is tagged: let public_key_hex = &quot;02036d9b880e44254afaf34330e57703a63aec53b5918d4470059b67a4a906350105&quot;; let public_key_decoded = hex::decode(public_key_hex).unwrap(); let (public_key, _) = PublicKey::from_bytes(public_key_decoded.as_slice()).unwrap(); let signature_verifier = SignatureVerifier::deploy(&amp;odra_test::env(), NoArgs); assert!(signature_verifier.verify_signature(&amp;message_bytes, &amp;signature_bytes, &amp;public_key)); }  ","version":"2.2.0","tagName":"h2"},{"title":"Delegating CSPR to Validators","type":0,"sectionRef":"#","url":"/docs/2.2.0/advanced/delegating-cspr","content":"","keywords":"","version":"2.2.0"},{"title":"Sample implementation​","type":1,"pageTitle":"Delegating CSPR to Validators","url":"/docs/2.2.0/advanced/delegating-cspr#sample-implementation","content":"The following code shows how to implement a simple contract that allows delegating CSPR tokens to a validator. examples/src/features/validators.rs use odra::{ casper_types::{PublicKey, U512}, prelude::* }; #[odra::module] pub struct ValidatorsContract { /// In this variable we store the validator's public key, this is the only way we can identify the validator validator: Var&lt;PublicKey&gt; } /// Implementation of the TestingContract #[odra::module] impl ValidatorsContract { /// Initializes the contract with the validator's public key pub fn init(&amp;mut self, validator: PublicKey) { self.validator.set(validator); } /// Stake the amount of tokens #[odra(payable)] pub fn stake(&amp;mut self) { // Get the amount of tokens attached to the call let amount = self.env().attached_value(); if amount.is_zero() { self.env().revert(ValError::InsufficientBalance); } // Use the ContractEnv's delegate method to delegate the tokens to the validator self.env().delegate(self.validator.get().unwrap(), amount); } /// Undelegate the amount from the validator pub fn unstake(&amp;mut self, amount: U512) { self.env().undelegate(self.validator.get().unwrap(), amount); } /// Withdraw the amount from the validator pub fn withdraw(&amp;mut self, amount: U512) { self.env().transfer_tokens(&amp;self.env().caller(), &amp;amount); } ... }  ","version":"2.2.0","tagName":"h2"},{"title":"Explanation​","type":1,"pageTitle":"Delegating CSPR to Validators","url":"/docs/2.2.0/advanced/delegating-cspr#explanation","content":"The above example can be a good starting point for implementing a liquid staking solution. The main things to remember are the new api methods in ContractEnv: pub fn delegate(&amp;self, validator: PublicKey, amount: U512); pub fn undelegate(&amp;self, validator: PublicKey, amount: U512); pub fn delegated_amount(&amp;self, validator: PublicKey) -&gt; U512;  As you can see, we identify the validator by its public key. Funds delegated to the validator are assigned to the calling contract. Remember, that the delegation and undelegation takes some time, depending on the configuration of the blockchain - it's not instant. For example in the Casper mainnet, the delegation takes 1 era and the undelegation takes 7 eras. ","version":"2.2.0","tagName":"h2"},{"title":"Testing​","type":1,"pageTitle":"Delegating CSPR to Validators","url":"/docs/2.2.0/advanced/delegating-cspr#testing","content":"It is possible to test the delegation and undelegation of tokens in the contract. The following code shows how to do it: examples/src/features/validators.rs ... let test_env = odra_test::env(); let auction_delay = test_env.auction_delay(); let unbonding_delay = test_env.unbonding_delay(); test_env.set_caller(test_env.get_account(0)); let mut staking = ValidatorsContract::deploy( &amp;test_env, ValidatorsContractInitArgs { validator: test_env.get_validator(0) } ); let initial_account_balance = test_env.balance_of(&amp;test_env.get_account(0)); // Stake some amount let staking_amount = U512::from(1_000_000_000_000u64); staking.with_tokens(staking_amount).stake(); assert_eq!(staking.currently_delegated_amount(), staking_amount); assert_eq!( test_env.balance_of(&amp;test_env.get_account(0)), initial_account_balance - staking_amount ); // Advance time, run auctions and give off rewards test_env.advance_with_auctions(auction_delay * 2); // Check that the amount is greater than the staking amount let staking_with_reward = staking.currently_delegated_amount(); assert!(staking_with_reward &gt; staking_amount); ...  You can see, that we use the new methods from HostEnv, namely:  fn advance_with_auctions(&amp;self, time_diff: u64); fn auction_delay(&amp;self) -&gt; u64; fn unbonding_delay(&amp;self) -&gt; u64; fn delegated_amount(&amp;self, delegator: Address, validator: PublicKey) -&gt; U512;  advance_with_auctions works in a similar way to advance_block_time, but it also runs the auctions and gives off rewards. The auction_delay and unbonding_delay methods return the values of the auction and unbonding delays specific to the network or backend. We used currently_delegated_amount in the example, it uses delegated_amount method from ContractEnv, but it is also possible to query this information from the HostEnv using delegated_amount method. ","version":"2.2.0","tagName":"h2"},{"title":"Memory allocators","type":0,"sectionRef":"#","url":"/docs/2.2.0/advanced/using-different-allocator","content":"","keywords":"","version":"2.2.0"},{"title":"Using a different allocator​","type":1,"pageTitle":"Memory allocators","url":"/docs/2.2.0/advanced/using-different-allocator#using-a-different-allocator","content":"If the default allocator does not suit your needs, or you use a crate that already provides an allocator, you can disable the default allocator by enabling the disable-allocator feature in the odra dependency in your project: [dependencies] odra = { path = &quot;../odra&quot;, features = [&quot;disable-allocator&quot;] }  If you want to have a better control over the features that are enabled during the building and tests, see the next article on building manually. ","version":"2.2.0","tagName":"h2"},{"title":"Storage Layout","type":0,"sectionRef":"#","url":"/docs/2.2.0/advanced/storage-layout","content":"","keywords":"","version":"2.2.0"},{"title":"Casper VM Perspective​","type":1,"pageTitle":"Storage Layout","url":"/docs/2.2.0/advanced/storage-layout#casper-vm-perspective","content":"The Casper Execution Engine (VM) enables the storage of data in named keys or dictionaries. However, a smart contract has a limited number of named keys, making it unsuitable for storing substantial data volumes. Odra resolves this issue by storing all user-generated data in a dictionary called state. This dictionary operates as a key-value store, where keys are strings with a maximum length of 64 characters, and values are arbitrary byte arrays. Here is an example of what the interface for reading and writing data could look like: pub trait CasperStorage { fn read(key: &amp;str) -&gt; Option&lt;Vec&lt;u8&gt;&gt;; fn write(key: &amp;str, value: Vec&lt;u8&gt;); }  ","version":"2.2.0","tagName":"h2"},{"title":"Odra Perspective​","type":1,"pageTitle":"Storage Layout","url":"/docs/2.2.0/advanced/storage-layout#odra-perspective","content":"Odra was conceived with modularity and code reusability in mind. Additionally, we aimed to streamline storage definition through the struct object. Consider this straightforward storage definition: #[odra::module] pub struct Token { name: Var&lt;String&gt;, balances: Mapping&lt;Address, U256&gt; }  The Token structure contains two fields: name of type String andbalances, which functions as a key-value store with Address as keys andU256 as values. The Token module can be reused in another module, as demonstrated in a more complex example: #[odra::module] pub struct Loans { lenders: SubModule&lt;Token&gt;, borrowers: SubModule&lt;Token&gt;, }  The Loans module has two fields: lenders and borrowers, both of which have the same storage layout as defined by the Token module. Odra guarantees thatlenders and borrowers are stored under distinct keys within the storage dictionary. Both Token and Loans serve as examples to show how Odra's storage layout operates. ","version":"2.2.0","tagName":"h2"},{"title":"Key generation.​","type":1,"pageTitle":"Storage Layout","url":"/docs/2.2.0/advanced/storage-layout#key-generation","content":"Every element of a module (struct) with N elements is associated with an index ranging from 0 to N-1, represented as a u8 with a maximum of 256 elements. If an element of a module is another module (SubModule&lt;...&gt;), the associated index serves as a prefix for the indexes of the inner module. While this may initially appear complex, it is easily understood through an example. In the example, indexes are presented as bytes, reflecting the actual implementation. Loans { lenders: Token { // prefix: 0x0001 name: 1, // key: 0x0001_0001 balances: 2 // key: 0x0001_0010 }, borrowers: Token { // prefix: 0x0010 name: 1, // key: 0x0010_0001 balances: 2 // key: 0x0010_0010 } }  Additionally, it's worth mentioning how Mapping's keys are used in thestorage. They are simply concatenated with the index of the module, as demonstrated in the example. For instance, triggering borrowers.balances.get(0x1234abcd) would result in a key: 0x0001_0001_1234_abcd  Finally, the key must be hashed to fit within the 64-character limit and then encoded in hexadecimal format. ","version":"2.2.0","tagName":"h2"},{"title":"Value serialization​","type":1,"pageTitle":"Storage Layout","url":"/docs/2.2.0/advanced/storage-layout#value-serialization","content":"Before being stored in the storage, each value is serialized into bytes using the CLType serialization method and subsequently encapsulated with Casper'sBytes types. ","version":"2.2.0","tagName":"h2"},{"title":"OdraVM","type":0,"sectionRef":"#","url":"/docs/2.2.0/backends/odra-vm","content":"","keywords":"","version":"2.2.0"},{"title":"Usage​","type":1,"pageTitle":"OdraVM","url":"/docs/2.2.0/backends/odra-vm#usage","content":"The OdraVM is the default backend for Odra framework, so each time you run cargo odra test  You are running your code against it. ","version":"2.2.0","tagName":"h2"},{"title":"Architecture​","type":1,"pageTitle":"OdraVM","url":"/docs/2.2.0/backends/odra-vm#architecture","content":"OdraVM consists of two main parts: the Contract Register and the State. The Contract Register is a list of contracts deployed onto the OdraVM, identified by an Address. Contracts and Test Env functions can modify the State of the OdraVM. Contrary to the &quot;real&quot; backend, which holds the whole history of the blockchain, the OdraVM State holds only the current state of the OdraVM. Thanks to this and the fact that we do not need the blockchain itself, OdraVM starts instantly and runs the tests in the native speed. ","version":"2.2.0","tagName":"h2"},{"title":"Execution​","type":1,"pageTitle":"OdraVM","url":"/docs/2.2.0/backends/odra-vm#execution","content":"When the OdraVM backend is enabled, the #[odra::module] attribute is responsible for converting your pub functions into a list of Entrypoints, which are put into a Contract Container. When the contract is deployed, its Container registered into a Registry under an address. During the contract call, OdraVM finds an Entrypoint and executes the code. ","version":"2.2.0","tagName":"h2"},{"title":"Casper","type":0,"sectionRef":"#","url":"/docs/2.2.0/backends/casper","content":"","keywords":"","version":"2.2.0"},{"title":"Contract Env​","type":1,"pageTitle":"Casper","url":"/docs/2.2.0/backends/casper#contract-env","content":"As with any other backend, Casper Backend must implement the same features, but some do not have native support. Let's take a closer look at how Odra overcomes these hindrances. ","version":"2.2.0","tagName":"h2"},{"title":"Events​","type":1,"pageTitle":"Casper","url":"/docs/2.2.0/backends/casper#events","content":"An event is not a first-class citizen in Casper like in Ethereum, so Odra mimics it. As you've already learned from the events article, in Odra you emit an event, similarly, you would do it in Solidity. Under the hood, Odra integrates with Casper Event Standard and creates a few URefs in the global state when a contract is being installed: __events - a dictionary that stores events' data.__events_length - the evens count.__events_ces_version - the version of Casper Event Standard. __events_schema - a dictionary that stores event schemas. Besides that, all the events the contract emits are registered - events schemas are written to the storage under the __events_schema key. So, Events are nothing different from any other data stored by a contract. A struct to be an event must implement traits defined by Casper Event Standard, thankfully you can derive them using #[odra::event]. note Don't forget to expose events in the module using #[odra::module(events = [...])]. ","version":"2.2.0","tagName":"h3"},{"title":"Payable​","type":1,"pageTitle":"Casper","url":"/docs/2.2.0/backends/casper#payable","content":"The first Odra idiom is a Contract Main Purse. It is a purse associated with a contract. The purse is created lazily - when the first transfer to the contract occurs, a proper URef and a purse are created and stored under the __contract_main_purse key. Casper does not allow direct transfers from an account to a contract, so Odra comes up with the second idiom - a Cargo Purse. It is a one-time-use purse proxy between an account and a contract. First, motes go from the account to the cargo purse and then to the contract's main purse. Behind the scenes, Odra handles an account-contract transfer via a cargo purse when a function is marked as payable. If under the way something goes wrong with the transfer, the contract reverts. The transferred amount can be read inside the contract by calling self.env().attached_value(). note Odra expects the cargo_purse runtime argument to be attached to a contract call. In case of its absence, the contract_env::attached_value() returns zero. ","version":"2.2.0","tagName":"h3"},{"title":"Revert​","type":1,"pageTitle":"Casper","url":"/docs/2.2.0/backends/casper#revert","content":"In Casper, we can stop the execution pretty straightforwardly - call the runtime::revert(). Odra adds an extra abstraction layer - in a contract ExecutionErrors are defined, which ultimately are transformed into Casper's ApiError::User. ","version":"2.2.0","tagName":"h3"},{"title":"Context​","type":1,"pageTitle":"Casper","url":"/docs/2.2.0/backends/casper#context","content":"Casper equips developers with very low-level tooling, which can be cumbersome for newcomers. If you want to check who called the contract or its address, you can not do it off-hand - you must analyze the call stack. The self.env().self_address() function takes the first element of the callstack (runtime::get_call_stack()) and casts it to Address. The self.env().caller() function takes the second element of the call stack (runtime::get_call_stack()) and casts it to Address. As mentioned in the [Payable] section, to store CSPR, each contract creates its purse. To read the contract balance, you call self.env().self_balance(), which checks the balance of the purse stored under __contract_main_purse. ","version":"2.2.0","tagName":"h3"},{"title":"Test Env​","type":1,"pageTitle":"Casper","url":"/docs/2.2.0/backends/casper#test-env","content":"Test environment allows you to test wasm contracts before you deploy them onto the testnet or livenet. It is built on top of the Casper Execution Engine. In your test, you can freely switch execution context by setting as a caller (test_env::set_caller()) one of the 20 predefined accounts. Each account possesses the default amount of Motes (100_000_000_000_000_000). The Test Env internally keeps track of the current block time, error and attached value. Each test is executed on a fresh instance of the Test Env. ","version":"2.2.0","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"Casper","url":"/docs/2.2.0/backends/casper#usage","content":"Name of the Casper backend in Odra is casper, so to run the tests against it, simply pass it as a -bparameter: cargo odra test -b casper  If you want to just generate a wasm file, simply run: cargo odra build -b casper  ","version":"2.2.0","tagName":"h2"},{"title":"Deploying a contract to Casper network​","type":1,"pageTitle":"Casper","url":"/docs/2.2.0/backends/casper#deploying-a-contract-to-casper-network","content":"There would be no point in writing a contract if you couldn't deploy it to the blockchain. You can do it in two ways: provided by the Casper itself: using the casper-client tool or using the Odra's Livenet integration. Let's explore the first option to better understand the process. note If you wish, you can skip the following section and jump to the Livenet integration. ","version":"2.2.0","tagName":"h2"},{"title":"WASM arguments​","type":1,"pageTitle":"Casper","url":"/docs/2.2.0/backends/casper#wasm-arguments","content":"When deploying a new contract you can pass some arguments to it. Every contract written in Odra expects those arguments to be set: odra_cfg_package_hash_key_name - String type. The key under which the package hash of the contract will be stored.odra_cfg_allow_key_override - Bool type. If true and the key specified in odra_cfg_package_hash_key_name already exists, it will be overwritten.odra_cfg_is_upgradable - Bool type. If true, the contract will be deployed as upgradable. Additionally, if required by the contract, you can pass constructor arguments. When working with the test env via cargo odra or when usingLivenet integration this is handled automatically. However, if you rather usecasper-client directly, you have to pass them manually: ","version":"2.2.0","tagName":"h3"},{"title":"Example: Deploy Counter​","type":1,"pageTitle":"Casper","url":"/docs/2.2.0/backends/casper#example-deploy-counter","content":"To deploy your contract with a constructor using casper-client, you need to pass the above arguments. Additionally, you need to pass the value argument, which sets the arbitrary initial value for the counter. casper-client put-deploy \\ --node-address [NODE_ADDRESS] \\ --chain-name casper-test \\ --secret-key [PATH_TO_YOUR_KEY]/secret_key.pem \\ --payment-amount 5000000000000 \\ --session-path ./wasm/counter.wasm \\ --session-arg &quot;odra_cfg_package_hash_key_name:string:'counter_package_hash'&quot; \\ --session-arg &quot;odra_cfg_allow_key_override:bool:'true'&quot; \\ --session-arg &quot;odra_cfg_is_upgradable:bool:'true'&quot; \\ --session-arg &quot;value:u32:42&quot;  For a more in-depth tutorial, please refer to the Casper's 'Writing On-Chain Code'. ","version":"2.2.0","tagName":"h3"},{"title":"Example: Deploy ERC721​","type":1,"pageTitle":"Casper","url":"/docs/2.2.0/backends/casper#example-deploy-erc721","content":"Odra comes with a standard ERC721 token implementation. Clone the main Odra repo and navigate to the modules directory. Firstly contract needs to be compiled. cargo odra build -b casper -c erc721_token  It produces the erc721_token.wasm file in the wasm directory. Now it's time to deploy the contract. casper-client put-deploy \\ --node-address [NODE_ADDRESS] \\ --chain-name casper-test \\ --secret-key [PATH_TO_YOUR_KEY]/secret_key.pem \\ --payment-amount 300000000000 \\ --session-path ./wasm/erc721_token.wasm \\ --session-arg &quot;odra_cfg_package_hash_key_name:string:'my_nft'&quot; \\ --session-arg &quot;odra_cfg_allow_key_override:bool:'false'&quot; \\ --session-arg &quot;odra_cfg_is_upgradable:bool:'true'&quot; \\ --session-arg &quot;name:string:'MyNFT'&quot; \\ --session-arg &quot;symbol:string:'NFT'&quot; \\ --session-arg &quot;base_uri:string:'https://example.com/'&quot;  It's done. The contract is deployed and ready to use. Your account is the owner of the contract and you can mint and burn tokens. For more details see the code of the ERC721 module. To obtain the package hash of the contract search for my_nft key in your account's named keys. ","version":"2.2.0","tagName":"h3"},{"title":"Example: Deploy ERC1155​","type":1,"pageTitle":"Casper","url":"/docs/2.2.0/backends/casper#example-deploy-erc1155","content":"The process is similar to the one described in the previous section. Contract compilation: cargo odra build -b casper -c erc1155_token  Contract deployment: casper-client put-deploy \\ --node-address [NODE_ADDRESS] \\ --chain-name casper-test \\ --secret-key [PATH_TO_YOUR_KEY]/secret_key.pem \\ --payment-amount 300000000000 \\ --session-path ./wasm/erc1155_token.wasm \\ --session-arg &quot;odra_cfg_package_hash_key_name:string:'my_tokens'&quot; \\ --session-arg &quot;odra_cfg_allow_key_override:bool:'false'&quot; \\ --session-arg &quot;odra_cfg_is_upgradable:bool:'true'&quot; \\ --session-arg &quot;odra_cfg_constructor:string:'init'&quot; \\  As previously, your account is the owner and can mint and burn tokens. For more details see the code of the ERC1155 module. ","version":"2.2.0","tagName":"h3"},{"title":"Sending CSPR to a contract​","type":1,"pageTitle":"Casper","url":"/docs/2.2.0/backends/casper#sending-cspr-to-a-contract","content":"Defining payable entry points is described in Native Token section. What is happening under the hood is that Odra creates a new cargo_purse argument for each payable entry point. The cargo_purse needs to be top-upped with CSPR before calling the contract. When a contract adds CSPR to another contract call, Odra handles it for you. The problem arises when you want to call an entry point and attach CSPR as an account. The only way of doing that is by executing code in the sessions context, that top-ups the cargo_purse and then calls the contract. Odra provides a generic proxy_caller.wasm that does exactly that. You can build it by yourself from the main Odra repository, or use the proxy_caller.wasmwe maintain. ","version":"2.2.0","tagName":"h2"},{"title":"Using proxy_caller.wasm​","type":1,"pageTitle":"Casper","url":"/docs/2.2.0/backends/casper#using-proxy_callerwasm","content":"To use the proxy_caller.wasm you need to attach the following arguments: contract_package_hash - BytesArray(32) type. The package hash of the contract you want to call. Result of to_bytes on CasperPackageHash.entry_point - String type. The name of the entry point you want to call.args - Bytes type. It is a serialized RuntimeArgs with the arguments you want to pass to the entry point. To be specific it is the result of to_bytes method wrapped with Bytes type.attached_value. U512 type. The amount of CSPR you want to attach to the call.amount. U512 type. Should be the same value as attached_value if not None. It is a special Casper argument that enables the access to account's main purse. Currently casper-client doesn't allow building such arguments. You have to build it using your SDK. See an example in the Tutorial section. ","version":"2.2.0","tagName":"h3"},{"title":"Execution​","type":1,"pageTitle":"Casper","url":"/docs/2.2.0/backends/casper#execution","content":"First thing Odra does with your code, is similar to the one used in OdraVM - a list of entrypoints is generated, thanks to the #[odra::module] attribute. ","version":"2.2.0","tagName":"h2"},{"title":"What is a backend?","type":0,"sectionRef":"#","url":"/docs/2.2.0/backends/what-is-a-backend","content":"","keywords":"","version":"2.2.0"},{"title":"Contract Env​","type":1,"pageTitle":"What is a backend?","url":"/docs/2.2.0/backends/what-is-a-backend#contract-env","content":"The Contract Env is a simple interface that each backend needs to implement, exposing features of the blockchain from the perspective of the contract. It gives Odra a set of functions, which allows implementing more complex concepts - for example, to implement Mapping, Odra requires some kind of storage integration. The exact implementation of those functions is a responsibility of a backend, making Odra and its user free to implement the contract logic, instead of messing with the blockchain internals. Other functions from Contract Env include handling transfers, addresses, block time, errors and events. ","version":"2.2.0","tagName":"h2"},{"title":"Host Env​","type":1,"pageTitle":"What is a backend?","url":"/docs/2.2.0/backends/what-is-a-backend#host-env","content":"Similarly to the Contract Env, the Host Env exposes a set of functions that allows the communication with the backend from the outside world - really useful for implementing tests. This ranges from interacting with the blockchain - like deploying new, loading existing and calling the contracts, to the more test-oriented - handling errors, forwarding the block time, etc. ","version":"2.2.0","tagName":"h2"},{"title":"What's next​","type":1,"pageTitle":"What is a backend?","url":"/docs/2.2.0/backends/what-is-a-backend#whats-next","content":"We will take a look at backends Odra implements in more detail. ","version":"2.2.0","tagName":"h2"},{"title":"Livenet","type":0,"sectionRef":"#","url":"/docs/2.2.0/backends/livenet","content":"","keywords":"","version":"2.2.0"},{"title":"Setup​","type":1,"pageTitle":"Livenet","url":"/docs/2.2.0/backends/livenet#setup","content":"To use Livenet backend, we need to provide Odra with some information - the network address, our private key and the name of the chain we want to use. Optionally, we can add multiple private keys to use more than one account in our tests. Those values are passed using environment variables. We can use .env file to store them - let's take a look at an example .env file, created from the .env.sample file from the examples folder: # .env file used by Livenet integration. You can use multiple .env files to manage deploys on multiple chains # by naming them casper-test.env, casper-livenet.env, etc. and calling the deploy script with the name of the # ennviroment provided in the &quot;ODRA_CASPER_LIVENET_ENV&quot; variable. For example: # ODRA_CASPER_LIVENET_ENV=casper-test cargo run --bin livenet_tests --features livenet # This will load integration.env file first, and then fill the missing values with the values from casper-test.env. # Path to the secret key of the account that will be used to deploy the contracts. # If you are using the nctl, you can use the following command to extract the secret key from the container: # docker exec mynctl /bin/bash -c &quot;cat /home/casper/casper-nctl/assets/net-1/users/user-1/secret_key.pem&quot; &gt; examples/.node-keys/secret_key.pem # docker exec mynctl /bin/bash -c &quot;cat /home/casper/casper-nctl/assets/net-1/users/user-2/secret_key.pem&quot; &gt; examples/.node-keys/secret_key_1.pem ODRA_CASPER_LIVENET_SECRET_KEY_PATH=&lt;path to secret_key.pem&gt; # RPC address of the node that will be used to deploy the contracts. # For CSPR.cloud, you can use the following addresses: # - https://node.cspr.cloud # - https://node.testnet.cspr.cloud # For nctl, default is: # - http://localhost:11101 ODRA_CASPER_LIVENET_NODE_ADDRESS=&lt;node address&gt; # Events url # For CSPR.cloud, you can use the following addresses: # - https://node.cspr.cloud/events # For nctl, default is: # - http://localhost:18101/events ODRA_CASPER_LIVENET_EVENTS_URL=&lt;events url&gt; # Chain name of the network. The mainnet is &quot;casper&quot; and test net is &quot;casper-test&quot;. # The integration network uses the &quot;integration-test&quot; chain name. # For nctl default is &quot;casper-net-1&quot; ODRA_CASPER_LIVENET_CHAIN_NAME=&lt;chain_name&gt; # Optionally, paths to the secret keys of the additional acccounts. Main secret key will be 0th account. # The following will work for nctl if you used the command above to extract the secret keys: # ODRA_CASPER_LIVENET_KEY_1=./keys/secret_key_1.pem #ODRA_CASPER_LIVENET_KEY_1=&lt;path to secret_key_1.pem&gt; # If using CSPR.cloud, you can set the auth token here. # CSPR_CLOUD_AUTH_TOKEN=  note CSPR.cloud is a service that provides mainnet and testnet Casper nodes on demand. With the proper value in place, we can write our tests or deploy scenarios. In the examples, we can find a simple binary that deploys a contract and calls it. The test is located in the erc20_on_livenet.rs file. Let's go through the code: //! Deploys an ERC20 contract and transfers some tokens to another address. use odra::casper_types::U256; use odra::host::{Deployer, HostEnv, HostRefLoader, InstallConfig}; use odra::prelude::*; use odra_modules::erc20::{Erc20, Erc20HostRef, Erc20InitArgs}; use std::str::FromStr; fn main() { let env = odra_casper_livenet_env::env(); let owner = env.caller(); let recipient = &quot;hash-2c4a6ce0da5d175e9638ec0830e01dd6cf5f4b1fbb0724f7d2d9de12b1e0f840&quot;; let recipient = Address::from_str(recipient).unwrap(); // Deploy new contract. let mut token = deploy_erc20(&amp;env); println!(&quot;Token address: {}&quot;, token.address().to_string()); // Uncomment to load existing contract. // let mut token = load_erc20(&amp;env); println!(&quot;Token name: {}&quot;, token.name()); env.set_gas(3_000_000_000u64); token.transfer(&amp;recipient, &amp;U256::from(1000)); println!(&quot;Owner's balance: {:?}&quot;, token.balance_of(&amp;owner)); println!(&quot;Recipient's balance: {:?}&quot;, token.balance_of(&amp;recipient)); } /// Loads an ERC20 contract. fn _load_erc20(env: &amp;HostEnv) -&gt; Erc20HostRef { let address = &quot;hash-d26fcbd2106e37be975d2045c580334a6d7b9d0a241c2358a4db970dfd516945&quot;; let address = Address::from_str(address).unwrap(); Erc20::load(env, address) } /// Deploys an ERC20 contract. pub fn deploy_erc20(env: &amp;HostEnv) -&gt; Erc20HostRef { let name = String::from(&quot;Plascoin&quot;); let symbol = String::from(&quot;PLS&quot;); let decimals = 10u8; let initial_supply = Some(U256::from(10_000)); let init_args = Erc20InitArgs { name, symbol, decimals, initial_supply }; env.set_gas(450_000_000_000u64); // You may configure a deploy passing `InstallConfig`. // Erc20::deploy_with_cfg(env, init_args, InstallConfig::upgradable::&lt;Erc20&gt;()) Erc20::deploy(env, init_args) }  note The above example is a rust binary, not a test. Note that it is also added as a section of theCargo.toml file: [bin] name = &quot;erc20_on_livenet&quot; path = &quot;src/bin/erc20_on_livenet.rs&quot; required-features = [&quot;livenet&quot;] test = false  ","version":"2.2.0","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"Livenet","url":"/docs/2.2.0/backends/livenet#usage","content":"To run the above code, we simply need to run the binary with the livenet feature enabled: cargo run --bin erc20_on_livenet --features=livenet  note Before executing the binary, make sure you built a wasm file. A part of a sample output should look like this: ... 💁 INFO : Calling &quot;contract-package-b796cf8e527472d7ced8c4f8db5adb30eb577176f4c7ce956675590e0cac4bb8&quot; directly with entrypoint &quot;transfer&quot;. 🙄 WAIT : Waiting 10 for V1(TransactionV1Hash(775913daa0ffbded9aaf2216942217d682f03d1c04e6e2560d1e4b3329ebd2d6)). 💁 INFO : Transaction &quot;775913daa0ffbded9aaf2216942217d682f03d1c04e6e2560d1e4b3329ebd2d6&quot; successfully executed. 🔗 LINK : Owner's balance: 9000 Recipient's balance: 1000  Those logs are a result of the last 4 lines of the above listing. Each deployment or a call to the blockchain will be noted and will take some time to execute. We can see that the transfer call took over 15 seconds to execute. But calling balance_of was nearly instant and cost us nothing. How it is possible? info You can see the deployment on http://cspr.live/ - the transfer from the example can be seen here. ","version":"2.2.0","tagName":"h2"},{"title":"How Livenet backend works​","type":1,"pageTitle":"Livenet","url":"/docs/2.2.0/backends/livenet#how-livenet-backend-works","content":"All calls of entrypoints executed on a Casper blockchain cost gas - even if they do not change the state. It is possible, however, to query the state of the blockchain for free. This principle is used in the Livenet backend - all calls that do not change the state of the blockchain are really executed offline - the only thing that is requested from the node is the current state. This is why the balance_of call was almost instant and free. Basically, if the entrypoint function is not mutable or does not make a call to an unknown external contract (see Cross Calls), it is executed offline and node is used for the state query only. However, the Livenet needs to know the connection between the contracts and the code, so make sure to deploy or load already deployed contracts ","version":"2.2.0","tagName":"h2"},{"title":"Multiple environments​","type":1,"pageTitle":"Livenet","url":"/docs/2.2.0/backends/livenet#multiple-environments","content":"It is possible to have multiple environments for the Livenet backend. This is useful if we want to easily switch between multiple accounts, multiple nodes or even multiple chains. To do this, simply create a new .env file with a different prefix - for example, integration.env and mainnet.env. Then, pass the ODRA_CASPER_LIVENET_ENV variable with value either integration or mainnet to select which file has to be used first. If your integration.env file has a value that IS present in the .env file, it will override the value from the .env file. ODRA_CASPER_LIVENET_ENV=integration cargo run --bin erc20_on_livenet --features=livenet  To sum up - this command will firstly load the integration.env file and then load the missing values from .env file. ","version":"2.2.0","tagName":"h2"},{"title":"Host Communication","type":0,"sectionRef":"#","url":"/docs/2.2.0/basics/communicating-with-host","content":"","keywords":"","version":"2.2.0"},{"title":"What's next​","type":1,"pageTitle":"Host Communication","url":"/docs/2.2.0/basics/communicating-with-host#whats-next","content":"In the next article, we'll dive into testing your contracts with Odra, so you can check that the code we presented in fact works! ","version":"2.2.0","tagName":"h2"},{"title":"Cargo Odra","type":0,"sectionRef":"#","url":"/docs/2.2.0/basics/cargo-odra","content":"","keywords":"","version":"2.2.0"},{"title":"Managing projects​","type":1,"pageTitle":"Cargo Odra","url":"/docs/2.2.0/basics/cargo-odra#managing-projects","content":"Two commands help you create a new project. The first one is cargo odra new. You need to pass one parameter, namely --name {PROJECT_NAME}: cargo odra new --name my-project  This creates a new project in the my_project folder and name it my_project. You can see it for yourself, for example by taking a look into a Cargo.toml file created in your project's folder: [package] name = &quot;my_project&quot; version = &quot;0.1.0&quot; edition = &quot;2021&quot;  The project is created using the template located in Odra's main repository. By default it uses full template, if you want, you can use minimalistic blank by running: cargo odra new -t blank --name my-project  The third available template is workspace, which creates a workspace with two projects, similar to the one created with the full template. There are also two templates which create a project with a sample tokens native to Casper Network: cep18 and cep78. By default, the latest release of Odra will be used for the template and as a dependency. You can pass a source of Odra you want to use, by using -s parameter: cargo odra new -n my-project -s ../odra # will use local folder of odra cargo odra new -n my-project -s release/0.9.0 # will use github branch, e.g. if you want to test new release cargo odra new -n my-project -s 1.1.0 # will use a version released on crates.io  The second way of creating a project is by using init command: cargo odra init --name my-project  It works in the same way as new, but instead of creating a new folder, it creates a project in the current, empty directory. ","version":"2.2.0","tagName":"h2"},{"title":"Generating code​","type":1,"pageTitle":"Cargo Odra","url":"/docs/2.2.0/basics/cargo-odra#generating-code","content":"If you want to quickly create a new contract code, you can use the generate command: cargo odra generate -c counter  This creates a new file src/counter.rs with sample code, add appropriate use and mod sections to src/lib.rs and update the Odra.toml file accordingly. To learn more about Odra.toml file, visit Odra.toml. ","version":"2.2.0","tagName":"h2"},{"title":"Testing​","type":1,"pageTitle":"Cargo Odra","url":"/docs/2.2.0/basics/cargo-odra#testing","content":"The most used command during the development of your project should be this one: cargo odra test  It runs your tests against Odra's MockVM. It is substantially faster than CasperVMand implements all the features Odra uses. When you want to run tests against a &quot;real&quot; VM, just provide the name of the backend using -boption: cargo odra test -b casper  In the example above, Cargo Odra builds the project, generates the wasm files, spin up CasperVM instance, deploys the contracts onto it and runs the tests against it. Pretty neat. Keep in mind that this is a lot slower than OdraVM and you cannot use the debugger. This is why OdraVM was created and should be your first choice when developing contracts. Of course, testing all of your code against a blockchain VM is a must in the end. If you want to run only some of the tests, you can pass arguments to the cargo test command (which is run in the background obviously): cargo odra test -- this-will-be-passed-to-cargo-test  If you want to run tests which names contain the word two, you can execute: cargo odra test -- two  Of course, you can do the same when using the backend: cargo odra test -b casper -- two  ","version":"2.2.0","tagName":"h2"},{"title":"Building code​","type":1,"pageTitle":"Cargo Odra","url":"/docs/2.2.0/basics/cargo-odra#building-code","content":"You can also build the code itself and generate the output contracts without running the tests. To do so, simply run: cargo odra build  If the build process finishes successfully, wasm files will be located in wasm folder. Notice, that this command does not require the -b option. If you want to build specific contract, you can use -c option: cargo odra build -c counter # you pass many comma separated contracts  ","version":"2.2.0","tagName":"h2"},{"title":"Skipping building​","type":1,"pageTitle":"Cargo Odra","url":"/docs/2.2.0/basics/cargo-odra#skipping-building","content":"As building wasm files can take a long time, especially if you have a lot of contracts. If you did not change anything in your contracts and you just want to rerun the tests for the casper backend, use the -s option: cargo odra test -b casper -s  ","version":"2.2.0","tagName":"h2"},{"title":"Generating contract schema​","type":1,"pageTitle":"Cargo Odra","url":"/docs/2.2.0/basics/cargo-odra#generating-contract-schema","content":"If you want to generate a schema (including the name, entrypoints, events, etc.) for your contract, you can use the schema command: cargo odra schema  This generates a schema file in JSON format for all your contracts and places them in the resources folder. If the resources folder does not exist, it creates the folder for you. Like with the build command, you can use the -c option to generate a schema for a specific contract. ","version":"2.2.0","tagName":"h2"},{"title":"What's next​","type":1,"pageTitle":"Cargo Odra","url":"/docs/2.2.0/basics/cargo-odra#whats-next","content":"In the next section, we will take a look at all the files and directories that cargo odra created for us and explain their purpose. ","version":"2.2.0","tagName":"h2"},{"title":"directory-structure","type":0,"sectionRef":"#","url":"/docs/2.2.0/basics/directory-structure","content":"","keywords":"","version":"2.2.0"},{"title":"Directory structure​","type":1,"pageTitle":"directory-structure","url":"/docs/2.2.0/basics/directory-structure#directory-structure","content":"After creating a new project using Odra and running the tests, you will be presented with the following files and directories: . ├── Cargo.lock ├── Cargo.toml ├── CHANGELOG.md ├── Odra.toml ├── README.md ├── rust-toolchain ├── src/ │ ├── flipper.rs │ └── lib.rs ├── bin/ | |── build_contract.rs | └── build_schema.rs ├── target/ └── wasm/  ","version":"2.2.0","tagName":"h2"},{"title":"Cargo.toml​","type":1,"pageTitle":"directory-structure","url":"/docs/2.2.0/basics/directory-structure#cargotoml","content":"Let's first take a look at Cargo.toml file: [package] name = &quot;sample&quot; version = &quot;0.1.0&quot; edition = &quot;2021&quot; [dependencies] odra = &quot;2.2.0&quot; [dev-dependencies] odra-test = &quot;2.2.0&quot; [build-dependencies] odra-build = &quot;2.2.0&quot; [[bin]] name = &quot;sample_build_contract&quot; path = &quot;bin/build_contract.rs&quot; test = false [[bin]] name = &quot;sample_build_schema&quot; path = &quot;bin/build_schema.rs&quot; test = false [profile.release] codegen-units = 1 lto = true [profile.dev.package.&quot;*&quot;] opt-level = 3  By default, your project will use the latest odra version available at crates.io. For testing purposes,odra-test is also added as a dev dependency. ","version":"2.2.0","tagName":"h3"},{"title":"Odra.toml​","type":1,"pageTitle":"directory-structure","url":"/docs/2.2.0/basics/directory-structure#odratoml","content":"This is the file that holds information about contracts that will be generated when running cargo odra build andcargo odra test: [[contracts]] fqn = &quot;sample::Flipper&quot;  As we can see, we have a single contract, its fqn (Fully Qualified Name) corresponds to the contract is located in src/flipper.rs. More contracts can be added here by hand, or by using cargo odra generate command. ","version":"2.2.0","tagName":"h3"},{"title":"src/​","type":1,"pageTitle":"directory-structure","url":"/docs/2.2.0/basics/directory-structure#src","content":"This is the folder where your smart contract files live. ","version":"2.2.0","tagName":"h3"},{"title":"bin/​","type":1,"pageTitle":"directory-structure","url":"/docs/2.2.0/basics/directory-structure#bin","content":"This is the folder where scripts that will be used to generate code or schemas live. You don't need to modify those files, they are generated by cargo odra new command and are used by cargo odra build, cargo odra test and cargo odra schema commands. ","version":"2.2.0","tagName":"h3"},{"title":"target/​","type":1,"pageTitle":"directory-structure","url":"/docs/2.2.0/basics/directory-structure#target","content":"Files generated by cargo during the build process are put here. ","version":"2.2.0","tagName":"h3"},{"title":"wasm/​","type":1,"pageTitle":"directory-structure","url":"/docs/2.2.0/basics/directory-structure#wasm","content":"WASM files generated by cargo odra build and cargo odra test are put here. You can grab those WASM files and deploy them on the blockchain. ","version":"2.2.0","tagName":"h3"},{"title":"What's next​","type":1,"pageTitle":"directory-structure","url":"/docs/2.2.0/basics/directory-structure#whats-next","content":"Now, let's take a look at one of the files mentioned above in more detail, namely the Odra.toml file. ","version":"2.2.0","tagName":"h2"},{"title":"Cross calls","type":0,"sectionRef":"#","url":"/docs/2.2.0/basics/cross-calls","content":"","keywords":"","version":"2.2.0"},{"title":"Contract Ref​","type":1,"pageTitle":"Cross calls","url":"/docs/2.2.0/basics/cross-calls#contract-ref","content":"We mentioned HostRef already in our Testing article - a host side reference to already deployed contract. In the module context we use a ContractRef instead, to call other contracts. Similarly to the HostRef trait implemetation for the module, the {{ModuleName}}ContractRef is generated automatically, by the #[odra::module] attribute. The reference implements all the public endpoints to the contract (those marked as pub in #[odra::module]impl), and the {{ModuleName}}ContractRef::address() function, which returns the address of the contract. External Contracts Sometimes in our contract, we would like to interact with a someone else's contract, already deployed onto the blockchain. The only thing we know about the contract is the ABI. For that purpose, we use #[odra:external_contract] attribute. This attribute should be applied to a trait. The trait defines the part of the ABI we would like to take advantage of. Let's pretend the MathEngine we defined is an external contract. There is a contract with add() function that adds two numbers somewhere. #[odra::external_contract] pub trait Adder { fn add(&amp;self, n1: u32, n2: u32) -&gt; u32; }  Odra automatically creates the AdderContractRef struct. Having an address, in the module context we can call: struct Contract { adder: External&lt;AdderContractRef&gt; } // in some function self.adder.add(3, 5) // or struct Contract { adder: Var&lt;Address&gt; } // in some function AdderContractRef::new(self.env(), address).add(3, 5)  ","version":"2.2.0","tagName":"h2"},{"title":"Loading the contract​","type":1,"pageTitle":"Cross calls","url":"/docs/2.2.0/basics/cross-calls#loading-the-contract","content":"Sometimes it is useful to load the deployed contract instead of deploying it by ourselves. This is especially useful when we want to test our contracts in Livenet backend. We can load the contract using load method on the Deployer: examples/bin/erc20_on_livenet.rs fn _load_erc20(env: &amp;HostEnv) -&gt; Erc20HostRef { let address = &quot;hash-d26fcbd2106e37be975d2045c580334a6d7b9d0a241c2358a4db970dfd516945&quot;; let address = Address::from_str(address).unwrap(); Erc20::load(env, address) }  ","version":"2.2.0","tagName":"h3"},{"title":"Testing​","type":1,"pageTitle":"Cross calls","url":"/docs/2.2.0/basics/cross-calls#testing","content":"Let's see how we can test our cross calls using this knowledge: examples/src/features/cross_calls.rs #[cfg(test)] mod tests { use super::{CrossContract, CrossContractInitArgs, MathEngineHostRef}; use odra::host::{Deployer, NoArgs}; use odra::prelude::*; #[test] fn test_cross_calls() { let test_env = odra_test::env(); let math_engine_contract = MathEngine::deploy(&amp;test_env, NoArgs); let cross_contract = CrossContract::deploy( &amp;test_env, CrossContractInitArgs { math_engine_address: *math_engine_contract.address() } ); assert_eq!(cross_contract.add_using_another(), 8); } }  Each test begins with a clean instance of the blockchain, with no contracts deployed. To test an external contract, we first deploy a MathEngine contract, although we won't directly utilize it. Instead, we only extract its address. Let's continue assuming there is a contract featuring the add() function that we intend to utilize. #[cfg(test)] mod tests { use super::*; use odra::host::{Deployer, NoArgs}; use odra::prelude::*; #[test] fn test_ext() { let test_env = odra_test::env(); let adder = Adder::new(&amp;test_env, get_adder_address(&amp;test_env)).add(3, 5) assert_eq!(adder.add(1, 2), 3); } fn get_adder_address(test_env: &amp;HostEnv) -&gt; Address { let contract = MathEngine::deploy(test_env, NoArgs); contract.address() } }  ","version":"2.2.0","tagName":"h2"},{"title":"Casper Contract Schema","type":0,"sectionRef":"#","url":"/docs/2.2.0/basics/casper-contract-schema","content":"","keywords":"","version":"2.2.0"},{"title":"Odra and CCS​","type":1,"pageTitle":"Casper Contract Schema","url":"/docs/2.2.0/basics/casper-contract-schema#odra-and-ccs","content":"There is almost nothing you need to do to use CCS in your Odra project. The only thing to be taken care of is using odra attributes namely: module, event, odra_error and odra_type. The schema will be generated for you and available in the resources directory. note If you forget to register events and errors in the module attribute, the definition remains valid; however, the errors and events will not be incorporated into the schema. src/contract.rs use odra::prelude::*; #[odra::module( // the name of the contract, default is the module name name = &quot;MyContract&quot;, // the version of the contract, default is the version of the crate version = &quot;0.1.0&quot;, // events that the contract can emit, collected recursively if submodules are used events = [ Created, Updated ], // the error enum the contract can revert with, collected recursively if submodules are used errors = MyErrors )] pub struct MyContract { name: Var&lt;String&gt;, owner: Var&lt;Address&gt;, } #[odra::module] impl MyContract { /// Initializes the contract, sets the name and owner and emits an event pub fn init(&amp;mut self, name: String, owner: Address) { self.name.set(name.clone()); self.owner.set(owner.clone()); self.env().emit_event(Created { name }); } /// Updates the name of the contract and emits an event pub fn update(&amp;mut self, name: String) { self.name.set(name.clone()); self.env().emit_event(Updated { name }); } /// Returns the data of the contract pub fn get_data(&amp;self) -&gt; Data { Data { name: self.name.get_or_default(), owner: self.owner.get_or_revert_with(MyErrors::InvalidOwner), } } } // The struct will we visible in the schema in the types section #[odra::odra_type] pub struct Data { name: String, owner: Address, } // The enum variants will we visible in the schema in the errors section #[odra::odra_error] pub enum MyErrors { /// The owner is invalid InvalidOwner, /// The name is invalid InvalidName, } // The struct will we visible in the schema in the types and events section #[odra::event] pub struct Updated { name: String, } // The struct will we visible in the schema in the types section and events section #[odra::event] pub struct Created { name: String, }  ","version":"2.2.0","tagName":"h2"},{"title":"Generating the Schema​","type":1,"pageTitle":"Casper Contract Schema","url":"/docs/2.2.0/basics/casper-contract-schema#generating-the-schema","content":"To generate the schema run the following cargo-odra command: cargo odra schema # or pass -c flag to generate the schema for a specific contract  ","version":"2.2.0","tagName":"h2"},{"title":"Schema Output​","type":1,"pageTitle":"Casper Contract Schema","url":"/docs/2.2.0/basics/casper-contract-schema#schema-output","content":"The generated schema will be available in the resources directory. The schema is a JSON file that contains all the information about the contract. Here is an example of the generated schema: resources/my_contract_schema.json { &quot;casper_contract_schema_version&quot;: 1, &quot;toolchain&quot;: &quot;rustc 1.77.0-nightly (5bd5d214e 2024-01-25)&quot;, &quot;authors&quot;: [], &quot;repository&quot;: null, &quot;homepage&quot;: null, &quot;contract_name&quot;: &quot;MyContract&quot;, &quot;contract_version&quot;: &quot;0.1.0&quot;, &quot;types&quot;: [ { &quot;struct&quot;: { &quot;name&quot;: &quot;Created&quot;, &quot;description&quot;: null, &quot;members&quot;: [ { &quot;name&quot;: &quot;name&quot;, &quot;description&quot;: null, &quot;ty&quot;: &quot;String&quot; } ] } }, { &quot;struct&quot;: { &quot;name&quot;: &quot;Data&quot;, &quot;description&quot;: null, &quot;members&quot;: [ { &quot;name&quot;: &quot;name&quot;, &quot;description&quot;: null, &quot;ty&quot;: &quot;String&quot; }, { &quot;name&quot;: &quot;owner&quot;, &quot;description&quot;: null, &quot;ty&quot;: &quot;Key&quot; } ] } }, { &quot;struct&quot;: { &quot;name&quot;: &quot;Updated&quot;, &quot;description&quot;: null, &quot;members&quot;: [ { &quot;name&quot;: &quot;name&quot;, &quot;description&quot;: null, &quot;ty&quot;: &quot;String&quot; } ] } } ], &quot;errors&quot;: [ { &quot;name&quot;: &quot;InvalidName&quot;, &quot;description&quot;: &quot;The name is invalid&quot;, &quot;discriminant&quot;: 1 }, { &quot;name&quot;: &quot;InvalidOwner&quot;, &quot;description&quot;: &quot;The owner is invalid&quot;, &quot;discriminant&quot;: 0 } ], &quot;entry_points&quot;: [ { &quot;name&quot;: &quot;update&quot;, &quot;description&quot;: &quot;Updates the name of the contract and emits an event&quot;, &quot;is_mutable&quot;: true, &quot;arguments&quot;: [ { &quot;name&quot;: &quot;name&quot;, &quot;description&quot;: null, &quot;ty&quot;: &quot;String&quot;, &quot;optional&quot;: false } ], &quot;return_ty&quot;: &quot;Unit&quot;, &quot;is_contract_context&quot;: true, &quot;access&quot;: &quot;public&quot; }, { &quot;name&quot;: &quot;get_data&quot;, &quot;description&quot;: &quot;Returns the data of the contract&quot;, &quot;is_mutable&quot;: false, &quot;arguments&quot;: [], &quot;return_ty&quot;: &quot;Data&quot;, &quot;is_contract_context&quot;: true, &quot;access&quot;: &quot;public&quot; } ], &quot;events&quot;: [ { &quot;name&quot;: &quot;Created&quot;, &quot;ty&quot;: &quot;Created&quot; }, { &quot;name&quot;: &quot;Updated&quot;, &quot;ty&quot;: &quot;Updated&quot; } ], &quot;call&quot;: { &quot;wasm_file_name&quot;: &quot;MyContract.wasm&quot;, &quot;description&quot;: &quot;Initializes the contract, sets the name and owner and emits an event&quot;, &quot;arguments&quot;: [ { &quot;name&quot;: &quot;odra_cfg_package_hash_key_name&quot;, &quot;description&quot;: &quot;The arg name for the package hash key name.&quot;, &quot;ty&quot;: &quot;String&quot;, &quot;optional&quot;: false }, { &quot;name&quot;: &quot;odra_cfg_allow_key_override&quot;, &quot;description&quot;: &quot;The arg name for the allow key override.&quot;, &quot;ty&quot;: &quot;Bool&quot;, &quot;optional&quot;: false }, { &quot;name&quot;: &quot;odra_cfg_is_upgradable&quot;, &quot;description&quot;: &quot;The arg name for the contract upgradeability setting.&quot;, &quot;ty&quot;: &quot;Bool&quot;, &quot;optional&quot;: false }, { &quot;name&quot;: &quot;name&quot;, &quot;description&quot;: null, &quot;ty&quot;: &quot;String&quot;, &quot;optional&quot;: false }, { &quot;name&quot;: &quot;owner&quot;, &quot;description&quot;: null, &quot;ty&quot;: &quot;Key&quot;, &quot;optional&quot;: false } ] } }  ","version":"2.2.0","tagName":"h2"},{"title":"Schema Fields​","type":1,"pageTitle":"Casper Contract Schema","url":"/docs/2.2.0/basics/casper-contract-schema#schema-fields","content":"casper_contract_schema_version is the version of the schema.toolchain is the version of the Rust compiler used to compile the contract.Fields authors, repository, and homepage are optional and can be set in the Cargo.toml file.contract_name is the name of the contract - by default is the module name, may be overriden by the module attribute.contract_version denotes the version of the contract, defaulting to the version specified in the Cargo.toml file, but can be overridden by the module attribute.types comprises a list of custom structs and enums defined within the contract. Each struct or enum includes a name, description (not currently supported, with the value set to null), and a list of members.errors is a list of error enums defined within the contract. Each error includes a name, description (the first line of the variant documentation), and a discriminant.entry_points is a list of contract functions that can be called from the outside. Each entry point includes a name, description (not currently supported, with the value set to null), whether the function is mutable, a list of arguments, the return type, whether the function is called in the contract context, and the access level.events is a list of events that the contract can emit. Each event includes a name and the type (earlier defined in types) of the event.The call section provides details regarding the contract's call function, which executes upon contract deployment. It includes the name of the Wasm file, a description (reflecting the constructor's description, typically the init function), and a list of arguments. These arguments are a combination of Odra configuration arguments and constructor arguments. ","version":"2.2.0","tagName":"h2"},{"title":"Errors","type":0,"sectionRef":"#","url":"/docs/2.2.0/basics/errors","content":"","keywords":"","version":"2.2.0"},{"title":"Testing errors​","type":1,"pageTitle":"Errors","url":"/docs/2.2.0/basics/errors#testing-errors","content":"Okay, but how about testing it? Let's write a test that will check if the error is thrown when the caller is not an owner: examples/src/features/handling_errors.rs #[cfg(test)] mod tests { use super::{Error, OwnedContract, OwnedContractInitArgs}; use odra::{host::Deployer, prelude::*}; #[test] fn test_owner_error() { let test_env = odra_test::env(); let owner = test_env.get_account(0); let not_an_owner = test_env.get_account(1); test_env.set_caller(owner); let init_args = OwnedContractInitArgs { name: &quot;OwnedContract&quot;.to_string() }; let mut owned_contract = OwnedContract::deploy(&amp;test_env, init_args); test_env.set_caller(not_an_owner); assert_eq!( owned_contract .try_change_name(&quot;NewName&quot;.to_string()) .unwrap_err(), Error::NotAnOwner.into() ); } }  Each deployed contract is of {{ModuleName}}HostRef type and has try_{{entry_point_name}} functions that return an OdraResult.OwnedContractHostRef implements regular entrypoints: name, owner, change_name, and and safe its safe version: try_name, try_owner, try_change_name. In our example, we are calling try_change_name and expecting an error to be thrown. For assertions, we are using a standard assert_eq! macro. As the contract call returns an OdraError, we need to convert our custom error to OdraError using Into::into(). ","version":"2.2.0","tagName":"h2"},{"title":"What's next​","type":1,"pageTitle":"Errors","url":"/docs/2.2.0/basics/errors#whats-next","content":"We will learn how to emit and test events using Odra. ","version":"2.2.0","tagName":"h2"},{"title":"Flipper Internals","type":0,"sectionRef":"#","url":"/docs/2.2.0/basics/flipper-internals","content":"","keywords":"","version":"2.2.0"},{"title":"Header​","type":1,"pageTitle":"Flipper Internals","url":"/docs/2.2.0/basics/flipper-internals#header","content":"flipper.rs use odra::prelude::*;  The first line of the file imports the odra crate. The prelude module contains all the necessary types and traits that you will need to write your contract. It is a good practice to import theodra::prelude::* module in every file that contains Odra code. This way, you will not have to import each type or trait separately. ","version":"2.2.0","tagName":"h2"},{"title":"Struct​","type":1,"pageTitle":"Flipper Internals","url":"/docs/2.2.0/basics/flipper-internals#struct","content":"flipper.rs /// A module definition. Each module struct consists of Vars and Mappings /// or/and other modules. #[odra::module] pub struct Flipper { /// The module itself does not store the value, /// it's a proxy that writes/reads value to/from the host. value: Var&lt;bool&gt;, }  In Odra, all contracts are also modules, which can be reused between contracts. That's why we need to mark the struct with the #[odra::module] attribute. In the struct definition itself, we state all the fields of the contract. Those fields can be regular Rust data types, however - those will not be persisted on the blockchain. They can also be Odra modules - defined in your project or coming from Odra itself. Finally, to make the data persistent on the blockchain, you can use something likeVar&lt;T&gt; showed above. To learn more about storage interaction, take a look at thenext article. ","version":"2.2.0","tagName":"h2"},{"title":"Impl​","type":1,"pageTitle":"Flipper Internals","url":"/docs/2.2.0/basics/flipper-internals#impl","content":"flipper.rs /// Module implementation. /// /// To generate entrypoints, /// an implementation block must be marked as #[odra::module]. #[odra::module] impl Flipper { /// Odra constructor. /// /// Initializes the contract with the value of value. pub fn init(&amp;mut self) { self.value.set(false); } ...  Similarly to the struct, we mark the impl section with the #[odra::module] attribute. Odra will take allpub functions from this section and create contract endpoints from them. So, if you wish to have functions that are not available for calling outside the contract, do not make them public. Alternatively, you can create a separate impl section without the attribute - all functions defined there, even marked with pub will be not callable. The function named init is the constructor of the contract. This function will be limited only to a single call, all further calls to it will result in an error. The init function is optional, if your contract does not need any initialization, you can skip it. flipper.rs ... /// Replaces the current value with the passed argument. pub fn set(&amp;mut self, value: bool) { self.value.set(value); } /// Replaces the current value with the opposite value. pub fn flip(&amp;mut self) { self.value.set(!self.get()); } ...  The endpoints above show you how to interact with the simplest type of storage - Var&lt;T&gt;. The data saved there using set function will be persisted in the blockchain. ","version":"2.2.0","tagName":"h2"},{"title":"Tests​","type":1,"pageTitle":"Flipper Internals","url":"/docs/2.2.0/basics/flipper-internals#tests","content":"flipper.rs #[cfg(test)] mod tests { use crate::flipper::Flipper; use odra::host::{Deployer, NoArgs}; #[test] fn flipping() { let env = odra_test::env(); // To test a module we need to deploy it. `Flipper` implements `Deployer` trait, // so we can use it to deploy the module. let mut contract = Flipper::deploy(&amp;env, NoArgs); assert!(!contract.get()); contract.flip(); assert!(contract.get()); } ...  You can write tests in any way you prefer and know in Rust. In the example above we are deploying the contract using Deployer::deploy function called on Flipper - a piece of code generated by the #[odra::module]. Because the module implements the constructor but does not accept any arguments, as the second argument of the deploy function, we pass NoArgs - one of the implementations of the InitArgs trait provided with the framework. The contract will be deployed on the VM you chose while running cargo odra test. ","version":"2.2.0","tagName":"h2"},{"title":"What's next​","type":1,"pageTitle":"Flipper Internals","url":"/docs/2.2.0/basics/flipper-internals#whats-next","content":"Now let's take a look at the different types of storage that Odra provides and how to use them. ","version":"2.2.0","tagName":"h2"},{"title":"Events","type":0,"sectionRef":"#","url":"/docs/2.2.0/basics/events","content":"","keywords":"","version":"2.2.0"},{"title":"Testing events​","type":1,"pageTitle":"Events","url":"/docs/2.2.0/basics/events#testing-events","content":"Odra's HostEnv comes with a few functions which lets you easily test the events that a given contract has emitted: examples/src/features/events.rs use super::{PartyContract, PartyStarted}; use odra::host::{Deployer, HostEnv, NoArgs}; #[test] fn test_party() { let test_env: HostEnv = odra_test::env(); let party_contract = PartyContract::deploy(&amp;test_env, NoArgs); assert!(test_env.emitted_event( &amp;party_contract, PartyStarted { caller: test_env.get_account(0), block_time: 0 } )); assert!(test_env.emitted_native_event( &amp;party_contract, NativePartyStarted { caller: test_env.get_account(0), block_time: 0 } )); // If you do not want to check the exact event, you can use `emitted` function assert!(test_env.emitted(&amp;party_contract, &quot;PartyStarted&quot;)); // Or `emitted_native` for the native events assert!(test_env.emitted_native(&amp;party_contract, &quot;NativePartyStarted&quot;)); // You can also check how many events were emitted: assert_eq!(test_env.events_count(&amp;party_contract), 1); assert_eq!(test_env.native_events_count(&amp;party_contract), 1); }  To explore more event testing functions, check the HostEnv documentation. ","version":"2.2.0","tagName":"h2"},{"title":"What's next​","type":1,"pageTitle":"Events","url":"/docs/2.2.0/basics/events#whats-next","content":"Read the next article to learn how to call other contracts from the contract context. ","version":"2.2.0","tagName":"h2"},{"title":"Modules","type":0,"sectionRef":"#","url":"/docs/2.2.0/basics/modules","content":"","keywords":"","version":"2.2.0"},{"title":"Testing​","type":1,"pageTitle":"Modules","url":"/docs/2.2.0/basics/modules#testing","content":"As we don't need to hold addresses, the test is really simple: examples/src/features/modules.rs #[cfg(test)] mod tests { use super::ModulesContract; use odra::host::{Deployer, NoArgs}; #[test] fn test_modules() { let test_env = odra_test::env(); let modules_contract = ModulesContract::deploy(&amp;test_env, NoArgs); assert_eq!(modules_contract.add_using_module(), 8); } }  ","version":"2.2.0","tagName":"h2"},{"title":"What's next​","type":1,"pageTitle":"Modules","url":"/docs/2.2.0/basics/modules#whats-next","content":"We will see how to handle native token transfers. ","version":"2.2.0","tagName":"h2"},{"title":"Odra.toml","type":0,"sectionRef":"#","url":"/docs/2.2.0/basics/odra-toml","content":"","keywords":"","version":"2.2.0"},{"title":"Adding a new contract manually​","type":1,"pageTitle":"Odra.toml","url":"/docs/2.2.0/basics/odra-toml#adding-a-new-contract-manually","content":"Besides using the cargo odra generate command, you can add a new contract to be compiled by hand. To do this, add another [[contracts]] element, name it and make sure that the fqn is set correctly. For example, if you want to create a new contract called counter, your Odra.toml file should finally look like this: [[contracts]] fqn = &quot;sample::Flipper&quot; [[contracts]] fqn = &quot;sample::Counter&quot;  ","version":"2.2.0","tagName":"h2"},{"title":"What's next​","type":1,"pageTitle":"Odra.toml","url":"/docs/2.2.0/basics/odra-toml#whats-next","content":"In the next section, we'll take a closer look at the code that was generated by Odra by default - the famousFlipper contract. ","version":"2.2.0","tagName":"h2"},{"title":"Native token","type":0,"sectionRef":"#","url":"/docs/2.2.0/basics/native-token","content":"","keywords":"","version":"2.2.0"},{"title":"Testing​","type":1,"pageTitle":"Native token","url":"/docs/2.2.0/basics/native-token#testing","content":"To be able to test how many tokens a contract (or any address) has, HostEnv comes with a function -balance_of: examples/src/features/native_token.rs #[cfg(test)] mod tests { use super::PublicWallet; use odra::{casper_types::U512, host::{Deployer, HostRef, NoArgs}}; #[test] fn test_modules() { let test_env = odra_test::env(); let mut my_contract = PublicWallet::deploy(&amp;test_env, NoArgs); assert_eq!(test_env.balance_of(&amp;my_contract), U512::zero()); my_contract.with_tokens(U512::from(100)).deposit(); assert_eq!(test_env.balance_of(&amp;my_contract), U512::from(100)); my_contract.withdraw(U512::from(25)); assert_eq!(test_env.balance_of(&amp;my_contract), U512::from(75)); } }  ","version":"2.2.0","tagName":"h2"},{"title":"HostEnv​","type":1,"pageTitle":"Native token","url":"/docs/2.2.0/basics/native-token#hostenv","content":"In a broader context of the host environment (test, livenet), you can also transfer CSPR tokens between accounts: let env = odra_casper_livenet_env::env(); //let env = odra_test::env(); let (alice, bob) = (env.get_account(0), env.get_account(1)); env.set_caller(alice); let result = env.transfer_tokens(bob, odra::casper_types::U512::from(100));  ","version":"2.2.0","tagName":"h2"},{"title":"Testing","type":0,"sectionRef":"#","url":"/docs/2.2.0/basics/testing","content":"","keywords":"","version":"2.2.0"},{"title":"HostEnv​","type":1,"pageTitle":"Testing","url":"/docs/2.2.0/basics/testing#hostenv","content":"Odra gives us some additional functions that we can use to communicate with the host (outside the contract context) and to configure how the contracts are deployed and called. Let's revisit the example from the previous article about host communication and implement the tests that prove it works: examples/src/features/testing.rs #[cfg(test)] mod tests { use crate::features::testing::{TestingContract, TestingContractInitArgs}; use odra::{host::{Deployer, HostEnv}, prelude::*}; #[test] fn env() { let test_env: HostEnv = odra_test::env(); test_env.set_caller(test_env.get_account(0)); let init_args = TestingContractInitArgs { name: &quot;MyContract&quot;.to_string() }; let testing_contract = TestingContract::deploy(&amp;test_env, init_args); let creator = testing_contract.created_by(); test_env.set_caller(test_env.get_account(1)); let init_args = TestingContractInitArgs { name: &quot;MyContract2&quot;.to_string() }; let testing_contract2 = TestingContract::deploy(&amp;test_env, init_args); let creator2 = testing_contract2.created_by(); assert_ne!(creator, creator2); } }  In the code above, at the beginning of the test, we are obtaining a HostEnv instance using odra_test::env(). Next, we are deploying two instances of the same contract, but we're using HostEnv::set_callerto change the caller - so the Address which is deploying the contract. This changes the result of the odra::ContractEnv::caller()the function we are calling inside the contract. HostEnv comes with a set of functions that will let you write better tests: fn set_caller(&amp;self, address: Address) - you've seen it in action just nowfn balance_of&lt;T: Addressable&gt;(&amp;self, addr: &amp;T) -&gt; U512 - returns the balance of the account associated with the given addressfn advance_block_time(&amp;self, time_diff: u64) - increases the current value of block_timefn get_account(&amp;self, n: usize) -&gt; Address - returns an n-th address that was prepared for you by Odra in advance; by default, you start with the 0-th accountfn emitted_event&lt;T: ToBytes + EventInstance, R: Addressable&gt;(&amp;self, contract_address: &amp;R, event: T) -&gt; bool - verifies if the event was emitted by the contract Full list of functions can be found in the HostEnv documentation. ","version":"2.2.0","tagName":"h2"},{"title":"What's next​","type":1,"pageTitle":"Testing","url":"/docs/2.2.0/basics/testing#whats-next","content":"We take a look at how Odra handles errors! ","version":"2.2.0","tagName":"h2"},{"title":"Storage interaction","type":0,"sectionRef":"#","url":"/docs/2.2.0/basics/storage-interaction","content":"","keywords":"","version":"2.2.0"},{"title":"Var​","type":1,"pageTitle":"Storage interaction","url":"/docs/2.2.0/basics/storage-interaction#var","content":"The Var is the simplest storage type available in the Odra framework. It serializes the data and stores it under a single key in the blockchain storage. To use it, just wrap your variable in the Var type. Let's look at a &quot;real world&quot; example of a contract that represents a dog: examples/src/features/storage/variable.rs use odra::prelude::*; #[odra::module] pub struct DogContract { barks: Var&lt;bool&gt;, weight: Var&lt;u32&gt;, name: Var&lt;String&gt;, walks: Var&lt;Vec&lt;u32&gt;&gt;, }  You can see the Var wrapping the data. Even complex types like Vec can be wrapped (with some caveats)! Let's make this contract usable, by providing a constructor and some getter functions: examples/src/features/storage/variable.rs #[odra::module] impl DogContract { pub fn init(&amp;mut self, barks: bool, weight: u32, name: String) { self.barks.set(barks); self.weight.set(weight); self.name.set(name); self.walks.set(Vec::&lt;u32&gt;::default()); } pub fn barks(&amp;self) -&gt; bool { self.barks.get_or_default() } pub fn weight(&amp;self) -&gt; u32 { self.weight.get_or_default() } pub fn name(&amp;self) -&gt; String { self.name.get_or_default() } pub fn walks_amount(&amp;self) -&gt; u32 { let walks = self.walks.get_or_default(); walks.len() as u32 } pub fn walks_total_length(&amp;self) -&gt; u32 { let walks = self.walks.get_or_default(); walks.iter().sum() } }  As you can see, you can access the data, by using get_or_default function: examples/src/features/storage/variable.rs ... self.barks.get_or_default() ...  note Keep in mind that using get() will result in an Option that you'll need to unwrap - the variable doesn't have to be initialized! To modify the data, use the set() function: examples/src/features/storage/variable.rs self.barks.set(barks);  A Var is easy to use and efficient for simple data types. One of its downsides is that it serializes the data as a whole, so when you're using complex types like Vec or HashMap, each time you get or set the whole data is read and written to the blockchain storage. In the example above, if we want to see how many walks our dog had, we would use the function: examples/src/features/storage/variable.rs pub fn walks_amount(&amp;self) -&gt; usize { let walks = self.walks.get_or_default(); walks.len() }  But to do so, we need to extract the whole serialized vector from the storage, which would inefficient, especially for larger sets of data. To tackle this issue following two types were created. ","version":"2.2.0","tagName":"h2"},{"title":"Mapping​","type":1,"pageTitle":"Storage interaction","url":"/docs/2.2.0/basics/storage-interaction#mapping","content":"The Mapping is used to store and access data as key-value pairs. To define a Mapping, you need to pass two values - the key type and the value type. Let's look at the variation of the Dog contract, that uses Mapping to store information about our dog's friends and how many times they visited: examples/src/features/storage/mapping.rs use odra::prelude::*; #[odra::module] pub struct DogContract2 { name: Var&lt;String&gt;, friends: Mapping&lt;String, u32&gt;, }  In the example above, our key is a String (it is a name of the friend) and we are storing u32 values (amount of visits). To read and write values from and into a Mapping we use a similar approach to the one shown in the Vars section with one difference - we need to pass a key: examples/src/features/storage/mapping.rs pub fn visit(&amp;mut self, friend_name: String) { let visits = self.visits(friend_name.clone()); self.friends.set(&amp;friend_name, visits + 1); } pub fn visits(&amp;self, friend_name: String) -&gt; u32 { self.friends.get_or_default(&amp;friend_name) }  The biggest improvement over a Var is that we can model functionality of a HashMap using Mapping. The amount of data written to and read from the storage is minimal. However, we cannot iterate over Mapping. We could implement such behavior by using a numeric type key and saving the length of the set in a separate variable. Thankfully Odra comes with a prepared solution - the List type. note If you take a look into List implementation in Odra, you'll see that in fact it is just a Mapping with a Var working together: core/src/list.rs use odra::prelude::*; pub struct List&lt;T&gt; { values: Mapping&lt;u32, T&gt;, index: Var&lt;u32&gt; }  ","version":"2.2.0","tagName":"h2"},{"title":"List​","type":1,"pageTitle":"Storage interaction","url":"/docs/2.2.0/basics/storage-interaction#list","content":"Going back to our DogContract example - let's revisit the walk case. This time, instead of Vec, we'll use the list: examples/src/features/storage/list.rs use odra::prelude::*; #[odra::module] pub struct DogContract3 { name: Var&lt;String&gt;, walks: List&lt;u32&gt;, }  As you can see, the notation is very similar to the Vec. To understand the usage, take a look at the reimplementation of the functions with an additional function that takes our dog for a walk (it writes the data to the storage): examples/src/features/storage/list.rs #[odra::module] impl DogContract3 { pub fn init(&amp;mut self, name: String) { self.name.set(name); } pub fn name(&amp;self) -&gt; String { self.name.get_or_default() } pub fn walks_amount(&amp;self) -&gt; u32 { self.walks.len() } pub fn walks_total_length(&amp;self) -&gt; u32 { self.walks.iter().sum() } pub fn walk_the_dog(&amp;mut self, length: u32) { self.walks.push(length); } }  Now, we can know how many walks our dog had without loading the whole vector from the storage. We need to do this to sum the length of all the walks, but the Odra framework cannot (yet) handle all the cases for you. info All of the above examples, alongside the tests, are available in the Odra repository in the examples/src/features/ folder. ","version":"2.2.0","tagName":"h2"},{"title":"Custom Types​","type":1,"pageTitle":"Storage interaction","url":"/docs/2.2.0/basics/storage-interaction#custom-types","content":"By default you can store only built-in types like numbers, Options, Results, Strings, Vectors. Implementing custom types is straightforward, your type must add #[odra::odra_type] attribute. Let's see how to implement a Dog type: use odra::prelude::*; #[odra::odra_type] pub struct Dog { pub name: String, pub age: u8, pub owner: Option&lt;Address&gt; }  #[odra_type] is applicable to named field structs and enums. It generates serialization, deserialization and schema code for your type.CLType of a custom type is CLType::Any, except for an unit-only enum, which is CLType::U8. unit_only_enum.rs enum Enum { Foo = 3, Bar = 2, Baz = 1, }  note Each custom typed field of your struct must be marked with the #[odra::odra_type] attribute . ","version":"2.2.0","tagName":"h2"},{"title":"What's next​","type":1,"pageTitle":"Storage interaction","url":"/docs/2.2.0/basics/storage-interaction#whats-next","content":"In the next article, we'll see how to query the host for information about the world and our contract. ","version":"2.2.0","tagName":"h2"},{"title":"odra-examples","type":0,"sectionRef":"#","url":"/docs/2.2.0/examples/odra-examples","content":"","keywords":"","version":"2.2.0"},{"title":"What's next​","type":1,"pageTitle":"odra-examples","url":"/docs/2.2.0/examples/odra-examples#whats-next","content":"Read the next article to learn about reusable Odra components encapsulated in odra-modules. ","version":"2.2.0","tagName":"h2"},{"title":"Installation","type":0,"sectionRef":"#","url":"/docs/2.2.0/getting-started/installation","content":"","keywords":"","version":"2.2.0"},{"title":"Prerequisites​","type":1,"pageTitle":"Installation","url":"/docs/2.2.0/getting-started/installation#prerequisites","content":"To start working with Odra, you need to have the following installed on your machine: Rust toolchain installed (see rustup.rs)wasmstrip tool installed (see wabt)wasm-opt tool installed (see binaryen) We do not provide exact commands for installing these tools, as they are different for different operating systems. Please refer to the documentation of the tools themselves. With Rust toolchain ready, you can add a new target: rustup target add wasm32-unknown-unknown  note wasm32-unknown-unknown is a target that will be used by Odra to compile your smart contracts to WASM files. ","version":"2.2.0","tagName":"h2"},{"title":"Installing Cargo Odra​","type":1,"pageTitle":"Installation","url":"/docs/2.2.0/getting-started/installation#installing-cargo-odra","content":"Cargo Odra is a helpful tool that will help you to build and test your smart contracts. It is not required to use Odra, but the documentation will assume that you have it installed. To install it, simply execute the following command: cargo install cargo-odra --locked  To check if it was installed correctly and see available commands, type: cargo odra --help  If everything went fine, we can proceed to the next step. ","version":"2.2.0","tagName":"h2"},{"title":"Creating a new Odra project​","type":1,"pageTitle":"Installation","url":"/docs/2.2.0/getting-started/installation#creating-a-new-odra-project","content":"To create a new project, simply execute: cargo odra new --name my-project &amp;&amp; cd my_project  This will create a new folder called my_project and initialize Odra there. Cargo Odra will create a sample contract for you in src directory. You can run the tests of this contract by executing: cargo odra test  This will run tests using Odra's internal OdraVM. You can run those tests against a real backend, let's use CasperVM: cargo odra test -b casper  Congratulations! Now you are ready to create contracts using Odra framework! If you had any problems during the installation process, feel free to ask for help on our Discord. ","version":"2.2.0","tagName":"h2"},{"title":"What's next?​","type":1,"pageTitle":"Installation","url":"/docs/2.2.0/getting-started/installation#whats-next","content":"If you want to see the code that you just tested, continue to the description of Flipper example. ","version":"2.2.0","tagName":"h2"},{"title":"Using odra-modules","type":0,"sectionRef":"#","url":"/docs/2.2.0/examples/using-odra-modules","content":"","keywords":"","version":"2.2.0"},{"title":"Available modules​","type":1,"pageTitle":"Using odra-modules","url":"/docs/2.2.0/examples/using-odra-modules#available-modules","content":"Odra modules comes with couple of ready-to-use modules and reusable extensions. ","version":"2.2.0","tagName":"h2"},{"title":"Tokens​","type":1,"pageTitle":"Using odra-modules","url":"/docs/2.2.0/examples/using-odra-modules#tokens","content":"CEP-18​ Casper Ecosystem Proposal 18 (CEP-18) is a standard interface for the CSPR and the custom made tokens. Inspired by the ERC20 standard. Read more about the CEP-18 here. CEP-95​ Casper Ecosystem Proposal 95 (CEP-95) is a Casper NFT Standard. It aims to replace CEP-47 and CEP-78, which have flaws that complicate their support in the ecosystem. This standard is aligned with Ethereum's ERC-721, but makes adjustments relevant for the Casper Ecosystem. Similarly to ERC-721, this standard can be used to represent a various range of tokenized assets Read more about the CEP-95 here. Erc20​ The Erc20 module implements the ERC20 standard. Erc721​ The Erc721Base module implements the ERC721 standard, adjusted for the Odra framework. The Erc721Token module implements the ERC721Base and additionally uses the Erc721Metadata and Ownable extensions. The Erc721Receiver trait lets you implement your own logic for receiving NFTs. The OwnedErc721WithMetadata trait is a combination of Erc721Token, Erc721Metadata and Ownable modules. Erc1155​ The Erc1155Base module implements the ERC1155 standard, adjusted for the Odra framework. The Erc1155Token module implements the ERC1155Base and additionally uses the Ownable extension. The OwnedErc1155 trait is a combination of Erc1155Token and Ownable modules. Wrapped native token​ The WrappedNativeToken module implements the Wrapper for the native token, it was inspired by the WETH. ","version":"2.2.0","tagName":"h3"},{"title":"Access​","type":1,"pageTitle":"Using odra-modules","url":"/docs/2.2.0/examples/using-odra-modules#access","content":"AccessControl​ This module enables the implementation of role-based access control mechanisms for children modules. Roles are identified by their 32-bytes identifier, which should be unique and exposed in the external API. Ownable​ This module provides a straightforward access control feature that enables exclusive access to particular functions by an account, known as the owner. The account that initiates the module is automatically assigned as the owner. However, ownership can be transferred later by using thetransfer_ownership() function. Ownable2Step​ An extension of the Ownable module. Ownership can be transferred in a two-step process by using transfer_ownership() and accept_ownership() functions. ","version":"2.2.0","tagName":"h3"},{"title":"Security​","type":1,"pageTitle":"Using odra-modules","url":"/docs/2.2.0/examples/using-odra-modules#security","content":"Pausable​ A module allowing to implement an emergency stop mechanism that can be triggered by any account. ","version":"2.2.0","tagName":"h3"},{"title":"Flipper example","type":0,"sectionRef":"#","url":"/docs/2.2.0/getting-started/flipper","content":"","keywords":"","version":"2.2.0"},{"title":"Let's flip​","type":1,"pageTitle":"Flipper example","url":"/docs/2.2.0/getting-started/flipper#lets-flip","content":"flipper.rs use odra::prelude::*; /// A module definition. Each module struct consists Vars and Mappings /// or/and another modules. #[odra::module] pub struct Flipper { /// The module itself does not store the value, /// it's a proxy that writes/reads value to/from the host. value: Var&lt;bool&gt;, } /// Module implementation. /// /// To generate entrypoints, /// an implementation block must be marked as #[odra::module]. #[odra::module] impl Flipper { /// Odra constructor. /// /// Initializes the contract. pub fn init(&amp;mut self) { self.value.set(false); } /// Replaces the current value with the passed argument. pub fn set(&amp;mut self, value: bool) { self.value.set(value); } /// Replaces the current value with the opposite value. pub fn flip(&amp;mut self) { self.value.set(!self.get()); } /// Retrieves value from the storage. /// If the value has never been set, the default value is returned. pub fn get(&amp;self) -&gt; bool { self.value.get_or_default() } } #[cfg(test)] mod tests { use crate::flipper::Flipper; use odra::host::{Deployer, NoArgs}; #[test] fn flipping() { let env = odra_test::env(); // To test a module we need to deploy it. `Flipper` implements `Deployer` trait, // so we can use it to deploy the module. let mut contract = Flipper::deploy(&amp;env, NoArgs); assert!(!contract.get()); contract.flip(); assert!(contract.get()); } }  ","version":"2.2.0","tagName":"h2"},{"title":"Testing​","type":1,"pageTitle":"Flipper example","url":"/docs/2.2.0/getting-started/flipper#testing","content":"To run the tests, execute the following command: cargo odra test # or add the `-b casper` flag to run tests on the CasperVM  ","version":"2.2.0","tagName":"h2"},{"title":"What's next​","type":1,"pageTitle":"Flipper example","url":"/docs/2.2.0/getting-started/flipper#whats-next","content":"In the next category of articles, we will go through basic concepts of Odra. ","version":"2.2.0","tagName":"h2"},{"title":"Odra for Solidity developers","type":0,"sectionRef":"#","url":"/docs/2.1.0/tutorials/odra-solidity","content":"","keywords":"","version":"2.1.0"},{"title":"Introduction​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.1.0/tutorials/odra-solidity#introduction","content":"Hi, stranger Solidity developer! If you are looking to expand your horizons into Rust-based smart contract development, you've come to the right place. Odra is a high-level framework designed to simplify the development of smart contracts for the Casper Network. This tutorial will guide you through the basics of transitioning from Solidity to Odra, highlighting key differences and providing practical examples. Before we delve into the details, we have great news for you. From the very beginning, we have been thinking of you. Our main goal was to design the framework in a way that flattens the learning curve, especially for Solidity developers. ","version":"2.1.0","tagName":"h2"},{"title":"Prerequisites​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.1.0/tutorials/odra-solidity#prerequisites","content":"To follow this guide, you should have: Knowledge of Solidity.Familiarity with Ethereum and smart contract concepts.Basic understanding of Rust, as Odra is based on it. ","version":"2.1.0","tagName":"h2"},{"title":"Hello World​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.1.0/tutorials/odra-solidity#hello-world","content":"Let's start with a simple &quot;Hello World&quot; contract in Odra. The following code snippet demonstrates a basic smart contract that stores a greeting message. OdraSolidity use odra::prelude::*; #[odra::module] pub struct HelloWorld { greet: Var&lt;String&gt;, } #[odra::module] impl HelloWorld { pub fn init(&amp;mut self, message: String) { self.greet.set(message); } pub fn get(&amp;self) -&gt; String { self.greet.get_or_default() } }  As you may have noticed, the Odra code is slightly more verbose than the Solidity code. To define a contract in Odra, you need to create a struct and implement a module for it, both annotated with the odra::module attribute. The struct contains the contract's state variables, while the module defines the contract's functions. In this example, the HelloWorld struct has a single state variable greet, which stores the greeting message. The module contains two functions: init to set the greeting message and get to retrieve it. Two key differences are: Odra does not generate getters for public state variables automatically, so you need to define them explicitly.To initialize values, you must do it in the init function, which is the contract constructor. You can't assign defaults outside the constructor. ","version":"2.1.0","tagName":"h2"},{"title":"Variable Storage and State Management​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.1.0/tutorials/odra-solidity#variable-storage-and-state-management","content":"","version":"2.1.0","tagName":"h2"},{"title":"Data Types​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.1.0/tutorials/odra-solidity#data-types","content":"OdraSolidity use core::str::FromStr; use odra::{casper_types::{bytesrepr::Bytes, U256}, prelude::*}; #[odra::module] pub struct Primitives { boo: Var&lt;bool&gt;, u: Var&lt;u8&gt;, // u8 is the smallest unsigned integer type u2: Var&lt;U256&gt;, // U256 is the biggest unsigned integer type i: Var&lt;i32&gt;, // i32 is the smallest signed integer type i2: Var&lt;i64&gt;, // i64 is the biggest signed integer type address: Var&lt;Address&gt;, bytes: Var&lt;Bytes&gt;, default_boo: Var&lt;bool&gt;, default_uint: Var&lt;U256&gt;, default_int: Var&lt;i64&gt;, default_addr: Var&lt;Address&gt;, } #[odra::module] impl Primitives { pub fn init(&amp;mut self) { self.boo.set(true); self.u.set(1); self.u2.set(U256::from(456)); self.i.set(-1); self.i2.set(456); self.address.set( Address::from_str( &quot;hash-d4b8fa492d55ac7a515c0c6043d72ba43c49cd120e7ba7eec8c0a330dedab3fb&quot;, ) .unwrap_or_revert(&amp;self.env()), ); self.bytes.set(Bytes::from(vec![0xb5])); let _min_int = U256::zero(); let _max_int = U256::MAX; } // For the types that have default values, we can use the get_or_default method pub fn get_default_boo(&amp;self) -&gt; bool { self.default_boo.get_or_default() } pub fn get_default_uint(&amp;self) -&gt; U256 { self.default_uint.get_or_default() } pub fn get_default_int(&amp;self) -&gt; i64 { self.default_int.get_or_default() } // Does not compile - Address does not have the default value pub fn get_default_addr(&amp;self) -&gt; Address { self.default_addr.get_or_default() } }  The range of integer types in Odra is slightly different from Solidity. Odra provides a wide range of integer types: u8, u16, u32, u64, U128, and U256 for unsigned integers, and i32 and i64 for signed integers. The Address type in Odra is used to represent account and contract addresses. In Odra, there is no default/zero value for the Address type; the workaround is to use Option&lt;Address&gt;. The Bytes type is used to store byte arrays. Values are stored in units called Named Keys and Dictionaries. Additionally, local variables are available within the entry points and can be used to perform necessary actions or computations within the scope of each entry point. ","version":"2.1.0","tagName":"h3"},{"title":"Constants and Immutability​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.1.0/tutorials/odra-solidity#constants-and-immutability","content":"OdraSolidity use odra::{casper_types::{account::AccountHash, U256}, prelude::*}; #[odra::module] pub struct Constants; #[odra::module] impl Constants { pub const MY_UINT: U256 = U256([123, 0, 0, 0]); pub const MY_ADDRESS: Address = Address::Account( AccountHash([0u8; 32]) ); }  In Odra, you can define constants using the const keyword. Constants are immutable and can be of any type, including custom types. In addition to constants, Solidity also supports the immutable keyword, which is used to set the value of a variable once, in the constructor. Further attempts to alter this value result in a compile error. Odra/Rust does not have an equivalent to Solidity's immutable keyword. ","version":"2.1.0","tagName":"h3"},{"title":"Variables​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.1.0/tutorials/odra-solidity#variables","content":"OdraSolidity use odra::{casper_types::U256, prelude::*}; #[odra::module] pub struct Variables { text: Var&lt;String&gt;, my_uint: Var&lt;U256&gt;, } #[odra::module] impl Variables { pub fn init(&amp;mut self) { self.text.set(&quot;Hello&quot;.to_string()); self.my_uint.set(U256::from(123)); } pub fn do_something(&amp;self) { // Local variables let i = 456; // Env variables let timestamp = self.env().get_block_time(); let sender = self.env().caller(); } }  In Solidity there are three types of variables: state variables, local variables, and global variables. State variables are stored on the blockchain and are accessible by all functions within the contract. Local variables are not stored on the blockchain and are only available within the function in which they are declared. Global variables provide information about the blockchain. Odra uses very similar concepts, but with some differences. In Odra, state variables are a part of a module definition, and local variables are available within the entry points and can be used to perform necessary actions or computations within the scope of each entry point. Global variables are accessed using an instance of ContractEnv retrieved using the env() function. ","version":"2.1.0","tagName":"h3"},{"title":"Arrays and Mappings​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.1.0/tutorials/odra-solidity#arrays-and-mappings","content":"OdraSolidity use odra::{casper_types::U256, prelude::*}; #[odra::module] pub struct MappingContract { my_map: Mapping&lt;Address, Option&lt;U256&gt;&gt; } #[odra::module] impl MappingContract { pub fn get(&amp;self, addr: Address) -&gt; U256 { // self.my_map.get(&amp;addr) would return Option&lt;Option&lt;U256&gt;&gt; // so we use get_or_default instead and unwrap the inner Option self.my_map.get_or_default(&amp;addr).unwrap_or_default() } pub fn set(&amp;mut self, addr: Address, i: U256) { self.my_map.set(&amp;addr, Some(i)); } pub fn remove(&amp;mut self, addr: Address) { self.my_map.set(&amp;addr, None); } } #[odra::module] pub struct NestedMapping { my_map: Mapping&lt;(Address, U256), Option&lt;bool&gt;&gt; } #[odra::module] impl NestedMapping { pub fn get(&amp;self, addr: Address, i: U256) -&gt; bool { self.my_map.get_or_default(&amp;(addr, i)).unwrap_or_default() } pub fn set(&amp;mut self, addr: Address, i: U256, boo: bool) { self.my_map.set(&amp;(addr, i), Some(boo)); } pub fn remove(&amp;mut self, addr: Address, i: U256) { self.my_map.set(&amp;(addr, i), None); } }  OdraSolidity use odra::prelude::*; #[odra::module] pub struct Array { // the size of the array must be known at compile time arr: Var&lt;[u8; 10]&gt;, vec: Var&lt;Vec&lt;u32&gt;&gt;, } #[odra::module] impl Array { pub fn init(&amp;mut self) { self.arr.set([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]); self.vec.set(vec![1, 2, 3, 4, 5]); } pub fn get_arr(&amp;self) -&gt; [u8; 10] { self.arr.get_or_default() } pub fn push_vec(&amp;mut self, value: u32) { let mut vec = self.vec.get_or_default(); vec.push(value); self.vec.set(vec); } pub fn pop_vec(&amp;mut self) { let mut vec = self.vec.get_or_default(); vec.pop(); self.vec.set(vec); } pub fn update_arr(&amp;mut self, index: u8, value: u8) { let mut arr = self.arr.get_or_default(); arr[index as usize] = value; self.arr.set(arr); } }  For storing a collection of data as a single unit, Odra uses the Vec type for dynamic arrays and fixed-size arrays, both wrapped with the Var container. As in Solidity, you must be aware that reading the entire array in one go can be expensive, so it's better to avoid it for large arrays. In many cases, you can use a Mapping or List instead of an array or vector to store data. ","version":"2.1.0","tagName":"h3"},{"title":"Custom types​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.1.0/tutorials/odra-solidity#custom-types","content":"OdraSolidity use odra::prelude::*; #[odra::odra_type] #[derive(Default)] pub enum Status { #[default] Pending, Shipped, Accepted, Rejected, Canceled, } #[odra::module] pub struct Enum { status: Var&lt;Status&gt;, } #[odra::module] impl Enum { pub fn get(&amp;self) -&gt; Status { self.status.get_or_default() } pub fn set(&amp;mut self, status: Status) { self.status.set(status); } pub fn cancel(&amp;mut self) { self.status.set(Status::Canceled); } pub fn reset(&amp;mut self) { self.status.set(Default::default()); } }  In Odra, custom types are defined using the #[odra::odra_type] attribute. The enum can have a default value specified using the #[default] attribute if derived from the Default trait. The enum can be used as a state variable in a contract, and its value can be set and retrieved using the set and get functions. The value cannot be deleted; however, it can be set using the Default::default() function. OdraSolidity use odra::prelude::*; #[odra::odra_type] pub struct Todo { text: String, completed: bool, } #[odra::module] pub struct Enum { // You could also use Var&lt;Vec&lt;Todo&gt;&gt; instead of List&lt;Todo&gt;, // but List is more efficient for large arrays, // it loads items lazily. todos: List&lt;Todo&gt;, } #[odra::module] impl Enum { pub fn create(&amp;mut self, text: String) { self.todos.push(Todo { text, completed: false, }); } pub fn update_text(&amp;mut self, index: u32, text: String) { if let Some(mut todo) = self.todos.get(index) { todo.text = text; self.todos.replace(index, todo); } } pub fn toggle_complete(&amp;mut self, index: u32) { if let Some(mut todo) = self.todos.get(index) { todo.completed = !todo.completed; self.todos.replace(index, todo); } } // Odra does not create getters by default pub fn get(&amp;self, index: u32) -&gt; Option&lt;Todo&gt; { self.todos.get(index) } }  Similarly to enums, custom structs are defined using the #[odra::odra_type] attribute. The struct can be used to define a list of items in a contract. The list can be created using the List type, which is more efficient for large arrays as it loads items lazily. ","version":"2.1.0","tagName":"h3"},{"title":"Data Location​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.1.0/tutorials/odra-solidity#data-location","content":"In Solidity, data location is an important concept that determines where the data is stored and how it can be accessed. The data location can be memory, storage, or calldata. In Odra, data location is not explicitly defined, but whenever interacting with storage primitives (e.g., Var, Mapping, List), the data is stored in the contract's storage. ","version":"2.1.0","tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.1.0/tutorials/odra-solidity#functions","content":"Odra contracts define their entry point and internal functions within the impl block. Here's an example of a transfer function: impl Erc20 { pub fn transfer(&amp;mut self, recipient: &amp;Address, amount: &amp;U256) { self.internal_transfer(&amp;self.env().caller(), recipient, amount); // Transfer logic goes here } fn internal_transfer(&amp;mut self, sender: &amp;Address, recipient: &amp;Address, amount: &amp;U256) { // Internal transfer logic goes here } }  Functions can modify contract state and emit events using the ContractEnv function. ","version":"2.1.0","tagName":"h2"},{"title":"View and Pure​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.1.0/tutorials/odra-solidity#view-and-pure","content":"OdraSolidity use odra::prelude::*; #[odra::module] pub struct ViewAndPure { x: Var&lt;u32&gt; } #[odra::module] impl ViewAndPure { pub fn add_to_x(&amp;self, y: u32) -&gt; u32 { self.x.get_or_default() + y } } pub fn add(i: u32, j: u32) -&gt; u32 { i + j }  In Odra, you don't need to specify view or pure functions explicitly. All functions are considered view functions by default, meaning they can read contract state but not modify it. To modify the state, the first parameter (called the receiver parameter) should be &amp;mut self. If you want to create a pure function that doesn't read or modify state, you can define it as a regular Rust function without any side effects. ","version":"2.1.0","tagName":"h3"},{"title":"Modifiers​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.1.0/tutorials/odra-solidity#modifiers","content":"OdraSolidity use odra::prelude::*; #[odra::module] pub struct FunctionModifier { x: Var&lt;u32&gt;, locked: Var&lt;bool&gt;, } #[odra::module] impl FunctionModifier { pub fn decrement(&amp;mut self, i: u32) { self.lock(); self.x.set(self.x.get_or_default() - i); if i &gt; 1 { self.decrement(i - 1); } self.unlock(); } #[inline] fn lock(&amp;mut self) { if self.locked.get_or_default() { self.env().revert(Error::NoReentrancy); } self.locked.set(true); } #[inline] fn unlock(&amp;mut self) { self.locked.set(false); } } #[odra::odra_error] pub enum Error { NoReentrancy = 1, }  In Odra, there is no direct equivalent to Solidity's function modifiers. Instead, you can define functions that perform certain actions before or after the main function logic. In the example above, the lock and unlock functions are called before and after the decrement function, respectively, but they must be called explicitly. As often as practicable, developers should inline functions by including the body of the function within their code using the #[inline] attribute. In the context of coding for Casper blockchain purposes, this reduces the overhead of executed Wasm and prevents unexpected errors due to exceeding resource tolerances. ","version":"2.1.0","tagName":"h3"},{"title":"Visibility​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.1.0/tutorials/odra-solidity#visibility","content":"Functions and state variables have to declare whether they are accessible by other contracts. Functions can be declared as: OdraSolidity `pub` inside `#[odra::module]` impl block - any contract/submodule and account can call. `pub` inside a regular impl block - any submodule can call. `default/no modifier/private` - only inside the contract that defines the function.  ","version":"2.1.0","tagName":"h3"},{"title":"Payable​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.1.0/tutorials/odra-solidity#payable","content":"OdraSolidity use odra::{casper_types::U512, prelude::*}; #[odra::module] pub struct Payable { owner: Var&lt;Address&gt;, } #[odra::module] impl Payable { pub fn init(&amp;mut self) { self.owner.set(self.env().caller()); } #[odra(payable)] pub fn deposit(&amp;self) { } pub fn not_payable(&amp;self) { } pub fn withdraw(&amp;self) { let amount = self.env().self_balance(); self.env().transfer_tokens(&amp;self.owner.get_or_revert_with(ExecutionError::UnwrapError), &amp;amount); } pub fn transfer(&amp;self, to: Address, amount: U512) { self.env().transfer_tokens(&amp;to, &amp;amount); } }  In Odra, you can define a function with the #[odra(payable)] attribute to indicate that the function can receive CSPRs. In Solidity, the payable keyword is used to define functions that can receive Ether. ","version":"2.1.0","tagName":"h3"},{"title":"Selectors​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.1.0/tutorials/odra-solidity#selectors","content":"In Solidity, when a function is called, the first 4 bytes of calldata specify which function to call. This is called a function selector. contract_addr.call( abi.encodeWithSignature(&quot;transfer(address,uint256)&quot;, address, 1234) )  Odra does not support such a mechanism. You must have access to the contract interface to call a function. ","version":"2.1.0","tagName":"h3"},{"title":"Events and Logging​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.1.0/tutorials/odra-solidity#events-and-logging","content":"OdraSolidity use odra::prelude::*; #[odra::event] pub struct Log { sender: Address, message: String, } #[odra::event] pub struct AnotherLog {} #[odra::module] struct Event; #[odra::module] impl Event { pub fn test(&amp;self) { let env = self.env(); env.emit_event(Log { sender: env.caller(), message: &quot;Hello World!&quot;.to_string(), }); env.emit_event(Log { sender: env.caller(), message: &quot;Hello Casper!&quot;.to_string(), }); env.emit_event(AnotherLog {}); } }  In Odra, events are regular structs defined using the #[odra::event] attribute. The event struct can contain multiple fields, which can be of any type (primitive or custom Odra type). To emit an event, use the env's emit_event() function, passing the event struct as an argument. note Events in Solidity are used to emit logs that off-chain services can capture. However, Casper does not support events natively. Odra mimics this feature. Read more about it in the Basics section. ","version":"2.1.0","tagName":"h2"},{"title":"Error Handling​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.1.0/tutorials/odra-solidity#error-handling","content":"OdraSolidity use odra::{prelude::*, casper_types::{U256, U512}}; #[odra::odra_error] pub enum CustomError { InsufficientBalance = 1, InputLowerThanTen = 2, } #[odra::module] pub struct Error; #[odra::module] impl Error { pub fn test_require(&amp;mut self, i: U256) { if i &lt;= 10.into() { self.env().revert(CustomError::InputLowerThanTen); } } pub fn execute_external_call(&amp;self, withdraw_amount: U512) { let balance = self.env().self_balance(); if balance &lt; withdraw_amount { self.env().revert(CustomError::InsufficientBalance); } } }  In Solidity, there are four ways to handle errors: require, revert, assert, and custom errors. In Odra, there is only one way to revert the execution of a function - by using the env().revert() function. The function takes an error type as an argument and stops the execution of the function. You define an error type using the #[odra::odra_error] attribute. On Casper, an error is only a number, so you can't pass a message with the error. ","version":"2.1.0","tagName":"h2"},{"title":"Composition vs. Inheritance​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.1.0/tutorials/odra-solidity#composition-vs-inheritance","content":"In Solidity, developers often use inheritance to reuse code and establish relationships between contracts. However, Odra and Rust follow a different paradigm known as composition. Instead of inheriting behavior from parent contracts, Odra encourages the composition of contracts by embedding one contract within another. Let's take a look at the difference between inheritance in Solidity and composition in Odra. OdraSolidity use odra::prelude::*; #[odra::module] pub struct A; #[odra::module] impl A { pub fn foo(&amp;self) -&gt; String { &quot;A&quot;.to_string() } } #[odra::module] pub struct B { a: SubModule&lt;A&gt; } #[odra::module] impl B { pub fn foo(&amp;self) -&gt; String { &quot;B&quot;.to_string() } } #[odra::module] pub struct C { a: SubModule&lt;A&gt; } #[odra::module] impl C { pub fn foo(&amp;self) -&gt; String { &quot;C&quot;.to_string() } } #[odra::module] pub struct D { b: SubModule&lt;B&gt;, c: SubModule&lt;C&gt; } #[odra::module] impl D { pub fn foo(&amp;self) -&gt; String { self.c.foo() } } #[odra::module] pub struct E { b: SubModule&lt;B&gt;, c: SubModule&lt;C&gt; } #[odra::module] impl E { pub fn foo(&amp;self) -&gt; String { self.b.foo() } } #[odra::module] pub struct F { a: SubModule&lt;A&gt;, b: SubModule&lt;B&gt;, } #[odra::module] impl F { pub fn foo(&amp;self) -&gt; String { self.a.foo() } }  Solidity supports both single and multiple inheritance. This means a contract can inherit from one or more contracts. Solidity uses a technique called &quot;C3 linearization&quot; to resolve the order in which base contracts are inherited in the case of multiple inheritance. This helps to ensure a consistent method resolution order. However, multiple inheritance can lead to complex code and potential issues, especially for inexperienced developers. In contrast, Rust does not have a direct equivalent to the inheritance model, but it achieves similar goals through composition. Each contract is defined as a struct, and contracts can be composed by embedding one struct within another. This approach provides a more flexible and modular way to reuse code and establish relationships between contracts. ","version":"2.1.0","tagName":"h2"},{"title":"Libraries and Utility​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.1.0/tutorials/odra-solidity#libraries-and-utility","content":"OdraSolidity use odra::{casper_types::U256, prelude::*}; mod math { use odra::casper_types::U256; pub fn sqrt(y: U256) -&gt; U256 { let mut z = y; if y &gt; 3.into() { let mut x = y / 2 + 1; while x &lt; z { z = x; x = (y / x + x) / 2; } } else if y != U256::zero() { z = U256::one(); } z } } #[odra::module] struct TestMath; #[odra::module] impl TestMath { pub fn test_square_root(&amp;self, x: U256) -&gt; U256 { math::sqrt(x) } } #[odra::odra_error] enum Error { EmptyArray = 100, } trait Removable { fn remove(&amp;mut self, index: usize); } impl Removable for Var&lt;Vec&lt;U256&gt;&gt; { fn remove(&amp;mut self, index: usize) { let env = self.env(); let mut vec = self.get_or_default(); if vec.is_empty() { env.revert(Error::EmptyArray); } vec[index] = vec.pop().unwrap_or_revert(&amp;env); self.set(vec); } } #[odra::module] struct TestArray { arr: Var&lt;Vec&lt;U256&gt;&gt;, } #[odra::module] impl TestArray { pub fn test_array_remove(&amp;mut self) { let mut arr = self.arr.get_or_default(); for i in 0..3 { arr.push(i.into()); } self.arr.set(arr); self.arr.remove(1); let arr = self.arr.get_or_default(); assert_eq!(arr.len(), 2); assert_eq!(arr[0], 0.into()); assert_eq!(arr[1], 2.into()); } }  In Solidity, libraries are similar to contracts but can't declare any state variables and can't receive Ether. In the sample code above, the Math library contains a square root function, while the Array library provides a function to remove an element from an array. Both libraries are consumed in different ways: the TestMath contract calls the sqrt function directly, while the TestArray contract uses the using keyword, which extends the type uint256[] by adding the remove function. In Odra, you use language-level features: modules and traits. The mod keyword defines a module, which is similar to a library in Solidity. Modules can contain functions, types, and other items that can be reused across multiple contracts. Traits are similar to interfaces in other programming languages, defining a set of functions that a type must implement. Implementing the Removable trait for the Var&lt;Vec&lt;U256&gt;&gt; type allows the remove function to be called on a variable that stores a vector of U256 values. ","version":"2.1.0","tagName":"h2"},{"title":"Fallback and Receive Functions​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.1.0/tutorials/odra-solidity#fallback-and-receive-functions","content":"In Solidity, a contract receiving Ether must implement a receive() and/or fallback() function. The receive() function is called when Ether is sent to the contract with no data, while the fallback() function is called when the contract receives Ether with data or when a function that does not exist is called. Odra does not have a direct equivalent to the receive() and fallback() functions. Instead, you can define a function with the #[odra(payable)] attribute to indicate that the function can receive CSPRs. ","version":"2.1.0","tagName":"h2"},{"title":"Miscellaneous​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.1.0/tutorials/odra-solidity#miscellaneous","content":"","version":"2.1.0","tagName":"h2"},{"title":"Hashing​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.1.0/tutorials/odra-solidity#hashing","content":"OdraSolidity use odra::{casper_types::{bytesrepr::ToBytes, U256}, prelude::*}; #[odra::module] pub struct HashFunction; #[odra::module] impl HashFunction { pub fn hash(&amp;self, text: String, num: U256, addr: Address) -&gt; [u8; 32] { let env = self.env(); let mut data = Vec::new(); data.extend(text.to_bytes().unwrap_or_revert(&amp;env)); data.extend(num.to_bytes().unwrap_or_revert(&amp;env)); data.extend(addr.to_bytes().unwrap_or_revert(&amp;env)); env.hash(data) } } #[odra::module] pub struct GuessTheMagicWord { answer: Var&lt;[u8; 32]&gt;, } #[odra::module] impl GuessTheMagicWord { /// Initializes the contract with the magic word hash. pub fn init(&amp;mut self) { self.answer.set([ 0x86, 0x67, 0x15, 0xbb, 0x0b, 0x96, 0xf1, 0x06, 0xe0, 0x68, 0x07, 0x89, 0x22, 0x84, 0x42, 0x81, 0x19, 0x6b, 0x1e, 0x61, 0x45, 0x50, 0xa5, 0x70, 0x4a, 0xb0, 0xa7, 0x55, 0xbe, 0xd7, 0x56, 0x08, ]); } /// Checks if the `word` is the magic word. pub fn guess(&amp;self, word: String) -&gt; bool { let env = self.env(); let hash = env.hash(word.to_bytes().unwrap_or_revert(&amp;env)); hash == self.answer.get_or_default() } }  The key difference between the two is that in Solidity, the keccak256 function is used to hash data, while in Odra, the env.hash() function is used, which implements the blake2b algorithm. Both functions take a byte array as input and return a 32-byte hash. ","version":"2.1.0","tagName":"h3"},{"title":"Try-catch​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.1.0/tutorials/odra-solidity#try-catch","content":"OdraSolidity use odra::prelude::*; #[odra::module] pub struct Example { other_contract: External&lt;OtherContractContractRef&gt;, } #[odra::module] impl Example { pub fn init(&amp;mut self, other_contract: Address) { self.other_contract.set(other_contract); } pub fn execute_external_call(&amp;self) { let result = self.other_contract.some_function(); match result { Ok(success) =&gt; { // Code to execute if the external call was successful } Err(reason) =&gt; { // Code to execute if the external call failed } } } } #[odra::module] pub struct OtherContract; #[odra::module] impl OtherContract { pub fn some_function(&amp;self) -&gt; Result&lt;bool, ()&gt; { Ok(true) } }  In Solidity, try/catch is a feature that allows developers to handle exceptions and errors more gracefully. The try/catch statement allows developers to catch and handle exceptions that occur during external function calls and contract creation. In Odra, there is no direct equivalent to the try/catch statement in Solidity. However, you can use the Result type to handle errors in a similar way. The Result type is an enum that represents either success (Ok) or failure (Err). You can use the match statement to handle the Result type and execute different code based on the result. However, if an unexpected error occurs on the way, the whole transaction reverts. ","version":"2.1.0","tagName":"h3"},{"title":"Conclusion​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.1.0/tutorials/odra-solidity#conclusion","content":"Congratulations! You've now learned the main differences in writing smart contracts with the Odra Framework. By understanding the structure, initialization, error handling, and the composition pattern in Odra, you can effectively transition from Solidity to Odra for Casper blockchain development. Experiment with the provided code samples, explore more advanced features, and unleash the full potential of the Odra Framework. Read more about the Odra Framework in the Basics and Advanced sections. Learn by example with our Tutorial series, you will find there a contract you likely familiar with - the Erc20 standard implementation. If you have any further questions or need clarification on specific topics, feel free to join our Discord! ","version":"2.1.0","tagName":"h2"},{"title":"Migration guide to v1.3.0","type":0,"sectionRef":"#","url":"/docs/2.2.0/migrations/to-1.3.0","content":"","keywords":"","version":"2.2.0"},{"title":"Migrating to Odra v1.3.0​","type":1,"pageTitle":"Migration guide to v1.3.0","url":"/docs/2.2.0/migrations/to-1.3.0#migrating-to-odra-v130","content":"To migrate your smart contracts to Odra v1.3.0, remove the use the deploy method from the module instead of the {{ModuleName}}HostRef struct: before.rs let token = TokenHostRef::deploy(env, init_args); let another_token = AnotherTokenHostRef::load(env, address);  after.rs let token = Token::deploy(env, init_args); let another_token = AnotherToken::load(env, address);  ","version":"2.2.0","tagName":"h2"},{"title":"Migration guide to v2.0.0 from 1.*","type":0,"sectionRef":"#","url":"/docs/2.2.0/migrations/to-2.0.0","content":"","keywords":"","version":"2.2.0"},{"title":"Updating rustc version​","type":1,"pageTitle":"Migration guide to v2.0.0 from 1.*","url":"/docs/2.2.0/migrations/to-2.0.0#updating-rustc-version","content":"Update rust-toolchain file in your project: nightly-2024-07-31  ","version":"2.2.0","tagName":"h2"},{"title":"Migration guide to v2.1.0 from 2.0.*","type":0,"sectionRef":"#","url":"/docs/2.2.0/migrations/to-2.1.0","content":"","keywords":"","version":"2.2.0"},{"title":"Updating the test code​","type":1,"pageTitle":"Migration guide to v2.1.0 from 2.0.*","url":"/docs/2.2.0/migrations/to-2.1.0#updating-the-test-code","content":"Function that required an event reference as an argument has been changed to accept an event type instead. before.rs assert!(test_env.emitted_event( &amp;party_contract, &amp;PartyStarted { caller: test_env.get_account(0), block_time: 0 } ));  after.rs assert!(test_env.emitted_event( &amp;party_contract, PartyStarted { caller: test_env.get_account(0), block_time: 0 } ));  In the previous version, the HostRef and Addressable traits both included a function called address, which may have caused confusion and led to exporting the address function from the wrong trait. In the updated version, address is now defined only in the Addressable trait, while the HostRef trait provides a separate function called contract_address instead. ","version":"2.2.0","tagName":"h2"},{"title":"Access Control","type":0,"sectionRef":"#","url":"/docs/2.2.0/tutorials/access-control","content":"","keywords":"","version":"2.2.0"},{"title":"Code​","type":1,"pageTitle":"Access Control","url":"/docs/2.2.0/tutorials/access-control#code","content":"Before we start writing code, we list the functionalities of our access control layer. A Role type is used across the module.A Role can be assigned to many Addresses.Each Role may have a corresponding admin role.Only an admin can grant/revoke a Role.A Role can be renounced.A Role cannot be renounced on someone's behalf.Each action triggers an event.Unauthorized access stops contract execution. ","version":"2.2.0","tagName":"h2"},{"title":"Project Structure​","type":1,"pageTitle":"Access Control","url":"/docs/2.2.0/tutorials/access-control#project-structure","content":"access-control ├── src │ ├── access │ │ ├── access_control.rs │ │ ├── events.rs │ │ └── errors.rs │ └── lib.rs |── build.rs |── Cargo.toml └── Odra.toml  ","version":"2.2.0","tagName":"h3"},{"title":"Events and Errors​","type":1,"pageTitle":"Access Control","url":"/docs/2.2.0/tutorials/access-control#events-and-errors","content":"There are three actions that can be performed concerning a Role: granting, revoking, and altering the admin role. Let us establish standard Odra events for each of these actions. events.rs use odra::prelude::*; use super::access_control::Role; #[odra::event] pub struct RoleGranted { pub role: Role, pub address: Address, pub sender: Address } #[odra::event] pub struct RoleRevoked { pub role: Role, pub address: Address, pub sender: Address } #[odra::event] pub struct RoleAdminChanged { pub role: Role, pub previous_admin_role: Role, pub new_admin_role: Role }  L4-L16 - to describe the grant or revoke actions, our events specify the Role, and Addresses indicating who receives or loses access and who provides or withdraws it.L18-L23 - the event describing the admin role change, requires the subject Role, the previous and the current admin Role. errors.rs #[odra::odra_error] pub enum Error { MissingRole = 20_000, RoleRenounceForAnotherAddress = 20_001, }  Errors definition is straightforward - there are only two invalid states: An action is triggered by an unauthorized actor.The caller is attempting to resign the Role on someone's behalf.  ","version":"2.2.0","tagName":"h3"},{"title":"Module​","type":1,"pageTitle":"Access Control","url":"/docs/2.2.0/tutorials/access-control#module","content":"Now, we are stepping into the most interesting part: the module definition and implementation. access_control.rs use super::events::*; use super::errors::Error; use odra::prelude::*; pub type Role = [u8; 32]; pub const DEFAULT_ADMIN_ROLE: Role = [0u8; 32]; #[odra::module(events = [RoleAdminChanged, RoleGranted, RoleRevoked], errors = Error)] pub struct AccessControl { roles: Mapping&lt;(Role, Address), bool&gt;, role_admin: Mapping&lt;Role, Role&gt; } #[odra::module] impl AccessControl { pub fn has_role(&amp;self, role: &amp;Role, address: &amp;Address) -&gt; bool { self.roles.get_or_default(&amp;(*role, *address)) } pub fn get_role_admin(&amp;self, role: &amp;Role) -&gt; Role { let admin_role = self.role_admin.get(role); if let Some(admin) = admin_role { admin } else { DEFAULT_ADMIN_ROLE } } pub fn grant_role(&amp;mut self, role: &amp;Role, address: &amp;Address) { self.check_role(&amp;self.get_role_admin(role), &amp;self.env().caller()); self.unchecked_grant_role(role, address); } pub fn revoke_role(&amp;mut self, role: &amp;Role, address: &amp;Address) { self.check_role(&amp;self.get_role_admin(role), &amp;self.env().caller()); self.unchecked_revoke_role(role, address); } pub fn renounce_role(&amp;mut self, role: &amp;Role, address: &amp;Address) { if address != &amp;self.env().caller() { self.env().revert(Error::RoleRenounceForAnotherAddress); } self.unchecked_revoke_role(role, address); } } impl AccessControl { pub fn check_role(&amp;self, role: &amp;Role, address: &amp;Address) { if !self.has_role(role, address) { self.env().revert(Error::MissingRole); } } pub fn set_admin_role(&amp;mut self, role: &amp;Role, admin_role: &amp;Role) { let previous_admin_role = self.get_role_admin(role); self.role_admin.set(role, *admin_role); self.env().emit_event(RoleAdminChanged { role: *role, previous_admin_role, new_admin_role: *admin_role }); } pub fn unchecked_grant_role(&amp;mut self, role: &amp;Role, address: &amp;Address) { if !self.has_role(role, address) { self.roles.set(&amp;(*role, *address), true); self.env().emit_event(RoleGranted { role: *role, address: *address, sender: self.env().caller() }); } } pub fn unchecked_revoke_role(&amp;mut self, role: &amp;Role, address: &amp;Address) { if self.has_role(role, address) { self.roles.set(&amp;(*role, *address), false); self.env().emit_event(RoleRevoked { role: *role, address: *address, sender: self.env().caller() }); } } }  L5 - Firstly, we need the Role type. It is simply an alias for a 32-byte array.L7 - The default role is an array filled with zeros.L10-L13 - The storage consists of two mappings: roles - a nested mapping that stores information about whether a certain Role is granted to a given Address.role_admin - each Role can have a single admin Role. L17-L19 - This is a simple check to determine if a Role has been granted to a given Address. It is an exposed entry point and an important building block widely used throughout the entire module.L48 - This is a non-exported block containing helper functions.L49-L53 - The check_role() function serves as a guard function. Before a Role is granted or revoked, we must ensure that the caller is allowed to do so. For this purpose, the function reads the roles mapping. If the role has not been granted to the address, the contract reverts with Error::MissingRole.L55-L63 - The set_admin_role() function simply updates the role_admin mapping and emits the RoleAdminChanged event.L65-L85 - The unchecked_grant_role() and unchecked_revoke_role() functions are mirror functions that update the roles mapping and post RoleGranted or RoleRevoked events. If the role is already granted, unchecked_grant_role() has no effect (the opposite check is made in the case of revoking a role).L21-L28 - The get_role_admin() entry point reads the role_admin. If there is no admin role for a given role, it returns the default role.L30-L45 - This is a combination of check_role() and unchecked_*_role(). Entry points fail on unauthorized access. ","version":"2.2.0","tagName":"h3"},{"title":"Migration guide to v0.9.0","type":0,"sectionRef":"#","url":"/docs/2.2.0/migrations/to-0.9.0","content":"","keywords":"","version":"2.2.0"},{"title":"1. Prerequisites​","type":1,"pageTitle":"Migration guide to v0.9.0","url":"/docs/2.2.0/migrations/to-0.9.0#1-prerequisites","content":"","version":"2.2.0","tagName":"h2"},{"title":"1.1. Update cargo-odra​","type":1,"pageTitle":"Migration guide to v0.9.0","url":"/docs/2.2.0/migrations/to-0.9.0#11-update-cargo-odra","content":"Before you begin the migration process, make sure you installed the latest version of the Cargo Odra toolchain. You can install it by running the following command: cargo install cargo-odra --force --locked  ","version":"2.2.0","tagName":"h3"},{"title":"1.2. Review the Changelog​","type":1,"pageTitle":"Migration guide to v0.9.0","url":"/docs/2.2.0/migrations/to-0.9.0#12-review-the-changelog","content":"Before you move to changing your code, start by reviewing the Changelog to understand the changes introduced in v0.9.0. ","version":"2.2.0","tagName":"h3"},{"title":"2. Migration Steps​","type":1,"pageTitle":"Migration guide to v0.9.0","url":"/docs/2.2.0/migrations/to-0.9.0#2-migration-steps","content":"","version":"2.2.0","tagName":"h2"},{"title":"2.1 Update build_schema.rs bin​","type":1,"pageTitle":"Migration guide to v0.9.0","url":"/docs/2.2.0/migrations/to-0.9.0#21-update-build_schemars-bin","content":"Odra 0.9.0 adds a new standardized way of generating contract schema - Casper Contract Schema. You can find the updated build_schema.rs file in templates directory in the Odra main repository. You can choose whatever template you want to use and copy the files to your project. In both files, you should replace {{project-name}} with the name of your project. ","version":"2.2.0","tagName":"h3"},{"title":"2.2 Update smart contract code​","type":1,"pageTitle":"Migration guide to v0.9.0","url":"/docs/2.2.0/migrations/to-0.9.0#22-update-smart-contract-code","content":"The main changes in the smart contract code are related to the way of defining custom types, events and errors. The following sections will guide you through the necessary changes. 2.2.1. Update custom types definitions.​ #[derive(OdraType)] attribute has been replace with #[odra::odra_type] attribute. 0.9.00.8.0 use odra::Address; #[odra::odra_type] pub struct Dog { pub name: String, pub age: u8, pub owner: Option&lt;Address&gt; }  2.2.2. Update errors definitions.​ #[derive(OdraError)] attribute has been replace with #[odra::odra_error] attribute. Error enum should be passed as a parameter to the #[odra::module] attribute. 0.9.00.8.0 #[odra::module(events = [/* events go here */], errors = Error)] pub struct Erc20 { // fields } #[odra::odra_error] pub enum Error { InsufficientBalance = 30_000, InsufficientAllowance = 30_001, NameNotSet = 30_002, SymbolNotSet = 30_003, DecimalsNotSet = 30_004 }  2.2.3. Update events definitions.​ #[derive(Event)] attribute has been replace with #[odra::event] attribute. 0.9.00.8.0 use odra::prelude::*; use odra::{Address, casper_types::U256}; #[odra::event] pub struct Transfer { pub from: Option&lt;Address&gt;, pub to: Option&lt;Address&gt;, pub amount: U256 }  ","version":"2.2.0","tagName":"h3"},{"title":"3. Code Examples​","type":1,"pageTitle":"Migration guide to v0.9.0","url":"/docs/2.2.0/migrations/to-0.9.0#3-code-examples","content":"Here is a complete example of a smart contract after and before the migration to v0.9.0. 0.9.0Prev src/erc20.rs use crate::erc20::errors::Error; use crate::erc20::events::*; use odra::prelude::*; use odra::{casper_types::U256, Address, Mapping, Var}; #[odra::module(events = [Approval, Transfer], errors = Error)] pub struct Erc20 { decimals: Var&lt;u8&gt;, symbol: Var&lt;String&gt;, name: Var&lt;String&gt;, total_supply: Var&lt;U256&gt;, balances: Mapping&lt;Address, U256&gt;, allowances: Mapping&lt;(Address, Address), U256&gt; } #[odra::module] impl Erc20 { pub fn init( &amp;mut self, symbol: String, name: String, decimals: u8, initial_supply: Option&lt;U256&gt; ) { let caller = self.env().caller(); self.symbol.set(symbol); self.name.set(name); self.decimals.set(decimals); if let Some(initial_supply) = initial_supply { self.total_supply.set(initial_supply); self.balances.set(&amp;caller, initial_supply); if !initial_supply.is_zero() { self.env().emit_event(Transfer { from: None, to: Some(caller), amount: initial_supply }); } } } pub fn transfer(&amp;mut self, recipient: &amp;Address, amount: &amp;U256) { let caller = self.env().caller(); self.raw_transfer(&amp;caller, recipient, amount); } pub fn transfer_from(&amp;mut self, owner: &amp;Address, recipient: &amp;Address, amount: &amp;U256) { let spender = self.env().caller(); self.spend_allowance(owner, &amp;spender, amount); self.raw_transfer(owner, recipient, amount); } pub fn approve(&amp;mut self, spender: &amp;Address, amount: &amp;U256) { let owner = self.env().caller(); self.allowances.set(&amp;(owner, *spender), *amount); self.env().emit_event(Approval { owner, spender: *spender, value: *amount }); } pub fn name(&amp;self) -&gt; String { self.name.get_or_revert_with(Error::NameNotSet) } // Other getter functions... pub fn allowance(&amp;self, owner: &amp;Address, spender: &amp;Address) -&gt; U256 { self.allowances.get_or_default(&amp;(*owner, *spender)) } pub fn mint(&amp;mut self, address: &amp;Address, amount: &amp;U256) { self.total_supply.add(*amount); self.balances.add(address, *amount); self.env().emit_event(Transfer { from: None, to: Some(*address), amount: *amount }); } pub fn burn(&amp;mut self, address: &amp;Address, amount: &amp;U256) { if self.balance_of(address) &lt; *amount { self.env().revert(Error::InsufficientBalance); } self.total_supply.subtract(*amount); self.balances.subtract(address, *amount); self.env().emit_event(Transfer { from: Some(*address), to: None, amount: *amount }); } } impl Erc20 { fn raw_transfer(&amp;mut self, owner: &amp;Address, recipient: &amp;Address, amount: &amp;U256) { if *amount &gt; self.balances.get_or_default(owner) { self.env().revert(Error::InsufficientBalance) } self.balances.subtract(owner, *amount); self.balances.add(recipient, *amount); self.env().emit_event(Transfer { from: Some(*owner), to: Some(*recipient), amount: *amount }); } fn spend_allowance(&amp;mut self, owner: &amp;Address, spender: &amp;Address, amount: &amp;U256) { let allowance = self.allowances.get_or_default(&amp;(*owner, *spender)); if allowance &lt; *amount { self.env().revert(Error::InsufficientAllowance) } self.allowances.subtract(&amp;(*owner, *spender), *amount); self.env().emit_event(Approval { owner: *owner, spender: *spender, value: allowance - *amount }); } } pub mod events { use odra::prelude::*; use odra::{casper_types::U256, Address}; #[odra::event] pub struct Transfer { pub from: Option&lt;Address&gt;, pub to: Option&lt;Address&gt;, pub amount: U256 } #[odra::event] pub struct Approval { pub owner: Address, pub spender: Address, pub value: U256 } } pub mod errors { #[odra::odra_error] pub enum Error { InsufficientBalance = 30_000, InsufficientAllowance = 30_001, NameNotSet = 30_002, SymbolNotSet = 30_003, DecimalsNotSet = 30_004 } } #[cfg(test)] mod tests { // nothing changed in the tests }  ","version":"2.2.0","tagName":"h2"},{"title":"4. Troubleshooting​","type":1,"pageTitle":"Migration guide to v0.9.0","url":"/docs/2.2.0/migrations/to-0.9.0#4-troubleshooting","content":"If you encounter any further issues after completing the migration steps, please don't hesitate to reach out to us on Discord or explore the other sections this documentation. You can also refer to the technical documentation for more detailed information. Additionally, our examples repository offers a wide range of examples to assist you in understanding the new features and APIs. Be sure to carefully review any compilation errors and warnings, as they may provide valuable insights into the necessary adjustments. ","version":"2.2.0","tagName":"h2"},{"title":"5. References​","type":1,"pageTitle":"Migration guide to v0.9.0","url":"/docs/2.2.0/migrations/to-0.9.0#5-references","content":"ChangelogOdra DocumentationDocs.rsExamples ","version":"2.2.0","tagName":"h2"},{"title":"Deploying a Token on Casper Livenet","type":0,"sectionRef":"#","url":"/docs/2.2.0/tutorials/deploying-on-casper","content":"","keywords":"","version":"2.2.0"},{"title":"Casper Wallet​","type":1,"pageTitle":"Deploying a Token on Casper Livenet","url":"/docs/2.2.0/tutorials/deploying-on-casper#casper-wallet","content":"We will be using Casper Wallet to do some tasks in this tutorial. To install it, please follow the instructions on the official website. After setting up the wallet, extract the private key of the account you want to use for our testing. You can do this by clicking on the Menu &gt; Download account keys. danger You are solely responsible for the security of your private keys. We recommend creating a new account for the testing purposes. Why do we need the private key? We will use it in Odra to deploy our contract to the Casper network using Livenet backend. ","version":"2.2.0","tagName":"h2"},{"title":"Getting tokens​","type":1,"pageTitle":"Deploying a Token on Casper Livenet","url":"/docs/2.2.0/tutorials/deploying-on-casper#getting-tokens","content":"To deploy the contract on the Livenet, we need to have some CSPR. The easiest way to get them is to use the faucet, which will send us 1000 CSPR for free. Unfortunately, only on the Testnet. To use the faucet, go to the Casper Testnet Faucet. Log in using your Casper Wallet account and click on the &quot;Request Tokens&quot; button. note One account can request tokens only once. If you run out of tokens, you can either ask someone in the Casper community to send you some, or simply create a new account in the wallet. Now, when we have the tokens, we can deploy the contract. Let's do it using Odra! ","version":"2.2.0","tagName":"h2"},{"title":"Odra Livenet​","type":1,"pageTitle":"Deploying a Token on Casper Livenet","url":"/docs/2.2.0/tutorials/deploying-on-casper#odra-livenet","content":"Odra Livenet is described in detail in thebackends section of this documentation. We will then briefly describe how to use set it up in this tutorial. In your contract code, create a new file in the bin folder: bin/our_token_livenet.rs //! Deploys a new OurToken contract on the Casper livenet and mints some tokens for the tutorial //! creator. use std::str::FromStr; use odra::casper_types::U256; use odra::host::{Deployer, HostEnv, HostRef, HostRefLoader}; use odra::prelude::Address; use ourcoin::token::{OurToken, OurToken, OurTokenInitArgs}; fn main() { // Load the Casper livenet environment. let env = odra_casper_livenet_env::env(); // Caller is the deployer and the owner of the private key. let owner = env.caller(); // Just some random address... let recipient = &quot;hash-48bd92253a1370d1d913c56800296145547a243d13ff4f059ba4b985b1e94c26&quot;; let recipient = Address::from_str(recipient).unwrap(); // Deploy new contract. let mut token = deploy_our_token(&amp;env); println!(&quot;Token address: {}&quot;, token.address().to_string()); env.set_gas(2_500_000_000u64); // Propose minting new tokens. token.propose_new_mint(recipient, U256::from(1_000)); // Vote, we are the only voter. token.vote(true, U256::from(1_000)); // Let's advance the block time by 11 minutes, as // we set the voting time to 10 minutes. // OH NO! It is the Livenet, so we need to wait real time... // Hopefully you are not in a hurry. env.advance_block_time(11 * 60 * 1000); // Tally the votes. token.tally(); // Check the balances. println!(&quot;Owner's balance: {:?}&quot;, token.balance_of(&amp;owner)); println!( &quot;Tutorial creator's balance: {:?}&quot;, token.balance_of(&amp;recipient) ); } /// Deploys a contract. pub fn deploy_our_token(env: &amp;HostEnv) -&gt; OurTokenHostRef { let name = String::from(&quot;OurToken&quot;); let symbol = String::from(&quot;OT&quot;); let decimals = 0; let initial_supply = U256::from(1_000); let init_args = OurTokenInitArgs { name, symbol, decimals, initial_supply, }; env.set_gas(400_000_000_000u64); OurToken::deploy(env, init_args) // OurToken::deploy_with_cfg(env, init_args, odra::host::InstallConfig { // package_named_key: String::from(&quot;OurToken&quot;), // is_upgradable: true, // allow_key_override: true, // }) } /// Loads a contract. Just in case you need to load an existing contract later... fn _load_our_token(env: &amp;HostEnv) -&gt; OurTokenHostRef { let address = &quot;hash-XXXXX&quot;; let address = Address::from_str(address).unwrap(); OurToken::load(env, address) }  You can deploy a contract with the default configuration or with a custom configuration calling deploy_with_cfg. Read more about InstallConfig in the Odra documentation. In your Cargo.toml file, we need to add a new dependency, a feature and register the new binary. In the end, it should look like this: Cargo.toml [package] name = &quot;ourcoin&quot; version = &quot;0.1.0&quot; edition = &quot;2021&quot; [dependencies] odra = { version = &quot;2.2.0&quot;, features = [], default-features = false } odra-modules = { version = &quot;2.2.0&quot;, features = [], default-features = false } odra-casper-livenet-env = { version = &quot;2.2.0&quot;, optional = true } [dev-dependencies] odra-test = { version = &quot;2.2.0&quot;, features = [], default-features = false } [build-dependencies] odra-build = { version = &quot;2.2.0&quot;, features = [], default-features = false } [features] default = [] livenet = [&quot;odra-casper-livenet-env&quot;] [[bin]] name = &quot;ourcoin_build_contract&quot; path = &quot;bin/build_contract.rs&quot; test = false [[bin]] name = &quot;ourcoin_build_schema&quot; path = &quot;bin/build_schema.rs&quot; test = false [[bin]] name = &quot;our_token_livenet&quot; path = &quot;bin/our_token_livenet.rs&quot; required-features = [&quot;livenet&quot;] [profile.release] codegen-units = 1 lto = true [profile.dev.package.&quot;*&quot;] opt-level = 3  Finally, add the .env file with the following content: .env # Path to the secret key of the account that will be used to deploy the contracts. ODRA_CASPER_LIVENET_SECRET_KEY_PATH=folder_with_your_secret_key/secret_key.pem # RPC address of the node that will be used to deploy the contracts. # For CSPR.cloud, you can use the following addresses: # - https://node.cspr.cloud # - https://node.testnet.cspr.cloud # For nctl, default is: # - http://localhost:11101 ODRA_CASPER_LIVENET_NODE_ADDRESS=&lt;node_address&gt; # Chain name of the network. The mainnet is &quot;casper&quot; and test net is &quot;casper-test&quot;. # The integration network uses the &quot;integration-test&quot; chain name. # For nctl default is &quot;casper-net-1&quot; ODRA_CASPER_LIVENET_CHAIN_NAME=&lt;chain_name&gt; # Events url # For CSPR.cloud, you can use the following addresses: # - https://node.cspr.cloud/events # For nctl, default is: # - http://localhost:18101/events ODRA_CASPER_LIVENET_EVENTS_URL=&lt;events url&gt;  Of course, you need to replace the secret key's path with the path to the secret key file you downloaded from the Casper Wallet. note One of the problems you may encounter is that the node you are using will be down or will not accept your calls. In this case, you will have to find and use another node IP address. Now, we will run our code: cargo run --bin our_token_livenet --features livenet  If everything is set up correctly, you should see the output similar to this: cargo run --bin our_token_livenet --features livenet Compiling ourcoin v0.1.0 (/Users/kpob/workspace/odra/examples/ourcoin) Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.33s Running `../../target/debug/our_token_livenet` 💁 INFO : Found wasm under &quot;/Users/kpob/workspace/odra/examples/ourcoin/wasm/OurToken.wasm&quot;. 💁 INFO : Deploying &quot;OurToken&quot;. 🙄 WAIT : Waiting 10 for V1(TransactionV1Hash(c856983e995c79d8459540bd9d29d196535f63ceb8bac0f73ea747c5c9c74d76)). 💁 INFO : Transaction &quot;c856983e995c79d8459540bd9d29d196535f63ceb8bac0f73ea747c5c9c74d76&quot; successfully executed. 🔗 LINK : https://testnet.cspr.live/transaction/c856983e995c79d8459540bd9d29d196535f63ceb8bac0f73ea747c5c9c74d76 💁 INFO : Contract &quot;contract-package-e39aa2f8e4d509c0253dcd1709a9f08449477eef0f22f0ad5912fff327f509c8&quot; deployed. Token address: hash-e39aa2f8e4d509c0253dcd1709a9f08449477eef0f22f0ad5912fff327f509c8 💁 INFO : Calling &quot;contract-package-e39aa2f8e4d509c0253dcd1709a9f08449477eef0f22f0ad5912fff327f509c8&quot; directly with entrypoint &quot;propose_new_mint&quot;. 🙄 WAIT : Waiting 10 for V1(TransactionV1Hash(2d1aafe8f06748c7cfaf7972caee6b701de7a817430b52a73215f5ad9a175e77)). 💁 INFO : Transaction &quot;2d1aafe8f06748c7cfaf7972caee6b701de7a817430b52a73215f5ad9a175e77&quot; successfully executed. 🔗 LINK : https://testnet.cspr.live/transaction/2d1aafe8f06748c7cfaf7972caee6b701de7a817430b52a73215f5ad9a175e77 💁 INFO : Calling &quot;contract-package-e39aa2f8e4d509c0253dcd1709a9f08449477eef0f22f0ad5912fff327f509c8&quot; directly with entrypoint &quot;vote&quot;. 🙄 WAIT : Waiting 10 for V1(TransactionV1Hash(b565acd01c2ebbab78fa91a3f0091b849a037f1984ca4c996788b92fcd9521db)). 🙄 WAIT : Waiting 10 for V1(TransactionV1Hash(b565acd01c2ebbab78fa91a3f0091b849a037f1984ca4c996788b92fcd9521db)). 💁 INFO : Transaction &quot;b565acd01c2ebbab78fa91a3f0091b849a037f1984ca4c996788b92fcd9521db&quot; successfully executed. 🔗 LINK : https://testnet.cspr.live/transaction/b565acd01c2ebbab78fa91a3f0091b849a037f1984ca4c996788b92fcd9521db 💁 INFO : advance_block_time called - Waiting for 660000 ms 💁 INFO : Calling &quot;contract-package-e39aa2f8e4d509c0253dcd1709a9f08449477eef0f22f0ad5912fff327f509c8&quot; directly with entrypoint &quot;tally&quot;. 🙄 WAIT : Waiting 10 for V1(TransactionV1Hash(8d24de09298522b028073be5ba05542bf4efd0f03d0e8771d5c5a727832eba94)). 🙄 WAIT : Waiting 10 for V1(TransactionV1Hash(8d24de09298522b028073be5ba05542bf4efd0f03d0e8771d5c5a727832eba94)). 💁 INFO : Transaction &quot;8d24de09298522b028073be5ba05542bf4efd0f03d0e8771d5c5a727832eba94&quot; successfully executed. 🔗 LINK : https://testnet.cspr.live/transaction/8d24de09298522b028073be5ba05542bf4efd0f03d0e8771d5c5a727832eba94 Owner's balance: 1000 Tutorial creator's balance: 1000  Congratulations, your contract is now deployed on the Casper network! Before we move on, note the address of the token! We will use it in the next section to interact with the token. In our case it ishash-e39aa2f8e4d509c0253dcd1709a9f08449477eef0f22f0ad5912fff327f509c8. ","version":"2.2.0","tagName":"h2"},{"title":"Cspr.live​","type":1,"pageTitle":"Deploying a Token on Casper Livenet","url":"/docs/2.2.0/tutorials/deploying-on-casper#csprlive","content":"The first thing we will do is to explore Casper's network block explorer,cspr.live. We can put the address of our token in the search bar to find it. note If you deployed your contract on the Testnet, remember to make sure that the Testnet network is selected in the dropdown menu in the top right corner. If everything is set up correctly, you should see the contract package's details. Besides the owner, keys etc., you can also see the contract's metdata, if it was developed using a standard that cspr.live supports. Indeed, we can see that it detected that our contract is a CEP-18 token! We see the name, symbol and total supply. All the mentions of the contract on the website will use the token name instead of the contract address.  Additionally, on the Token Txs tab, we can see the transactions that happened with the token. We can see the minting transaction we did in the previous section and transfers done during the voting process.  If we click on one of the accounts that recieved the tokens, we will go to the account page. Here, on the Tokens tab, we can see all the tokens that the account has - and OurToken is one of them! If you wish, you can check the status of the contract deployed during the development of this tutorial here. ","version":"2.2.0","tagName":"h2"},{"title":"Transferring Tokens using Casper Wallet​","type":1,"pageTitle":"Deploying a Token on Casper Livenet","url":"/docs/2.2.0/tutorials/deploying-on-casper#transferring-tokens-using-casper-wallet","content":"Casper wallet can do much more than just logging in to the faucet, exporting the private keys and transferring CSPR. It can also interact with the contracts deployed on the network. If you deployed the contract and left some OT tokens to yourself, you should see them in the Casper Wallet window. You should also be able to transfer them to another account!  ","version":"2.2.0","tagName":"h2"},{"title":"Conclusion​","type":1,"pageTitle":"Deploying a Token on Casper Livenet","url":"/docs/2.2.0/tutorials/deploying-on-casper#conclusion","content":"We've successfully deployed a token on the Casper network and interacted with it using the Odra backend and Casper Wallet. We've also learned how to use the cspr.live block explorer to check the status of your contract. Odra, Cspr.live and Casper Wallet are just a few of the tools that the Casper ecosystem provides. Feel free to explore them on casperecosystem.io. ","version":"2.2.0","tagName":"h2"},{"title":"Build, Deploy and Read the State of a Contract","type":0,"sectionRef":"#","url":"/docs/2.2.0/tutorials/build-deploy-read","content":"","keywords":"","version":"2.2.0"},{"title":"Contract​","type":1,"pageTitle":"Build, Deploy and Read the State of a Contract","url":"/docs/2.2.0/tutorials/build-deploy-read#contract","content":"Let's write a contract with complex storage layout. The contract stores a plain numeric value, a custom nested type and a submodule with another submodule with stores a Mapping. We will expose two methods: The constructor init which sets the metadata and the version of the contract.The method set_data which sets the value of the numeric field and the values of the mapping. custom_item.rs use odra::{casper_types::U256, prelude::*}; // A custom type with a vector of another custom type #[odra::odra_type] pub struct Metadata { name: String, description: String, prices: Vec&lt;Price&gt;, } #[odra::odra_type] pub struct Price { value: U256, } // The main contract with a version, metadata and a submodule #[odra::module] pub struct CustomItem { version: Var&lt;u32&gt;, meta: Var&lt;Metadata&gt;, data: SubModule&lt;Data&gt; } #[odra::module] impl CustomItem { pub fn init(&amp;mut self, name: String, description: String, price_1: U256, price_2: U256) { let meta = Metadata { name, description, prices: vec![ Price { value: price_1 }, Price { value: price_2 } ] }; self.meta.set(meta); self.version.set(self.version.get_or_default() + 1); } pub fn set_data(&amp;mut self, value: u32, name: String, name2: String) { self.data.value.set(value); self.data.inner.named_values.set(&amp;name, 10); self.data.inner.named_values.set(&amp;name2, 20); } } // A submodule with a numeric value and another submodule #[odra::module] struct Data { value: Var&lt;u32&gt;, inner: SubModule&lt;InnerData&gt;, } // A submodule with a mapping #[odra::module] struct InnerData { named_values: Mapping&lt;String, u32&gt;, }  ","version":"2.2.0","tagName":"h3"},{"title":"Deploying the contract​","type":1,"pageTitle":"Build, Deploy and Read the State of a Contract","url":"/docs/2.2.0/tutorials/build-deploy-read#deploying-the-contract","content":"First, we need to setup the chain. We will use the NCTL docker image to run a local network. docker run --rm -it --name mynctl -d -p 11101:11101 -p 14101:14101 -p 18101:18101 makesoftware/casper-nctl  Next, we need to compile the contract to a Wasm file. cargo odra build -c custom_item  Then, we can deploy the contract using the casper-client tool. casper-client put-transaction session \\ --node-address http://localhost:11101 \\ --chain-name casper-net-1 \\ --secret-key path/to/your/secret_key.pem \\ --wasm-path ./wasm/Erc20.wasm \\ --payment-amount 450000000000 \\ --gas-price-tolerance 1 \\ --standard-payment true \\ --session-arg &quot;odra_cfg_package_hash_key_name:string:'test_contract_package_hash'&quot; \\ --session-arg &quot;odra_cfg_allow_key_override:bool:'true'&quot; \\ --session-arg &quot;odra_cfg_is_upgradable:bool:'true'&quot; \\ --session-arg &quot;name:string='My Name'&quot; \\ --session-arg &quot;description:string='My Description'&quot; \\ --session-arg &quot;price_1:u256='101'&quot; \\ --session-arg &quot;price_2:u256='202'&quot;  Finally, we can call the set_data method to set the values of the contract. casper-client put-transaction package \\ --node-address http://localhost:11101 \\ --chain-name casper-net-1 \\ --secret-key path/to/your/secret_key.pem \\ --gas-price-tolerance 1 \\ --contract-package-hash &quot;hash-...&quot; \\ --payment-amount 2500000000 \\ --standard-payment &quot;true&quot; \\ --session-entry-point &quot;set_data&quot; \\ --session-arg &quot;value:u32:'666'&quot; \\ --session-arg &quot;name:string='alice'&quot; \\ --session-arg &quot;name2:string='bob'&quot;  ","version":"2.2.0","tagName":"h3"},{"title":"Storage Layout​","type":1,"pageTitle":"Build, Deploy and Read the State of a Contract","url":"/docs/2.2.0/tutorials/build-deploy-read#storage-layout","content":"To read the state of the contract, we need to understand the storage layout. The first step is to calculate the index of the keys. Storage Layout CustomItem: prefix: 0x0..._0000_0000_0000 0 version: u32, 0x0..._0000_0000_0001 1 meta: Metadata, 0x0..._0000_0000_0010 2 data: Data: prefix: 0x0..._0000_0000_0011 3 value: u32, 0x0..._0000_0011_0001 (3 &lt;&lt; 4) + 1 inner: InnerData: prefix: 0x0..._0000_0011_0010 (3 &lt;&lt; 4) + 2 named_values: Mapping 0x0..._0011_0010_0001 ((3 &lt;&lt; 4) + 2) &lt;&lt; 4 + 1  The actual key is obtained as follows: Convert the index to a big-endian byte array.Concatenate the index with the mapping data.Hash the concatenated bytes using blake2b.Return the hex representation of the hash (the stored key must be utf-8 encoded). In more detail, the storage layout is described in the Storage Layout article. ","version":"2.2.0","tagName":"h3"},{"title":"Reading the state​","type":1,"pageTitle":"Build, Deploy and Read the State of a Contract","url":"/docs/2.2.0/tutorials/build-deploy-read#reading-the-state","content":"RustTypeScript main.rs use casper_client::{rpcs::DictionaryItemIdentifier, types::StoredValue, Verbosity}; use casper_types::{ bytesrepr::{FromBytes, ToBytes}, U256, }; // replace with your contract hash const CONTRACT_HASH: &amp;str = &quot;hash-...&quot;; const NODE_ADDRESS: &amp;str = &quot;http://localhost:11101/rpc&quot;; const RPC_ID: &amp;str = &quot;casper-net-1&quot;; const DICTIONARY_NAME: &amp;str = &quot;state&quot;; #[derive(Debug, PartialEq, Eq, Hash)] pub struct Metadata { name: String, description: String, prices: Vec&lt;Price&gt;, } #[derive(Debug, PartialEq, Eq, Hash)] pub struct Price { value: U256, } async fn read_state_key(key: String) -&gt; Vec&lt;u8&gt; { let state_root_hash = casper_client::get_state_root_hash( RPC_ID.to_string().into(), NODE_ADDRESS, Verbosity::Low, None, ) .await .unwrap() .result .state_root_hash .unwrap(); // Read the value from the `state` dictionary. let result = casper_client::get_dictionary_item( RPC_ID.to_string().into(), NODE_ADDRESS, Verbosity::Low, state_root_hash, DictionaryItemIdentifier::ContractNamedKey { key: CONTRACT_HASH.to_string(), dictionary_name: DICTIONARY_NAME.to_string(), dictionary_item_key: key, }, ) .await .unwrap() .result .stored_value; // We expect the value to be a CLValue if let StoredValue::CLValue(cl_value) = result { // Ignore the first 4 bytes, which are the length of the CLType. cl_value.inner_bytes()[4..].to_vec() } else { vec![] } } async fn metadata() -&gt; Metadata { // The key for the metadata is 2, and it has no mapping data let key = key(2, &amp;[]); let bytes = read_state_key(key).await; // Read the name and store the remaining bytes let (name, bytes) = String::from_bytes(&amp;bytes).unwrap(); // Read the description and store the remaining bytes let (description, bytes) = String::from_bytes(&amp;bytes).unwrap(); // A vector is stored as a u32 size followed by the elements // Read the size of the vector and store the remaining bytes let (size, mut bytes) = u32::from_bytes(&amp;bytes).unwrap(); let mut prices = vec![]; // As we know the size of the vector, we can loop over it for _ in 0..size { // Read the value and store the remaining bytes let (value, rem) = U256::from_bytes(&amp;bytes).unwrap(); bytes = rem; prices.push(Price { value }); } // Anytime you finish parsing a value, you should check if there are any remaining bytes // if there are, it means you have a bug in your parsing logic. // For simplicity, we will ignore the remaining bytes here. Metadata { name, description, prices } } async fn value() -&gt; u32 { // The key for the value is (3 &lt;&lt; 4) + 1, and it has no mapping data let key = key((3 &lt;&lt; 4) + 1, &amp;[]); let bytes = read_state_key(key).await; // Read the value and ignore the remaining bytes for simplicity u32::from_bytes(&amp;bytes).unwrap().0 } async fn named_value(name: &amp;str) -&gt; u32 { // The key for the named value is (((3 &lt;&lt; 4) + 2) &lt;&lt; 4) + 1, and the mapping data is the name as bytes let mapping_data = name.to_bytes().unwrap(); let key = key((((3 &lt;&lt; 4) + 2) &lt;&lt; 4) + 1, &amp;mapping_data); let bytes = read_state_key(key).await; // Read the value and ignore the remaining bytes for simplicity u32::from_bytes(&amp;bytes).unwrap().0 } fn main() { let runtime = tokio::runtime::Runtime::new().unwrap(); dbg!(runtime.block_on(metadata())); dbg!(runtime.block_on(value())); dbg!(runtime.block_on(named_value(&quot;alice&quot;))); dbg!(runtime.block_on(named_value(&quot;bob&quot;))); } // The key is a combination of the index and the mapping data // The algorithm is as follows: // 1. Convert the index to a big-endian byte array // 2. Concatenate the index with the mapping data // 3. Hash the concatenated bytes using blake2b // 4. Return the hex representation of the hash (the stored key must be utf-8 encoded) fn key(idx: u32, mapping_data: &amp;[u8]) -&gt; String { let mut key = Vec::new(); key.extend_from_slice(idx.to_be_bytes().as_ref()); key.extend_from_slice(mapping_data); let hashed_key = blake2b(&amp;key); hex::encode(&amp;hashed_key) } fn blake2b(bytes: &amp;[u8]) -&gt; [u8; 32] { let mut result = [0u8; 32]; let mut hasher = &lt;blake2::Blake2bVar as blake2::digest::VariableOutput&gt;::new(32) .expect(&quot;should create hasher&quot;); let _ = std::io::Write::write(&amp;mut hasher, bytes); blake2::digest::VariableOutput::finalize_variable(hasher, &amp;mut result) .expect(&quot;should copy hash to the result array&quot;); result } cargo run [src/main.rs:116:5] runtime.block_on(metadata()) = Metadata { name: &quot;My Contract&quot;, description: &quot;My Description&quot;, prices: [ Price { value: 123, }, Price { value: 321, }, ], } [src/main.rs:117:5] runtime.block_on(value()) = 666 [src/main.rs:118:5] runtime.block_on(named_value(&quot;alice&quot;)) = 20 [src/main.rs:119:5] runtime.block_on(named_value(&quot;bob&quot;)) = 10  ","version":"2.2.0","tagName":"h3"},{"title":"Migration guide to v0.8.0","type":0,"sectionRef":"#","url":"/docs/2.2.0/migrations/to-0.8.0","content":"","keywords":"","version":"2.2.0"},{"title":"1. Prerequisites​","type":1,"pageTitle":"Migration guide to v0.8.0","url":"/docs/2.2.0/migrations/to-0.8.0#1-prerequisites","content":"","version":"2.2.0","tagName":"h2"},{"title":"1.1. Update cargo-odra​","type":1,"pageTitle":"Migration guide to v0.8.0","url":"/docs/2.2.0/migrations/to-0.8.0#11-update-cargo-odra","content":"Before you begin the migration process, make sure you installed the latest version of the Cargo Odra toolchain. You can install it by running the following command: cargo install cargo-odra --force --locked  ","version":"2.2.0","tagName":"h3"},{"title":"1.2. Review the Changelog​","type":1,"pageTitle":"Migration guide to v0.8.0","url":"/docs/2.2.0/migrations/to-0.8.0#12-review-the-changelog","content":"Before you move to changing your code, start by reviewing the Changelog to understand the changes introduced in v0.8.0. ","version":"2.2.0","tagName":"h3"},{"title":"2. Migration Steps​","type":1,"pageTitle":"Migration guide to v0.8.0","url":"/docs/2.2.0/migrations/to-0.8.0#2-migration-steps","content":"","version":"2.2.0","tagName":"h2"},{"title":"2.1 Add bin directory​","type":1,"pageTitle":"Migration guide to v0.8.0","url":"/docs/2.2.0/migrations/to-0.8.0#21-add-bin-directory","content":"Odra 0.8.0 introduces a new way to build smart contracts. The .builder_casper directory is no longer used. Instead, you should create a new directory called bin in the root of your project and add the build_contract.rs and build_schema.rs files to the bin directory. You can find the build_contract.rs and build_schema.rs files in templates directory in the Odra main repository. You can choose whatever template you want to use and copy the files to your project. In both files, you should replace {{project-name}} with the name of your project. ","version":"2.2.0","tagName":"h3"},{"title":"2.2. Update Cargo.toml​","type":1,"pageTitle":"Migration guide to v0.8.0","url":"/docs/2.2.0/migrations/to-0.8.0#22-update-cargotoml","content":"There a bunch of changes in the Cargo.toml file. You don't have to specify the features anymore - remove the features section and default-features flag from the odra dependency.Register bins you added in the previous step.Add dev-dependencies section with odra-test crate.Add recommended profiles for release and dev to optimize the build process. Below you can compare the Cargo.toml file after and before the migration to v0.8.0: 0.8.0Prev [package] name = &quot;my_project&quot; version = &quot;0.1.0&quot; edition = &quot;2021&quot; [dependencies] odra = &quot;0.8.0&quot; [dev-dependencies] odra-test = &quot;0.8.0&quot; [[bin]] name = &quot;my_project_build_contract&quot; path = &quot;bin/build_contract.rs&quot; test = false [[bin]] name = &quot;my_project_build_schema&quot; path = &quot;bin/build_schema.rs&quot; test = false [profile.release] codegen-units = 1 lto = true [profile.dev.package.&quot;*&quot;] opt-level = 3  ","version":"2.2.0","tagName":"h3"},{"title":"2.2. Update Odra.toml​","type":1,"pageTitle":"Migration guide to v0.8.0","url":"/docs/2.2.0/migrations/to-0.8.0#22-update-odratoml","content":"Due to the changes in cargo-odra, the Odra.toml file has been simplified. The name property is no longer required. 0.8.0Prev [[contracts]] fqn = &quot;my_project::Flipper&quot;  ","version":"2.2.0","tagName":"h3"},{"title":"2.3. Update Smart Contracts​","type":1,"pageTitle":"Migration guide to v0.8.0","url":"/docs/2.2.0/migrations/to-0.8.0#23-update-smart-contracts","content":"The smart contracts themselves will need to be updated to work with the new version of the framework. The changes will depend on the specific features and APIs used in the contracts. Here are some common changes you might need to make: 2.3.1. Update the use statements to reflect the new module structure.​ Big integer types are now located in the odra::casper_types module.odra::types::Address is now odra::Address.Variable is now Var.Remove odra::contract_env.Remove odra::types::event::OdraEvent.Remove odra::types::OdraType as it is no longer required.Change odra::types::casper_types::*; to odra::casper_types::*;. 2.3.2. Some type aliases are no longer in use.​ Balance - use odra::casper_types::U512.BlockTime - use u64.EventData - use odra::casper_types::bytesrepr::Bytes. 2.3.3. Consider import odra::prelude::* in your module files.​ 2.3.4. Flatten nested Mappings.​ // Before #[odra::module(events = [Approval, Transfer])] pub struct Erc20 { ... allowances: Mapping&lt;Address, Mapping&lt;Address, U256&gt;&gt; } // After #[odra::module(events = [Approval, Transfer])] pub struct Erc20 { ... allowances: Mapping&lt;(Address, Address), U256&gt; }  2.3.5. Update errors definitions.​ execution_error! macro has been replace with OdraError derive macro. 0.8.0Prev use odra::OdraError; #[derive(OdraError)] pub enum Error { InsufficientBalance = 30_000, InsufficientAllowance = 30_001, NameNotSet = 30_002, SymbolNotSet = 30_003, DecimalsNotSet = 30_004 }  2.3.6. Update events definitions.​ 0.8.0Prev use odra::prelude::*; use odra::Event; #[derive(Event, Eq, PartialEq, Debug)] pub struct Transfer { pub from: Option&lt;Address&gt;, pub to: Option&lt;Address&gt;, pub amount: U256 } // Emitting the event self.env().emit_event(Transfer { from: None, to: Some(*address), amount: *amount });  2.3.7. Replace contract_env with self.env() in your modules.​ self.env() is a new way to access the contract environment, returns a reference to ContractEnv. The API is similar to the previous contract_env but with some changes. fn get_var&lt;T: FromBytes&gt;(key: &amp;[u8]) -&gt; Option&lt;T&gt; is now fn get_value&lt;T: FromBytes&gt;(&amp;self, key: &amp;[u8]) -&gt; Option&lt;T&gt;.fn set_var&lt;T: CLTyped + ToBytes&gt;(key: &amp;[u8], value: T) is now fn set_value&lt;T: ToBytes + CLTyped&gt;(&amp;self, key: &amp;[u8], value: T).set_dict_value() and get_dict_value() has been removed. All the dictionary operations should be performed using Mapping type, internally using set_var() and get_var() functions. fn hash&lt;T: AsRef&lt;[u8]&gt;&gt;(input: T) -&gt; Vec&lt;u8&gt; is now fn hash&lt;T: ToBytes&gt;(&amp;self, value: T) -&gt; [u8; 32].fn revert&lt;E: Into&lt;ExecutionError&gt;&gt;(error: E) -&gt; ! is now fn revert&lt;E: Into&lt;OdraError&gt;&gt;(&amp;self, error: E) -&gt; !.fn emit_event&lt;T: ToBytes + OdraEvent&gt;(event: T) is now fn emit_event&lt;T: ToBytes&gt;(&amp;self, event: T).fn call_contract&lt;T: CLTyped + FromBytes&gt;(address: Address, entrypoint: &amp;str, args: &amp;RuntimeArgs, amount: Option&lt;U512&gt;) -&gt; T is now fn call_contract&lt;T: FromBytes&gt;(&amp;self, address: Address, call: CallDef) -&gt; T.functions native_token_metadata() and one_token() have been removed. 2.3.8. Wrap submodules of your module with odra::SubModule&lt;T&gt;.​ 0.8.0Prev #[odra::module(events = [Transfer])] pub struct Erc721Token { core: SubModule&lt;Erc721Base&gt;, metadata: SubModule&lt;Erc721MetadataExtension&gt;, ownable: SubModule&lt;Ownable&gt; }  2.3.9. Update external contract calls.​ However the definition of an external contract remains the same, the way you call it has changed. A reference to an external contract is named {{ModuleName}}ContractRef (former {{ModuleName}}Ref) and you can call it using {{ModuleName}}ContractRef::new(env, address) (former {{ModuleName}}Ref::at()). 0.8.0Prev #[odra::external_contract] pub trait Token { fn balance_of(&amp;self, owner: &amp;Address) -&gt; U256; } // Usage TokenContractRef::new(env, token).balance_of(account)  2.3.10. Update constructors.​ Remove the #[odra::init] attribute from the constructor and ensure that the constructor function is named init. 2.3.11. Update UnwrapOrRevert calls.​ The functions unwrap_or_revert and unwrap_or_revert_with now require &amp;HostEnv as the first parameter. 2.3.12. Remove #[odra(using)] attribute from your module definition.​ Sharing the same instance of a module is no longer supported. A redesign of the module structure might be required. ","version":"2.2.0","tagName":"h3"},{"title":"2.4. Update Tests​","type":1,"pageTitle":"Migration guide to v0.8.0","url":"/docs/2.2.0/migrations/to-0.8.0#24-update-tests","content":"Once you've updated your smart contracts, you'll need to update your tests to reflect the changes. The changes will depend on the specific features and APIs used in the tests. Here are some common changes you might need to make: 2.4.1. Contract deployment.​ The way you deploy a contract has changed: You should use {{ModuleName}}HostRef::deploy(&amp;env, args) instead of {{ModuleName}}Deployer::init(). The {{ModuleName}}HostRef implements odra::host::Deployer.Instantiate the HostEnv using odra_test::env(), required by the odra::host::Deployer::deploy() function.If the contract doesn't have init args, you should use odra::host::NoArgs as the second argument of the deploy function.If the contract has init args, you should pass the autogenerated {{ModuleName}}InitArgs as the second argument of the deploy function. 0.8.0Prev // A contract without init args use super::OwnableHostRef; use odra::host::{Deployer, HostEnv, HostRef, NoArgs}; let env: HostEnv = odra_test::env(); let ownable = OwnableHostRef::deploy(&amp;env, NoArgs) // A contract with init args use super::{Erc20HostRef, Erc20InitArgs}; use odra::host::{Deployer, HostEnv}; let env: HostEnv = odra_test::env(); let init_args = Erc20InitArgs { symbol: SYMBOL.to_string(), name: NAME.to_string(), decimals: DECIMALS, initial_supply: Some(INITIAL_SUPPLY.into()) }; let erc20 = Erc20HostRef::deploy(&amp;env, init_args);  2.4.2. Host interactions.​ Replace odra::test_env with odra_test::env().The API of odra::test_env and odra_test::env() are similar, but there are some differences: test_env::advance_block_time_by(BlockTime) is now env.advance_block_time(u64).test_env::token_balance(Address) is now env.balance_of(&amp;Address).functions test_env::last_call_contract_gas_cost(), test_env::last_call_contract_gas_used(), test_env::total_gas_used(Address), test_env::gas_report() have been removed. You should use HostRef::last_call() and extract the data from a odra::ContractCallResult instance. HostRef is a trait implemented by {{ModuleName}}HostRef. 2.4.3. Testing failing scenarios.​ test_env::assert_exception() has been removed. You should use the try_ prefix to call the function and then assert the result.try_ prefix is a new way to call a function that might fail. It returns a OdraResult type, which you can then assert using the standard Rust assert_eq! macro. 0.8.0Prev #[test] fn transfer_from_error() { let (env, mut erc20) = setup(); let (owner, spender, recipient) = (env.get_account(0), env.get_account(1), env.get_account(2)); let amount = 1_000.into(); env.set_caller(spender); assert_eq!( erc20.try_transfer_from(owner, recipient, amount), Err(Error::InsufficientAllowance.into()) ); }  2.4.4. Testing events.​ assert_events! macro has been removed. You should use HostEnv::emitted_event() to assert the emitted events. The new API doesn't allow to assert multiple events at once, but adds alternative ways to assert the emitted events. Check the HostEnv documentation to explore the available options. 0.8.0Prev let env: HostEnv = odra_test::env(); let erc20 = Erc20HostRef::deploy(&amp;env, init_args); ... assert!(env.emitted_event( erc20.address(), &amp;Approval { owner, spender, value: approved_amount - transfer_amount } )); assert!(env.emitted_event( erc20.address(), &amp;Transfer { from: Some(owner), to: Some(recipient), amount: transfer_amount } ));  ","version":"2.2.0","tagName":"h3"},{"title":"3. Code Examples​","type":1,"pageTitle":"Migration guide to v0.8.0","url":"/docs/2.2.0/migrations/to-0.8.0#3-code-examples","content":"Here is a complete example of a smart contract after and before the migration to v0.8.0. 0.8.0Prev src/erc20.rs use crate::erc20::errors::Error::*; use crate::erc20::events::*; use odra::prelude::*; use odra::{casper_types::U256, Address, Mapping, Var}; #[odra::module(events = [Approval, Transfer])] pub struct Erc20 { decimals: Var&lt;u8&gt;, symbol: Var&lt;String&gt;, name: Var&lt;String&gt;, total_supply: Var&lt;U256&gt;, balances: Mapping&lt;Address, U256&gt;, allowances: Mapping&lt;(Address, Address), U256&gt; } #[odra::module] impl Erc20 { pub fn init( &amp;mut self, symbol: String, name: String, decimals: u8, initial_supply: Option&lt;U256&gt; ) { let caller = self.env().caller(); self.symbol.set(symbol); self.name.set(name); self.decimals.set(decimals); if let Some(initial_supply) = initial_supply { self.total_supply.set(initial_supply); self.balances.set(&amp;caller, initial_supply); if !initial_supply.is_zero() { self.env().emit_event(Transfer { from: None, to: Some(caller), amount: initial_supply }); } } } pub fn transfer(&amp;mut self, recipient: &amp;Address, amount: &amp;U256) { let caller = self.env().caller(); self.raw_transfer(&amp;caller, recipient, amount); } pub fn transfer_from(&amp;mut self, owner: &amp;Address, recipient: &amp;Address, amount: &amp;U256) { let spender = self.env().caller(); self.spend_allowance(owner, &amp;spender, amount); self.raw_transfer(owner, recipient, amount); } pub fn approve(&amp;mut self, spender: &amp;Address, amount: &amp;U256) { let owner = self.env().caller(); self.allowances.set(&amp;(owner, *spender), *amount); self.env().emit_event(Approval { owner, spender: *spender, value: *amount }); } pub fn name(&amp;self) -&gt; String { self.name.get_or_revert_with(NameNotSet) } // Other getter functions... pub fn allowance(&amp;self, owner: &amp;Address, spender: &amp;Address) -&gt; U256 { self.allowances.get_or_default(&amp;(*owner, *spender)) } pub fn mint(&amp;mut self, address: &amp;Address, amount: &amp;U256) { self.total_supply.add(*amount); self.balances.add(address, *amount); self.env().emit_event(Transfer { from: None, to: Some(*address), amount: *amount }); } pub fn burn(&amp;mut self, address: &amp;Address, amount: &amp;U256) { if self.balance_of(address) &lt; *amount { self.env().revert(InsufficientBalance); } self.total_supply.subtract(*amount); self.balances.subtract(address, *amount); self.env().emit_event(Transfer { from: Some(*address), to: None, amount: *amount }); } } impl Erc20 { fn raw_transfer(&amp;mut self, owner: &amp;Address, recipient: &amp;Address, amount: &amp;U256) { if *amount &gt; self.balances.get_or_default(owner) { self.env().revert(InsufficientBalance) } self.balances.subtract(owner, *amount); self.balances.add(recipient, *amount); self.env().emit_event(Transfer { from: Some(*owner), to: Some(*recipient), amount: *amount }); } fn spend_allowance(&amp;mut self, owner: &amp;Address, spender: &amp;Address, amount: &amp;U256) { let allowance = self.allowances.get_or_default(&amp;(*owner, *spender)); if allowance &lt; *amount { self.env().revert(InsufficientAllowance) } self.allowances.subtract(&amp;(*owner, *spender), *amount); self.env().emit_event(Approval { owner: *owner, spender: *spender, value: allowance - *amount }); } } pub mod events { use odra::prelude::*; use odra::{casper_types::U256, Address, Event}; #[derive(Event, Eq, PartialEq, Debug)] pub struct Transfer { pub from: Option&lt;Address&gt;, pub to: Option&lt;Address&gt;, pub amount: U256 } #[derive(Event, Eq, PartialEq, Debug)] pub struct Approval { pub owner: Address, pub spender: Address, pub value: U256 } } pub mod errors { use odra::OdraError; #[derive(OdraError)] pub enum Error { InsufficientBalance = 30_000, InsufficientAllowance = 30_001, NameNotSet = 30_002, SymbolNotSet = 30_003, DecimalsNotSet = 30_004 } } #[cfg(test)] mod tests { use super::{ errors::Error, events::{Approval, Transfer}, Erc20HostRef, Erc20InitArgs }; use odra::{ casper_types::U256, host::{Deployer, HostEnv, HostRef}, prelude::* }; const NAME: &amp;str = &quot;Plascoin&quot;; const SYMBOL: &amp;str = &quot;PLS&quot;; const DECIMALS: u8 = 10; const INITIAL_SUPPLY: u32 = 10_000; fn setup() -&gt; (HostEnv, Erc20HostRef) { let env = odra_test::env(); ( env.clone(), Erc20HostRef::deploy( &amp;env, Erc20InitArgs { symbol: SYMBOL.to_string(), name: NAME.to_string(), decimals: DECIMALS, initial_supply: Some(INITIAL_SUPPLY.into()) } ) ) } #[test] fn initialization() { // When deploy a contract with the initial supply. let (env, erc20) = setup(); // Then the contract has the metadata set. assert_eq!(erc20.symbol(), SYMBOL.to_string()); assert_eq!(erc20.name(), NAME.to_string()); assert_eq!(erc20.decimals(), DECIMALS); // Then the total supply is updated. assert_eq!(erc20.total_supply(), INITIAL_SUPPLY.into()); // Then a Transfer event was emitted. assert!(env.emitted_event( erc20.address(), &amp;Transfer { from: None, to: Some(env.get_account(0)), amount: INITIAL_SUPPLY.into() } )); } #[test] fn transfer_works() { // Given a new contract. let (env, mut erc20) = setup(); // When transfer tokens to a recipient. let sender = env.get_account(0); let recipient = env.get_account(1); let amount = 1_000.into(); erc20.transfer(&amp;recipient, &amp;amount); // Then the sender balance is deducted. assert_eq!( erc20.balance_of(&amp;sender), U256::from(INITIAL_SUPPLY) - amount ); // Then the recipient balance is updated. assert_eq!(erc20.balance_of(&amp;recipient), amount); // Then Transfer event was emitted. assert!(env.emitted_event( erc20.address(), &amp;Transfer { from: Some(sender), to: Some(recipient), amount } )); } #[test] fn transfer_error() { // Given a new contract. let (env, mut erc20) = setup(); // When the transfer amount exceeds the sender balance. let recipient = env.get_account(1); let amount = U256::from(INITIAL_SUPPLY) + U256::one(); // Then an error occurs. assert!(erc20.try_transfer(&amp;recipient, &amp;amount).is_err()); } // Other tests... }  ","version":"2.2.0","tagName":"h2"},{"title":"4. Troubleshooting​","type":1,"pageTitle":"Migration guide to v0.8.0","url":"/docs/2.2.0/migrations/to-0.8.0#4-troubleshooting","content":"If you encounter any further issues after completing the migration steps, please don't hesitate to reach out to us on Discord or explore the other sections this documentation. You can also refer to the technical documentation for more detailed information. Additionally, our examples repository offers a wide range of examples to assist you in understanding the new features and APIs. Be sure to carefully review any compilation errors and warnings, as they may provide valuable insights into the necessary adjustments. ","version":"2.2.0","tagName":"h2"},{"title":"5. References​","type":1,"pageTitle":"Migration guide to v0.8.0","url":"/docs/2.2.0/migrations/to-0.8.0#5-references","content":"ChangelogOdra DocumentationDocs.rsExamples ","version":"2.2.0","tagName":"h2"},{"title":"CEP-18","type":0,"sectionRef":"#","url":"/docs/2.2.0/tutorials/cep18","content":"","keywords":"","version":"2.2.0"},{"title":"Self-governing token​","type":1,"pageTitle":"CEP-18","url":"/docs/2.2.0/tutorials/cep18#self-governing-token","content":"There are many ways to implement a governance mechanism for a token, each more complex than the other. In our example, we will use a simple one, where the community of token holders can vote to mint new tokens. ","version":"2.2.0","tagName":"h2"},{"title":"Token implementation​","type":1,"pageTitle":"CEP-18","url":"/docs/2.2.0/tutorials/cep18#token-implementation","content":"Let's start by creating a new project, choosing a clever name and using cep18 as our starting template: cargo odra new --name ourcoin --template cep18  Let's glance at our token code: src/token.rs #[odra::module] pub struct MyToken { token: SubModule&lt;Cep18&gt;, } impl MyToken { // Delegate all Cep18 functions to the token sub-module. delegate! { to self.token { ... fn name(&amp;self) -&gt; String; fn symbol(&amp;self) -&gt; String; ...  As we can see, it indeed uses the Cep18 module and delegates all the methods to it. The only thing to do is to change the name of the struct to more appropriate OurToken, run the provided tests using cargo odra test, and continue with the implementation of the governance. note Remember to change the name of the struct and its usages as well as the struct name in the Odra.toml file! ","version":"2.2.0","tagName":"h2"},{"title":"Governance implementation​","type":1,"pageTitle":"CEP-18","url":"/docs/2.2.0/tutorials/cep18#governance-implementation","content":"Let's go through the process of implementing the governance mechanism. If we don't want to, we don't have to hide entrypoints from the public responsible for minting new tokens. By default, minting Modalityis turned off, so any attempt of direct minting will result in an error. We will however implement a voting mechanism, where the token holders can vote to mint new tokens. ","version":"2.2.0","tagName":"h2"},{"title":"Voting mechanism​","type":1,"pageTitle":"CEP-18","url":"/docs/2.2.0/tutorials/cep18#voting-mechanism","content":"Our voting system will be straightforward: Anyone with the tokens can propose a new mint.Anyone with the tokens can vote for the new mint by staking their tokens.If the majority of the token holders vote for the mint, it is executed. Storage​ We will need to store some additional information about the votes, so let's add some fields to our token struct: src/token.rs #[odra::module] pub struct OurToken { /// A sub-module that implements the CEP-18 token standard. token: SubModule&lt;Cep18&gt;, /// The proposed mint. proposed_mint: Var&lt;(Address, U256)&gt;, /// The list of votes cast in the current vote. votes: List&lt;Ballot&gt;, /// Whether a vote is open. is_vote_open: Var&lt;bool&gt;, /// The time when the vote ends. vote_end_time: Var&lt;u64&gt;, } /// A ballot cast by a voter. #[odra::odra_type] struct Ballot { voter: Address, choice: bool, amount: U256, }  Notice that proposed_mint contains a tuple containing the address of the proposer and the amount of tokens to mint. Moreover, we need to keep track if the vote time has ended, but also if it was already tallied, that's why we need both is_vote_open and vote_end_time. We will also use the power of the Listtype to store the Ballots. Proposing a new mint​ To implement the endpoint that allows token holders to propose a new mint, we need to add a new function to our token module: src/token.rs /// Proposes a new mint for the contract. pub fn propose_new_mint(&amp;mut self, account: Address, amount: U256) { // Only allow proposing a new mint if there is no vote in progress. if self.is_vote_open().get_or_default() { self.env().revert(GovernanceError::VoteAlreadyOpen); } // Only the token holders can propose a new mint. if self.balance_of(&amp;self.env().caller()) == U256::zero() { self.env().revert(GovernanceError::OnlyTokenHoldersCanPropose); } // Set the proposed mint. self.proposed_mint.set((account, amount)); // Open a vote. self.is_vote_open.set(true); // Set the vote end time to 10 minutes from now. self.vote_end_time .set(self.env().get_block_time() + 60 * 10 * 1000); }  As a parameters to the function, we pass the address of the account that should be the receiver of the minted tokens, and the amount. After some validation, we open the vote by setting the is_vote_open to true, and setting the vote_end_time to 10 minutes. In real-world scenarios, the time could be configurable, but for the sake of simplicity, we hardcoded it. Also, it should be quite longer than 10 minutes, but it will come in handy when we test it on Livenet. Voting for the mint​ Next, we need an endpoint that will allow us to cast a ballot: src/token.rs /// Votes on the proposed mint. pub fn vote(&amp;mut self, choice: bool, amount: U256) { // Only allow voting if there is a vote in progress. self.assert_vote_in_progress(); let voter = self.env().caller(); let contract = self.env().self_address(); // Transfer the voting tokens from the voter to the contract. self.token .transfer(&amp;contract, &amp;amount); // Add the vote to the list. self.votes.push(Ballot { voter, choice, amount, }); }  The most interesting thing here is that we are using a mechanism of staking, where we transfer our tokens to the contract, to show that we really mean it. The tokens will be locked until the vote is over, and tallied. Speaking of tallying... Tallying the votes​ The last step is to tally the votes and mint the tokens if the majority of voters agreed to do so: src/token.rs /// Count the votes and perform the action pub fn tally(&amp;mut self) { // Only allow tallying the votes once. if !self.is_vote_open.get_or_default() { self.env().revert(GovernanceError::NoVoteInProgress); } // Only allow tallying the votes after the vote has ended. let finish_time = self .vote_end_time .get_or_revert_with(GovernanceError::NoVoteInProgress); if self.env().get_block_time() &lt; finish_time { self.env().revert(GovernanceError::VoteNotYetEnded); } // Count the votes let mut yes_votes = U256::zero(); let mut no_votes = U256::zero(); let contract = self.env().self_address(); while let Some(vote) = self.votes.pop() { if vote.choice { yes_votes += vote.amount; } else { no_votes += vote.amount; } // Transfer back the voting tokens to the voter. self.token.raw_transfer(&amp;contract, &amp;vote.voter, &amp;vote.amount); } // Perform the action if the vote has passed. if yes_votes &gt; no_votes { let (account, amount) = self .proposed_mint .get_or_revert_with(GovernanceError::NoVoteInProgress); self.token.raw_mint(&amp;account, &amp;amount); } // Close the vote. self.is_vote_open.set(false); }  Notice how we used raw_transfer from the Cep18 module. We used it to set the sender, so the contract's balance will be used, instead of the caller's. Additonally, we used raw_mint to mint the tokens, skipping the security checks. We have no modality for minting, but even if we had, we don't have anyone with permissions! The Contract needs to mint the tokens itself. ","version":"2.2.0","tagName":"h3"},{"title":"Testing​","type":1,"pageTitle":"CEP-18","url":"/docs/2.2.0/tutorials/cep18#testing","content":"Now, we will put our implementation to the test. One unit test, that we can run both on OdraVM and on the CasperVM. src/token.rs #[test] fn it_works() { let env = odra_test::env(); let init_args = OurTokenInitArgs { name: &quot;OurToken&quot;.to_string(), symbol: &quot;OT&quot;.to_string(), decimals: 0, initial_supply: U256::from(1_000u64), }; let mut token = OurToken::deploy(&amp;env, init_args); // The deployer, as the only token holder, // starts a new voting to mint 1000 tokens to account 1. // There is only 1 token holder, so there is one Ballot cast. token.propose_new_mint(env.get_account(1), U256::from(2000)); token.vote(true, U256::from(1000)); // The tokens should now be staked. assert_eq!(token.balance_of(&amp;env.get_account(0)), U256::zero()); // Wait for the vote to end. env.advance_block_time(60 * 11 * 1000); // Finish the vote. token.tally(); // The tokens should now be minted. assert_eq!(token.balance_of(&amp;env.get_account(1)), U256::from(2000)); assert_eq!(token.total_supply(), 3000.into()); // The stake should be returned. assert_eq!(token.balance_of(&amp;env.get_account(0)), U256::from(1000)); // Now account 1 can mint new tokens with their voting power... env.set_caller(env.get_account(1)); token.propose_new_mint(env.get_account(1), U256::from(2000)); token.vote(true, U256::from(2000)); // ...Even if the deployer votes against it. env.set_caller(env.get_account(0)); token.vote(false, U256::from(1000)); env.advance_block_time(60 * 11 * 1000); token.tally(); // The power of community governance! assert_eq!(token.balance_of(&amp;env.get_account(1)), U256::from(4000)); }  We can run the test using both methods: cargo odra test cargo odra test -b casper  It is all nice and green, but it would be really nice to see it in action. How about deploying it on the Casper network? ","version":"2.2.0","tagName":"h3"},{"title":"What's next​","type":1,"pageTitle":"CEP-18","url":"/docs/2.2.0/tutorials/cep18#whats-next","content":"We will se our token in action, by deploying it on the Casper network, and using tools from the Casper Ecosystem to interact with it. ","version":"2.2.0","tagName":"h2"},{"title":"Complete code​","type":1,"pageTitle":"CEP-18","url":"/docs/2.2.0/tutorials/cep18#complete-code","content":"Here is the complete code of the OurToken module: src/token.rs use odra::{casper_types::U256, prelude::*}; use odra_modules::cep18_token::Cep18; /// A ballot cast by a voter. #[odra::odra_type] struct Ballot { voter: Address, choice: bool, amount: U256, } /// Errors for the governed token. #[odra::odra_error] pub enum GovernanceError { /// The vote is already in progress. VoteAlreadyOpen = 0, /// No vote is in progress. NoVoteInProgress = 1, /// Cannot tally votes yet. VoteNotYetEnded = 2, /// Vote ended VoteEnded = 3, /// Only the token holders can propose a new mint. OnlyTokenHoldersCanPropose = 4, } /// A module definition. Each module struct consists of Vars and Mappings /// or/and other modules. #[odra::module(errors = GovernanceError)] pub struct OurToken { /// A submodule that implements the CEP-18 token standard. token: SubModule&lt;Cep18&gt;, /// The proposed mint. proposed_mint: Var&lt;(Address, U256)&gt;, /// The list of votes cast in the current vote. votes: List&lt;Ballot&gt;, /// Whether a vote is open. is_vote_open: Var&lt;bool&gt;, /// The time when the vote ends. vote_end_time: Var&lt;u64&gt;, } /// Module implementation. /// /// To generate entrypoints, /// an implementation block must be marked as #[odra::module]. #[odra::module] impl OurToken { /// Initializes the contract with the given metadata and initial supply. pub fn init(&amp;mut self, name: String, symbol: String, decimals: u8, initial_supply: U256) { // We put the token address as an admin, so it can govern itself. Self-governing token! self.token.init(symbol, name, decimals, initial_supply); } // Delegate all Cep18 functions to the token submodule. delegate! { to self.token { /// Returns the name of the token. fn name(&amp;self) -&gt; String; /// Returns the symbol of the token. fn symbol(&amp;self) -&gt; String; /// Returns the number of decimals the token uses. fn decimals(&amp;self) -&gt; u8; /// Returns the total supply of the token. fn total_supply(&amp;self) -&gt; U256; /// Returns the balance of the given address. fn balance_of(&amp;self, address: &amp;Address) -&gt; U256; /// Returns the amount of tokens the owner has allowed the spender to spend. fn allowance(&amp;self, owner: &amp;Address, spender: &amp;Address) -&gt; U256; /// Approves the spender to spend the given amount of tokens on behalf of the caller. fn approve(&amp;mut self, spender: &amp;Address, amount: &amp;U256); /// Decreases the allowance of the spender by the given amount. fn decrease_allowance(&amp;mut self, spender: &amp;Address, decr_by: &amp;U256); /// Increases the allowance of the spender by the given amount. fn increase_allowance(&amp;mut self, spender: &amp;Address, inc_by: &amp;U256); /// Transfers tokens from the caller to the recipient. fn transfer(&amp;mut self, recipient: &amp;Address, amount: &amp;U256); /// Transfers tokens from the owner to the recipient using the spender's allowance. fn transfer_from(&amp;mut self, owner: &amp;Address, recipient: &amp;Address, amount: &amp;U256); } } /// Burns the given amount of tokens from the given address. pub fn burn(&amp;mut self, owner: &amp;Address, amount: &amp;U256) { self.token.assert_caller(owner); // Burn the tokens. self.token.raw_burn(owner, amount); } /// Proposes a new mint for the contract. pub fn propose_new_mint(&amp;mut self, account: Address, amount: U256) { // Only allow proposing a new mint if there is no vote in progress. if self.is_vote_open.get_or_default() { self.env().revert(GovernanceError::VoteAlreadyOpen); } // Only the token holders can propose a new mint. if self.balance_of(&amp;self.env().caller()) == U256::zero() { self.env() .revert(GovernanceError::OnlyTokenHoldersCanPropose); } // Set the proposed mint. self.proposed_mint.set((account, amount)); // Open a vote. self.is_vote_open.set(true); // Set the vote end time to 10 minutes from now. self.vote_end_time .set(self.env().get_block_time() + 10 * 60 * 1000); } /// Votes on the proposed mint. pub fn vote(&amp;mut self, choice: bool, amount: U256) { // Only allow voting if there is a vote in progress. self.assert_vote_in_progress(); let voter = self.env().caller(); let contract = self.env().self_address(); // Transfer the voting tokens from the voter to the contract. self.token.transfer(&amp;contract, &amp;amount); // Add the vote to the list. self.votes.push(Ballot { voter, choice, amount, }); } /// Count the votes and perform the action pub fn tally(&amp;mut self) { // Only allow tallying the votes once. if !self.is_vote_open.get_or_default() { self.env().revert(GovernanceError::NoVoteInProgress); } // Only allow tallying the votes after the vote has ended. let finish_time = self .vote_end_time .get_or_revert_with(GovernanceError::NoVoteInProgress); if self.env().get_block_time() &lt; finish_time { self.env().revert(GovernanceError::VoteNotYetEnded); } // Count the votes let mut yes_votes = U256::zero(); let mut no_votes = U256::zero(); let contract = self.env().self_address(); while let Some(vote) = self.votes.pop() { if vote.choice { yes_votes += vote.amount; } else { no_votes += vote.amount; } // Transfer back the voting tokens to the voter. self.token .raw_transfer(&amp;contract, &amp;vote.voter, &amp;vote.amount); } // Perform the action if the vote has passed. if yes_votes &gt; no_votes { let (account, amount) = self .proposed_mint .get_or_revert_with(GovernanceError::NoVoteInProgress); self.token.raw_mint(&amp;account, &amp;amount); } // Close the vote. self.is_vote_open.set(false); } fn assert_vote_in_progress(&amp;self) { if !self.is_vote_open.get_or_default() { self.env().revert(GovernanceError::NoVoteInProgress); } let finish_time = self .vote_end_time .get_or_revert_with(GovernanceError::NoVoteInProgress); if self.env().get_block_time() &gt; finish_time { self.env().revert(GovernanceError::VoteEnded); } } } #[cfg(test)] mod tests { use super::*; use odra::host::Deployer; #[test] fn it_works() { let env = odra_test::env(); let init_args = OurTokenInitArgs { name: &quot;OurToken&quot;.to_string(), symbol: &quot;OT&quot;.to_string(), decimals: 0, initial_supply: U256::from(1_000u64), }; let mut token = OurToken::deploy(&amp;env, init_args); // The deployer, as the only token holder, // starts a new voting to mint 1000 tokens to account 1. // There is only 1 token holder, so there is one Ballot cast. token.propose_new_mint(env.get_account(1), U256::from(2000)); token.vote(true, U256::from(1000)); // The tokens should now be staked. assert_eq!(token.balance_of(&amp;env.get_account(0)), U256::zero()); // Wait for the vote to end. env.advance_block_time(60 * 11 * 1000); // Finish the vote. token.tally(); // The tokens should now be minted. assert_eq!(token.balance_of(&amp;env.get_account(1)), U256::from(2000)); assert_eq!(token.total_supply(), 3000.into()); // The stake should be returned. assert_eq!(token.balance_of(&amp;env.get_account(0)), U256::from(1000)); // Now account 1 can mint new tokens with their voting power... env.set_caller(env.get_account(1)); token.propose_new_mint(env.get_account(1), U256::from(2000)); token.vote(true, U256::from(2000)); // ...Even if the deployer votes against it. env.set_caller(env.get_account(0)); token.vote(false, U256::from(1000)); env.advance_block_time(60 * 11 * 1000); token.tally(); // The power of community governance! assert_eq!(token.balance_of(&amp;env.get_account(1)), U256::from(4000)); } }  ","version":"2.2.0","tagName":"h2"},{"title":"Odra CLI","type":0,"sectionRef":"#","url":"/docs/2.2.0/tutorials/odra-cli","content":"","keywords":"","version":"2.2.0"},{"title":"Example​","type":1,"pageTitle":"Odra CLI","url":"/docs/2.2.0/tutorials/odra-cli#example","content":"Let's go through an example available in the odra repository to see how to use the Odra CLI library. It creates a CLI tool for a useful DogContract. ","version":"2.2.0","tagName":"h2"},{"title":"Cargo.toml​","type":1,"pageTitle":"Odra CLI","url":"/docs/2.2.0/tutorials/odra-cli#cargotoml","content":"To use the Odra CLI library in your project, you need to add odra-cli to your Cargo.toml file, alongside a new binary: [dependencies] ... odra-cli = &quot;2&quot; ... [[bin]] name = &quot;odra-cli&quot; path = &quot;bin/odra-cli.rs&quot;  Then, create an empty file in the bin directory named odra-cli.rs. ","version":"2.2.0","tagName":"h3"},{"title":"Deploy script​","type":1,"pageTitle":"Odra CLI","url":"/docs/2.2.0/tutorials/odra-cli#deploy-script","content":"The first type of script we can create is a deploy script. It is used to deploy the contract to the network and store the address of the deployed contract in a container for later use. Only one deploy script can be used in a single CLI tool, and it is executed when the user runs the deploy command. bin/odra-cli.rs use odra::host::HostEnv; use odra_cli::{ deploy::DeployScript, DeployerExt, DeployedContractsContainer, }; use odra_examples::features::storage::variable::{DogContract, DogContractInitArgs}; /// Deploys the `DogContract` and adds it to the container. pub struct DeployDogScript; impl DeployScript for DeployDogScript { fn deploy( &amp;self, env: &amp;HostEnv, container: &amp;mut DeployedContractsContainer ) -&gt; Result&lt;(), odra_cli::deploy::Error&gt; { env.set_gas(350_000_000_000); let dog_contract = DogContract::try_deploy( env, DogContractInitArgs { barks: true, weight: 10, name: &quot;Mantus&quot;.to_string() } )?; container.add_contract(&amp;dog_contract)?; // By default, a contract is non-upgradeable, you can change it by passing `InstallConfig` _ = DogContract::try_deploy_with_cfg( env, DogContractInitArgs { barks: true, weight: 10, name: &quot;Mantus&quot;.to_string() }, InstallConfig::upgradable::&lt;DogContract&gt;(), )?; // Alternatively, you can use the `DeployerExt` trait to deploy the contract: _ = DogContract::load_or_deploy( env, DogContractInitArgs { barks: true, weight: 10, name: &quot;Mantus&quot;.to_string() }, container, 350_000_000_000 )?; // You can use `load_or_deploy_with_cfg` to deploy the contract with a custom configuration _ = DogContract::load_or_deploy_with_cfg( env, DogContractInitArgs { barks: true, weight: 10, name: &quot;Mantus&quot;.to_string() }, InstallConfig::upgradable::&lt;DogContract&gt;(), container, 350_000_000_000 )?; Ok(()) } }  In the example above, we see a few alternative implementations of a simple DeployScript for our DogContract. All of them set the gas limit, deploy the contract and adds it to a container. The first one uses the DogContract::try_deploy method, which deploys the contract every time the script is run. The second also deploys a contract everytime, but passes InstallConfig instance to configure the deployment using a factory method InstallConfig::upgradable. A next option utilizes the DeployerExt trait, which checks if the contract is already deployed and returns the existing instance if it is, or deploys it if it is not. It is a convenient way to ensure that the contract is deployed only once. It is useful when you want to add more contracts to the script in the future and avoid redeploying previously deployed contracts. The last option is to use load_or_deploy_with_cfg that accepts a custom configuration. The address of the deployed contract is stored in a TOML file in the resources directory, which is created automatically by the Odra CLI library. ","version":"2.2.0","tagName":"h3"},{"title":"Scenarios​","type":1,"pageTitle":"Odra CLI","url":"/docs/2.2.0/tutorials/odra-cli#scenarios","content":"Scenarios are a way to run multiple calls one after another, and can be used to test the contract or perform complex operations like setting up the dependencies between contracts. To create a scenario, you need to implement the Scenario trait and add it to the OdraCli instance in the main function. A scenario also implements the ScenarioMetadata trait, which provides metadata about the scenario, such as its name and description. You can use this metadata to display the scenario in the CLI tool and provide a description of what it does. bin/odra-cli.rs use odra_cli::{ scenario::{Args, Error, Scenario, ScenarioMetadata}, CommandArg, ContractProvider, DeployedContractsContainer, }; use std::vec; pub struct DogCheckScenario; impl Scenario for DogCheckScenario { fn args(&amp;self) -&gt; Vec&lt;CommandArg&gt; { vec![CommandArg::new( &quot;name&quot;, &quot;The name of the dog&quot;, NamedCLType::String, ).required()] } fn run( &amp;self, env: &amp;HostEnv, container: &amp;DeployedContractsContainer, args: Args ) -&gt; Result&lt;(), Error&gt; { let dog_contract = container.contract_ref::&lt;DogContract&gt;(env)?; let test_name = args.get_single::&lt;String&gt;(&quot;name&quot;)?; env.set_gas(50_000_000); let actual_name = dog_contract.try_name()?; assert_eq!(test_name, actual_name, &quot;Dog name mismatch&quot;); Ok(()) } } impl ScenarioMetadata for DogCheckScenario { const NAME: &amp;'static str = &quot;check&quot;; const DESCRIPTION: &amp;'static str = &quot;Checks if the name of the deployed dog matches the provided name&quot;; }  A scenario must implement the Scenario trait, which requires defining the args and run methods. The args method returns a vector of CommandArg that defines the arguments that the scenario accepts. In this case, we define a single argument name of type String, which is required - the program will fail at parse time if the argument is not provided. The run method is where the scenario logic is implemented. It receives the HostEnv, a container with deployed contracts, and the arguments passed to the scenario. To load the contract, we use the ContractProvider trait, which allows us to get a reference to the contract by its type. The trait is implemented for the DeployedContractsContainer, which is passed to the run method. To read the arguments, we use the Args type, which provides two methods: get_single and get_many. In this case, we use get_single to get the value of the name argument. If we want to get multiple values for an argument, we must define the argument as CommandArg::new(&quot;name&quot;, &quot;The name of the dog&quot;, NamedCLType::String).list(), where list() indicates that the argument can be provided multiple times. The example above performs a simple check on the return value of one of the methods. Of course, there is no limit to how complex a scenario can be. ","version":"2.2.0","tagName":"h3"},{"title":"Contract methods​","type":1,"pageTitle":"Odra CLI","url":"/docs/2.2.0/tutorials/odra-cli#contract-methods","content":"To interact with the contract methods, we can use the contract command. The Odra CLI automatically generates commands for each contract method, allowing us to call them directly by name. But first, we need to register the contract in the OdraCli instance. ","version":"2.2.0","tagName":"h3"},{"title":"Builder​","type":1,"pageTitle":"Odra CLI","url":"/docs/2.2.0/tutorials/odra-cli#builder","content":"Now, let's put everything together in the main function. We will use the OdraCli builder to create a CLI tool that can deploy the contract, call its methods, and run scenarios. bin/odra-cli.rs use odra_cli::OdraCli; /// Main function to run the CLI tool. pub fn main() { OdraCli::new() .about(&quot;Dog contract cli tool&quot;) .deploy(DeployDogScript) .contract::&lt;DogContract&gt;() .scenario(DogCheckScenario) .build() .run(); }  This code creates a new OdraCli instance, sets the description of the tool, adds the deploy script, registers the DogContract, and adds the scenario. Finally, it builds the CLI tool and runs it. ","version":"2.2.0","tagName":"h3"},{"title":"How to use it​","type":1,"pageTitle":"Odra CLI","url":"/docs/2.2.0/tutorials/odra-cli#how-to-use-it","content":"Assuming the correct livenet environment is set up, you can run the CLI tool using the following command: cargo run --bin odra-cli  This will display all of our options: Dog contract cli tool Usage: odra_cli [OPTIONS] &lt;COMMAND&gt; Commands: deploy Runs the deploy script contract Commands for interacting with contracts scenario Commands for interacting with scenarios print-events Prints the most recent events emitted by a contract help Print this message or the help of the given subcommand(s) Options: -c, --contracts-toml &lt;PathBuf&gt; The path to the file with the deployed contracts. Relative to the project root. -h, --help Print help  By default, contracts are written/read to/from the contracts.toml file, which is located in the resources directory, but you can specify a different path using the -c or --contracts-toml option. ","version":"2.2.0","tagName":"h2"},{"title":"Deploy command​","type":1,"pageTitle":"Odra CLI","url":"/docs/2.2.0/tutorials/odra-cli#deploy-command","content":"First, we need to deploy the contract: cargo run --bin odra_cli deploy  This gives us the following output: cargo run --bin odra_cli -- deploy Compiling odra-examples v2.1.0 (/home/kuba/Projekty/odra/odra/examples) Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.65s Running `../target/debug/odra_cli deploy` 💁 INFO : Found wasm under &quot;wasm/DogContract.wasm&quot;. 💁 INFO : Deploying &quot;DogContract&quot;. 🙄 WAIT : Waiting 10 for V1(TransactionV1Hash(4230d5ca3113d87190e4136cefe097bd08fea03c841ce5e4df73a049e10208f1)). 💁 INFO : Transaction &quot;4230d5ca3113d87190e4136cefe097bd08fea03c841ce5e4df73a049e10208f1&quot; successfully executed. 🔗 LINK : 💁 INFO : Contract &quot;contract-package-53b3486180b2a9506fbb0523ed159b1908cec628d091b19cbe74e057e7ebbc8b&quot; deployed. 💁 INFO : Command executed successfully  This will run the deploy script and create a new file in the resources directory named contracts.toml: last_updated = &quot;2025-07-03T10:33:55Z&quot; [[contracts]] name = &quot;DogContract&quot; package_hash = &quot;hash-53b3486180b2a9506fbb0523ed159b1908cec628d091b19cbe74e057e7ebbc8b&quot;  All the calls to the contract will be made using this package hash, unless you specify a different one using the -c or --contracts-toml option. ","version":"2.2.0","tagName":"h3"},{"title":"Contract command​","type":1,"pageTitle":"Odra CLI","url":"/docs/2.2.0/tutorials/odra-cli#contract-command","content":"To call a contract method, we need to use the contract command. The command itself will display all the available contracts: cargo run --bin odra_cli -- contract  This outputs: Commands for interacting with contracts Usage: odra_cli contract &lt;COMMAND&gt; Commands: DogContract Commands for interacting with the DogContract contract help Print this message or the help of the given subcommand(s)  And when a contract is selected, it will show us the available methods: cargo run --bin odra_cli -- contract DogContract  Commands for interacting with the DogContract contract Usage: odra_cli contract DogContract &lt;COMMAND&gt; Commands: barks Returns true if the dog barks. weight Returns the dog's weight. name Returns the dog's name. walks_amount Adds a walk to the dog's walks. walks_total_length Returns the total length of the dog's walks. help Print this message or the help of the given subcommand(s)  To run a command, compose a command like this: cargo run --bin odra_cli -- contract DogContract barks  This will result in: 💁 INFO : Call result: true 💁 INFO : Command executed successfully  If you run a command that requires arguments, it will display an error message: cargo run --bin odra_cli -- contract DogContract rename error: the following required arguments were not provided: --new_name &lt;String&gt; --gas &lt;U64&gt; Usage: odra_cli contract DogContract rename --new_name &lt;String&gt; --gas &lt;U64&gt; For more information, try '--help'.  The error message above indicates that the rename method requires two arguments: new_name and gas. In the code, the rename method is mutable and takes a single argument new_name of type String. As the entry point is mutable and requires a real transaction, the gas argument is also required to specify how much gas to use for the call. The gas amount is denominated in motes. Let's run the command with the required arguments: cargo run --bin odra_cli -- contract DogContract rename --new_name &quot;Doggy&quot; --gas 200000000 error: invalid value '200000000' for '--gas &lt;U64&gt;': 200000000 is not in 2500000000..18446744073709551615  As the minimum gas amount for a transaction is 2.5 CSPRs, we need to increase the gas amount to at least that value: cargo run --bin odra_cli -- contract DogContract rename --new_name &quot;Doggy&quot; --gas 2500000000 💁 INFO : Calling &quot;contract-package-0eda9544d667775d8e5503543dd8ba0996d439fd9ded79cfe28454d07f42df3a&quot; directly with entrypoint &quot;rename&quot;. 🙄 WAIT : Waiting 10 for V1(TransactionV1Hash(e9d2e7f9d7d832cbf64e6e9eb09404423757e354a1ed7420c0398d851fea3a40)). 💁 INFO : Transaction &quot;e9d2e7f9d7d832cbf64e6e9eb09404423757e354a1ed7420c0398d851fea3a40&quot; successfully executed. 🔗 LINK : 💁 INFO : Call executed successfully, but no result was returned. 💁 INFO : Command executed successfully # Verifying the name change cargo run --bin odra_cli -- contract DogContract name 💁 INFO : Call result: Doggy 💁 INFO : Command executed successfully  There are more options available for the contract command that we can discover by running the help command: cargo run --bin odra_cli -- contract DogContract rename --help It is uncommon but you can change the dog's name. Usage: odra_cli contract DogContract rename [OPTIONS] --new_name &lt;String&gt; --gas &lt;U64&gt; Options: --new_name &lt;String&gt; --attached_value &lt;U512&gt; The amount of CSPRs attached to the call --gas &lt;U64&gt; The amount of gas to attach to the call -p, --print-events Print events emitted by the contract -h, --help  If you want to print the events emitted by the contract, you can use the --print-events option. This will print all the events emitted by the contract during the call. cargo run --bin odra_cli -- contract DogContract rename --new_name &quot;Doggy&quot; --gas 2500000000 --print-events 💁 INFO : Syncing events for the call... 💁 INFO : Calling &quot;contract-package-0eda9544d667775d8e5503543dd8ba0996d439fd9ded79cfe28454d07f42df3a&quot; directly with entrypoint &quot;rename&quot;. 🙄 WAIT : Waiting 10 for V1(TransactionV1Hash(f2f473d46b59c136052f687539ab76e5fbb3af958c483e3a382b5a0e498227c4)). 💁 INFO : Transaction &quot;f2f473d46b59c136052f687539ab76e5fbb3af958c483e3a382b5a0e498227c4&quot; successfully executed. 🔗 LINK : 💁 INFO : Captured 1 events for contract 'DogContract' 💁 INFO : Event 1: 'NamedChanged': 'old_name': Mantus 'new_name': Doggy 💁 INFO : Call executed successfully, but no result was returned. 💁 INFO : Command executed successfully  For a payable method, you can use the --attached_value option to specify the amount of CSPRs to attach to the call. The value is denominated in motes. ","version":"2.2.0","tagName":"h3"},{"title":"Print-events command​","type":1,"pageTitle":"Odra CLI","url":"/docs/2.2.0/tutorials/odra-cli#print-events-command","content":"The print-events command allows you to print the most recent events emitted by a contract. It is useful for debugging and understanding what is happening in the contract. You can run it like this: cargo run --bin odra_cli -- print-events DogContract --help Print events of the DogContract contract Usage: odra_cli print-events DogContract [OPTIONS] Options: -n, --number &lt;N&gt; Number of events to print [default: 10] -h, --help Print help cargo run --bin odra_cli -- print-events DogContract -n 2 💁 INFO : Printing 4 the most recent events for contract 'DogContract' 💁 INFO : Event 1: 'NamedChanged': 'old_name': Mantus 'new_name': Doggy 💁 INFO : Event 2: 'NamedChanged': 'old_name': Rex 'new_name': Mantus 💁 INFO : Command executed successfully  By default, it prints the last 10 events, but you can specify a different number using the -n or --number option. ","version":"2.2.0","tagName":"h3"},{"title":"Scenario command​","type":1,"pageTitle":"Odra CLI","url":"/docs/2.2.0/tutorials/odra-cli#scenario-command","content":"Scenarios registered in the OdraCli instance can be run using the scenario command. It displays all the available scenarios: cargo run --bin odra_cli -- scenario  This will output: Commands for running user-defined scenarios Usage: odra_cli scenario &lt;COMMAND&gt; Commands: check Checks if the name of the deployed dog matches the provided name help Print this message or the help of the given subcommand(s)  It can be run like this: cargo run --bin odra_cli -- scenario check --name Doggy  This will output: thread 'main' panicked at examples/bin/odra_cli.rs:59:9: assertion `left == right` failed: Dog name mismatch left: &quot;Doggy&quot; right: &quot;Mantus&quot; ## Conclusion The Odra CLI library provides a powerful and convenient way to create command-line tools for your Odra contracts. It simplifies the process of deploying, interacting with, and testing your contracts, allowing you to focus on the business logic of your application. By following the examples in this tutorial, you can create your own CLI tools and streamline your development workflow.  ","version":"2.2.0","tagName":"h3"},{"title":"ERC-20","type":0,"sectionRef":"#","url":"/docs/2.2.0/tutorials/erc20","content":"","keywords":"","version":"2.2.0"},{"title":"Framework features​","type":1,"pageTitle":"ERC-20","url":"/docs/2.2.0/tutorials/erc20#framework-features","content":"A module we will write in a minute, will help you master a few Odra features: Advanced storage using key-value pairs,Odra types such as Address,Advanced event assertion. ","version":"2.2.0","tagName":"h2"},{"title":"Code​","type":1,"pageTitle":"ERC-20","url":"/docs/2.2.0/tutorials/erc20#code","content":"Our module features a considerably more complex storage layout compared to the previous example. It is designed to store the following data: Immutable metadata - name, symbol, and decimals.Total supply.Balances of individual users.Allowances, essentially indicating who is permitted to spend tokens on behalf of another user. ","version":"2.2.0","tagName":"h2"},{"title":"Module definition​","type":1,"pageTitle":"ERC-20","url":"/docs/2.2.0/tutorials/erc20#module-definition","content":"erc20.rs use odra::prelude::*; use odra::casper_types::U256; #[odra::module(events = [Transfer, Approval], errors = Error)] pub struct Erc20 { decimals: Var&lt;u8&gt;, symbol: Var&lt;String&gt;, name: Var&lt;String&gt;, total_supply: Var&lt;U256&gt;, balances: Mapping&lt;Address, U256&gt;, allowances: Mapping&lt;(Address, Address), U256&gt; }  L10 - For the first time, we need to store key-value pairs. In order to do that, we use Mapping. The name is taken after Solidity's native type mapping.L11 - Odra does not allows nested Mappings as Solidity does. Instead, you can create a compound key using a tuple of keys. ","version":"2.2.0","tagName":"h2"},{"title":"Metadata​","type":1,"pageTitle":"ERC-20","url":"/docs/2.2.0/tutorials/erc20#metadata","content":"erc20.rs #[odra::module] impl Erc20 { pub fn init(&amp;mut self, name: String, symbol: String, decimals: u8, initial_supply: U256) { let caller = self.env().caller(); self.name.set(name); self.symbol.set(symbol); self.decimals.set(decimals); self.mint(&amp;caller, &amp;initial_supply); } pub fn name(&amp;self) -&gt; String { self.name.get_or_default() } pub fn symbol(&amp;self) -&gt; String { self.symbol.get_or_default() } pub fn decimals(&amp;self) -&gt; u8 { self.decimals.get_or_default() } pub fn total_supply(&amp;self) -&gt; U256 { self.total_supply.get_or_default() } } impl Erc20 { pub fn mint(&amp;mut self, address: &amp;Address, amount: &amp;U256) { self.balances.add(address, *amount); self.total_supply.add(*amount); self.env().emit_event(Transfer { from: None, to: Some(*address), amount: *amount }); } } #[odra::event] pub struct Transfer { pub from: Option&lt;Address&gt;, pub to: Option&lt;Address&gt;, pub amount: U256 }  L1 - The first impl block, marked as a module, contains functions defined in the ERC-20 standard.L3-L9 - A constructor sets the token metadata and mints the initial supply.L28 - The second impl is not an Odra module; in other words, these functions will not be part of the contract's public interface.L29-L38 - The mint function is public, so, like in regular Rust code, it will be accessible from the outside. mint() uses the notation self.balances.add(address, *amount);, which is syntactic sugar for: let current_balance = self.balances.get(address).unwrap_or_default(); let new_balance = &lt;U256 as OverflowingAdd&gt;::overflowing_add(current_balance, current_balance).unwrap_or_revert(&amp;self.env()); self.balances.set(address, new_balance);  ","version":"2.2.0","tagName":"h3"},{"title":"Core​","type":1,"pageTitle":"ERC-20","url":"/docs/2.2.0/tutorials/erc20#core","content":"To ensure comprehensive functionality, let's implement the remaining features such as transfer, transfer_from, and approve. Since they do not introduce any new concepts, we will present them without additional remarks. erc20.rs #[odra::module] impl Erc20 { ... pub fn transfer(&amp;mut self, recipient: &amp;Address, amount: &amp;U256) { let caller = self.env().caller(); self.raw_transfer(&amp;caller, recipient, amount); } pub fn transfer_from(&amp;mut self, owner: &amp;Address, recipient: &amp;Address, amount: &amp;U256) { let spender = self.env().caller(); self.spend_allowance(owner, &amp;spender, amount); self.raw_transfer(owner, recipient, amount); } pub fn approve(&amp;mut self, spender: &amp;Address, amount: &amp;U256) { let owner = self.env().caller(); self.allowances.set(&amp;(owner, *spender), *amount); self.env().emit_event(Approval { owner, spender: *spender, value: *amount }); } pub fn balance_of(&amp;self, address: &amp;Address) -&gt; U256 { self.balances.get_or_default(&amp;address) } pub fn allowance(&amp;self, owner: &amp;Address, spender: &amp;Address) -&gt; U256 { self.allowances.get_or_default(&amp;(*owner, *spender)) } } impl Erc20 { ... fn raw_transfer(&amp;mut self, owner: &amp;Address, recipient: &amp;Address, amount: &amp;U256) { let owner_balance = self.balances.get_or_default(&amp;owner); if *amount &gt; owner_balance { self.env().revert(Error::InsufficientBalance) } self.balances.set(owner, owner_balance - *amount); self.balances.add(recipient, *amount); self.env().emit_event(Transfer { from: Some(*owner), to: Some(*recipient), amount: *amount }); } fn spend_allowance(&amp;mut self, owner: &amp;Address, spender: &amp;Address, amount: &amp;U256) { let allowance = self.allowance(owner, spender); if allowance &lt; *amount { self.env().revert(Error::InsufficientAllowance) } let new_allowance = allowance - *amount; self.allowances .set(&amp;(*owner, *spender), new_allowance); self.env().emit_event(Approval { owner: *owner, spender: *spender, value: allowance - *amount }); } } #[odra::event] pub struct Approval { pub owner: Address, pub spender: Address, pub value: U256 } #[odra::odra_error] pub enum Error { InsufficientBalance = 1, InsufficientAllowance = 2, }  Now, compare the code we have written, with Open Zeppelin code. Out of 10, how Solidity-ish is our implementation? ","version":"2.2.0","tagName":"h3"},{"title":"Test​","type":1,"pageTitle":"ERC-20","url":"/docs/2.2.0/tutorials/erc20#test","content":"erc20.rs #[cfg(test)] pub mod tests { use super::*; use odra::{ casper_types::U256, host::{Deployer, HostEnv}, prelude::* }; const NAME: &amp;str = &quot;Plascoin&quot;; const SYMBOL: &amp;str = &quot;PLS&quot;; const DECIMALS: u8 = 10; const INITIAL_SUPPLY: u32 = 10_000; fn setup() -&gt; (HostEnv, Erc20HostRef) { let env = odra_test::env(); ( env.clone(), Erc20::deploy( &amp;env, Erc20InitArgs { symbol: SYMBOL.to_string(), name: NAME.to_string(), decimals: DECIMALS, initial_supply: INITIAL_SUPPLY.into() } ) ) } #[test] fn initialization() { // When deploy a contract with the initial supply. let (env, erc20) = setup(); // Then the contract has the metadata set. assert_eq!(erc20.symbol(), SYMBOL.to_string()); assert_eq!(erc20.name(), NAME.to_string()); assert_eq!(erc20.decimals(), DECIMALS); // Then the total supply is updated. assert_eq!(erc20.total_supply(), INITIAL_SUPPLY.into()); // Then a Transfer event was emitted. assert!(env.emitted_event( &amp;erc20, &amp;Transfer { from: None, to: Some(env.get_account(0)), amount: INITIAL_SUPPLY.into() } )); } #[test] fn transfer_works() { // Given a new contract. let (env, mut erc20) = setup(); // When transfer tokens to a recipient. let sender = env.get_account(0); let recipient = env.get_account(1); let amount = 1_000.into(); erc20.transfer(&amp;recipient, &amp;amount); // Then the sender balance is deducted. assert_eq!( erc20.balance_of(&amp;sender), U256::from(INITIAL_SUPPLY) - amount ); // Then the recipient balance is updated. assert_eq!(erc20.balance_of(&amp;recipient), amount); // Then Transfer event was emitted. assert!(env.emitted_event( &amp;erc20, &amp;Transfer { from: Some(sender), to: Some(recipient), amount } )); } #[test] fn transfer_error() { // Given a new contract. let (env, mut erc20) = setup(); // When the transfer amount exceeds the sender balance. let recipient = env.get_account(1); let amount = U256::from(INITIAL_SUPPLY) + U256::one(); // Then an error occurs. assert!(erc20.try_transfer(&amp;recipient, &amp;amount).is_err()); } #[test] fn transfer_from_and_approval_work() { let (env, mut erc20) = setup(); let (owner, recipient, spender) = (env.get_account(0), env.get_account(1), env.get_account(2)); let approved_amount = 3_000.into(); let transfer_amount = 1_000.into(); assert_eq!(erc20.balance_of(&amp;owner), U256::from(INITIAL_SUPPLY)); // Owner approves Spender. erc20.approve(&amp;spender, &amp;approved_amount); // Allowance was recorded. assert_eq!(erc20.allowance(&amp;owner, &amp;spender), approved_amount); assert!(env.emitted_event( &amp;erc20, Approval { owner, spender, value: approved_amount } )); // Spender transfers tokens from Owner to Recipient. env.set_caller(spender); erc20.transfer_from(&amp;owner, &amp;recipient, &amp;transfer_amount); // Tokens are transferred and allowance decremented. assert_eq!( erc20.balance_of(&amp;owner), U256::from(INITIAL_SUPPLY) - transfer_amount ); assert_eq!(erc20.balance_of(&amp;recipient), transfer_amount); assert!(env.emitted_event( &amp;erc20, Approval { owner, spender, value: approved_amount - transfer_amount } )); assert!(env.emitted_event( &amp;erc20, Transfer { from: Some(owner), to: Some(recipient), amount: transfer_amount } )); // assert!(env.emitted(&amp;erc20, &quot;Transfer&quot;)); } #[test] fn transfer_from_error() { // Given a new instance. let (env, mut erc20) = setup(); // When the spender's allowance is zero. let (owner, spender, recipient) = (env.get_account(0), env.get_account(1), env.get_account(2)); let amount = 1_000.into(); env.set_caller(spender); // Then transfer fails. assert_eq!( erc20.try_transfer_from(&amp;owner, &amp;recipient, &amp;amount), Err(Error::InsufficientAllowance.into()) ); } }  L146 - Alternatively, if you don't want to check the entire event, you may assert only its type. ","version":"2.2.0","tagName":"h3"},{"title":"What's next​","type":1,"pageTitle":"ERC-20","url":"/docs/2.2.0/tutorials/erc20#whats-next","content":"Having two modules: Ownable and Erc20, let's combine them, and create an ERC-20 on steroids. ","version":"2.2.0","tagName":"h2"},{"title":"Ticketing System","type":0,"sectionRef":"#","url":"/docs/2.2.0/tutorials/nft","content":"","keywords":"","version":"2.2.0"},{"title":"Ticket Office Contract​","type":1,"pageTitle":"Ticketing System","url":"/docs/2.2.0/tutorials/nft#ticket-office-contract","content":"Our TicketOffice contract will include the following features: Compliance with the CEP-78 standard.Ownership functionality.Only the owner can issue new event tickets.Users can purchase tickets for events.Tickets are limited to a one-time sale.Public access to view the total income of the TicketOffice. ","version":"2.2.0","tagName":"h2"},{"title":"Setup the project​","type":1,"pageTitle":"Ticketing System","url":"/docs/2.2.0/tutorials/nft#setup-the-project","content":"Creating a new NFT token with Odra is straightforward. Use the cargo odra new command to create a new project with the CEP-95 template: cargo odra new --name ticket-office --template cep95  ","version":"2.2.0","tagName":"h2"},{"title":"Contract implementation​","type":1,"pageTitle":"Ticketing System","url":"/docs/2.2.0/tutorials/nft#contract-implementation","content":"Let's start implementing the TicketOffice contract by modify the code generated from the template. src/token.rs use odra::{casper_types::{U256, U512}, prelude::*}; use odra_modules::access::Ownable; use odra_modules::cep95::{CEP95Interface, Cep95}; pub type TicketId = U256; #[odra::odra_type] pub enum TicketStatus { Available, Sold, } #[odra::odra_type] pub struct TicketInfo { event_name: String, price: U512, status: TicketStatus, } #[odra::event] pub struct OnTicketIssue { ticket_id: TicketId, event_name: String, price: U512, } #[odra::event] pub struct OnTicketSell { ticket_id: TicketId, buyer: Address, } #[odra::odra_error] pub enum Error { TicketNotAvailableForSale = 200, InsufficientFunds = 201, InvalidTicketId = 202, TicketDoesNotExist = 203, } #[odra::module( events = [OnTicketIssue, OnTicketSell], errors = Error )] pub struct TicketOffice { token: SubModule&lt;Cep95&gt;, ownable: SubModule&lt;Ownable&gt;, tickets: Mapping&lt;TicketId, TicketInfo&gt;, token_id_counter: Var&lt;TicketId&gt;, total_supply: Var&lt;u64&gt;, } #[odra::module] impl TicketOffice { pub fn init(&amp;mut self, collection_name: String, collection_symbol: String, total_supply: u64) { let caller = self.env().caller(); self.ownable.init(caller); self.token.init(collection_name, collection_symbol); } pub fn issue_ticket(&amp;mut self, event_name: String, price: U512) { let env = self.env(); let caller = env.caller(); self.ownable.assert_owner(&amp;caller); // mint a new token let ticket_id = self.token_id_counter.get_or_default(); self.token.mint(caller, ticket_id, Default::default()); // store ticket info self.tickets.set( &amp;ticket_id, TicketInfo { event_name: event_name.clone(), price, status: TicketStatus::Available, }, ); self.token_id_counter.set(ticket_id + 1); // emit an event env.emit_event(OnTicketIssue { ticket_id, event_name, price, }); } #[odra(payable)] pub fn buy_ticket(&amp;mut self, ticket_id: TicketId) { let env = self.env(); let owner = self.ownable.get_owner(); let buyer = env.caller(); let value = env.attached_value(); // only tokens owned by the owner can be sold if self.token.owner_of(ticket_id) != Some(owner) { env.revert(Error::TicketNotAvailableForSale); } let mut ticket = self .tickets .get(&amp;ticket_id) .unwrap_or_revert_with(&amp;env, Error::TicketDoesNotExist); // only available tickets can be sold if ticket.status != TicketStatus::Available { env.revert(Error::TicketNotAvailableForSale); } // check if the buyer sends enough funds if value &lt; ticket.price { env.revert(Error::InsufficientFunds); } // transfer csprs to the owner env.transfer_tokens(&amp;owner, &amp;value); // transfer the ticket to the buyer self.token.transfer_from(owner, buyer, ticket_id); ticket.status = TicketStatus::Sold; self.tickets.set(&amp;ticket_id, ticket); env.emit_event(OnTicketSell { ticket_id, buyer }); } pub fn balance_of(&amp;self) -&gt; U512 { self.env().self_balance() } }  L7-L39 - We define structures and enums that will be used in our contract. TicketStatus enum represents the status of a ticket, TicketInfo struct contains information about a ticket that is written to the storage, TicketId is a type alias for u64. OnTicketIssue and OnTicketSell are events that will be emitted when a ticket is issued or sold.L41-L44 - Register errors and events that will be used in our contract, required to produce a complete contract schema.L45-L51 - TicketOffice module definition. The module contains a Cep95 token, an Ownable module, a Mapping that stores information about tickets and Vars token_id_counter and total_supply to keep track of the total number of tickets issued.L55-L59 - The init function has been generated from the template and there is no need to modify it, except the Ownable module initialization.L61-L84 - The issue_ticket function allows the owner to issue a new ticket. The function mints a new token, stores information about the ticket, and emits an OnTicketIssue event.L86 - The payable attribute indicates that the buy_ticket function can receive funds.L87-L116 - The buy_ticket function checks if the ticket is available for sale, if the buyer sends enough funds, and transfers the ticket to the buyer. Finally, the function updates the ticket status and emits an OnTicketSell event. Lets test the contract. The test scenario will be as follows: Deploy the contract.Issue two tickets.Try to buy a ticket with insufficient funds.Buy tickets.Try to buy the same ticket again.Check the balance of the contract. src/tests.rs use odra::{ casper_types::U512, host::{Deployer, HostRef}, }; use crate::token::{Error, TicketOfficeHostRef, TicketOfficeInitArgs}; #[test] fn it_works() { let env = odra_test::env(); let init_args = TicketOfficeInitArgs { collection_name: &quot;Ticket&quot;.to_string(), collection_symbol: &quot;T&quot;.to_string(), total_supply: 100, }; let mut contract = TicketOffice::deploy(&amp;env, init_args); contract.issue_ticket(&quot;Ev&quot;.to_string(), U512::from(100)); contract.issue_ticket(&quot;Ev&quot;.to_string(), U512::from(50)); let buyer = env.get_account(1); env.set_caller(buyer); assert_eq!( contract .with_tokens(U512::from(50)) .try_buy_ticket(0.into()), Err(Error::InsufficientFunds.into()) ); assert_eq!( contract .with_tokens(U512::from(100)) .try_buy_ticket(0.into()), Ok(()) ); assert_eq!( contract .with_tokens(U512::from(50)) .try_buy_ticket(1.into()), Ok(()) ); assert_eq!( contract .with_tokens(U512::from(100)) .try_buy_ticket(0.into()), Err(Error::TicketNotAvailableForSale.into()) ); }  Unfortunately, the test failed. The first assertion succeeds because the buyer sends insufficient funds to buy the ticket. However, the second assertion fails even though the buyer sends enough funds to purchase the ticket. The buy_ticket function reverts with CEP-95 Error::NotAnOwnerOrApproved because the buyer attempts to transfer a token that they do not own, are not approved for, or are not an operator of. odra/modules/src/cep95.rs fn transfer_from(&amp;mut self, from: Address, to: Address, token_id: U256) { self.assert_exists(&amp;token_id); let caller = self.env().caller(); let owner = self .owner_of(token_id) .unwrap_or_revert_with(self, Error::ValueNotSet); // Only the owner or an approved spender can transfer the token. if (owner != from || owner != caller) &amp;&amp; !self.is_approved_for_all(from, caller) { if let Some(approved) = self.approved_for(token_id) { if approved != caller { self.env().revert(Error::NotAnOwnerOrApproved); } } else { self.env().revert(Error::NotAnOwnerOrApproved); } } ... }  Let's fix it by redesigning our little system. ","version":"2.2.0","tagName":"h2"},{"title":"Redesign​","type":1,"pageTitle":"Ticketing System","url":"/docs/2.2.0/tutorials/nft#redesign","content":"Since a buyer cannot purchase a ticket directly, we need to introduce an intermediary — an operator who will be responsible for buying tickets on behalf of the buyer. The operator will be approved by the ticket office to transfer tickets. The sequence diagram below illustrates the new flow: ","version":"2.2.0","tagName":"h2"},{"title":"Ticket Operator Contract​","type":1,"pageTitle":"Ticketing System","url":"/docs/2.2.0/tutorials/nft#ticket-operator-contract","content":"As shown in the sequence diagram, a new contract will act as an operator for the ticket office. To create this new contract, use the cargo odra generate command. cargo odra generate -c ticket_operator  src/ticket_operator.rs use crate::token::{TicketId, TicketOfficeContractRef}; use odra::{casper_types::{U256, U512}, ContractRef, prelude::*}; #[odra::odra_error] pub enum Error { UnknownTicketOffice = 300, } #[odra::module(errors = Error)] pub struct TicketOperator { ticket_office_address: Var&lt;Address&gt;, } #[odra::module] impl TicketOperator { pub fn register(&amp;mut self, ticket_office_address: Address) { self.ticket_office_address.set(ticket_office_address); } // now the operator's `buy_ticket` receives funds. #[odra(payable)] pub fn buy_ticket(&amp;mut self, ticket_id: TicketId) { let env = self.env(); let buyer = env.caller(); let value = env.attached_value(); let center = self .ticket_office_address .get() .unwrap_or_revert_with(&amp;env, Error::UnknownTicketOffice); let mut ticket_contract = TicketOfficeContractRef::new(env, center); // now and approved entity - the operator - buys the ticket on behalf of the buyer ticket_contract.buy_ticket(ticket_id, buyer, value); } pub fn balance_of(&amp;self) -&gt; U512 { self.env().self_balance() } }  L4-L7 - Define errors that will be used in the contract.L9-L13 - Define the TicketOperator module that stores the address of the ticketing office.L16-L18 - The register function sets the address of the ticketing office.L20-L32 - The buy_ticket function buys a ticket on behalf of the buyer using the ticket office address. The function forwards the call to the ticketing office contract. We simply create a TicketOfficeContractRef to interact we the TicketOffice contract. Note that, the operator's buy_ticket now receives funds. Now we need to adjust the TicketOffice contract to use the TicketOperator contract to buy tickets. src/token.rs #[odra::odra_error] pub enum Error { ... MissingOperator = 204, Unauthorized = 205, } #[odra::module] pub struct TicketOffice { ... operator: Var&lt;Address&gt;, } #[odra::module] impl TicketOffice { ... pub fn register_operator(&amp;mut self, operator: Address) { // only the owner can register an operator let caller = self.env().caller(); self.ownable.assert_owner(&amp;caller); // store the ticketing center address in the operator contract TicketOperatorContractRef::new(self.env(), operator).register(self.env().self_address()); self.operator.set(operator); } pub fn issue_ticket(&amp;mut self, event_name: String, price: U512) { // minting logic remains the same... ... // approve the operator to transfer the ticket let operator = self.operator(); self.token.approve(operator, ticket_id); // emit an event ... } pub fn buy_ticket(&amp;mut self, ticket_id: TicketId, buyer: Address, value: U512) { let env = self.env(); let owner = self.ownable.get_owner(); let caller = env.caller(); // make sure the caller is the operator if !self.is_operator(caller) { env.revert(Error::Unauthorized); } ... // the logic remains the same, except for the csprs transfer // it is now handled by the operator contract. // env.transfer_tokens(&amp;owner, &amp;value); } #[inline] fn is_operator(&amp;self, caller: Address) -&gt; bool { Some(caller) == self.operator.get() } #[inline] fn operator(&amp;self) -&gt; Address { self.operator .get() .unwrap_or_revert_with(&amp;self.env(), Error::MissingOperator) } }  L11 - the contract stores the operator address.L18-L25 - a new function register_operator allows the owner to register an operator. Also calls the register entry point on the operator contract.L32-36 - modify the issue_ticket function: once a new token is minted, approves the operator to transfer the ticket later.L40-L53 - modify the buy_ticket function: check if the caller is the operator, do not transfer cspr to the contract - now the operator collect funds.We also added two helper functions: is_operator and operator to check if the caller is the operator and get the operator address. Two new errors were added: MissingOperator and Unauthorized. Now we need to update our tests to create a scenario we presented in the sequence diagram. src/tests.rs use odra::{ casper_types::U512, host::{Deployer, HostRef, NoArgs}, prelude::* }; use crate::{ ticket_operator::TicketOperatorHostRef, token::{Error, TicketId, TicketOfficeContractRef, TicketOfficeInitArgs}, }; #[test] fn it_works() { let env = odra_test::env(); let init_args = TicketOfficeInitArgs { collection_name: &quot;Ticket&quot;.to_string(), collection_symbol: &quot;T&quot;.to_string(), total_supply: 100, }; let operator = TicketOperator::deploy(&amp;env, NoArgs); let mut ticket_office = TicketOfficeContractRef::deploy(&amp;env, init_args); ticket_office.register_operator(operator.address().clone()); ticket_office.issue_ticket(&quot;Ev&quot;.to_string(), U512::from(100)); ticket_office.issue_ticket(&quot;Ev&quot;.to_string(), U512::from(50)); let buyer = env.get_account(1); env.set_caller(buyer); assert_eq!( buy_ticket(&amp;operator, 0.into(), 50), Err(Error::InsufficientFunds.into()) ); assert_eq!(buy_ticket(&amp;operator, 0.into(), 100), Ok(())); assert_eq!(buy_ticket(&amp;operator, 1.into(), 50), Ok(())); assert_eq!( buy_ticket(&amp;operator, 0.into(), 100), Err(Error::TicketNotAvailableForSale.into()) ); assert_eq!(operator.balance_of(), U512::from(150)); } fn buy_ticket(operator: &amp;TicketOperatorHostRef, id: TicketId, price: u64) -&gt; OdraResult&lt;()&gt; { operator.with_tokens(U512::from(price)).try_buy_ticket(id) }  ","version":"2.2.0","tagName":"h3"},{"title":"Conclusion​","type":1,"pageTitle":"Ticketing System","url":"/docs/2.2.0/tutorials/nft#conclusion","content":"In this tutorial, we created a simple ticketing system using the CEP-95 standard. This guide demonstrates how to combine various Odra features, including modules, events, errors, payable functions, and cross-contract calls. ","version":"2.2.0","tagName":"h2"},{"title":"OwnedToken","type":0,"sectionRef":"#","url":"/docs/2.2.0/tutorials/owned-token","content":"","keywords":"","version":"2.2.0"},{"title":"Code​","type":1,"pageTitle":"OwnedToken","url":"/docs/2.2.0/tutorials/owned-token#code","content":"What should our module be capable of? Conform the Erc20 interface.Allow only the module owner to mint tokens.Enable the current owner to designate a new owner. ","version":"2.2.0","tagName":"h2"},{"title":"Module definition​","type":1,"pageTitle":"OwnedToken","url":"/docs/2.2.0/tutorials/owned-token#module-definition","content":"Let's define a module called OwnedToken that is a composition of Ownable and Erc20 modules. owned_token.rs use crate::{erc20::Erc20, ownable::Ownable}; use odra::prelude::*; #[odra::module] pub struct OwnedToken { ownable: SubModule&lt;Ownable&gt;, erc20: SubModule&lt;Erc20&gt; }  As you can see, we do not need any storage definition - we just take advantage of the already-defined modules! ","version":"2.2.0","tagName":"h3"},{"title":"Delegation​","type":1,"pageTitle":"OwnedToken","url":"/docs/2.2.0/tutorials/owned-token#delegation","content":"owned_token.rs ... use odra::casper_types::U256; ... #[odra::module] impl OwnedToken { pub fn init(&amp;mut self, name: String, symbol: String, decimals: u8, initial_supply: U256) { let deployer = self.env().caller(); self.ownable.init(deployer); self.erc20.init(name, symbol, decimals, initial_supply); } pub fn name(&amp;self) -&gt; String { self.erc20.name() } pub fn symbol(&amp;self) -&gt; String { self.erc20.symbol() } pub fn decimals(&amp;self) -&gt; u8 { self.erc20.decimals() } pub fn total_supply(&amp;self) -&gt; U256 { self.erc20.total_supply() } pub fn balance_of(&amp;self, address: &amp;Address) -&gt; U256 { self.erc20.balance_of(address) } pub fn allowance(&amp;self, owner: &amp;Address, spender: &amp;Address) -&gt; U256 { self.erc20.allowance(owner, spender) } pub fn transfer(&amp;mut self, recipient: &amp;Address, amount: &amp;U256) { self.erc20.transfer(recipient, amount); } pub fn transfer_from(&amp;mut self, owner: &amp;Address, recipient: &amp;Address, amount: &amp;U256) { self.erc20.transfer_from(owner, recipient, amount); } pub fn approve(&amp;mut self, spender: &amp;Address, amount: &amp;U256) { self.erc20.approve(spender, amount); } pub fn get_owner(&amp;self) -&gt; Address { self.ownable.get_owner() } pub fn change_ownership(&amp;mut self, new_owner: &amp;Address) { self.ownable.change_ownership(new_owner); } pub fn mint(&amp;mut self, address: &amp;Address, amount: &amp;U256) { self.ownable.ensure_ownership(&amp;self.env().caller()); self.erc20.mint(address, amount); } }  Easy. However, there are a few worth mentioning subtleness: L9-L10 - A constructor is an excellent place to initialize both modules at once.L13-L15 - Most of the entrypoints do not need any modification, so we simply delegate them to the erc20 module.L49-L51 - The same is done with the ownable module.L57-L60 - Minting should not be unconditional, we need some control over it. First, using ownable we make sure the caller really is indeed the owner. ","version":"2.2.0","tagName":"h3"},{"title":"Summary​","type":1,"pageTitle":"OwnedToken","url":"/docs/2.2.0/tutorials/owned-token#summary","content":"The Odra Framework encourages a modularized design of your smart contracts. You can encapsulate features in smaller units and test them in isolation, ensuring your project is easy to maintain. Finally, unleash their full potential by combining modules. You do not need any magic bindings for that. ","version":"2.2.0","tagName":"h2"},{"title":"Ownable","type":0,"sectionRef":"#","url":"/docs/2.2.0/tutorials/ownable","content":"","keywords":"","version":"2.2.0"},{"title":"Framework features​","type":1,"pageTitle":"Ownable","url":"/docs/2.2.0/tutorials/ownable#framework-features","content":"A module we will write in a minute, will help you master a few Odra features: storing a single value,defining a constructor,error handling,defining and emitting events.registering a contact in a test environment,interactions with the test environment,assertions (value, events, errors assertions). ","version":"2.2.0","tagName":"h2"},{"title":"Code​","type":1,"pageTitle":"Ownable","url":"/docs/2.2.0/tutorials/ownable#code","content":"Before we write any code, we define functionalities we would like to implement. Module has an initializer that should be called once. Only the current owner can set a new owner.Read the current owner.A function that fails if called by a non-owner account. ","version":"2.2.0","tagName":"h2"},{"title":"Define a module​","type":1,"pageTitle":"Ownable","url":"/docs/2.2.0/tutorials/ownable#define-a-module","content":"ownable.rs use odra::prelude::*; #[odra::module(events = [OwnershipChanged])] pub struct Ownable { owner: Var&lt;Option&lt;Address&gt;&gt; }  That was easy, but it is crucial to understand the basics before we move on. L3 - Firstly, we need to create a struct called Ownable and apply #[odra::module(events = [OwnershipChanged])] attribute to it. The events attribute is optional but informs the Odra toolchain about the events that will be emitted by the module and includes them in the contract's metadata. OwnershipChanged is a type that will be defined later.L5 - Then we can define the layout of our module. It is extremely simple - just a single state value. What is most important is that you can never leave a raw type; you must always wrap it with Var. ","version":"2.2.0","tagName":"h3"},{"title":"Init the module​","type":1,"pageTitle":"Ownable","url":"/docs/2.2.0/tutorials/ownable#init-the-module","content":"ownable.rs #[odra::module] impl Ownable { pub fn init(&amp;mut self, owner: Address) { if self.owner.get_or_default().is_some() { self.env().revert(Error::OwnerIsAlreadyInitialized) } self.owner.set(Some(owner)); self.env().emit_event(OwnershipChanged { prev_owner: None, new_owner: owner }); } } #[odra::odra_error] pub enum Error { OwnerIsAlreadyInitialized = 1, } #[odra::event] pub struct OwnershipChanged { pub prev_owner: Option&lt;Address&gt;, pub new_owner: Address }  Ok, we have done a couple of things, let's analyze them one by one: L1 - The impl should be an Odra module, so add #[odra::module].L3 - The init function is a constructor. This matters if we would like to deploy the Ownable module as a standalone contract.L17-L20 - Before we set a new owner, we must assert there was no owner before and raise an error otherwise. For that purpose, we defined an Error enum. Notice that the #[odra::odra_error] attribute is applied to the enum. It generates, among others, the required Into&lt;odra::OdraError&gt; binding.L4-L6 - If the owner has been set already, we call ContractEnv::revert() function with an Error::OwnerIsAlreadyInitialized argument. L8 - Then we write the owner passed as an argument to the storage. To do so, we call the set() on Var.L22-L26 - Once the owner is set, we would like to inform the outside world. The first step is to define an event struct. The struct annotated with #[odra::event] attribute.L10 - Finally, call ContractEnv::emit_event() passing the OwnershipChanged instance to the function. Hence, we set the first owner, we set the prev_owner value to None.  ","version":"2.2.0","tagName":"h3"},{"title":"Features implementation​","type":1,"pageTitle":"Ownable","url":"/docs/2.2.0/tutorials/ownable#features-implementation","content":"ownable.rs #[odra::module] impl Ownable { ... pub fn ensure_ownership(&amp;self, address: &amp;Address) { if Some(address) != self.owner.get_or_default().as_ref() { self.env().revert(Error::NotOwner) } } pub fn change_ownership(&amp;mut self, new_owner: &amp;Address) { self.ensure_ownership(&amp;self.env().caller()); let current_owner = self.get_owner(); self.owner.set(Some(*new_owner)); self.env().emit_event(OwnershipChanged { prev_owner: Some(current_owner), new_owner: *new_owner }); } pub fn get_owner(&amp;self) -&gt; Address { match self.owner.get_or_default() { Some(owner) =&gt; owner, None =&gt; self.env().revert(Error::OwnerIsNotInitialized) } } } #[odra::odra_error] pub enum Error { NotOwner = 1, OwnerIsAlreadyInitialized = 2, OwnerIsNotInitialized = 3, }  The above implementation relies on the concepts we have already used in this tutorial, so it should be easy for you to get along. L7,L31 - ensure_ownership() reads the current owner and reverts if it does not match the input Address. Also, we need to update our Error enum by adding a new variant NotOwner.L11 - The function defined above can be reused in the change_ownership() implementation. We pass to it the current caller, using the ContractEnv::caller() function. Then we update the state and emit OwnershipChanged.L21,L33 - Lastly, a getter function. Read the owner from storage, if the getter is called on an uninitialized module, it should revert with a new Error variant OwnerIsNotInitialized. There is one worth-mentioning subtlety: Var::get() function returns Option&lt;T&gt;. If the type implements the Default trait, you can call the get_or_default() function, and the contract does not fail even if the value is not initialized. As the owner is of type Option&lt;Address&gt; the Var::get() would return Option&lt;Option&lt;Address&gt;&gt;, we use Var::get_or_default() instead. ","version":"2.2.0","tagName":"h3"},{"title":"Test​","type":1,"pageTitle":"Ownable","url":"/docs/2.2.0/tutorials/ownable#test","content":"ownable.rs #[cfg(test)] mod tests { use super::*; use odra::host::{Deployer, HostEnv}; fn setup() -&gt; (OwnableHostRef, HostEnv, Address) { let env: HostEnv = odra_test::env(); let init_args = OwnableInitArgs { owner: env.get_account(0) }; (Ownable::deploy(&amp;env, init_args), env.clone(), env.get_account(0)) } #[test] fn initialization_works() { let (ownable, env, owner) = setup(); assert_eq!(ownable.get_owner(), owner); env.emitted_event( &amp;ownable, OwnershipChanged { prev_owner: None, new_owner: owner } ); } #[test] fn owner_can_change_ownership() { let (mut ownable, env, owner) = setup(); let new_owner = env.get_account(1); env.set_caller(owner); ownable.change_ownership(&amp;new_owner); assert_eq!(ownable.get_owner(), new_owner); env.emitted_event( &amp;ownable, OwnershipChanged { prev_owner: Some(owner), new_owner } ); } #[test] fn non_owner_cannot_change_ownership() { let (mut ownable, env, _) = setup(); let new_owner = env.get_account(1); ownable.change_ownership(&amp;new_owner); assert_eq!( ownable.try_change_ownership(&amp;new_owner), Err(Error::NotOwner.into()) ); } }  L6 - Each test case starts with the same initialization process, so for convenience, we have defined the setup() function, which we call in the first statement of each test. Take a look at the signature: fn setup() -&gt; (OwnableHostRef, HostEnv, Address). OwnableHostRef is a contract reference generated by Odra. This reference allows us to call all the defined entrypoints, namely: ensure_ownership(), change_ownership(), get_owner(), but not init(), which is a constructor.L7-L11 - The starting point of every test is getting an instance of HostEnv by calling odra_test::env(). Our function returns a triple: a contract ref, an env, and an address (the initial owner). Odra's #[odra::module] attribute implements a odra::host::Deployer for Ownable, and OwnableInitArgs that we pass as the second argument of the odra::host::Deployer::deploy() function. Lastly, the module needs an owner. The easiest way is to take one from the HostEnv. We choose the address of first account (which is the default one). L14 - It is time to define the first test. As you see, it is a regular Rust test.L16-17 - Using the setup() function, we get the owner and a reference (in this test, we don't use the env, so we ignore it). We make a standard assertion, comparing the owner we know with the value returned from the contract. note You may have noticed, we use here the term module interchangeably with contract. The reason is once we deploy our module onto a virtual blockchain it may be considered a contract. L19-25 - On the contract, only the init() function has been called, so we expect one event to have been emitted. To assert that, let's use HostEnv. To get the env, we call env() on the contract, then call HostEnv::emitted_event. As the first argument, pass the contract you want to read events from, followed by an event as you expect it to have occurred.L31 - Because we know the initial owner is the 0th account, we must select a different account. It could be any index from 1 to 19 - the HostEnv predefines 20 accounts.L33 - As mentioned, the default is the 0th account, if you want to change the executor, call the HostEnv::set_caller() function. note The caller switch applies only the next contract interaction, the second call will be done as the default account. L46-55 - If a non-owner account tries to change ownership, we expect it to fail. To capture the error, call HostEnv::try_change_ownership() instead of HostEnv::change_ownership(). HostEnv provides try_ functions for each contract's entrypoint. The try functions return OdraResult (an alias for Result&lt;T, OdraError&gt;) instead of panicking and halting the execution. In our case, we expect the contract to revert with the Error::NotOwner error. To compare the error, we use the Error::into() function, which converts the error into the OdraError type. ","version":"2.2.0","tagName":"h3"},{"title":"Summary​","type":1,"pageTitle":"Ownable","url":"/docs/2.2.0/tutorials/ownable#summary","content":"The Ownable module is ready, and we can test it against any defined backend. Theoretically it can be deployed as a standalone contract, but in upcoming tutorials you will see how to use it to compose a more complex contract. ","version":"2.2.0","tagName":"h2"},{"title":"What's next​","type":1,"pageTitle":"Ownable","url":"/docs/2.2.0/tutorials/ownable#whats-next","content":"In the next tutorial we will implement a ERC20 standard. ","version":"2.2.0","tagName":"h2"},{"title":"Odra framework","type":0,"sectionRef":"#","url":"/docs/2.3.0/","content":"","keywords":"","version":"2.3.0"},{"title":"What's next​","type":1,"pageTitle":"Odra framework","url":"/docs/2.3.0/#whats-next","content":"See the Installation and our Flipper example to find out how to start your new project with Odra. ","version":"2.3.0","tagName":"h2"},{"title":"Pausable","type":0,"sectionRef":"#","url":"/docs/2.2.0/tutorials/pauseable","content":"","keywords":"","version":"2.2.0"},{"title":"Code​","type":1,"pageTitle":"Pausable","url":"/docs/2.2.0/tutorials/pauseable#code","content":"As always, we will start with defining functionalities of our module. Check the state - is it paused or not.State guards - a contract should stop execution if is in a state we don't expect.Switch the state. ","version":"2.2.0","tagName":"h2"},{"title":"Events and Error​","type":1,"pageTitle":"Pausable","url":"/docs/2.2.0/tutorials/pauseable#events-and-error","content":"There just two errors that may occur: PausedRequired, UnpausedRequired. We define them in a standard Odra way. Events definition is highly uncomplicated: Paused and Unpaused events holds only the address of the pauser. pauseable.rs use odra::prelude::*; #[odra::odra_error] pub enum Error { PausedRequired = 1_000, UnpausedRequired = 1_001, } #[odra::event] pub struct Paused { pub account: Address } #[odra::event] pub struct Unpaused { pub account: Address }  ","version":"2.2.0","tagName":"h3"},{"title":"Module definition​","type":1,"pageTitle":"Pausable","url":"/docs/2.2.0/tutorials/pauseable#module-definition","content":"The module storage is extremely simple - has a single Var of type bool, that indicates if a contract is paused. pauseable.rs #[odra::module(events = [Paused, Unpaused], errors = Error)] pub struct Pausable { is_paused: Var&lt;bool&gt; }  ","version":"2.2.0","tagName":"h3"},{"title":"Checks and guards​","type":1,"pageTitle":"Pausable","url":"/docs/2.2.0/tutorials/pauseable#checks-and-guards","content":"Now, let's move to state checks and guards. pauseable.rs impl Pausable { pub fn is_paused(&amp;self) -&gt; bool { self.is_paused.get_or_default() } pub fn require_not_paused(&amp;self) { if self.is_paused() { self.env().revert(Error::UnpausedRequired); } } pub fn require_paused(&amp;self) { if !self.is_paused() { self.env().revert(Error::PausedRequired); } } }  L1 - as mentioned in the intro, the module is not intended to be a standalone contract, so the only impl block is not annotated with odra::module and hence does not expose any entrypoint.L2 - is_paused() checks the contract state, if the Var is_paused has not been initialized, the default value (false) is returned.L6 - to guarantee the code is executed when the contract is not paused, require_not_paused() function reads the state and reverts if the contract is paused. L12 - require_paused() is a mirror function - stops the contract execution if the contract is not paused. ","version":"2.2.0","tagName":"h3"},{"title":"Actions​","type":1,"pageTitle":"Pausable","url":"/docs/2.2.0/tutorials/pauseable#actions","content":"Finally, we will add the ability to switch the module state. pauseable.rs impl Pausable { pub fn pause(&amp;mut self) { self.require_not_paused(); self.is_paused.set(true); self.env().emit_event(Paused { account: self.env().caller() }); } pub fn unpause(&amp;mut self) { self.require_paused(); self.is_paused.set(false); self.env().emit_event(Unpaused { account: self.env().caller() }); } }  pause() and unpause() functions do three things: ensure the contract is the right state (unpaused for pause(), not paused for unpause()), updates the state, and finally emits events (Paused/Unpaused). ","version":"2.2.0","tagName":"h3"},{"title":"Pausable counter​","type":1,"pageTitle":"Pausable","url":"/docs/2.2.0/tutorials/pauseable#pausable-counter","content":"In the end, let's use the module in a contract. For this purpose, we will implement a mock contract called PausableCounter. The contract consists of a Var value and a Pausable module. The counter can only be incremented if the contract is in a normal state (is not paused). pauseable.rs ... #[odra::module] pub struct PausableCounter { value: Var&lt;u32&gt;, pauseable: SubModule&lt;Pausable&gt; } #[odra::module] impl PausableCounter { pub fn increment(&amp;mut self) { self.pauseable.require_not_paused(); let new_value = self.value.get_or_default() + 1; self.value.set(new_value); } pub fn pause(&amp;mut self) { self.pauseable.pause(); } pub fn unpause(&amp;mut self) { self.pauseable.unpause(); } pub fn get_value(&amp;self) -&gt; u32 { self.value.get_or_default() } } #[cfg(test)] mod test { use super::*; use odra::host::{Deployer, NoArgs}; #[test] fn increment_only_if_unpaused() { let test_env = odra_test::env(); let mut contract = PausableCounter::deploy(&amp;test_env, NoArgs); contract.increment(); contract.pause(); assert_eq!( contract.try_increment().unwrap_err(), Error::UnpausedRequired.into() ); assert_eq!(contract.get_value(), 1); } }  As we see in the test, in a simple way, using a single function call we can turn off the counter for a while and freeze the counter. Any time we want we can turn it back on. Easy! ","version":"2.2.0","tagName":"h2"},{"title":"Advanced Storage Concepts","type":0,"sectionRef":"#","url":"/docs/2.3.0/advanced/advanced-storage","content":"","keywords":"","version":"2.3.0"},{"title":"Recap and Basic Concepts​","type":1,"pageTitle":"Advanced Storage Concepts","url":"/docs/2.3.0/advanced/advanced-storage#recap-and-basic-concepts","content":"Before we delve into the advanced features, let's recap some basic storage concepts in Odra. In the realm of basic storage interaction, Odra provides several types for interacting with contract storage, including Var, Mapping, and List. These types enable contracts to store and retrieve data in a structured manner. The Var type is used to store a single value, while the List and Mapping types store collections of values. Var: A Var in Odra is a fundamental building block used for storing single values. Each Var is uniquely identified by its name in the contract. Mapping: Mapping in Odra serves as a key-value storage system. It stores an association of unique keys to values, and the value can be retrieved using the key. List: Built on top of the Var and Mapping building blocks, List in Odra allows storing an ordered collection of values that can be iterated over. If you need a refresher on these topics, please refer to our guide on basic storage in Odra. ","version":"2.3.0","tagName":"h2"},{"title":"Advanced Storage Concepts​","type":1,"pageTitle":"Advanced Storage Concepts","url":"/docs/2.3.0/advanced/advanced-storage#advanced-storage-concepts-1","content":"","version":"2.3.0","tagName":"h2"},{"title":"Sequence​","type":1,"pageTitle":"Advanced Storage Concepts","url":"/docs/2.3.0/advanced/advanced-storage#sequence","content":"The Sequence in Odra is a basic module that stores a single value in the storage that can be read or incremented. Internally, holds a Var which keeps track of the current value. pub struct Sequence&lt;T&gt; where T: Num + One + ToBytes + FromBytes + CLTyped { value: Var&lt;T&gt; }  The Sequence module provides functions get_current_value and next_value to get the current value and increment the value respectively. ","version":"2.3.0","tagName":"h3"},{"title":"Advanced Mapping​","type":1,"pageTitle":"Advanced Storage Concepts","url":"/docs/2.3.0/advanced/advanced-storage#advanced-mapping","content":"In Odra, a Mapping is a key-value storage system where the key is associated with a value. In previous examples, the value of the Mapping typically comprised a standard serializable type (such as number, string, or bool) or a custom type marked with the #[odra::odra_type] attribute. However, there are more advanced scenarios where the value of the Mapping represents a module itself. This approach is beneficial when managing a collection of modules, each maintaining its unique state. Let's consider the following example: examples/src/features/storage/mapping.rs use odra::casper_types::U256; use odra::prelude::*; use crate::owned_token::OwnedToken; #[odra::module] pub struct Mappings { strings: Mapping&lt;(String, u32, String), String&gt;, tokens: Mapping&lt;String, OwnedToken&gt; } #[odra::module] impl Mappings { ... pub fn total_supply(&amp;mut self, token_name: String) -&gt; U256 { self.tokens.module(&amp;token_name).total_supply() } pub fn get_string_api( &amp;self, key1: String, key2: u32, key3: String ) -&gt; String { let opt_string = self.strings.get(&amp;(key1, key2, key3)); opt_string.unwrap_or_revert(&amp;self.env()) } }  As you can see, a Mapping key can consist of a tuple of values, not limited to a single value. note Accessing Odra modules differs from accessing regular values such as strings or numbers. Firstly, within a Mapping, you don't encapsulate the module with Submodule. Secondly, rather than utilizing the Mapping::get() function, call Mapping::module(), which returns SubModule&lt;T&gt; and sets the appropriate namespace for nested modules. ","version":"2.3.0","tagName":"h3"},{"title":"AdvancedStorage Contract​","type":1,"pageTitle":"Advanced Storage Concepts","url":"/docs/2.3.0/advanced/advanced-storage#advancedstorage-contract","content":"The given code snippet showcases the AdvancedStorage contract that incorporates these storage concepts. use odra::casper_types::U512; use odra::prelude::*; use crate::modules::Token; #[odra::module] pub struct AdvancedStorage { counter: Sequence&lt;u32&gt;, tokens: Mapping&lt;(String, String), Token&gt;, } impl AdvancedStorage { pub fn current_value(&amp;self) -&gt; u32 { self.counter.get_current_value() } pub fn increment_and_get(&amp;mut self) -&gt; u32 { self.counter.next_value() } pub fn balance_of(&amp;mut self, token_name: String, creator: String, address: Address) -&gt; U512 { let token = self.tokens.module(&amp;(token_name, creator)); token.balance_of(&amp;address) } pub fn mint(&amp;self, token_name: String, creator: String, amount: U512, to: Address) { let mut token = self.tokens.module(&amp;(token_name, creator)); token.mint(amount, to); } }  ","version":"2.3.0","tagName":"h2"},{"title":"Conclusion​","type":1,"pageTitle":"Advanced Storage Concepts","url":"/docs/2.3.0/advanced/advanced-storage#conclusion","content":"Advanced storage features in Odra offer robust options for managing contract state. Two key takeaways from this document are: Odra offers a Sequence module, enabling contracts to store and increment a single value.Mappings support composite keys expressed as tuples and can store modules as values. Understanding these concepts can help developers design and implement more efficient and flexible smart contracts. ","version":"2.3.0","tagName":"h2"},{"title":"Using Proxy Caller","type":0,"sectionRef":"#","url":"/docs/2.2.0/tutorials/using-proxy-caller","content":"","keywords":"","version":"2.2.0"},{"title":"Contract​","type":1,"pageTitle":"Using Proxy Caller","url":"/docs/2.2.0/tutorials/using-proxy-caller#contract","content":"For this tutorial, we will use the TimeLockWallet contract from our examples. examples/src/contracts/tlw.rs use odra::prelude::*; use odra::casper_types::U512; #[odra::module(errors = Error, events = [Deposit, Withdrawal])] pub struct TimeLockWallet { balances: Mapping&lt;Address, U512&gt;, lock_expiration_map: Mapping&lt;Address, u64&gt;, lock_duration: Var&lt;u64&gt; } #[odra::module] impl TimeLockWallet { /// Initializes the contract with the lock duration. pub fn init(&amp;mut self, lock_duration: u64) { self.lock_duration.set(lock_duration); } /// Deposits the tokens into the contract. #[odra(payable)] pub fn deposit(&amp;mut self) { // Extract values let caller: Address = self.env().caller(); let amount: U512 = self.env().attached_value(); let current_block_time: u64 = self.env().get_block_time(); // Multiple lock check if self.balances.get(&amp;caller).is_some() { self.env().revert(Error::CannotLockTwice) } // Update state, emit event self.balances.set(&amp;caller, amount); self.lock_expiration_map .set(&amp;caller, current_block_time + self.lock_duration()); self.env().emit_event(Deposit { address: caller, amount }); } /// Withdraws the tokens from the contract. pub fn withdraw(&amp;mut self, amount: &amp;U512) { // code omitted for brevity } /// Returns the balance of the given account. pub fn get_balance(&amp;self, address: &amp;Address) -&gt; U512 { // code omitted for brevity } /// Returns the lock duration. pub fn lock_duration(&amp;self) -&gt; u64 { // code omitted for brevity } } /// Errors that may occur during the contract execution. #[odra::odra_error] pub enum Error { LockIsNotOver = 1, CannotLockTwice = 2, InsufficientBalance = 3 } /// Deposit event. #[odra::event] pub struct Deposit { pub address: Address, pub amount: U512 } /// Withdrawal event. #[odra::event] pub struct Withdrawal { pub address: Address, pub amount: U512 }  Full code can be found in our Github repo. ","version":"2.2.0","tagName":"h2"},{"title":"Client​","type":1,"pageTitle":"Using Proxy Caller","url":"/docs/2.2.0/tutorials/using-proxy-caller#client","content":"Before we can interact with the node, we need to set it up. We will use the casper-nctl-docker image. docker run --rm -it --name mynctl -d -p 11101:11101 -p 14101:14101 -p 18101:18101 makesoftware/casper-nctl  Make sure you have the contract's wasm file and the secret key. # Build the contract cargo odra build -c TimeLockWallet # Extract secret key docker exec mynctl /bin/bash -c &quot;cat /home/casper/casper-node/utils/nctl/assets/net-1/users/user-1/secret_key.pem&quot; &gt; your/path/secret_key.pem  RustTypeScript To interact with the contract, we use the livenet backend. It allows to write the code in the same manner as the test code, but it interacts with the live network (a local node in our case). Cargo.toml [package] name = &quot;odra-examples&quot; version = &quot;2.2.0&quot; edition = &quot;2021&quot; [dependencies] odra = { path = &quot;../odra&quot;, default-features = false } ... # other dependencies odra-casper-livenet-env = { version = &quot;2.2.0&quot;, optional = true } ... # other sections [features] default = [] livenet = [&quot;odra-casper-livenet-env&quot;] ... # other sections [[bin]] name = &quot;tlw_on_livenet&quot; path = &quot;bin/tlw_on_livenet.rs&quot; required-features = [&quot;livenet&quot;] test = false ... # other sections examples/bin/tlw_on_livenet.rs //! Deploys an [odra_examples::contracts::tlw::TimeLockWallet] contract, then deposits and withdraw some CSPRs. use odra::casper_types::{AsymmetricType, PublicKey, U512}; use odra::host::{Deployer, HostRef}; use odra::prelude::*; use odra_examples::contracts::tlw::{TimeLockWallet, TimeLockWalletInitArgs}; const DEPOSIT: u64 = 100; const WITHDRAWAL: u64 = 99; const GAS: u64 = 20u64.pow(9); fn main() { let env = odra_casper_livenet_env::env(); let caller = env.get_account(0); env.set_caller(caller); env.set_gas(GAS); let mut contract = TimeLockWallet::deploy( &amp;env, TimeLockWalletInitArgs { lock_duration: 60 * 60 } ); // Send 100 CSPRs to the contract. contract .with_tokens(U512::from(DEPOSIT)) .deposit(); println!(&quot;Caller's balance: {:?}&quot;, contract.get_balance(&amp;caller)); // Withdraw 99 CSPRs from the contract. contract.withdraw(&amp;U512::from(WITHDRAWAL)); println!(&quot;Remaining balance: {:?}&quot;, contract.get_balance(&amp;caller)); } To run the code, execute the following command: ODRA_CASPER_LIVENET_SECRET_KEY_PATH=path/to/secret_key.pem \\ ODRA_CASPER_LIVENET_NODE_ADDRESS=[NODE_ADDRESS] \\ ODRA_CASPER_LIVENET_CHAIN_NAME=casper-test \\ ODRA_CASPER_LIVENET_EVENTS_URL=[EVENTS_STREAM_ADDRESS] \\ cargo run --bin tlw_on_livenet --features=livenet Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.09s Running `../target/debug/tlw_on_livenet` 💁 INFO : Found wasm under &quot;/Users/kpob/workspace/odra/examples/wasm/TimeLockWallet.wasm&quot;. 💁 INFO : Deploying &quot;TimeLockWallet&quot;. 🙄 WAIT : Waiting 10 for V1(TransactionV1Hash(5ab45ba29c9e7b9a91c4b5a5fbd2ba31735f03f99f94dce542d3584c8776ce8a)). 🙄 WAIT : Waiting 10 for V1(TransactionV1Hash(5ab45ba29c9e7b9a91c4b5a5fbd2ba31735f03f99f94dce542d3584c8776ce8a)). 💁 INFO : Transaction &quot;5ab45ba29c9e7b9a91c4b5a5fbd2ba31735f03f99f94dce542d3584c8776ce8a&quot; successfully executed. 🔗 LINK : https://testnet.cspr.live/transaction/5ab45ba29c9e7b9a91c4b5a5fbd2ba31735f03f99f94dce542d3584c8776ce8a 💁 INFO : Contract &quot;contract-package-fe69f4dd63445cda6cdc3b4c066760227208a752857950af6bda8a41600781ea&quot; deployed. 💁 INFO : Calling &quot;contract-package-fe69f4dd63445cda6cdc3b4c066760227208a752857950af6bda8a41600781ea&quot; with entrypoint &quot;deposit&quot; through proxy. 🙄 WAIT : Waiting 10 for V1(TransactionV1Hash(86d07f72dc9383f46144b5fdfd912ddf15c7be539cf2c34e43f1214244da25b3)). 💁 INFO : Transaction &quot;86d07f72dc9383f46144b5fdfd912ddf15c7be539cf2c34e43f1214244da25b3&quot; successfully executed. 🔗 LINK : https://testnet.cspr.live/transaction/86d07f72dc9383f46144b5fdfd912ddf15c7be539cf2c34e43f1214244da25b3 Owner's balance: 100 💁 INFO : Calling &quot;contract-package-fe69f4dd63445cda6cdc3b4c066760227208a752857950af6bda8a41600781ea&quot; directly with entrypoint &quot;withdraw&quot;. 🙄 WAIT : Waiting 10 for V1(TransactionV1Hash(cbdedd1d5f528754904feb23a0e2087a53ed6f6ed27298367a98bc2accc5792f)). 💁 INFO : Transaction &quot;cbdedd1d5f528754904feb23a0e2087a53ed6f6ed27298367a98bc2accc5792f&quot; successfully executed. 🔗 LINK : https://testnet.cspr.live/transaction/cbdedd1d5f528754904feb23a0e2087a53ed6f6ed27298367a98bc2accc5792f Remaining balance: 1 As observed, the contract was successfully deployed, and the Caller deposited tokens. Subsequently, the caller withdrew 99 CSPRs from the contract, leaving the contract's balance at 1 CSPR. The logs display deploy hashes, the contract's hash, and even indicate if the call was made through the proxy, providing a comprehensive overview of the on-chain activity. ","version":"2.2.0","tagName":"h2"},{"title":"Conclusion​","type":1,"pageTitle":"Using Proxy Caller","url":"/docs/2.2.0/tutorials/using-proxy-caller#conclusion","content":"In this tutorial, we learned how to use the proxy_caller wasm to make a payable function call. We deployed the TimeLockWallet contract, deposited tokens using the proxy_caller with attached CSPRs, and withdrew them. You got to try it out in both Rust and TypeScript, so you can choose whichever you prefer. Rust code seemed simpler, thanks to the Odra livenet backend making chain interactions easier to handle. ","version":"2.2.0","tagName":"h2"},{"title":"Building contracts manually","type":0,"sectionRef":"#","url":"/docs/2.3.0/advanced/building-manually","content":"","keywords":"","version":"2.3.0"},{"title":"Building the contract manually​","type":1,"pageTitle":"Building contracts manually","url":"/docs/2.3.0/advanced/building-manually#building-the-contract-manually","content":"To build the contract manually, cargo odra uses the following command: ODRA_MODULE=my_contract cargo build --release --target wasm32-unknown-unknown --bin my_project_build_contract  info Odra uses the environment variable ODRA_MODULE to determine which contract to build. Assuming that project's crate is named my_project, this command will build the my_contract contract in release mode and generate the wasm file. The file will be put into the target/wasm32-unknown-unknown/release directory under the name my_project_build_contract.wasm. The Odra Framework expects the contracts to be placed in the wasm directory, and to be named correctly, so the next step would be to move the file: mv target/wasm32-unknown-unknown/release/my_project_build_contract.wasm wasm/my_contract.wasm  ","version":"2.3.0","tagName":"h2"},{"title":"Optimizing the contract​","type":1,"pageTitle":"Building contracts manually","url":"/docs/2.3.0/advanced/building-manually#optimizing-the-contract","content":"To lower the size of the wasm file, cargo odra uses the wasm-strip tool: wasm-strip wasm/my_contract.wasm  To further optimize the wasm file, the wasm-opt tool is also used. wasm-opt --signext-lowering wasm/my_contract.wasm -o wasm/my_contract.wasm  danger This step is required, as the wasm file generated by the Rust compiler is not fully compatible with the Casper execution engine. ","version":"2.3.0","tagName":"h2"},{"title":"Running the tests manually​","type":1,"pageTitle":"Building contracts manually","url":"/docs/2.3.0/advanced/building-manually#running-the-tests-manually","content":"To run the tests manually, Odra needs to know which backend to use. To run tests against Casper backend, the following command needs to be used: ODRA_BACKEND=casper cargo test  ","version":"2.3.0","tagName":"h2"},{"title":"Wrapping up​","type":1,"pageTitle":"Building contracts manually","url":"/docs/2.3.0/advanced/building-manually#wrapping-up","content":"Let's say we want to build the my_contract in debug mode, run the tests against the casper backend and use the my-own-allocator feature from our my_project project. To do that, we can use the following set of commands: ODRA_MODULE=my_contract cargo build --target wasm32-unknown-unknown --bin my_project_build_contract mv target/wasm32-unknown-unknown/debug/my_project_build_contract.wasm wasm/my_contract.wasm wasm-strip wasm/my_contract.wasm wasm-opt --signext-lowering wasm/my_contract.wasm -o wasm/my_contract.wasm ODRA_BACKEND=casper cargo test --features my-own-allocator  ","version":"2.3.0","tagName":"h2"},{"title":"Attributes","type":0,"sectionRef":"#","url":"/docs/2.3.0/advanced/attributes","content":"","keywords":"","version":"2.3.0"},{"title":"Payable​","type":1,"pageTitle":"Attributes","url":"/docs/2.3.0/advanced/attributes#payable","content":"When writing a smart contract, you need to make sure that money can be both sent to and extracted from the contract. The 'payable' attribute helps wit this. Any function, except for a constructor, with the #[odra(payable)] attribute can send and take money in the form of native tokens. ","version":"2.3.0","tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"Attributes","url":"/docs/2.3.0/advanced/attributes#example","content":"examples/src/contracts/tlw.rs #[odra(payable)] pub fn deposit(&amp;mut self) { // Extract values let caller: Address = self.env().caller(); let amount: U256 = self.env().attached_value(); let current_block_time: u64 = self.env().get_block_time(); // Multiple lock check if self.balances.get(&amp;caller).is_some() { self.env.revert(Error::CannotLockTwice) } // Update state, emit event self.balances.set(&amp;caller, amount); self.lock_expiration_map .set(&amp;caller, current_block_time + self.lock_duration()); self.env() .emit_event(Deposit { address: caller, amount }); }  If you try to send tokens to a non-payable function, the transaction will be automatically rejected. ","version":"2.3.0","tagName":"h3"},{"title":"Non Reentrant​","type":1,"pageTitle":"Attributes","url":"/docs/2.3.0/advanced/attributes#non-reentrant","content":"Reentrancy attacks in smart contracts exploit the possibility of a function being called multiple times before its initial execution is completed, leading to the repeated unauthorized withdrawal of funds. To prevent such attacks, developers should ensure that all effects on the contract's state and balance checks occur before calling external contracts. They can also use reentrancy guards to block recursive calls to sensitive functions. In Odra you can just apply the #[odra(non_reentrant)] attribute to your function. ","version":"2.3.0","tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"Attributes","url":"/docs/2.3.0/advanced/attributes#example-1","content":"#[odra::module] pub struct NonReentrantCounter { counter: Var&lt;u32&gt; } #[odra::module] impl NonReentrantCounter { #[odra(non_reentrant)] pub fn count_ref_recursive(&amp;mut self, n: u32) { if n &gt; 0 { self.count(); ReentrancyMockRef::new(self.env(), self.env().self_address()).count_ref_recursive(n - 1); } } } impl NonReentrantCounter { fn count(&amp;mut self) { let c = self.counter.get_or_default(); self.counter.set(c + 1); } } #[cfg(test)] mod test { use super::*; use odra::host::{Deployer, NoArgs}; #[test] fn ref_recursion_not_allowed() { let test_env = odra_test::env(); let mut contract = NonReentrantCounter::deploy(&amp;test_env, NoArgs); let result = contract.count_ref_recursive(11); assert_eq!(result, ExecutionError::ReentrantCall.into()); } }  ","version":"2.3.0","tagName":"h3"},{"title":"Mixing attributes​","type":1,"pageTitle":"Attributes","url":"/docs/2.3.0/advanced/attributes#mixing-attributes","content":"A function can accept more than one attribute. The only exclusion is a constructor cannot be payable. To apply multiple attributes, you can write: #[odra(payable, non_reentrant)] fn deposit() { // your logic... }  or #[odra(payable)] #[odra(non_reentrant)] fn deposit() { // your logic... }  In both cases attributes order does not matter. ","version":"2.3.0","tagName":"h2"},{"title":"Delegate","type":0,"sectionRef":"#","url":"/docs/2.3.0/advanced/delegate","content":"","keywords":"","version":"2.3.0"},{"title":"Overview​","type":1,"pageTitle":"Delegate","url":"/docs/2.3.0/advanced/delegate#overview","content":"To utilize the delegate feature in your contract, use the delegate! macro provided by Odra. This macro allows you to list the functions you wish to delegate to the child modules. By using the delegate! macro, your parent module remains clean and easy to understand. You can delegate functions to as many child modules as you like. The functions will be available as if they were implemented in the parent module itself. ","version":"2.3.0","tagName":"h2"},{"title":"Code Examples​","type":1,"pageTitle":"Delegate","url":"/docs/2.3.0/advanced/delegate#code-examples","content":"Consider the following basic example for better understanding: use crate::{erc20::Erc20, ownable::Ownable}; use odra::{casper_types::U256, prelude::*}; #[odra::module] pub struct OwnedToken { ownable: SubModule&lt;Ownable&gt;, erc20: SubModule&lt;Erc20&gt; } #[odra::module] impl OwnedToken { pub fn init(&amp;mut self, name: String, symbol: String, decimals: u8, initial_supply: U256) { let deployer = self.env().caller(); self.ownable.init(deployer); self.erc20.init(name, symbol, decimals, initial_supply); } delegate! { to self.erc20 { fn transfer(&amp;mut self, recipient: Address, amount: U256); fn transfer_from(&amp;mut self, owner: Address, recipient: Address, amount: U256); fn approve(&amp;mut self, spender: Address, amount: U256); fn name(&amp;self) -&gt; String; fn symbol(&amp;self) -&gt; String; fn decimals(&amp;self) -&gt; u8; fn total_supply(&amp;self) -&gt; U256; fn balance_of(&amp;self, owner: Address) -&gt; U256; fn allowance(&amp;self, owner: Address, spender: Address) -&gt; U256; } to self.ownable { fn get_owner(&amp;self) -&gt; Address; fn change_ownership(&amp;mut self, new_owner: Address); } } pub fn mint(&amp;mut self, address: Address, amount: U256) { self.ownable.ensure_ownership(self.env().caller()); self.erc20.mint(address, amount); } }  This OwnedToken contract includes two modules: Erc20 and Ownable. We delegate various functions from both modules using the delegate! macro. As a result, the contract retains its succinctness without compromising on functionality. The above example basically merges the functionalities of modules and adds some control over the minting process. But you can use delegation to build more complex contracts, cherry-picking just a few module functionalities. Let's take a look at another example. use crate::{erc20::Erc20, ownable::Ownable, exchange::Exchange}; use odra::{casper_types::U256, prelude::*}; #[odra::module] pub struct DeFiPlatform { ownable: SubModule&lt;Ownable&gt;, erc20: SubModule&lt;Erc20&gt;, exchange: SubModule&lt;Exchange&gt; } #[odra::module] impl DeFiPlatform { pub fn init(&amp;mut self, name: String, symbol: String, decimals: u8, initial_supply: U256, exchange_rate: u64) { let deployer = self.env().caller(); self.ownable.init(deployer); self.erc20.init(name, symbol, decimals, initial_supply); self.exchange.init(exchange_rate); } delegate! { to self.erc20 { fn transfer(&amp;mut self, recipient: Address, amount: U256); fn balance_of(&amp;self, owner: Address) -&gt; U256; } to self.ownable { fn get_owner(&amp;self) -&gt; Address; } to self.exchange { fn swap(&amp;mut self, sender: Address, recipient: Address); fn set_exchange_rate(&amp;mut self, new_rate: u64); } } pub fn mint(&amp;mut self, address: Address, amount: U256) { self.ownable.ensure_ownership(self.env().caller()); self.erc20.mint(address, amount); } }  In this DeFiPlatform contract, we include Erc20, Ownable, and Exchange modules. By delegating functions from these modules, the parent contract becomes a powerhouse of functionality while retaining its readability and structure. Remember, the possibilities are endless with Odra's. By leveraging this feature, you can write cleaner, more efficient, and modular smart contracts. ","version":"2.3.0","tagName":"h2"},{"title":"Delegating CSPR to Validators","type":0,"sectionRef":"#","url":"/docs/2.3.0/advanced/delegating-cspr","content":"","keywords":"","version":"2.3.0"},{"title":"Sample implementation​","type":1,"pageTitle":"Delegating CSPR to Validators","url":"/docs/2.3.0/advanced/delegating-cspr#sample-implementation","content":"The following code shows how to implement a simple contract that allows delegating CSPR tokens to a validator. examples/src/features/validators.rs use odra::{ casper_types::{PublicKey, U512}, prelude::* }; #[odra::module] pub struct ValidatorsContract { /// In this variable we store the validator's public key, this is the only way we can identify the validator validator: Var&lt;PublicKey&gt; } /// Implementation of the TestingContract #[odra::module] impl ValidatorsContract { /// Initializes the contract with the validator's public key pub fn init(&amp;mut self, validator: PublicKey) { self.validator.set(validator); } /// Stake the amount of tokens #[odra(payable)] pub fn stake(&amp;mut self) { // Get the amount of tokens attached to the call let amount = self.env().attached_value(); if amount.is_zero() { self.env().revert(ValError::InsufficientBalance); } // Use the ContractEnv's delegate method to delegate the tokens to the validator self.env().delegate(self.validator.get().unwrap(), amount); } /// Undelegate the amount from the validator pub fn unstake(&amp;mut self, amount: U512) { self.env().undelegate(self.validator.get().unwrap(), amount); } /// Withdraw the amount from the validator pub fn withdraw(&amp;mut self, amount: U512) { self.env().transfer_tokens(&amp;self.env().caller(), &amp;amount); } ... }  ","version":"2.3.0","tagName":"h2"},{"title":"Explanation​","type":1,"pageTitle":"Delegating CSPR to Validators","url":"/docs/2.3.0/advanced/delegating-cspr#explanation","content":"The above example can be a good starting point for implementing a liquid staking solution. The main things to remember are the new api methods in ContractEnv: pub fn delegate(&amp;self, validator: PublicKey, amount: U512); pub fn undelegate(&amp;self, validator: PublicKey, amount: U512); pub fn delegated_amount(&amp;self, validator: PublicKey) -&gt; U512;  As you can see, we identify the validator by its public key. Funds delegated to the validator are assigned to the calling contract. Remember, that the delegation and undelegation takes some time, depending on the configuration of the blockchain - it's not instant. For example in the Casper mainnet, the delegation takes 1 era and the undelegation takes 7 eras. ","version":"2.3.0","tagName":"h2"},{"title":"Testing​","type":1,"pageTitle":"Delegating CSPR to Validators","url":"/docs/2.3.0/advanced/delegating-cspr#testing","content":"It is possible to test the delegation and undelegation of tokens in the contract. The following code shows how to do it: examples/src/features/validators.rs ... let test_env = odra_test::env(); let auction_delay = test_env.auction_delay(); let unbonding_delay = test_env.unbonding_delay(); test_env.set_caller(test_env.get_account(0)); let mut staking = ValidatorsContract::deploy( &amp;test_env, ValidatorsContractInitArgs { validator: test_env.get_validator(0) } ); let initial_account_balance = test_env.balance_of(&amp;test_env.get_account(0)); // Stake some amount let staking_amount = U512::from(1_000_000_000_000u64); staking.with_tokens(staking_amount).stake(); assert_eq!(staking.currently_delegated_amount(), staking_amount); assert_eq!( test_env.balance_of(&amp;test_env.get_account(0)), initial_account_balance - staking_amount ); // Advance time, run auctions and give off rewards test_env.advance_with_auctions(auction_delay * 2); // Check that the amount is greater than the staking amount let staking_with_reward = staking.currently_delegated_amount(); assert!(staking_with_reward &gt; staking_amount); ...  You can see, that we use the new methods from HostEnv, namely:  fn advance_with_auctions(&amp;self, time_diff: u64); fn auction_delay(&amp;self) -&gt; u64; fn unbonding_delay(&amp;self) -&gt; u64; fn delegated_amount(&amp;self, delegator: Address, validator: PublicKey) -&gt; U512;  advance_with_auctions works in a similar way to advance_block_time, but it also runs the auctions and gives off rewards. The auction_delay and unbonding_delay methods return the values of the auction and unbonding delays specific to the network or backend. We used currently_delegated_amount in the example, it uses delegated_amount method from ContractEnv, but it is also possible to query this information from the HostEnv using delegated_amount method. ","version":"2.3.0","tagName":"h2"},{"title":"Signatures","type":0,"sectionRef":"#","url":"/docs/2.3.0/advanced/signatures","content":"","keywords":"","version":"2.3.0"},{"title":"Signature verification​","type":1,"pageTitle":"Signatures","url":"/docs/2.3.0/advanced/signatures#signature-verification","content":"Signature verification is conducted by a function in contract's env(): pub fn verify_signature(message: &amp;Bytes, signature: &amp;Bytes, public_key: &amp;PublicKey) -&gt; bool;  Here's the simplest example of this function used in a contract: examples/src/features/signature_verifier.rs #[odra::module] impl SignatureVerifier { pub fn verify_signature( &amp;self, message: &amp;Bytes, signature: &amp;Bytes, public_key: &amp;PublicKey ) -&gt; bool { self.env().verify_signature(message, signature, public_key) } }  ","version":"2.3.0","tagName":"h2"},{"title":"Testing​","type":1,"pageTitle":"Signatures","url":"/docs/2.3.0/advanced/signatures#testing","content":"Besides the above function in the contract context, Odra provides corresponding functions in the HostEnv: pub fn sign_message(message: &amp;Bytes, address: &amp;Address) -&gt; Bytes; pub fn public_key(address: &amp;Address) -&gt; PublicKey;  sign_message will return a signed message. The signing itself will be performed using a private key of an account behind the address. public_key returns the PublicKey of an address account. Here's a complete example of how to test the signature verification in the contract: examples/src/features/signature_verifier.rs #[test] fn signature_verification_works() { let test_env = odra_test::env(); let message = &quot;Message to be signed&quot;; let message_bytes = Bytes::from(message.as_bytes()); let account = test_env.get_account(0); let signature = test_env.sign_message(&amp;message_bytes, &amp;account); let public_key = test_env.public_key(&amp;account); let signature_verifier = SignatureVerifier::deploy(&amp;test_env, NoArgs); assert!(signature_verifier.verify_signature(&amp;message_bytes, &amp;signature, &amp;public_key)); }  If you want, you can also test signatures created outside Odra: examples/src/features/signature_verifier.rs #[test] fn verify_signature_casper_wallet() { // Casper Wallet for the message &quot;Ahoj przygodo!&quot; signed using SECP256K1 key // produces the following signature: // 1e87e186238fa1df9c222b387a79910388c6ef56285924c7e4f6d7e77ed1d6c61815312cf66a5318db204c693b79e020b1d392dafe8c1b3841e1f6b4c41ca0fa // Casper Wallet adds &quot;Casper Message:\\n&quot; prefix to the message: let message = &quot;Casper Message:\\nAhoj przygodo!&quot;; let message_bytes = Bytes::from(message.as_bytes()); // Depending on the type of the key, we need to prefix the signature with a tag: // 0x01 for ED25519 // 0x02 for SECP256K1 let signature_hex = &quot;021e87e186238fa1df9c222b387a79910388c6ef56285924c7e4f6d7e77ed1d6c61815312cf66a5318db204c693b79e020b1d392dafe8c1b3841e1f6b4c41ca0fa&quot;; let signature: [u8; 65] = hex::decode(signature_hex).unwrap().try_into().unwrap(); let signature_bytes = Bytes::from(signature.as_slice()); // Similar to the above, the public key is tagged: let public_key_hex = &quot;02036d9b880e44254afaf34330e57703a63aec53b5918d4470059b67a4a906350105&quot;; let public_key_decoded = hex::decode(public_key_hex).unwrap(); let (public_key, _) = PublicKey::from_bytes(public_key_decoded.as_slice()).unwrap(); let signature_verifier = SignatureVerifier::deploy(&amp;odra_test::env(), NoArgs); assert!(signature_verifier.verify_signature(&amp;message_bytes, &amp;signature_bytes, &amp;public_key)); }  ","version":"2.3.0","tagName":"h2"},{"title":"Memory allocators","type":0,"sectionRef":"#","url":"/docs/2.3.0/advanced/using-different-allocator","content":"","keywords":"","version":"2.3.0"},{"title":"Using a different allocator​","type":1,"pageTitle":"Memory allocators","url":"/docs/2.3.0/advanced/using-different-allocator#using-a-different-allocator","content":"If the default allocator does not suit your needs, or you use a crate that already provides an allocator, you can disable the default allocator by enabling the disable-allocator feature in the odra dependency in your project: [dependencies] odra = { path = &quot;../odra&quot;, features = [&quot;disable-allocator&quot;] }  If you want to have a better control over the features that are enabled during the building and tests, see the next article on building manually. ","version":"2.3.0","tagName":"h2"},{"title":"Storage Layout","type":0,"sectionRef":"#","url":"/docs/2.3.0/advanced/storage-layout","content":"","keywords":"","version":"2.3.0"},{"title":"Casper VM Perspective​","type":1,"pageTitle":"Storage Layout","url":"/docs/2.3.0/advanced/storage-layout#casper-vm-perspective","content":"The Casper Execution Engine (VM) enables the storage of data in named keys or dictionaries. However, a smart contract has a limited number of named keys, making it unsuitable for storing substantial data volumes. Odra resolves this issue by storing all user-generated data in a dictionary called state. This dictionary operates as a key-value store, where keys are strings with a maximum length of 64 characters, and values are arbitrary byte arrays. Here is an example of what the interface for reading and writing data could look like: pub trait CasperStorage { fn read(key: &amp;str) -&gt; Option&lt;Vec&lt;u8&gt;&gt;; fn write(key: &amp;str, value: Vec&lt;u8&gt;); }  ","version":"2.3.0","tagName":"h2"},{"title":"Odra Perspective​","type":1,"pageTitle":"Storage Layout","url":"/docs/2.3.0/advanced/storage-layout#odra-perspective","content":"Odra was conceived with modularity and code reusability in mind. Additionally, we aimed to streamline storage definition through the struct object. Consider this straightforward storage definition: #[odra::module] pub struct Token { name: Var&lt;String&gt;, balances: Mapping&lt;Address, U256&gt; }  The Token structure contains two fields: name of type String andbalances, which functions as a key-value store with Address as keys andU256 as values. The Token module can be reused in another module, as demonstrated in a more complex example: #[odra::module] pub struct Loans { lenders: SubModule&lt;Token&gt;, borrowers: SubModule&lt;Token&gt;, }  The Loans module has two fields: lenders and borrowers, both of which have the same storage layout as defined by the Token module. Odra guarantees thatlenders and borrowers are stored under distinct keys within the storage dictionary. Both Token and Loans serve as examples to show how Odra's storage layout operates. ","version":"2.3.0","tagName":"h2"},{"title":"Key generation.​","type":1,"pageTitle":"Storage Layout","url":"/docs/2.3.0/advanced/storage-layout#key-generation","content":"Every element of a module (struct) with N elements is associated with an index ranging from 0 to N-1, represented as a u8 with a maximum of 256 elements. If an element of a module is another module (SubModule&lt;...&gt;), the associated index serves as a prefix for the indexes of the inner module. While this may initially appear complex, it is easily understood through an example. In the example, indexes are presented as bytes, reflecting the actual implementation. Loans { lenders: Token { // prefix: 0x0001 name: 1, // key: 0x0001_0001 balances: 2 // key: 0x0001_0010 }, borrowers: Token { // prefix: 0x0010 name: 1, // key: 0x0010_0001 balances: 2 // key: 0x0010_0010 } }  Additionally, it's worth mentioning how Mapping's keys are used in thestorage. They are simply concatenated with the index of the module, as demonstrated in the example. For instance, triggering borrowers.balances.get(0x1234abcd) would result in a key: 0x0001_0001_1234_abcd  Finally, the key must be hashed to fit within the 64-character limit and then encoded in hexadecimal format. ","version":"2.3.0","tagName":"h2"},{"title":"Value serialization​","type":1,"pageTitle":"Storage Layout","url":"/docs/2.3.0/advanced/storage-layout#value-serialization","content":"Before being stored in the storage, each value is serialized into bytes using the CLType serialization method and subsequently encapsulated with Casper'sBytes types. ","version":"2.3.0","tagName":"h2"},{"title":"OdraVM","type":0,"sectionRef":"#","url":"/docs/2.3.0/backends/odra-vm","content":"","keywords":"","version":"2.3.0"},{"title":"Usage​","type":1,"pageTitle":"OdraVM","url":"/docs/2.3.0/backends/odra-vm#usage","content":"The OdraVM is the default backend for Odra framework, so each time you run cargo odra test  You are running your code against it. ","version":"2.3.0","tagName":"h2"},{"title":"Architecture​","type":1,"pageTitle":"OdraVM","url":"/docs/2.3.0/backends/odra-vm#architecture","content":"OdraVM consists of two main parts: the Contract Register and the State. The Contract Register is a list of contracts deployed onto the OdraVM, identified by an Address. Contracts and Test Env functions can modify the State of the OdraVM. Contrary to the &quot;real&quot; backend, which holds the whole history of the blockchain, the OdraVM State holds only the current state of the OdraVM. Thanks to this and the fact that we do not need the blockchain itself, OdraVM starts instantly and runs the tests in the native speed. ","version":"2.3.0","tagName":"h2"},{"title":"Execution​","type":1,"pageTitle":"OdraVM","url":"/docs/2.3.0/backends/odra-vm#execution","content":"When the OdraVM backend is enabled, the #[odra::module] attribute is responsible for converting your pub functions into a list of Entrypoints, which are put into a Contract Container. When the contract is deployed, its Container registered into a Registry under an address. During the contract call, OdraVM finds an Entrypoint and executes the code. ","version":"2.3.0","tagName":"h2"},{"title":"What is a backend?","type":0,"sectionRef":"#","url":"/docs/2.3.0/backends/what-is-a-backend","content":"","keywords":"","version":"2.3.0"},{"title":"Contract Env​","type":1,"pageTitle":"What is a backend?","url":"/docs/2.3.0/backends/what-is-a-backend#contract-env","content":"The Contract Env is a simple interface that each backend needs to implement, exposing features of the blockchain from the perspective of the contract. It gives Odra a set of functions, which allows implementing more complex concepts - for example, to implement Mapping, Odra requires some kind of storage integration. The exact implementation of those functions is a responsibility of a backend, making Odra and its user free to implement the contract logic, instead of messing with the blockchain internals. Other functions from Contract Env include handling transfers, addresses, block time, errors and events. ","version":"2.3.0","tagName":"h2"},{"title":"Host Env​","type":1,"pageTitle":"What is a backend?","url":"/docs/2.3.0/backends/what-is-a-backend#host-env","content":"Similarly to the Contract Env, the Host Env exposes a set of functions that allows the communication with the backend from the outside world - really useful for implementing tests. This ranges from interacting with the blockchain - like deploying new, loading existing and calling the contracts, to the more test-oriented - handling errors, forwarding the block time, etc. ","version":"2.3.0","tagName":"h2"},{"title":"What's next​","type":1,"pageTitle":"What is a backend?","url":"/docs/2.3.0/backends/what-is-a-backend#whats-next","content":"We will take a look at backends Odra implements in more detail. ","version":"2.3.0","tagName":"h2"},{"title":"Livenet","type":0,"sectionRef":"#","url":"/docs/2.3.0/backends/livenet","content":"","keywords":"","version":"2.3.0"},{"title":"Setup​","type":1,"pageTitle":"Livenet","url":"/docs/2.3.0/backends/livenet#setup","content":"To use Livenet backend, we need to provide Odra with some information - the network address, our private key and the name of the chain we want to use. Optionally, we can add multiple private keys to use more than one account in our tests. Those values are passed using environment variables. We can use .env file to store them - let's take a look at an example .env file, created from the .env.sample file from the examples folder: # .env file used by Livenet integration. You can use multiple .env files to manage deploys on multiple chains # by naming them casper-test.env, casper-livenet.env, etc. and calling the deploy script with the name of the # ennviroment provided in the &quot;ODRA_CASPER_LIVENET_ENV&quot; variable. For example: # ODRA_CASPER_LIVENET_ENV=casper-test cargo run --bin livenet_tests --features livenet # This will load integration.env file first, and then fill the missing values with the values from casper-test.env. # Path to the secret key of the account that will be used to deploy the contracts. # If you are using the nctl, you can use the following command to extract the secret key from the container: # docker exec mynctl /bin/bash -c &quot;cat /home/casper/casper-nctl/assets/net-1/users/user-1/secret_key.pem&quot; &gt; examples/.node-keys/secret_key.pem # docker exec mynctl /bin/bash -c &quot;cat /home/casper/casper-nctl/assets/net-1/users/user-2/secret_key.pem&quot; &gt; examples/.node-keys/secret_key_1.pem ODRA_CASPER_LIVENET_SECRET_KEY_PATH=&lt;path to secret_key.pem&gt; # RPC address of the node that will be used to deploy the contracts. # For CSPR.cloud, you can use the following addresses: # - https://node.cspr.cloud # - https://node.testnet.cspr.cloud # For nctl, default is: # - http://localhost:11101 ODRA_CASPER_LIVENET_NODE_ADDRESS=&lt;node address&gt; # Events url # For CSPR.cloud, you can use the following addresses: # - https://node.cspr.cloud/events # For nctl, default is: # - http://localhost:18101/events ODRA_CASPER_LIVENET_EVENTS_URL=&lt;events url&gt; # Chain name of the network. The mainnet is &quot;casper&quot; and test net is &quot;casper-test&quot;. # The integration network uses the &quot;integration-test&quot; chain name. # For nctl default is &quot;casper-net-1&quot; ODRA_CASPER_LIVENET_CHAIN_NAME=&lt;chain_name&gt; # Optionally, paths to the secret keys of the additional acccounts. Main secret key will be 0th account. # The following will work for nctl if you used the command above to extract the secret keys: # ODRA_CASPER_LIVENET_KEY_1=./keys/secret_key_1.pem #ODRA_CASPER_LIVENET_KEY_1=&lt;path to secret_key_1.pem&gt; # If using CSPR.cloud, you can set the auth token here. # CSPR_CLOUD_AUTH_TOKEN=  note CSPR.cloud is a service that provides mainnet and testnet Casper nodes on demand. With the proper value in place, we can write our tests or deploy scenarios. In the examples, we can find a simple binary that deploys a contract and calls it. The test is located in the erc20_on_livenet.rs file. Let's go through the code: //! Deploys an ERC20 contract and transfers some tokens to another address. use odra::casper_types::U256; use odra::host::{Deployer, HostEnv, HostRefLoader, InstallConfig}; use odra::prelude::*; use odra_modules::erc20::{Erc20, Erc20HostRef, Erc20InitArgs}; use std::str::FromStr; fn main() { let env = odra_casper_livenet_env::env(); let owner = env.caller(); let recipient = &quot;hash-2c4a6ce0da5d175e9638ec0830e01dd6cf5f4b1fbb0724f7d2d9de12b1e0f840&quot;; let recipient = Address::from_str(recipient).unwrap(); // Deploy new contract. let mut token = deploy_erc20(&amp;env); println!(&quot;Token address: {}&quot;, token.address().to_string()); // Uncomment to load existing contract. // let mut token = load_erc20(&amp;env); println!(&quot;Token name: {}&quot;, token.name()); env.set_gas(3_000_000_000u64); token.transfer(&amp;recipient, &amp;U256::from(1000)); println!(&quot;Owner's balance: {:?}&quot;, token.balance_of(&amp;owner)); println!(&quot;Recipient's balance: {:?}&quot;, token.balance_of(&amp;recipient)); } /// Loads an ERC20 contract. fn _load_erc20(env: &amp;HostEnv) -&gt; Erc20HostRef { let address = &quot;hash-d26fcbd2106e37be975d2045c580334a6d7b9d0a241c2358a4db970dfd516945&quot;; let address = Address::from_str(address).unwrap(); Erc20::load(env, address) } /// Deploys an ERC20 contract. pub fn deploy_erc20(env: &amp;HostEnv) -&gt; Erc20HostRef { let name = String::from(&quot;Plascoin&quot;); let symbol = String::from(&quot;PLS&quot;); let decimals = 10u8; let initial_supply = Some(U256::from(10_000)); let init_args = Erc20InitArgs { name, symbol, decimals, initial_supply }; env.set_gas(450_000_000_000u64); // You may configure a deploy passing `InstallConfig`. // Erc20::deploy_with_cfg(env, init_args, InstallConfig::upgradable::&lt;Erc20&gt;()) Erc20::deploy(env, init_args) }  note The above example is a rust binary, not a test. Note that it is also added as a section of theCargo.toml file: [bin] name = &quot;erc20_on_livenet&quot; path = &quot;src/bin/erc20_on_livenet.rs&quot; required-features = [&quot;livenet&quot;] test = false  ","version":"2.3.0","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"Livenet","url":"/docs/2.3.0/backends/livenet#usage","content":"To run the above code, we simply need to run the binary with the livenet feature enabled: cargo run --bin erc20_on_livenet --features=livenet  note Before executing the binary, make sure you built a wasm file. A part of a sample output should look like this: ... 💁 INFO : Calling &quot;contract-package-b796cf8e527472d7ced8c4f8db5adb30eb577176f4c7ce956675590e0cac4bb8&quot; directly with entrypoint &quot;transfer&quot;. 🙄 WAIT : Waiting 10 for V1(TransactionV1Hash(775913daa0ffbded9aaf2216942217d682f03d1c04e6e2560d1e4b3329ebd2d6)). 💁 INFO : Transaction &quot;775913daa0ffbded9aaf2216942217d682f03d1c04e6e2560d1e4b3329ebd2d6&quot; successfully executed. 🔗 LINK : Owner's balance: 9000 Recipient's balance: 1000  Those logs are a result of the last 4 lines of the above listing. Each deployment or a call to the blockchain will be noted and will take some time to execute. We can see that the transfer call took over 15 seconds to execute. But calling balance_of was nearly instant and cost us nothing. How it is possible? info You can see the deployment on http://cspr.live/ - the transfer from the example can be seen here. ","version":"2.3.0","tagName":"h2"},{"title":"How Livenet backend works​","type":1,"pageTitle":"Livenet","url":"/docs/2.3.0/backends/livenet#how-livenet-backend-works","content":"All calls of entrypoints executed on a Casper blockchain cost gas - even if they do not change the state. It is possible, however, to query the state of the blockchain for free. This principle is used in the Livenet backend - all calls that do not change the state of the blockchain are really executed offline - the only thing that is requested from the node is the current state. This is why the balance_of call was almost instant and free. Basically, if the entrypoint function is not mutable or does not make a call to an unknown external contract (see Cross Calls), it is executed offline and node is used for the state query only. However, the Livenet needs to know the connection between the contracts and the code, so make sure to deploy or load already deployed contracts ","version":"2.3.0","tagName":"h2"},{"title":"Multiple environments​","type":1,"pageTitle":"Livenet","url":"/docs/2.3.0/backends/livenet#multiple-environments","content":"It is possible to have multiple environments for the Livenet backend. This is useful if we want to easily switch between multiple accounts, multiple nodes or even multiple chains. To do this, simply create a new .env file with a different prefix - for example, integration.env and mainnet.env. Then, pass the ODRA_CASPER_LIVENET_ENV variable with value either integration or mainnet to select which file has to be used first. If your integration.env file has a value that IS present in the .env file, it will override the value from the .env file. ODRA_CASPER_LIVENET_ENV=integration cargo run --bin erc20_on_livenet --features=livenet  To sum up - this command will firstly load the integration.env file and then load the missing values from .env file. ","version":"2.3.0","tagName":"h2"},{"title":"Casper","type":0,"sectionRef":"#","url":"/docs/2.3.0/backends/casper","content":"","keywords":"","version":"2.3.0"},{"title":"Contract Env​","type":1,"pageTitle":"Casper","url":"/docs/2.3.0/backends/casper#contract-env","content":"As with any other backend, Casper Backend must implement the same features, but some do not have native support. Let's take a closer look at how Odra overcomes these hindrances. ","version":"2.3.0","tagName":"h2"},{"title":"Events​","type":1,"pageTitle":"Casper","url":"/docs/2.3.0/backends/casper#events","content":"An event is not a first-class citizen in Casper like in Ethereum, so Odra mimics it. As you've already learned from the events article, in Odra you emit an event, similarly, you would do it in Solidity. Under the hood, Odra integrates with Casper Event Standard and creates a few URefs in the global state when a contract is being installed: __events - a dictionary that stores events' data.__events_length - the evens count.__events_ces_version - the version of Casper Event Standard. __events_schema - a dictionary that stores event schemas. Besides that, all the events the contract emits are registered - events schemas are written to the storage under the __events_schema key. So, Events are nothing different from any other data stored by a contract. A struct to be an event must implement traits defined by Casper Event Standard, thankfully you can derive them using #[odra::event]. note Don't forget to expose events in the module using #[odra::module(events = [...])]. ","version":"2.3.0","tagName":"h3"},{"title":"Payable​","type":1,"pageTitle":"Casper","url":"/docs/2.3.0/backends/casper#payable","content":"The first Odra idiom is a Contract Main Purse. It is a purse associated with a contract. The purse is created lazily - when the first transfer to the contract occurs, a proper URef and a purse are created and stored under the __contract_main_purse key. Casper does not allow direct transfers from an account to a contract, so Odra comes up with the second idiom - a Cargo Purse. It is a one-time-use purse proxy between an account and a contract. First, motes go from the account to the cargo purse and then to the contract's main purse. Behind the scenes, Odra handles an account-contract transfer via a cargo purse when a function is marked as payable. If under the way something goes wrong with the transfer, the contract reverts. The transferred amount can be read inside the contract by calling self.env().attached_value(). note Odra expects the cargo_purse runtime argument to be attached to a contract call. In case of its absence, the contract_env::attached_value() returns zero. ","version":"2.3.0","tagName":"h3"},{"title":"Revert​","type":1,"pageTitle":"Casper","url":"/docs/2.3.0/backends/casper#revert","content":"In Casper, we can stop the execution pretty straightforwardly - call the runtime::revert(). Odra adds an extra abstraction layer - in a contract ExecutionErrors are defined, which ultimately are transformed into Casper's ApiError::User. ","version":"2.3.0","tagName":"h3"},{"title":"Context​","type":1,"pageTitle":"Casper","url":"/docs/2.3.0/backends/casper#context","content":"Casper equips developers with very low-level tooling, which can be cumbersome for newcomers. If you want to check who called the contract or its address, you can not do it off-hand - you must analyze the call stack. The self.env().self_address() function takes the first element of the callstack (runtime::get_call_stack()) and casts it to Address. The self.env().caller() function takes the second element of the call stack (runtime::get_call_stack()) and casts it to Address. As mentioned in the [Payable] section, to store CSPR, each contract creates its purse. To read the contract balance, you call self.env().self_balance(), which checks the balance of the purse stored under __contract_main_purse. ","version":"2.3.0","tagName":"h3"},{"title":"Test Env​","type":1,"pageTitle":"Casper","url":"/docs/2.3.0/backends/casper#test-env","content":"Test environment allows you to test wasm contracts before you deploy them onto the testnet or livenet. It is built on top of the Casper Execution Engine. In your test, you can freely switch execution context by setting as a caller (test_env::set_caller()) one of the 20 predefined accounts. Each account possesses the default amount of Motes (100_000_000_000_000_000). The Test Env internally keeps track of the current block time, error and attached value. Each test is executed on a fresh instance of the Test Env. ","version":"2.3.0","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"Casper","url":"/docs/2.3.0/backends/casper#usage","content":"Name of the Casper backend in Odra is casper, so to run the tests against it, simply pass it as a -bparameter: cargo odra test -b casper  If you want to just generate a wasm file, simply run: cargo odra build -b casper  ","version":"2.3.0","tagName":"h2"},{"title":"Deploying a contract to Casper network​","type":1,"pageTitle":"Casper","url":"/docs/2.3.0/backends/casper#deploying-a-contract-to-casper-network","content":"There would be no point in writing a contract if you couldn't deploy it to the blockchain. You can do it in two ways: provided by the Casper itself: using the casper-client tool or using the Odra's Livenet integration. note In the commands below, we use casper-client version 5.0.0. Let's explore the first option to better understand the process. note If you wish, you can skip the following section and jump to the Livenet integration. ","version":"2.3.0","tagName":"h2"},{"title":"WASM arguments​","type":1,"pageTitle":"Casper","url":"/docs/2.3.0/backends/casper#wasm-arguments","content":"When deploying a new contract you can pass some arguments to it. Every contract written in Odra expects those arguments to be set: odra_cfg_package_hash_key_name - String type. The key under which the package hash of the contract will be stored.odra_cfg_allow_key_override - Bool type. If true and the key specified in odra_cfg_package_hash_key_name already exists, it will be overwritten.odra_cfg_is_upgradable - Bool type. If true, the contract will be deployed as upgradable.odra_cfg_is_upgrade - Bool type. If true, the contract will be upgraded. If we want to install a contract to should be set to false. Additionally, if required by the contract, you can pass constructor arguments. When working with the test env via cargo odra or when usingLivenet integration this is handled automatically. However, if you rather usecasper-client directly, you have to pass them manually: ","version":"2.3.0","tagName":"h3"},{"title":"Example: Deploy Counter​","type":1,"pageTitle":"Casper","url":"/docs/2.3.0/backends/casper#example-deploy-counter","content":"To deploy your contract with a constructor using casper-client, you need to pass the above arguments. Additionally, you need to pass the value argument, which sets the arbitrary initial value for the counter. casper-client put-transaction session \\ --node-address [NODE_ADDRESS] \\ --chain-name casper-test \\ --secret-key [PATH_TO_YOUR_KEY]/secret_key.pem \\ --payment-amount 5000000000000 \\ --gas-price-tolerance 1 \\ --standard-payment true \\ --wasm-path ./wasm/counter.wasm \\ --session-arg &quot;odra_cfg_package_hash_key_name:string:'counter_package_hash'&quot; \\ --session-arg &quot;odra_cfg_allow_key_override:bool:'true'&quot; \\ --session-arg &quot;odra_cfg_is_upgradable:bool:'true'&quot; \\ --session-arg &quot;odra_cfg_is_upgrade:bool:'false'&quot; \\ --session-arg &quot;value:u32:42&quot;  For a more in-depth tutorial, please refer to the Casper's 'Writing On-Chain Code'. ","version":"2.3.0","tagName":"h3"},{"title":"Example: Deploy ERC721​","type":1,"pageTitle":"Casper","url":"/docs/2.3.0/backends/casper#example-deploy-erc721","content":"Odra comes with a standard ERC721 token implementation. Clone the main Odra repo and navigate to the modules directory. Firstly contract needs to be compiled. cargo odra build -b casper -c erc721_token  It produces the erc721_token.wasm file in the wasm directory. Now it's time to deploy the contract. casper-client put-transaction session \\ --node-address [NODE_ADDRESS] \\ --chain-name casper-test \\ --secret-key [PATH_TO_YOUR_KEY]/secret_key.pem \\ --payment-amount 300000000000 \\ --gas-price-tolerance 1 \\ --standard-payment true \\ --wasm-path ./wasm/erc721_token.wasm \\ --session-arg &quot;odra_cfg_package_hash_key_name:string:'my_nft'&quot; \\ --session-arg &quot;odra_cfg_allow_key_override:bool:'false'&quot; \\ --session-arg &quot;odra_cfg_is_upgradable:bool:'true'&quot; \\ --session-arg &quot;odra_cfg_is_upgrade:bool:'false'&quot; \\ --session-arg &quot;name:string:'MyNFT'&quot; \\ --session-arg &quot;symbol:string:'NFT'&quot; \\ --session-arg &quot;base_uri:string:'https://example.com/'&quot;  It's done. The contract is deployed and ready to use. Your account is the owner of the contract and you can mint and burn tokens. For more details see the code of the ERC721 module. To obtain the package hash of the contract search for my_nft key in your account's named keys. ","version":"2.3.0","tagName":"h3"},{"title":"Example: Deploy ERC1155​","type":1,"pageTitle":"Casper","url":"/docs/2.3.0/backends/casper#example-deploy-erc1155","content":"The process is similar to the one described in the previous section. Contract compilation: cargo odra build -b casper -c erc1155_token  Contract deployment: casper-client put-transaction session \\ --node-address [NODE_ADDRESS] \\ --chain-name casper-test \\ --secret-key [PATH_TO_YOUR_KEY]/secret_key.pem \\ --payment-amount 300000000000 \\ --gas-price-tolerance 1 \\ --standard-payment true \\ --wasm-path ./wasm/erc1155_token.wasm \\ --session-arg &quot;odra_cfg_package_hash_key_name:string:'my_tokens'&quot; \\ --session-arg &quot;odra_cfg_allow_key_override:bool:'false'&quot; \\ --session-arg &quot;odra_cfg_is_upgradable:bool:'true'&quot; \\ --session-arg &quot;odra_cfg_is_upgrade:bool:'false'&quot; \\ --session-arg &quot;odra_cfg_constructor:string:'init'&quot; \\  As previously, your account is the owner and can mint and burn tokens. For more details see the code of the ERC1155 module. ","version":"2.3.0","tagName":"h3"},{"title":"Sending CSPR to a contract​","type":1,"pageTitle":"Casper","url":"/docs/2.3.0/backends/casper#sending-cspr-to-a-contract","content":"Defining payable entry points is described in Native Token section. What is happening under the hood is that Odra creates a new cargo_purse argument for each payable entry point. The cargo_purse needs to be top-upped with CSPR before calling the contract. When a contract adds CSPR to another contract call, Odra handles it for you. The problem arises when you want to call an entry point and attach CSPR as an account. The only way of doing that is by executing code in the sessions context, that top-ups the cargo_purse and then calls the contract. Odra provides a generic proxy_caller.wasm that does exactly that. You can build it by yourself from the main Odra repository, or use the proxy_caller.wasmwe maintain. ","version":"2.3.0","tagName":"h2"},{"title":"Using proxy_caller.wasm​","type":1,"pageTitle":"Casper","url":"/docs/2.3.0/backends/casper#using-proxy_callerwasm","content":"To use the proxy_caller.wasm you need to attach the following arguments: contract_package_hash - BytesArray(32) type. The package hash of the contract you want to call. Result of to_bytes on CasperPackageHash.entry_point - String type. The name of the entry point you want to call.args - Bytes type. It is a serialized RuntimeArgs with the arguments you want to pass to the entry point. To be specific it is the result of to_bytes method wrapped with Bytes type.attached_value. U512 type. The amount of CSPR you want to attach to the call.amount. U512 type. Should be the same value as attached_value if not None. It is a special Casper argument that enables the access to account's main purse. Currently casper-client doesn't allow building such arguments. You have to build it using your SDK. See an example in the Tutorial section. ","version":"2.3.0","tagName":"h3"},{"title":"Execution​","type":1,"pageTitle":"Casper","url":"/docs/2.3.0/backends/casper#execution","content":"First thing Odra does with your code, is similar to the one used in OdraVM - a list of entrypoints is generated, thanks to the #[odra::module] attribute. ","version":"2.3.0","tagName":"h2"},{"title":"Cargo Odra","type":0,"sectionRef":"#","url":"/docs/2.3.0/basics/cargo-odra","content":"","keywords":"","version":"2.3.0"},{"title":"Managing projects​","type":1,"pageTitle":"Cargo Odra","url":"/docs/2.3.0/basics/cargo-odra#managing-projects","content":"Two commands help you create a new project. The first one is cargo odra new. You need to pass one parameter, namely --name {PROJECT_NAME}: cargo odra new --name my-project  This creates a new project in the my_project folder and name it my_project. You can see it for yourself, for example by taking a look into a Cargo.toml file created in your project's folder: [package] name = &quot;my_project&quot; version = &quot;0.1.0&quot; edition = &quot;2021&quot;  The project is created using the template located in Odra's main repository. By default it uses full template, if you want, you can use minimalistic blank by running: cargo odra new -t blank --name my-project  The third available template is workspace, which creates a workspace with two projects, similar to the one created with the full template. There are also two templates which create a project with a sample tokens native to Casper Network: cep18 and cep78. By default, the latest release of Odra will be used for the template and as a dependency. You can pass a source of Odra you want to use, by using -s parameter: cargo odra new -n my-project -s ../odra # will use local folder of odra cargo odra new -n my-project -s release/0.9.0 # will use github branch, e.g. if you want to test new release cargo odra new -n my-project -s 1.1.0 # will use a version released on crates.io  The second way of creating a project is by using init command: cargo odra init --name my-project  It works in the same way as new, but instead of creating a new folder, it creates a project in the current, empty directory. ","version":"2.3.0","tagName":"h2"},{"title":"Generating code​","type":1,"pageTitle":"Cargo Odra","url":"/docs/2.3.0/basics/cargo-odra#generating-code","content":"If you want to quickly create a new contract code, you can use the generate command: cargo odra generate -c counter  This creates a new file src/counter.rs with sample code, add appropriate use and mod sections to src/lib.rs and update the Odra.toml file accordingly. To learn more about Odra.toml file, visit Odra.toml. ","version":"2.3.0","tagName":"h2"},{"title":"Testing​","type":1,"pageTitle":"Cargo Odra","url":"/docs/2.3.0/basics/cargo-odra#testing","content":"The most used command during the development of your project should be this one: cargo odra test  It runs your tests against Odra's MockVM. It is substantially faster than CasperVMand implements all the features Odra uses. When you want to run tests against a &quot;real&quot; VM, just provide the name of the backend using -boption: cargo odra test -b casper  In the example above, Cargo Odra builds the project, generates the wasm files, spin up CasperVM instance, deploys the contracts onto it and runs the tests against it. Pretty neat. Keep in mind that this is a lot slower than OdraVM and you cannot use the debugger. This is why OdraVM was created and should be your first choice when developing contracts. Of course, testing all of your code against a blockchain VM is a must in the end. If you want to run only some of the tests, you can pass arguments to the cargo test command (which is run in the background obviously): cargo odra test -- this-will-be-passed-to-cargo-test  If you want to run tests which names contain the word two, you can execute: cargo odra test -- two  Of course, you can do the same when using the backend: cargo odra test -b casper -- two  ","version":"2.3.0","tagName":"h2"},{"title":"Building code​","type":1,"pageTitle":"Cargo Odra","url":"/docs/2.3.0/basics/cargo-odra#building-code","content":"You can also build the code itself and generate the output contracts without running the tests. To do so, simply run: cargo odra build  If the build process finishes successfully, wasm files will be located in wasm folder. Notice, that this command does not require the -b option. If you want to build specific contract, you can use -c option: cargo odra build -c counter # you pass many comma separated contracts  ","version":"2.3.0","tagName":"h2"},{"title":"Skipping building​","type":1,"pageTitle":"Cargo Odra","url":"/docs/2.3.0/basics/cargo-odra#skipping-building","content":"As building wasm files can take a long time, especially if you have a lot of contracts. If you did not change anything in your contracts and you just want to rerun the tests for the casper backend, use the -s option: cargo odra test -b casper -s  ","version":"2.3.0","tagName":"h2"},{"title":"Generating contract schema​","type":1,"pageTitle":"Cargo Odra","url":"/docs/2.3.0/basics/cargo-odra#generating-contract-schema","content":"If you want to generate a schema (including the name, entrypoints, events, etc.) for your contract, you can use the schema command: cargo odra schema  This generates a schema file in JSON format for all your contracts and places them in the resources folder. If the resources folder does not exist, it creates the folder for you. Like with the build command, you can use the -c option to generate a schema for a specific contract. ","version":"2.3.0","tagName":"h2"},{"title":"What's next​","type":1,"pageTitle":"Cargo Odra","url":"/docs/2.3.0/basics/cargo-odra#whats-next","content":"In the next section, we will take a look at all the files and directories that cargo odra created for us and explain their purpose. ","version":"2.3.0","tagName":"h2"},{"title":"Host Communication","type":0,"sectionRef":"#","url":"/docs/2.3.0/basics/communicating-with-host","content":"","keywords":"","version":"2.3.0"},{"title":"What's next​","type":1,"pageTitle":"Host Communication","url":"/docs/2.3.0/basics/communicating-with-host#whats-next","content":"In the next article, we'll dive into testing your contracts with Odra, so you can check that the code we presented in fact works! ","version":"2.3.0","tagName":"h2"},{"title":"directory-structure","type":0,"sectionRef":"#","url":"/docs/2.3.0/basics/directory-structure","content":"","keywords":"","version":"2.3.0"},{"title":"Directory structure​","type":1,"pageTitle":"directory-structure","url":"/docs/2.3.0/basics/directory-structure#directory-structure","content":"After creating a new project using Odra and running the tests, you will be presented with the following files and directories: . ├── Cargo.lock ├── Cargo.toml ├── CHANGELOG.md ├── Odra.toml ├── README.md ├── rust-toolchain ├── src/ │ ├── flipper.rs │ └── lib.rs ├── bin/ | |── build_contract.rs | └── build_schema.rs ├── target/ └── wasm/  ","version":"2.3.0","tagName":"h2"},{"title":"Cargo.toml​","type":1,"pageTitle":"directory-structure","url":"/docs/2.3.0/basics/directory-structure#cargotoml","content":"Let's first take a look at Cargo.toml file: [package] name = &quot;sample&quot; version = &quot;0.1.0&quot; edition = &quot;2021&quot; [dependencies] odra = &quot;2.2.0&quot; [dev-dependencies] odra-test = &quot;2.2.0&quot; [build-dependencies] odra-build = &quot;2.2.0&quot; [[bin]] name = &quot;sample_build_contract&quot; path = &quot;bin/build_contract.rs&quot; test = false [[bin]] name = &quot;sample_build_schema&quot; path = &quot;bin/build_schema.rs&quot; test = false [profile.release] codegen-units = 1 lto = true [profile.dev.package.&quot;*&quot;] opt-level = 3  By default, your project will use the latest odra version available at crates.io. For testing purposes,odra-test is also added as a dev dependency. ","version":"2.3.0","tagName":"h3"},{"title":"Odra.toml​","type":1,"pageTitle":"directory-structure","url":"/docs/2.3.0/basics/directory-structure#odratoml","content":"This is the file that holds information about contracts that will be generated when running cargo odra build andcargo odra test: [[contracts]] fqn = &quot;sample::Flipper&quot;  As we can see, we have a single contract, its fqn (Fully Qualified Name) corresponds to the contract is located in src/flipper.rs. More contracts can be added here by hand, or by using cargo odra generate command. ","version":"2.3.0","tagName":"h3"},{"title":"src/​","type":1,"pageTitle":"directory-structure","url":"/docs/2.3.0/basics/directory-structure#src","content":"This is the folder where your smart contract files live. ","version":"2.3.0","tagName":"h3"},{"title":"bin/​","type":1,"pageTitle":"directory-structure","url":"/docs/2.3.0/basics/directory-structure#bin","content":"This is the folder where scripts that will be used to generate code or schemas live. You don't need to modify those files, they are generated by cargo odra new command and are used by cargo odra build, cargo odra test and cargo odra schema commands. ","version":"2.3.0","tagName":"h3"},{"title":"target/​","type":1,"pageTitle":"directory-structure","url":"/docs/2.3.0/basics/directory-structure#target","content":"Files generated by cargo during the build process are put here. ","version":"2.3.0","tagName":"h3"},{"title":"wasm/​","type":1,"pageTitle":"directory-structure","url":"/docs/2.3.0/basics/directory-structure#wasm","content":"WASM files generated by cargo odra build and cargo odra test are put here. You can grab those WASM files and deploy them on the blockchain. ","version":"2.3.0","tagName":"h3"},{"title":"What's next​","type":1,"pageTitle":"directory-structure","url":"/docs/2.3.0/basics/directory-structure#whats-next","content":"Now, let's take a look at one of the files mentioned above in more detail, namely the Odra.toml file. ","version":"2.3.0","tagName":"h2"},{"title":"Cross calls","type":0,"sectionRef":"#","url":"/docs/2.3.0/basics/cross-calls","content":"","keywords":"","version":"2.3.0"},{"title":"Contract Ref​","type":1,"pageTitle":"Cross calls","url":"/docs/2.3.0/basics/cross-calls#contract-ref","content":"We mentioned HostRef already in our Testing article - a host side reference to already deployed contract. In the module context we use a ContractRef instead, to call other contracts. Similarly to the HostRef trait implemetation for the module, the {{ModuleName}}ContractRef is generated automatically, by the #[odra::module] attribute. The reference implements all the public endpoints to the contract (those marked as pub in #[odra::module]impl), and the {{ModuleName}}ContractRef::address() function, which returns the address of the contract. External Contracts Sometimes in our contract, we would like to interact with a someone else's contract, already deployed onto the blockchain. The only thing we know about the contract is the ABI. For that purpose, we use #[odra:external_contract] attribute. This attribute should be applied to a trait. The trait defines the part of the ABI we would like to take advantage of. Let's pretend the MathEngine we defined is an external contract. There is a contract with add() function that adds two numbers somewhere. #[odra::external_contract] pub trait Adder { fn add(&amp;self, n1: u32, n2: u32) -&gt; u32; }  Odra automatically creates the AdderContractRef struct. Having an address, in the module context we can call: struct Contract { adder: External&lt;AdderContractRef&gt; } // in some function self.adder.add(3, 5) // or struct Contract { adder: Var&lt;Address&gt; } // in some function AdderContractRef::new(self.env(), address).add(3, 5)  ","version":"2.3.0","tagName":"h2"},{"title":"Loading the contract​","type":1,"pageTitle":"Cross calls","url":"/docs/2.3.0/basics/cross-calls#loading-the-contract","content":"Sometimes it is useful to load the deployed contract instead of deploying it by ourselves. This is especially useful when we want to test our contracts in Livenet backend. We can load the contract using load method on the Deployer: examples/bin/erc20_on_livenet.rs fn _load_erc20(env: &amp;HostEnv) -&gt; Erc20HostRef { let address = &quot;hash-d26fcbd2106e37be975d2045c580334a6d7b9d0a241c2358a4db970dfd516945&quot;; let address = Address::from_str(address).unwrap(); Erc20::load(env, address) }  ","version":"2.3.0","tagName":"h3"},{"title":"Testing​","type":1,"pageTitle":"Cross calls","url":"/docs/2.3.0/basics/cross-calls#testing","content":"Let's see how we can test our cross calls using this knowledge: examples/src/features/cross_calls.rs #[cfg(test)] mod tests { use super::{CrossContract, CrossContractInitArgs, MathEngineHostRef}; use odra::host::{Deployer, NoArgs}; use odra::prelude::*; #[test] fn test_cross_calls() { let test_env = odra_test::env(); let math_engine_contract = MathEngine::deploy(&amp;test_env, NoArgs); let cross_contract = CrossContract::deploy( &amp;test_env, CrossContractInitArgs { math_engine_address: *math_engine_contract.address() } ); assert_eq!(cross_contract.add_using_another(), 8); } }  Each test begins with a clean instance of the blockchain, with no contracts deployed. To test an external contract, we first deploy a MathEngine contract, although we won't directly utilize it. Instead, we only extract its address. Let's continue assuming there is a contract featuring the add() function that we intend to utilize. #[cfg(test)] mod tests { use super::*; use odra::host::{Deployer, NoArgs}; use odra::prelude::*; #[test] fn test_ext() { let test_env = odra_test::env(); let adder = Adder::new(&amp;test_env, get_adder_address(&amp;test_env)).add(3, 5) assert_eq!(adder.add(1, 2), 3); } fn get_adder_address(test_env: &amp;HostEnv) -&gt; Address { let contract = MathEngine::deploy(test_env, NoArgs); contract.address() } }  ","version":"2.3.0","tagName":"h2"},{"title":"Casper Contract Schema","type":0,"sectionRef":"#","url":"/docs/2.3.0/basics/casper-contract-schema","content":"","keywords":"","version":"2.3.0"},{"title":"Odra and CCS​","type":1,"pageTitle":"Casper Contract Schema","url":"/docs/2.3.0/basics/casper-contract-schema#odra-and-ccs","content":"There is almost nothing you need to do to use CCS in your Odra project. The only thing to be taken care of is using odra attributes namely: module, event, odra_error and odra_type. The schema will be generated for you and available in the resources directory. note If you forget to register events and errors in the module attribute, the definition remains valid; however, the errors and events will not be incorporated into the schema. src/contract.rs use odra::prelude::*; #[odra::module( // the name of the contract, default is the module name name = &quot;MyContract&quot;, // the version of the contract, default is the version of the crate version = &quot;0.1.0&quot;, // events that the contract can emit, collected recursively if submodules are used events = [ Created, Updated ], // the error enum the contract can revert with, collected recursively if submodules are used errors = MyErrors )] pub struct MyContract { name: Var&lt;String&gt;, owner: Var&lt;Address&gt;, } #[odra::module] impl MyContract { /// Initializes the contract, sets the name and owner and emits an event pub fn init(&amp;mut self, name: String, owner: Address) { self.name.set(name.clone()); self.owner.set(owner.clone()); self.env().emit_event(Created { name }); } /// Updates the name of the contract and emits an event pub fn update(&amp;mut self, name: String) { self.name.set(name.clone()); self.env().emit_event(Updated { name }); } /// Returns the data of the contract pub fn get_data(&amp;self) -&gt; Data { Data { name: self.name.get_or_default(), owner: self.owner.get_or_revert_with(MyErrors::InvalidOwner), } } } // The struct will we visible in the schema in the types section #[odra::odra_type] pub struct Data { name: String, owner: Address, } // The enum variants will we visible in the schema in the errors section #[odra::odra_error] pub enum MyErrors { /// The owner is invalid InvalidOwner, /// The name is invalid InvalidName, } // The struct will we visible in the schema in the types and events section #[odra::event] pub struct Updated { name: String, } // The struct will we visible in the schema in the types section and events section #[odra::event] pub struct Created { name: String, }  ","version":"2.3.0","tagName":"h2"},{"title":"Generating the Schema​","type":1,"pageTitle":"Casper Contract Schema","url":"/docs/2.3.0/basics/casper-contract-schema#generating-the-schema","content":"To generate the schema run the following cargo-odra command: cargo odra schema # or pass -c flag to generate the schema for a specific contract  ","version":"2.3.0","tagName":"h2"},{"title":"Schema Output​","type":1,"pageTitle":"Casper Contract Schema","url":"/docs/2.3.0/basics/casper-contract-schema#schema-output","content":"The generated schema will be available in the resources directory. The schema is a JSON file that contains all the information about the contract. Here is an example of the generated schema: resources/my_contract_schema.json { &quot;casper_contract_schema_version&quot;: 1, &quot;toolchain&quot;: &quot;rustc 1.77.0-nightly (5bd5d214e 2024-01-25)&quot;, &quot;authors&quot;: [], &quot;repository&quot;: null, &quot;homepage&quot;: null, &quot;contract_name&quot;: &quot;MyContract&quot;, &quot;contract_version&quot;: &quot;0.1.0&quot;, &quot;types&quot;: [ { &quot;struct&quot;: { &quot;name&quot;: &quot;Created&quot;, &quot;description&quot;: null, &quot;members&quot;: [ { &quot;name&quot;: &quot;name&quot;, &quot;description&quot;: null, &quot;ty&quot;: &quot;String&quot; } ] } }, { &quot;struct&quot;: { &quot;name&quot;: &quot;Data&quot;, &quot;description&quot;: null, &quot;members&quot;: [ { &quot;name&quot;: &quot;name&quot;, &quot;description&quot;: null, &quot;ty&quot;: &quot;String&quot; }, { &quot;name&quot;: &quot;owner&quot;, &quot;description&quot;: null, &quot;ty&quot;: &quot;Key&quot; } ] } }, { &quot;struct&quot;: { &quot;name&quot;: &quot;Updated&quot;, &quot;description&quot;: null, &quot;members&quot;: [ { &quot;name&quot;: &quot;name&quot;, &quot;description&quot;: null, &quot;ty&quot;: &quot;String&quot; } ] } } ], &quot;errors&quot;: [ { &quot;name&quot;: &quot;InvalidName&quot;, &quot;description&quot;: &quot;The name is invalid&quot;, &quot;discriminant&quot;: 1 }, { &quot;name&quot;: &quot;InvalidOwner&quot;, &quot;description&quot;: &quot;The owner is invalid&quot;, &quot;discriminant&quot;: 0 } ], &quot;entry_points&quot;: [ { &quot;name&quot;: &quot;update&quot;, &quot;description&quot;: &quot;Updates the name of the contract and emits an event&quot;, &quot;is_mutable&quot;: true, &quot;arguments&quot;: [ { &quot;name&quot;: &quot;name&quot;, &quot;description&quot;: null, &quot;ty&quot;: &quot;String&quot;, &quot;optional&quot;: false } ], &quot;return_ty&quot;: &quot;Unit&quot;, &quot;is_contract_context&quot;: true, &quot;access&quot;: &quot;public&quot; }, { &quot;name&quot;: &quot;get_data&quot;, &quot;description&quot;: &quot;Returns the data of the contract&quot;, &quot;is_mutable&quot;: false, &quot;arguments&quot;: [], &quot;return_ty&quot;: &quot;Data&quot;, &quot;is_contract_context&quot;: true, &quot;access&quot;: &quot;public&quot; } ], &quot;events&quot;: [ { &quot;name&quot;: &quot;Created&quot;, &quot;ty&quot;: &quot;Created&quot; }, { &quot;name&quot;: &quot;Updated&quot;, &quot;ty&quot;: &quot;Updated&quot; } ], &quot;call&quot;: { &quot;wasm_file_name&quot;: &quot;MyContract.wasm&quot;, &quot;description&quot;: &quot;Initializes the contract, sets the name and owner and emits an event&quot;, &quot;arguments&quot;: [ { &quot;name&quot;: &quot;odra_cfg_package_hash_key_name&quot;, &quot;description&quot;: &quot;The arg name for the package hash key name.&quot;, &quot;ty&quot;: &quot;String&quot;, &quot;optional&quot;: false }, { &quot;name&quot;: &quot;odra_cfg_allow_key_override&quot;, &quot;description&quot;: &quot;The arg name for the allow key override.&quot;, &quot;ty&quot;: &quot;Bool&quot;, &quot;optional&quot;: false }, { &quot;name&quot;: &quot;odra_cfg_is_upgradable&quot;, &quot;description&quot;: &quot;The arg name for the contract upgradeability setting.&quot;, &quot;ty&quot;: &quot;Bool&quot;, &quot;optional&quot;: false }, { &quot;name&quot;: &quot;odra_cfg_is_upgrade&quot;, &quot;description&quot;: &quot;The arg name for the contract upgrade setting.&quot;, &quot;ty&quot;: &quot;Bool&quot;, &quot;optional&quot;: false }, { &quot;name&quot;: &quot;name&quot;, &quot;description&quot;: null, &quot;ty&quot;: &quot;String&quot;, &quot;optional&quot;: false }, { &quot;name&quot;: &quot;owner&quot;, &quot;description&quot;: null, &quot;ty&quot;: &quot;Key&quot;, &quot;optional&quot;: false } ] } }  ","version":"2.3.0","tagName":"h2"},{"title":"Schema Fields​","type":1,"pageTitle":"Casper Contract Schema","url":"/docs/2.3.0/basics/casper-contract-schema#schema-fields","content":"casper_contract_schema_version is the version of the schema.toolchain is the version of the Rust compiler used to compile the contract.Fields authors, repository, and homepage are optional and can be set in the Cargo.toml file.contract_name is the name of the contract - by default is the module name, may be overriden by the module attribute.contract_version denotes the version of the contract, defaulting to the version specified in the Cargo.toml file, but can be overridden by the module attribute.types comprises a list of custom structs and enums defined within the contract. Each struct or enum includes a name, description (not currently supported, with the value set to null), and a list of members.errors is a list of error enums defined within the contract. Each error includes a name, description (the first line of the variant documentation), and a discriminant.entry_points is a list of contract functions that can be called from the outside. Each entry point includes a name, description (not currently supported, with the value set to null), whether the function is mutable, a list of arguments, the return type, whether the function is called in the contract context, and the access level.events is a list of events that the contract can emit. Each event includes a name and the type (earlier defined in types) of the event.The call section provides details regarding the contract's call function, which executes upon contract deployment. It includes the name of the Wasm file, a description (reflecting the constructor's description, typically the init function), and a list of arguments. These arguments are a combination of Odra configuration arguments and constructor arguments. ","version":"2.3.0","tagName":"h2"},{"title":"Errors","type":0,"sectionRef":"#","url":"/docs/2.3.0/basics/errors","content":"","keywords":"","version":"2.3.0"},{"title":"Testing errors​","type":1,"pageTitle":"Errors","url":"/docs/2.3.0/basics/errors#testing-errors","content":"Okay, but how about testing it? Let's write a test that will check if the error is thrown when the caller is not an owner: examples/src/features/handling_errors.rs #[cfg(test)] mod tests { use super::{Error, OwnedContract, OwnedContractInitArgs}; use odra::{host::Deployer, prelude::*}; #[test] fn test_owner_error() { let test_env = odra_test::env(); let owner = test_env.get_account(0); let not_an_owner = test_env.get_account(1); test_env.set_caller(owner); let init_args = OwnedContractInitArgs { name: &quot;OwnedContract&quot;.to_string() }; let mut owned_contract = OwnedContract::deploy(&amp;test_env, init_args); test_env.set_caller(not_an_owner); assert_eq!( owned_contract .try_change_name(&quot;NewName&quot;.to_string()) .unwrap_err(), Error::NotAnOwner.into() ); } }  Each deployed contract is of {{ModuleName}}HostRef type and has try_{{entry_point_name}} functions that return an OdraResult.OwnedContractHostRef implements regular entrypoints: name, owner, change_name, and and safe its safe version: try_name, try_owner, try_change_name. In our example, we are calling try_change_name and expecting an error to be thrown. For assertions, we are using a standard assert_eq! macro. As the contract call returns an OdraError, we need to convert our custom error to OdraError using Into::into(). ","version":"2.3.0","tagName":"h2"},{"title":"What's next​","type":1,"pageTitle":"Errors","url":"/docs/2.3.0/basics/errors#whats-next","content":"We will learn how to emit and test events using Odra. ","version":"2.3.0","tagName":"h2"},{"title":"Events","type":0,"sectionRef":"#","url":"/docs/2.3.0/basics/events","content":"","keywords":"","version":"2.3.0"},{"title":"Testing events​","type":1,"pageTitle":"Events","url":"/docs/2.3.0/basics/events#testing-events","content":"Odra's HostEnv comes with a few functions which lets you easily test the events that a given contract has emitted: examples/src/features/events.rs use super::{PartyContract, PartyStarted}; use odra::host::{Deployer, HostEnv, NoArgs}; #[test] fn test_party() { let test_env: HostEnv = odra_test::env(); let party_contract = PartyContract::deploy(&amp;test_env, NoArgs); assert!(test_env.emitted_event( &amp;party_contract, PartyStarted { caller: test_env.get_account(0), block_time: 0 } )); assert!(test_env.emitted_native_event( &amp;party_contract, NativePartyStarted { caller: test_env.get_account(0), block_time: 0 } )); // If you do not want to check the exact event, you can use `emitted` function assert!(test_env.emitted(&amp;party_contract, &quot;PartyStarted&quot;)); // Or `emitted_native` for the native events assert!(test_env.emitted_native(&amp;party_contract, &quot;NativePartyStarted&quot;)); // You can also check how many events were emitted: assert_eq!(test_env.events_count(&amp;party_contract), 1); assert_eq!(test_env.native_events_count(&amp;party_contract), 1); }  To explore more event testing functions, check the HostEnv documentation. ","version":"2.3.0","tagName":"h2"},{"title":"What's next​","type":1,"pageTitle":"Events","url":"/docs/2.3.0/basics/events#whats-next","content":"Read the next article to learn how to call other contracts from the contract context. ","version":"2.3.0","tagName":"h2"},{"title":"Modules","type":0,"sectionRef":"#","url":"/docs/2.3.0/basics/modules","content":"","keywords":"","version":"2.3.0"},{"title":"Testing​","type":1,"pageTitle":"Modules","url":"/docs/2.3.0/basics/modules#testing","content":"As we don't need to hold addresses, the test is really simple: examples/src/features/modules.rs #[cfg(test)] mod tests { use super::ModulesContract; use odra::host::{Deployer, NoArgs}; #[test] fn test_modules() { let test_env = odra_test::env(); let modules_contract = ModulesContract::deploy(&amp;test_env, NoArgs); assert_eq!(modules_contract.add_using_module(), 8); } }  ","version":"2.3.0","tagName":"h2"},{"title":"What's next​","type":1,"pageTitle":"Modules","url":"/docs/2.3.0/basics/modules#whats-next","content":"We will see how to handle native token transfers. ","version":"2.3.0","tagName":"h2"},{"title":"Flipper Internals","type":0,"sectionRef":"#","url":"/docs/2.3.0/basics/flipper-internals","content":"","keywords":"","version":"2.3.0"},{"title":"Header​","type":1,"pageTitle":"Flipper Internals","url":"/docs/2.3.0/basics/flipper-internals#header","content":"flipper.rs use odra::prelude::*;  The first line of the file imports the odra crate. The prelude module contains all the necessary types and traits that you will need to write your contract. It is a good practice to import theodra::prelude::* module in every file that contains Odra code. This way, you will not have to import each type or trait separately. ","version":"2.3.0","tagName":"h2"},{"title":"Struct​","type":1,"pageTitle":"Flipper Internals","url":"/docs/2.3.0/basics/flipper-internals#struct","content":"flipper.rs /// A module definition. Each module struct consists of Vars and Mappings /// or/and other modules. #[odra::module] pub struct Flipper { /// The module itself does not store the value, /// it's a proxy that writes/reads value to/from the host. value: Var&lt;bool&gt;, }  In Odra, all contracts are also modules, which can be reused between contracts. That's why we need to mark the struct with the #[odra::module] attribute. In the struct definition itself, we state all the fields of the contract. Those fields can be regular Rust data types, however - those will not be persisted on the blockchain. They can also be Odra modules - defined in your project or coming from Odra itself. Finally, to make the data persistent on the blockchain, you can use something likeVar&lt;T&gt; showed above. To learn more about storage interaction, take a look at thenext article. ","version":"2.3.0","tagName":"h2"},{"title":"Impl​","type":1,"pageTitle":"Flipper Internals","url":"/docs/2.3.0/basics/flipper-internals#impl","content":"flipper.rs /// Module implementation. /// /// To generate entrypoints, /// an implementation block must be marked as #[odra::module]. #[odra::module] impl Flipper { /// Odra constructor. /// /// Initializes the contract with the value of value. pub fn init(&amp;mut self) { self.value.set(false); } ...  Similarly to the struct, we mark the impl section with the #[odra::module] attribute. Odra will take allpub functions from this section and create contract endpoints from them. So, if you wish to have functions that are not available for calling outside the contract, do not make them public. Alternatively, you can create a separate impl section without the attribute - all functions defined there, even marked with pub will be not callable. The function named init is the constructor of the contract. This function will be limited only to a single call, all further calls to it will result in an error. The init function is optional, if your contract does not need any initialization, you can skip it. flipper.rs ... /// Replaces the current value with the passed argument. pub fn set(&amp;mut self, value: bool) { self.value.set(value); } /// Replaces the current value with the opposite value. pub fn flip(&amp;mut self) { self.value.set(!self.get()); } ...  The endpoints above show you how to interact with the simplest type of storage - Var&lt;T&gt;. The data saved there using set function will be persisted in the blockchain. ","version":"2.3.0","tagName":"h2"},{"title":"Tests​","type":1,"pageTitle":"Flipper Internals","url":"/docs/2.3.0/basics/flipper-internals#tests","content":"flipper.rs #[cfg(test)] mod tests { use crate::flipper::Flipper; use odra::host::{Deployer, NoArgs}; #[test] fn flipping() { let env = odra_test::env(); // To test a module we need to deploy it. `Flipper` implements `Deployer` trait, // so we can use it to deploy the module. let mut contract = Flipper::deploy(&amp;env, NoArgs); assert!(!contract.get()); contract.flip(); assert!(contract.get()); } ...  You can write tests in any way you prefer and know in Rust. In the example above we are deploying the contract using Deployer::deploy function called on Flipper - a piece of code generated by the #[odra::module]. Because the module implements the constructor but does not accept any arguments, as the second argument of the deploy function, we pass NoArgs - one of the implementations of the InitArgs trait provided with the framework. The contract will be deployed on the VM you chose while running cargo odra test. ","version":"2.3.0","tagName":"h2"},{"title":"What's next​","type":1,"pageTitle":"Flipper Internals","url":"/docs/2.3.0/basics/flipper-internals#whats-next","content":"Now let's take a look at the different types of storage that Odra provides and how to use them. ","version":"2.3.0","tagName":"h2"},{"title":"Odra.toml","type":0,"sectionRef":"#","url":"/docs/2.3.0/basics/odra-toml","content":"","keywords":"","version":"2.3.0"},{"title":"Adding a new contract manually​","type":1,"pageTitle":"Odra.toml","url":"/docs/2.3.0/basics/odra-toml#adding-a-new-contract-manually","content":"Besides using the cargo odra generate command, you can add a new contract to be compiled by hand. To do this, add another [[contracts]] element, name it and make sure that the fqn is set correctly. For example, if you want to create a new contract called counter, your Odra.toml file should finally look like this: [[contracts]] fqn = &quot;sample::Flipper&quot; [[contracts]] fqn = &quot;sample::Counter&quot;  ","version":"2.3.0","tagName":"h2"},{"title":"What's next​","type":1,"pageTitle":"Odra.toml","url":"/docs/2.3.0/basics/odra-toml#whats-next","content":"In the next section, we'll take a closer look at the code that was generated by Odra by default - the famousFlipper contract. ","version":"2.3.0","tagName":"h2"},{"title":"Native token","type":0,"sectionRef":"#","url":"/docs/2.3.0/basics/native-token","content":"","keywords":"","version":"2.3.0"},{"title":"Testing​","type":1,"pageTitle":"Native token","url":"/docs/2.3.0/basics/native-token#testing","content":"To be able to test how many tokens a contract (or any address) has, HostEnv comes with a function -balance_of: examples/src/features/native_token.rs #[cfg(test)] mod tests { use super::PublicWallet; use odra::{casper_types::U512, host::{Deployer, HostRef, NoArgs}}; #[test] fn test_modules() { let test_env = odra_test::env(); let mut my_contract = PublicWallet::deploy(&amp;test_env, NoArgs); assert_eq!(test_env.balance_of(&amp;my_contract), U512::zero()); my_contract.with_tokens(U512::from(100)).deposit(); assert_eq!(test_env.balance_of(&amp;my_contract), U512::from(100)); my_contract.withdraw(U512::from(25)); assert_eq!(test_env.balance_of(&amp;my_contract), U512::from(75)); } }  ","version":"2.3.0","tagName":"h2"},{"title":"HostEnv​","type":1,"pageTitle":"Native token","url":"/docs/2.3.0/basics/native-token#hostenv","content":"In a broader context of the host environment (test, livenet), you can also transfer CSPR tokens between accounts: let env = odra_casper_livenet_env::env(); //let env = odra_test::env(); let (alice, bob) = (env.get_account(0), env.get_account(1)); env.set_caller(alice); let result = env.transfer_tokens(bob, odra::casper_types::U512::from(100));  ","version":"2.3.0","tagName":"h2"},{"title":"Odra for Solidity developers","type":0,"sectionRef":"#","url":"/docs/2.2.0/tutorials/odra-solidity","content":"","keywords":"","version":"2.2.0"},{"title":"Introduction​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.2.0/tutorials/odra-solidity#introduction","content":"Hi, stranger Solidity developer! If you are looking to expand your horizons into Rust-based smart contract development, you've come to the right place. Odra is a high-level framework designed to simplify the development of smart contracts for the Casper Network. This tutorial will guide you through the basics of transitioning from Solidity to Odra, highlighting key differences and providing practical examples. Before we delve into the details, we have great news for you. From the very beginning, we have been thinking of you. Our main goal was to design the framework in a way that flattens the learning curve, especially for Solidity developers. ","version":"2.2.0","tagName":"h2"},{"title":"Prerequisites​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.2.0/tutorials/odra-solidity#prerequisites","content":"To follow this guide, you should have: Knowledge of Solidity.Familiarity with Ethereum and smart contract concepts.Basic understanding of Rust, as Odra is based on it. ","version":"2.2.0","tagName":"h2"},{"title":"Hello World​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.2.0/tutorials/odra-solidity#hello-world","content":"Let's start with a simple &quot;Hello World&quot; contract in Odra. The following code snippet demonstrates a basic smart contract that stores a greeting message. OdraSolidity use odra::prelude::*; #[odra::module] pub struct HelloWorld { greet: Var&lt;String&gt;, } #[odra::module] impl HelloWorld { pub fn init(&amp;mut self, message: String) { self.greet.set(message); } pub fn get(&amp;self) -&gt; String { self.greet.get_or_default() } }  As you may have noticed, the Odra code is slightly more verbose than the Solidity code. To define a contract in Odra, you need to create a struct and implement a module for it, both annotated with the odra::module attribute. The struct contains the contract's state variables, while the module defines the contract's functions. In this example, the HelloWorld struct has a single state variable greet, which stores the greeting message. The module contains two functions: init to set the greeting message and get to retrieve it. Two key differences are: Odra does not generate getters for public state variables automatically, so you need to define them explicitly.To initialize values, you must do it in the init function, which is the contract constructor. You can't assign defaults outside the constructor. ","version":"2.2.0","tagName":"h2"},{"title":"Variable Storage and State Management​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.2.0/tutorials/odra-solidity#variable-storage-and-state-management","content":"","version":"2.2.0","tagName":"h2"},{"title":"Data Types​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.2.0/tutorials/odra-solidity#data-types","content":"OdraSolidity use core::str::FromStr; use odra::{casper_types::{bytesrepr::Bytes, U256}, prelude::*}; #[odra::module] pub struct Primitives { boo: Var&lt;bool&gt;, u: Var&lt;u8&gt;, // u8 is the smallest unsigned integer type u2: Var&lt;U256&gt;, // U256 is the biggest unsigned integer type i: Var&lt;i32&gt;, // i32 is the smallest signed integer type i2: Var&lt;i64&gt;, // i64 is the biggest signed integer type address: Var&lt;Address&gt;, bytes: Var&lt;Bytes&gt;, default_boo: Var&lt;bool&gt;, default_uint: Var&lt;U256&gt;, default_int: Var&lt;i64&gt;, default_addr: Var&lt;Address&gt;, } #[odra::module] impl Primitives { pub fn init(&amp;mut self) { self.boo.set(true); self.u.set(1); self.u2.set(U256::from(456)); self.i.set(-1); self.i2.set(456); self.address.set( Address::from_str( &quot;hash-d4b8fa492d55ac7a515c0c6043d72ba43c49cd120e7ba7eec8c0a330dedab3fb&quot;, ) .unwrap_or_revert(&amp;self.env()), ); self.bytes.set(Bytes::from(vec![0xb5])); let _min_int = U256::zero(); let _max_int = U256::MAX; } // For the types that have default values, we can use the get_or_default method pub fn get_default_boo(&amp;self) -&gt; bool { self.default_boo.get_or_default() } pub fn get_default_uint(&amp;self) -&gt; U256 { self.default_uint.get_or_default() } pub fn get_default_int(&amp;self) -&gt; i64 { self.default_int.get_or_default() } // Does not compile - Address does not have the default value pub fn get_default_addr(&amp;self) -&gt; Address { self.default_addr.get_or_default() } }  The range of integer types in Odra is slightly different from Solidity. Odra provides a wide range of integer types: u8, u16, u32, u64, U128, and U256 for unsigned integers, and i32 and i64 for signed integers. The Address type in Odra is used to represent account and contract addresses. In Odra, there is no default/zero value for the Address type; the workaround is to use Option&lt;Address&gt;. The Bytes type is used to store byte arrays. Values are stored in units called Named Keys and Dictionaries. Additionally, local variables are available within the entry points and can be used to perform necessary actions or computations within the scope of each entry point. ","version":"2.2.0","tagName":"h3"},{"title":"Constants and Immutability​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.2.0/tutorials/odra-solidity#constants-and-immutability","content":"OdraSolidity use odra::{casper_types::{account::AccountHash, U256}, prelude::*}; #[odra::module] pub struct Constants; #[odra::module] impl Constants { pub const MY_UINT: U256 = U256([123, 0, 0, 0]); pub const MY_ADDRESS: Address = Address::Account( AccountHash([0u8; 32]) ); }  In Odra, you can define constants using the const keyword. Constants are immutable and can be of any type, including custom types. In addition to constants, Solidity also supports the immutable keyword, which is used to set the value of a variable once, in the constructor. Further attempts to alter this value result in a compile error. Odra/Rust does not have an equivalent to Solidity's immutable keyword. ","version":"2.2.0","tagName":"h3"},{"title":"Variables​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.2.0/tutorials/odra-solidity#variables","content":"OdraSolidity use odra::{casper_types::U256, prelude::*}; #[odra::module] pub struct Variables { text: Var&lt;String&gt;, my_uint: Var&lt;U256&gt;, } #[odra::module] impl Variables { pub fn init(&amp;mut self) { self.text.set(&quot;Hello&quot;.to_string()); self.my_uint.set(U256::from(123)); } pub fn do_something(&amp;self) { // Local variables let i = 456; // Env variables let timestamp = self.env().get_block_time(); let sender = self.env().caller(); } }  In Solidity there are three types of variables: state variables, local variables, and global variables. State variables are stored on the blockchain and are accessible by all functions within the contract. Local variables are not stored on the blockchain and are only available within the function in which they are declared. Global variables provide information about the blockchain. Odra uses very similar concepts, but with some differences. In Odra, state variables are a part of a module definition, and local variables are available within the entry points and can be used to perform necessary actions or computations within the scope of each entry point. Global variables are accessed using an instance of ContractEnv retrieved using the env() function. ","version":"2.2.0","tagName":"h3"},{"title":"Arrays and Mappings​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.2.0/tutorials/odra-solidity#arrays-and-mappings","content":"OdraSolidity use odra::{casper_types::U256, prelude::*}; #[odra::module] pub struct MappingContract { my_map: Mapping&lt;Address, Option&lt;U256&gt;&gt; } #[odra::module] impl MappingContract { pub fn get(&amp;self, addr: Address) -&gt; U256 { // self.my_map.get(&amp;addr) would return Option&lt;Option&lt;U256&gt;&gt; // so we use get_or_default instead and unwrap the inner Option self.my_map.get_or_default(&amp;addr).unwrap_or_default() } pub fn set(&amp;mut self, addr: Address, i: U256) { self.my_map.set(&amp;addr, Some(i)); } pub fn remove(&amp;mut self, addr: Address) { self.my_map.set(&amp;addr, None); } } #[odra::module] pub struct NestedMapping { my_map: Mapping&lt;(Address, U256), Option&lt;bool&gt;&gt; } #[odra::module] impl NestedMapping { pub fn get(&amp;self, addr: Address, i: U256) -&gt; bool { self.my_map.get_or_default(&amp;(addr, i)).unwrap_or_default() } pub fn set(&amp;mut self, addr: Address, i: U256, boo: bool) { self.my_map.set(&amp;(addr, i), Some(boo)); } pub fn remove(&amp;mut self, addr: Address, i: U256) { self.my_map.set(&amp;(addr, i), None); } }  OdraSolidity use odra::prelude::*; #[odra::module] pub struct Array { // the size of the array must be known at compile time arr: Var&lt;[u8; 10]&gt;, vec: Var&lt;Vec&lt;u32&gt;&gt;, } #[odra::module] impl Array { pub fn init(&amp;mut self) { self.arr.set([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]); self.vec.set(vec![1, 2, 3, 4, 5]); } pub fn get_arr(&amp;self) -&gt; [u8; 10] { self.arr.get_or_default() } pub fn push_vec(&amp;mut self, value: u32) { let mut vec = self.vec.get_or_default(); vec.push(value); self.vec.set(vec); } pub fn pop_vec(&amp;mut self) { let mut vec = self.vec.get_or_default(); vec.pop(); self.vec.set(vec); } pub fn update_arr(&amp;mut self, index: u8, value: u8) { let mut arr = self.arr.get_or_default(); arr[index as usize] = value; self.arr.set(arr); } }  For storing a collection of data as a single unit, Odra uses the Vec type for dynamic arrays and fixed-size arrays, both wrapped with the Var container. As in Solidity, you must be aware that reading the entire array in one go can be expensive, so it's better to avoid it for large arrays. In many cases, you can use a Mapping or List instead of an array or vector to store data. ","version":"2.2.0","tagName":"h3"},{"title":"Custom types​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.2.0/tutorials/odra-solidity#custom-types","content":"OdraSolidity use odra::prelude::*; #[odra::odra_type] #[derive(Default)] pub enum Status { #[default] Pending, Shipped, Accepted, Rejected, Canceled, } #[odra::module] pub struct Enum { status: Var&lt;Status&gt;, } #[odra::module] impl Enum { pub fn get(&amp;self) -&gt; Status { self.status.get_or_default() } pub fn set(&amp;mut self, status: Status) { self.status.set(status); } pub fn cancel(&amp;mut self) { self.status.set(Status::Canceled); } pub fn reset(&amp;mut self) { self.status.set(Default::default()); } }  In Odra, custom types are defined using the #[odra::odra_type] attribute. The enum can have a default value specified using the #[default] attribute if derived from the Default trait. The enum can be used as a state variable in a contract, and its value can be set and retrieved using the set and get functions. The value cannot be deleted; however, it can be set using the Default::default() function. OdraSolidity use odra::prelude::*; #[odra::odra_type] pub struct Todo { text: String, completed: bool, } #[odra::module] pub struct Enum { // You could also use Var&lt;Vec&lt;Todo&gt;&gt; instead of List&lt;Todo&gt;, // but List is more efficient for large arrays, // it loads items lazily. todos: List&lt;Todo&gt;, } #[odra::module] impl Enum { pub fn create(&amp;mut self, text: String) { self.todos.push(Todo { text, completed: false, }); } pub fn update_text(&amp;mut self, index: u32, text: String) { if let Some(mut todo) = self.todos.get(index) { todo.text = text; self.todos.replace(index, todo); } } pub fn toggle_complete(&amp;mut self, index: u32) { if let Some(mut todo) = self.todos.get(index) { todo.completed = !todo.completed; self.todos.replace(index, todo); } } // Odra does not create getters by default pub fn get(&amp;self, index: u32) -&gt; Option&lt;Todo&gt; { self.todos.get(index) } }  Similarly to enums, custom structs are defined using the #[odra::odra_type] attribute. The struct can be used to define a list of items in a contract. The list can be created using the List type, which is more efficient for large arrays as it loads items lazily. ","version":"2.2.0","tagName":"h3"},{"title":"Data Location​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.2.0/tutorials/odra-solidity#data-location","content":"In Solidity, data location is an important concept that determines where the data is stored and how it can be accessed. The data location can be memory, storage, or calldata. In Odra, data location is not explicitly defined, but whenever interacting with storage primitives (e.g., Var, Mapping, List), the data is stored in the contract's storage. ","version":"2.2.0","tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.2.0/tutorials/odra-solidity#functions","content":"Odra contracts define their entry point and internal functions within the impl block. Here's an example of a transfer function: impl Erc20 { pub fn transfer(&amp;mut self, recipient: &amp;Address, amount: &amp;U256) { self.internal_transfer(&amp;self.env().caller(), recipient, amount); // Transfer logic goes here } fn internal_transfer(&amp;mut self, sender: &amp;Address, recipient: &amp;Address, amount: &amp;U256) { // Internal transfer logic goes here } }  Functions can modify contract state and emit events using the ContractEnv function. ","version":"2.2.0","tagName":"h2"},{"title":"View and Pure​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.2.0/tutorials/odra-solidity#view-and-pure","content":"OdraSolidity use odra::prelude::*; #[odra::module] pub struct ViewAndPure { x: Var&lt;u32&gt; } #[odra::module] impl ViewAndPure { pub fn add_to_x(&amp;self, y: u32) -&gt; u32 { self.x.get_or_default() + y } } pub fn add(i: u32, j: u32) -&gt; u32 { i + j }  In Odra, you don't need to specify view or pure functions explicitly. All functions are considered view functions by default, meaning they can read contract state but not modify it. To modify the state, the first parameter (called the receiver parameter) should be &amp;mut self. If you want to create a pure function that doesn't read or modify state, you can define it as a regular Rust function without any side effects. ","version":"2.2.0","tagName":"h3"},{"title":"Modifiers​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.2.0/tutorials/odra-solidity#modifiers","content":"OdraSolidity use odra::prelude::*; #[odra::module] pub struct FunctionModifier { x: Var&lt;u32&gt;, locked: Var&lt;bool&gt;, } #[odra::module] impl FunctionModifier { pub fn decrement(&amp;mut self, i: u32) { self.lock(); self.x.set(self.x.get_or_default() - i); if i &gt; 1 { self.decrement(i - 1); } self.unlock(); } #[inline] fn lock(&amp;mut self) { if self.locked.get_or_default() { self.env().revert(Error::NoReentrancy); } self.locked.set(true); } #[inline] fn unlock(&amp;mut self) { self.locked.set(false); } } #[odra::odra_error] pub enum Error { NoReentrancy = 1, }  In Odra, there is no direct equivalent to Solidity's function modifiers. Instead, you can define functions that perform certain actions before or after the main function logic. In the example above, the lock and unlock functions are called before and after the decrement function, respectively, but they must be called explicitly. As often as practicable, developers should inline functions by including the body of the function within their code using the #[inline] attribute. In the context of coding for Casper blockchain purposes, this reduces the overhead of executed Wasm and prevents unexpected errors due to exceeding resource tolerances. ","version":"2.2.0","tagName":"h3"},{"title":"Visibility​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.2.0/tutorials/odra-solidity#visibility","content":"Functions and state variables have to declare whether they are accessible by other contracts. Functions can be declared as: OdraSolidity `pub` inside `#[odra::module]` impl block - any contract/submodule and account can call. `pub` inside a regular impl block - any submodule can call. `default/no modifier/private` - only inside the contract that defines the function.  ","version":"2.2.0","tagName":"h3"},{"title":"Payable​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.2.0/tutorials/odra-solidity#payable","content":"OdraSolidity use odra::{casper_types::U512, prelude::*}; #[odra::module] pub struct Payable { owner: Var&lt;Address&gt;, } #[odra::module] impl Payable { pub fn init(&amp;mut self) { self.owner.set(self.env().caller()); } #[odra(payable)] pub fn deposit(&amp;self) { } pub fn not_payable(&amp;self) { } pub fn withdraw(&amp;self) { let amount = self.env().self_balance(); self.env().transfer_tokens(&amp;self.owner.get_or_revert_with(ExecutionError::UnwrapError), &amp;amount); } pub fn transfer(&amp;self, to: Address, amount: U512) { self.env().transfer_tokens(&amp;to, &amp;amount); } }  In Odra, you can define a function with the #[odra(payable)] attribute to indicate that the function can receive CSPRs. In Solidity, the payable keyword is used to define functions that can receive Ether. ","version":"2.2.0","tagName":"h3"},{"title":"Selectors​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.2.0/tutorials/odra-solidity#selectors","content":"In Solidity, when a function is called, the first 4 bytes of calldata specify which function to call. This is called a function selector. contract_addr.call( abi.encodeWithSignature(&quot;transfer(address,uint256)&quot;, address, 1234) )  Odra does not support such a mechanism. You must have access to the contract interface to call a function. ","version":"2.2.0","tagName":"h3"},{"title":"Events and Logging​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.2.0/tutorials/odra-solidity#events-and-logging","content":"OdraSolidity use odra::prelude::*; #[odra::event] pub struct Log { sender: Address, message: String, } #[odra::event] pub struct AnotherLog {} #[odra::module] struct Event; #[odra::module] impl Event { pub fn test(&amp;self) { let env = self.env(); env.emit_event(Log { sender: env.caller(), message: &quot;Hello World!&quot;.to_string(), }); env.emit_event(Log { sender: env.caller(), message: &quot;Hello Casper!&quot;.to_string(), }); env.emit_event(AnotherLog {}); } }  In Odra, events are regular structs defined using the #[odra::event] attribute. The event struct can contain multiple fields, which can be of any type (primitive or custom Odra type). To emit an event, use the env's emit_event() function, passing the event struct as an argument. note Events in Solidity are used to emit logs that off-chain services can capture. However, Casper does not support events natively. Odra mimics this feature. Read more about it in the Basics section. ","version":"2.2.0","tagName":"h2"},{"title":"Error Handling​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.2.0/tutorials/odra-solidity#error-handling","content":"OdraSolidity use odra::{prelude::*, casper_types::{U256, U512}}; #[odra::odra_error] pub enum CustomError { InsufficientBalance = 1, InputLowerThanTen = 2, } #[odra::module] pub struct Error; #[odra::module] impl Error { pub fn test_require(&amp;mut self, i: U256) { if i &lt;= 10.into() { self.env().revert(CustomError::InputLowerThanTen); } } pub fn execute_external_call(&amp;self, withdraw_amount: U512) { let balance = self.env().self_balance(); if balance &lt; withdraw_amount { self.env().revert(CustomError::InsufficientBalance); } } }  In Solidity, there are four ways to handle errors: require, revert, assert, and custom errors. In Odra, there is only one way to revert the execution of a function - by using the env().revert() function. The function takes an error type as an argument and stops the execution of the function. You define an error type using the #[odra::odra_error] attribute. On Casper, an error is only a number, so you can't pass a message with the error. ","version":"2.2.0","tagName":"h2"},{"title":"Composition vs. Inheritance​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.2.0/tutorials/odra-solidity#composition-vs-inheritance","content":"In Solidity, developers often use inheritance to reuse code and establish relationships between contracts. However, Odra and Rust follow a different paradigm known as composition. Instead of inheriting behavior from parent contracts, Odra encourages the composition of contracts by embedding one contract within another. Let's take a look at the difference between inheritance in Solidity and composition in Odra. OdraSolidity use odra::prelude::*; #[odra::module] pub struct A; #[odra::module] impl A { pub fn foo(&amp;self) -&gt; String { &quot;A&quot;.to_string() } } #[odra::module] pub struct B { a: SubModule&lt;A&gt; } #[odra::module] impl B { pub fn foo(&amp;self) -&gt; String { &quot;B&quot;.to_string() } } #[odra::module] pub struct C { a: SubModule&lt;A&gt; } #[odra::module] impl C { pub fn foo(&amp;self) -&gt; String { &quot;C&quot;.to_string() } } #[odra::module] pub struct D { b: SubModule&lt;B&gt;, c: SubModule&lt;C&gt; } #[odra::module] impl D { pub fn foo(&amp;self) -&gt; String { self.c.foo() } } #[odra::module] pub struct E { b: SubModule&lt;B&gt;, c: SubModule&lt;C&gt; } #[odra::module] impl E { pub fn foo(&amp;self) -&gt; String { self.b.foo() } } #[odra::module] pub struct F { a: SubModule&lt;A&gt;, b: SubModule&lt;B&gt;, } #[odra::module] impl F { pub fn foo(&amp;self) -&gt; String { self.a.foo() } }  Solidity supports both single and multiple inheritance. This means a contract can inherit from one or more contracts. Solidity uses a technique called &quot;C3 linearization&quot; to resolve the order in which base contracts are inherited in the case of multiple inheritance. This helps to ensure a consistent method resolution order. However, multiple inheritance can lead to complex code and potential issues, especially for inexperienced developers. In contrast, Rust does not have a direct equivalent to the inheritance model, but it achieves similar goals through composition. Each contract is defined as a struct, and contracts can be composed by embedding one struct within another. This approach provides a more flexible and modular way to reuse code and establish relationships between contracts. ","version":"2.2.0","tagName":"h2"},{"title":"Libraries and Utility​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.2.0/tutorials/odra-solidity#libraries-and-utility","content":"OdraSolidity use odra::{casper_types::U256, prelude::*}; mod math { use odra::casper_types::U256; pub fn sqrt(y: U256) -&gt; U256 { let mut z = y; if y &gt; 3.into() { let mut x = y / 2 + 1; while x &lt; z { z = x; x = (y / x + x) / 2; } } else if y != U256::zero() { z = U256::one(); } z } } #[odra::module] struct TestMath; #[odra::module] impl TestMath { pub fn test_square_root(&amp;self, x: U256) -&gt; U256 { math::sqrt(x) } } #[odra::odra_error] enum Error { EmptyArray = 100, } trait Removable { fn remove(&amp;mut self, index: usize); } impl Removable for Var&lt;Vec&lt;U256&gt;&gt; { fn remove(&amp;mut self, index: usize) { let env = self.env(); let mut vec = self.get_or_default(); if vec.is_empty() { env.revert(Error::EmptyArray); } vec[index] = vec.pop().unwrap_or_revert(&amp;env); self.set(vec); } } #[odra::module] struct TestArray { arr: Var&lt;Vec&lt;U256&gt;&gt;, } #[odra::module] impl TestArray { pub fn test_array_remove(&amp;mut self) { let mut arr = self.arr.get_or_default(); for i in 0..3 { arr.push(i.into()); } self.arr.set(arr); self.arr.remove(1); let arr = self.arr.get_or_default(); assert_eq!(arr.len(), 2); assert_eq!(arr[0], 0.into()); assert_eq!(arr[1], 2.into()); } }  In Solidity, libraries are similar to contracts but can't declare any state variables and can't receive Ether. In the sample code above, the Math library contains a square root function, while the Array library provides a function to remove an element from an array. Both libraries are consumed in different ways: the TestMath contract calls the sqrt function directly, while the TestArray contract uses the using keyword, which extends the type uint256[] by adding the remove function. In Odra, you use language-level features: modules and traits. The mod keyword defines a module, which is similar to a library in Solidity. Modules can contain functions, types, and other items that can be reused across multiple contracts. Traits are similar to interfaces in other programming languages, defining a set of functions that a type must implement. Implementing the Removable trait for the Var&lt;Vec&lt;U256&gt;&gt; type allows the remove function to be called on a variable that stores a vector of U256 values. ","version":"2.2.0","tagName":"h2"},{"title":"Fallback and Receive Functions​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.2.0/tutorials/odra-solidity#fallback-and-receive-functions","content":"In Solidity, a contract receiving Ether must implement a receive() and/or fallback() function. The receive() function is called when Ether is sent to the contract with no data, while the fallback() function is called when the contract receives Ether with data or when a function that does not exist is called. Odra does not have a direct equivalent to the receive() and fallback() functions. Instead, you can define a function with the #[odra(payable)] attribute to indicate that the function can receive CSPRs. ","version":"2.2.0","tagName":"h2"},{"title":"Miscellaneous​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.2.0/tutorials/odra-solidity#miscellaneous","content":"","version":"2.2.0","tagName":"h2"},{"title":"Hashing​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.2.0/tutorials/odra-solidity#hashing","content":"OdraSolidity use odra::{casper_types::{bytesrepr::ToBytes, U256}, prelude::*}; #[odra::module] pub struct HashFunction; #[odra::module] impl HashFunction { pub fn hash(&amp;self, text: String, num: U256, addr: Address) -&gt; [u8; 32] { let env = self.env(); let mut data = Vec::new(); data.extend(text.to_bytes().unwrap_or_revert(&amp;env)); data.extend(num.to_bytes().unwrap_or_revert(&amp;env)); data.extend(addr.to_bytes().unwrap_or_revert(&amp;env)); env.hash(data) } } #[odra::module] pub struct GuessTheMagicWord { answer: Var&lt;[u8; 32]&gt;, } #[odra::module] impl GuessTheMagicWord { /// Initializes the contract with the magic word hash. pub fn init(&amp;mut self) { self.answer.set([ 0x86, 0x67, 0x15, 0xbb, 0x0b, 0x96, 0xf1, 0x06, 0xe0, 0x68, 0x07, 0x89, 0x22, 0x84, 0x42, 0x81, 0x19, 0x6b, 0x1e, 0x61, 0x45, 0x50, 0xa5, 0x70, 0x4a, 0xb0, 0xa7, 0x55, 0xbe, 0xd7, 0x56, 0x08, ]); } /// Checks if the `word` is the magic word. pub fn guess(&amp;self, word: String) -&gt; bool { let env = self.env(); let hash = env.hash(word.to_bytes().unwrap_or_revert(&amp;env)); hash == self.answer.get_or_default() } }  The key difference between the two is that in Solidity, the keccak256 function is used to hash data, while in Odra, the env.hash() function is used, which implements the blake2b algorithm. Both functions take a byte array as input and return a 32-byte hash. ","version":"2.2.0","tagName":"h3"},{"title":"Try-catch​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.2.0/tutorials/odra-solidity#try-catch","content":"OdraSolidity use odra::prelude::*; #[odra::module] pub struct Example { other_contract: External&lt;OtherContractContractRef&gt;, } #[odra::module] impl Example { pub fn init(&amp;mut self, other_contract: Address) { self.other_contract.set(other_contract); } pub fn execute_external_call(&amp;self) { let result = self.other_contract.some_function(); match result { Ok(success) =&gt; { // Code to execute if the external call was successful } Err(reason) =&gt; { // Code to execute if the external call failed } } } } #[odra::module] pub struct OtherContract; #[odra::module] impl OtherContract { pub fn some_function(&amp;self) -&gt; Result&lt;bool, ()&gt; { Ok(true) } }  In Solidity, try/catch is a feature that allows developers to handle exceptions and errors more gracefully. The try/catch statement allows developers to catch and handle exceptions that occur during external function calls and contract creation. In Odra, there is no direct equivalent to the try/catch statement in Solidity. However, you can use the Result type to handle errors in a similar way. The Result type is an enum that represents either success (Ok) or failure (Err). You can use the match statement to handle the Result type and execute different code based on the result. However, if an unexpected error occurs on the way, the whole transaction reverts. ","version":"2.2.0","tagName":"h3"},{"title":"Conclusion​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.2.0/tutorials/odra-solidity#conclusion","content":"Congratulations! You've now learned the main differences in writing smart contracts with the Odra Framework. By understanding the structure, initialization, error handling, and the composition pattern in Odra, you can effectively transition from Solidity to Odra for Casper blockchain development. Experiment with the provided code samples, explore more advanced features, and unleash the full potential of the Odra Framework. Read more about the Odra Framework in the Basics and Advanced sections. Learn by example with our Tutorial series, you will find there a contract you likely familiar with - the Erc20 standard implementation. If you have any further questions or need clarification on specific topics, feel free to join our Discord! ","version":"2.2.0","tagName":"h2"},{"title":"Testing","type":0,"sectionRef":"#","url":"/docs/2.3.0/basics/testing","content":"","keywords":"","version":"2.3.0"},{"title":"HostEnv​","type":1,"pageTitle":"Testing","url":"/docs/2.3.0/basics/testing#hostenv","content":"Odra gives us some additional functions that we can use to communicate with the host (outside the contract context) and to configure how the contracts are deployed and called. Let's revisit the example from the previous article about host communication and implement the tests that prove it works: examples/src/features/testing.rs #[cfg(test)] mod tests { use crate::features::testing::{TestingContract, TestingContractInitArgs}; use odra::{host::{Deployer, HostEnv}, prelude::*}; #[test] fn env() { let test_env: HostEnv = odra_test::env(); test_env.set_caller(test_env.get_account(0)); let init_args = TestingContractInitArgs { name: &quot;MyContract&quot;.to_string() }; let testing_contract = TestingContract::deploy(&amp;test_env, init_args); let creator = testing_contract.created_by(); test_env.set_caller(test_env.get_account(1)); let init_args = TestingContractInitArgs { name: &quot;MyContract2&quot;.to_string() }; let testing_contract2 = TestingContract::deploy(&amp;test_env, init_args); let creator2 = testing_contract2.created_by(); assert_ne!(creator, creator2); } }  In the code above, at the beginning of the test, we are obtaining a HostEnv instance using odra_test::env(). Next, we are deploying two instances of the same contract, but we're using HostEnv::set_callerto change the caller - so the Address which is deploying the contract. This changes the result of the odra::ContractEnv::caller()the function we are calling inside the contract. HostEnv comes with a set of functions that will let you write better tests: fn set_caller(&amp;self, address: Address) - you've seen it in action just nowfn balance_of&lt;T: Addressable&gt;(&amp;self, addr: &amp;T) -&gt; U512 - returns the balance of the account associated with the given addressfn advance_block_time(&amp;self, time_diff: u64) - increases the current value of block_timefn get_account(&amp;self, n: usize) -&gt; Address - returns an n-th address that was prepared for you by Odra in advance; by default, you start with the 0-th accountfn emitted_event&lt;T: ToBytes + EventInstance, R: Addressable&gt;(&amp;self, contract_address: &amp;R, event: T) -&gt; bool - verifies if the event was emitted by the contract Full list of functions can be found in the HostEnv documentation. ","version":"2.3.0","tagName":"h2"},{"title":"What's next​","type":1,"pageTitle":"Testing","url":"/docs/2.3.0/basics/testing#whats-next","content":"We take a look at how Odra handles errors! ","version":"2.3.0","tagName":"h2"},{"title":"Storage interaction","type":0,"sectionRef":"#","url":"/docs/2.3.0/basics/storage-interaction","content":"","keywords":"","version":"2.3.0"},{"title":"Var​","type":1,"pageTitle":"Storage interaction","url":"/docs/2.3.0/basics/storage-interaction#var","content":"The Var is the simplest storage type available in the Odra framework. It serializes the data and stores it under a single key in the blockchain storage. To use it, just wrap your variable in the Var type. Let's look at a &quot;real world&quot; example of a contract that represents a dog: examples/src/features/storage/variable.rs use odra::prelude::*; #[odra::module] pub struct DogContract { barks: Var&lt;bool&gt;, weight: Var&lt;u32&gt;, name: Var&lt;String&gt;, walks: Var&lt;Vec&lt;u32&gt;&gt;, }  You can see the Var wrapping the data. Even complex types like Vec can be wrapped (with some caveats)! Let's make this contract usable, by providing a constructor and some getter functions: examples/src/features/storage/variable.rs #[odra::module] impl DogContract { pub fn init(&amp;mut self, barks: bool, weight: u32, name: String) { self.barks.set(barks); self.weight.set(weight); self.name.set(name); self.walks.set(Vec::&lt;u32&gt;::default()); } pub fn barks(&amp;self) -&gt; bool { self.barks.get_or_default() } pub fn weight(&amp;self) -&gt; u32 { self.weight.get_or_default() } pub fn name(&amp;self) -&gt; String { self.name.get_or_default() } pub fn walks_amount(&amp;self) -&gt; u32 { let walks = self.walks.get_or_default(); walks.len() as u32 } pub fn walks_total_length(&amp;self) -&gt; u32 { let walks = self.walks.get_or_default(); walks.iter().sum() } }  As you can see, you can access the data, by using get_or_default function: examples/src/features/storage/variable.rs ... self.barks.get_or_default() ...  note Keep in mind that using get() will result in an Option that you'll need to unwrap - the variable doesn't have to be initialized! To modify the data, use the set() function: examples/src/features/storage/variable.rs self.barks.set(barks);  A Var is easy to use and efficient for simple data types. One of its downsides is that it serializes the data as a whole, so when you're using complex types like Vec or HashMap, each time you get or set the whole data is read and written to the blockchain storage. In the example above, if we want to see how many walks our dog had, we would use the function: examples/src/features/storage/variable.rs pub fn walks_amount(&amp;self) -&gt; usize { let walks = self.walks.get_or_default(); walks.len() }  But to do so, we need to extract the whole serialized vector from the storage, which would inefficient, especially for larger sets of data. To tackle this issue following two types were created. ","version":"2.3.0","tagName":"h2"},{"title":"Mapping​","type":1,"pageTitle":"Storage interaction","url":"/docs/2.3.0/basics/storage-interaction#mapping","content":"The Mapping is used to store and access data as key-value pairs. To define a Mapping, you need to pass two values - the key type and the value type. Let's look at the variation of the Dog contract, that uses Mapping to store information about our dog's friends and how many times they visited: examples/src/features/storage/mapping.rs use odra::prelude::*; #[odra::module] pub struct DogContract2 { name: Var&lt;String&gt;, friends: Mapping&lt;String, u32&gt;, }  In the example above, our key is a String (it is a name of the friend) and we are storing u32 values (amount of visits). To read and write values from and into a Mapping we use a similar approach to the one shown in the Vars section with one difference - we need to pass a key: examples/src/features/storage/mapping.rs pub fn visit(&amp;mut self, friend_name: String) { let visits = self.visits(friend_name.clone()); self.friends.set(&amp;friend_name, visits + 1); } pub fn visits(&amp;self, friend_name: String) -&gt; u32 { self.friends.get_or_default(&amp;friend_name) }  The biggest improvement over a Var is that we can model functionality of a HashMap using Mapping. The amount of data written to and read from the storage is minimal. However, we cannot iterate over Mapping. We could implement such behavior by using a numeric type key and saving the length of the set in a separate variable. Thankfully Odra comes with a prepared solution - the List type. note If you take a look into List implementation in Odra, you'll see that in fact it is just a Mapping with a Var working together: core/src/list.rs use odra::prelude::*; pub struct List&lt;T&gt; { values: Mapping&lt;u32, T&gt;, index: Var&lt;u32&gt; }  ","version":"2.3.0","tagName":"h2"},{"title":"List​","type":1,"pageTitle":"Storage interaction","url":"/docs/2.3.0/basics/storage-interaction#list","content":"Going back to our DogContract example - let's revisit the walk case. This time, instead of Vec, we'll use the list: examples/src/features/storage/list.rs use odra::prelude::*; #[odra::module] pub struct DogContract3 { name: Var&lt;String&gt;, walks: List&lt;u32&gt;, }  As you can see, the notation is very similar to the Vec. To understand the usage, take a look at the reimplementation of the functions with an additional function that takes our dog for a walk (it writes the data to the storage): examples/src/features/storage/list.rs #[odra::module] impl DogContract3 { pub fn init(&amp;mut self, name: String) { self.name.set(name); } pub fn name(&amp;self) -&gt; String { self.name.get_or_default() } pub fn walks_amount(&amp;self) -&gt; u32 { self.walks.len() } pub fn walks_total_length(&amp;self) -&gt; u32 { self.walks.iter().sum() } pub fn walk_the_dog(&amp;mut self, length: u32) { self.walks.push(length); } }  Now, we can know how many walks our dog had without loading the whole vector from the storage. We need to do this to sum the length of all the walks, but the Odra framework cannot (yet) handle all the cases for you. info All of the above examples, alongside the tests, are available in the Odra repository in the examples/src/features/ folder. ","version":"2.3.0","tagName":"h2"},{"title":"Custom Types​","type":1,"pageTitle":"Storage interaction","url":"/docs/2.3.0/basics/storage-interaction#custom-types","content":"By default you can store only built-in types like numbers, Options, Results, Strings, Vectors. Implementing custom types is straightforward, your type must add #[odra::odra_type] attribute. Let's see how to implement a Dog type: use odra::prelude::*; #[odra::odra_type] pub struct Dog { pub name: String, pub age: u8, pub owner: Option&lt;Address&gt; }  #[odra_type] is applicable to named field structs and enums. It generates serialization, deserialization and schema code for your type.CLType of a custom type is CLType::Any, except for an unit-only enum, which is CLType::U8. unit_only_enum.rs enum Enum { Foo = 3, Bar = 2, Baz = 1, }  note Each custom typed field of your struct must be marked with the #[odra::odra_type] attribute . ","version":"2.3.0","tagName":"h2"},{"title":"What's next​","type":1,"pageTitle":"Storage interaction","url":"/docs/2.3.0/basics/storage-interaction#whats-next","content":"In the next article, we'll see how to query the host for information about the world and our contract. ","version":"2.3.0","tagName":"h2"},{"title":"odra-examples","type":0,"sectionRef":"#","url":"/docs/2.3.0/examples/odra-examples","content":"","keywords":"","version":"2.3.0"},{"title":"What's next​","type":1,"pageTitle":"odra-examples","url":"/docs/2.3.0/examples/odra-examples#whats-next","content":"Read the next article to learn about reusable Odra components encapsulated in odra-modules. ","version":"2.3.0","tagName":"h2"},{"title":"Installation","type":0,"sectionRef":"#","url":"/docs/2.3.0/getting-started/installation","content":"","keywords":"","version":"2.3.0"},{"title":"Prerequisites​","type":1,"pageTitle":"Installation","url":"/docs/2.3.0/getting-started/installation#prerequisites","content":"To start working with Odra, you need to have the following installed on your machine: Rust toolchain installed (see rustup.rs)wasmstrip tool installed (see wabt)wasm-opt tool installed (see binaryen) We do not provide exact commands for installing these tools, as they are different for different operating systems. Please refer to the documentation of the tools themselves. With Rust toolchain ready, you can add a new target: rustup target add wasm32-unknown-unknown  note wasm32-unknown-unknown is a target that will be used by Odra to compile your smart contracts to WASM files. ","version":"2.3.0","tagName":"h2"},{"title":"Installing Cargo Odra​","type":1,"pageTitle":"Installation","url":"/docs/2.3.0/getting-started/installation#installing-cargo-odra","content":"Cargo Odra is a helpful tool that will help you to build and test your smart contracts. It is not required to use Odra, but the documentation will assume that you have it installed. To install it, simply execute the following command: cargo install cargo-odra --locked  To check if it was installed correctly and see available commands, type: cargo odra --help  If everything went fine, we can proceed to the next step. ","version":"2.3.0","tagName":"h2"},{"title":"Creating a new Odra project​","type":1,"pageTitle":"Installation","url":"/docs/2.3.0/getting-started/installation#creating-a-new-odra-project","content":"To create a new project, simply execute: cargo odra new --name my-project &amp;&amp; cd my_project  This will create a new folder called my_project and initialize Odra there. Cargo Odra will create a sample contract for you in src directory. You can run the tests of this contract by executing: cargo odra test  This will run tests using Odra's internal OdraVM. You can run those tests against a real backend, let's use CasperVM: cargo odra test -b casper  Congratulations! Now you are ready to create contracts using Odra framework! If you had any problems during the installation process, feel free to ask for help on our Discord. ","version":"2.3.0","tagName":"h2"},{"title":"What's next?​","type":1,"pageTitle":"Installation","url":"/docs/2.3.0/getting-started/installation#whats-next","content":"If you want to see the code that you just tested, continue to the description of Flipper example. ","version":"2.3.0","tagName":"h2"},{"title":"Using odra-modules","type":0,"sectionRef":"#","url":"/docs/2.3.0/examples/using-odra-modules","content":"","keywords":"","version":"2.3.0"},{"title":"Available modules​","type":1,"pageTitle":"Using odra-modules","url":"/docs/2.3.0/examples/using-odra-modules#available-modules","content":"Odra modules comes with couple of ready-to-use modules and reusable extensions. ","version":"2.3.0","tagName":"h2"},{"title":"Tokens​","type":1,"pageTitle":"Using odra-modules","url":"/docs/2.3.0/examples/using-odra-modules#tokens","content":"CEP-18​ Casper Ecosystem Proposal 18 (CEP-18) is a standard interface for the CSPR and the custom made tokens. Inspired by the ERC20 standard. Read more about the CEP-18 here. CEP-95​ Casper Ecosystem Proposal 95 (CEP-95) is a Casper NFT Standard. It aims to replace CEP-47 and CEP-78, which have flaws that complicate their support in the ecosystem. This standard is aligned with Ethereum's ERC-721, but makes adjustments relevant for the Casper Ecosystem. Similarly to ERC-721, this standard can be used to represent a various range of tokenized assets Read more about the CEP-95 here. Erc20​ The Erc20 module implements the ERC20 standard. Erc721​ The Erc721Base module implements the ERC721 standard, adjusted for the Odra framework. The Erc721Token module implements the ERC721Base and additionally uses the Erc721Metadata and Ownable extensions. The Erc721Receiver trait lets you implement your own logic for receiving NFTs. The OwnedErc721WithMetadata trait is a combination of Erc721Token, Erc721Metadata and Ownable modules. Erc1155​ The Erc1155Base module implements the ERC1155 standard, adjusted for the Odra framework. The Erc1155Token module implements the ERC1155Base and additionally uses the Ownable extension. The OwnedErc1155 trait is a combination of Erc1155Token and Ownable modules. Wrapped native token​ The WrappedNativeToken module implements the Wrapper for the native token, it was inspired by the WETH. ","version":"2.3.0","tagName":"h3"},{"title":"Access​","type":1,"pageTitle":"Using odra-modules","url":"/docs/2.3.0/examples/using-odra-modules#access","content":"AccessControl​ This module enables the implementation of role-based access control mechanisms for children modules. Roles are identified by their 32-bytes identifier, which should be unique and exposed in the external API. Ownable​ This module provides a straightforward access control feature that enables exclusive access to particular functions by an account, known as the owner. The account that initiates the module is automatically assigned as the owner. However, ownership can be transferred later by using thetransfer_ownership() function. Ownable2Step​ An extension of the Ownable module. Ownership can be transferred in a two-step process by using transfer_ownership() and accept_ownership() functions. ","version":"2.3.0","tagName":"h3"},{"title":"Security​","type":1,"pageTitle":"Using odra-modules","url":"/docs/2.3.0/examples/using-odra-modules#security","content":"Pausable​ A module allowing to implement an emergency stop mechanism that can be triggered by any account. ","version":"2.3.0","tagName":"h3"},{"title":"Flipper example","type":0,"sectionRef":"#","url":"/docs/2.3.0/getting-started/flipper","content":"","keywords":"","version":"2.3.0"},{"title":"Let's flip​","type":1,"pageTitle":"Flipper example","url":"/docs/2.3.0/getting-started/flipper#lets-flip","content":"flipper.rs use odra::prelude::*; /// A module definition. Each module struct consists Vars and Mappings /// or/and another modules. #[odra::module] pub struct Flipper { /// The module itself does not store the value, /// it's a proxy that writes/reads value to/from the host. value: Var&lt;bool&gt;, } /// Module implementation. /// /// To generate entrypoints, /// an implementation block must be marked as #[odra::module]. #[odra::module] impl Flipper { /// Odra constructor. /// /// Initializes the contract. pub fn init(&amp;mut self) { self.value.set(false); } /// Replaces the current value with the passed argument. pub fn set(&amp;mut self, value: bool) { self.value.set(value); } /// Replaces the current value with the opposite value. pub fn flip(&amp;mut self) { self.value.set(!self.get()); } /// Retrieves value from the storage. /// If the value has never been set, the default value is returned. pub fn get(&amp;self) -&gt; bool { self.value.get_or_default() } } #[cfg(test)] mod tests { use crate::flipper::Flipper; use odra::host::{Deployer, NoArgs}; #[test] fn flipping() { let env = odra_test::env(); // To test a module we need to deploy it. `Flipper` implements `Deployer` trait, // so we can use it to deploy the module. let mut contract = Flipper::deploy(&amp;env, NoArgs); assert!(!contract.get()); contract.flip(); assert!(contract.get()); } }  ","version":"2.3.0","tagName":"h2"},{"title":"Testing​","type":1,"pageTitle":"Flipper example","url":"/docs/2.3.0/getting-started/flipper#testing","content":"To run the tests, execute the following command: cargo odra test # or add the `-b casper` flag to run tests on the CasperVM  ","version":"2.3.0","tagName":"h2"},{"title":"What's next​","type":1,"pageTitle":"Flipper example","url":"/docs/2.3.0/getting-started/flipper#whats-next","content":"In the next category of articles, we will go through basic concepts of Odra. ","version":"2.3.0","tagName":"h2"},{"title":"Migration guide to v1.3.0","type":0,"sectionRef":"#","url":"/docs/2.3.0/migrations/to-1.3.0","content":"","keywords":"","version":"2.3.0"},{"title":"Migrating to Odra v1.3.0​","type":1,"pageTitle":"Migration guide to v1.3.0","url":"/docs/2.3.0/migrations/to-1.3.0#migrating-to-odra-v130","content":"To migrate your smart contracts to Odra v1.3.0, remove the use the deploy method from the module instead of the {{ModuleName}}HostRef struct: before.rs let token = TokenHostRef::deploy(env, init_args); let another_token = AnotherTokenHostRef::load(env, address);  after.rs let token = Token::deploy(env, init_args); let another_token = AnotherToken::load(env, address);  ","version":"2.3.0","tagName":"h2"},{"title":"Migration guide to v2.0.0 from 1.*","type":0,"sectionRef":"#","url":"/docs/2.3.0/migrations/to-2.0.0","content":"","keywords":"","version":"2.3.0"},{"title":"Updating rustc version​","type":1,"pageTitle":"Migration guide to v2.0.0 from 1.*","url":"/docs/2.3.0/migrations/to-2.0.0#updating-rustc-version","content":"Update rust-toolchain file in your project: nightly-2024-07-31  ","version":"2.3.0","tagName":"h2"},{"title":"Migration guide to v2.1.0 from 2.0.*","type":0,"sectionRef":"#","url":"/docs/2.3.0/migrations/to-2.1.0","content":"","keywords":"","version":"2.3.0"},{"title":"Updating the test code​","type":1,"pageTitle":"Migration guide to v2.1.0 from 2.0.*","url":"/docs/2.3.0/migrations/to-2.1.0#updating-the-test-code","content":"Function that required an event reference as an argument has been changed to accept an event type instead. before.rs assert!(test_env.emitted_event( &amp;party_contract, &amp;PartyStarted { caller: test_env.get_account(0), block_time: 0 } ));  after.rs assert!(test_env.emitted_event( &amp;party_contract, PartyStarted { caller: test_env.get_account(0), block_time: 0 } ));  In the previous version, the HostRef and Addressable traits both included a function called address, which may have caused confusion and led to exporting the address function from the wrong trait. In the updated version, address is now defined only in the Addressable trait, while the HostRef trait provides a separate function called contract_address instead. ","version":"2.3.0","tagName":"h2"},{"title":"Access Control","type":0,"sectionRef":"#","url":"/docs/2.3.0/tutorials/access-control","content":"","keywords":"","version":"2.3.0"},{"title":"Code​","type":1,"pageTitle":"Access Control","url":"/docs/2.3.0/tutorials/access-control#code","content":"Before we start writing code, we list the functionalities of our access control layer. A Role type is used across the module.A Role can be assigned to many Addresses.Each Role may have a corresponding admin role.Only an admin can grant/revoke a Role.A Role can be renounced.A Role cannot be renounced on someone's behalf.Each action triggers an event.Unauthorized access stops contract execution. ","version":"2.3.0","tagName":"h2"},{"title":"Project Structure​","type":1,"pageTitle":"Access Control","url":"/docs/2.3.0/tutorials/access-control#project-structure","content":"access-control ├── src │ ├── access │ │ ├── access_control.rs │ │ ├── events.rs │ │ └── errors.rs │ └── lib.rs |── build.rs |── Cargo.toml └── Odra.toml  ","version":"2.3.0","tagName":"h3"},{"title":"Events and Errors​","type":1,"pageTitle":"Access Control","url":"/docs/2.3.0/tutorials/access-control#events-and-errors","content":"There are three actions that can be performed concerning a Role: granting, revoking, and altering the admin role. Let us establish standard Odra events for each of these actions. events.rs use odra::prelude::*; use super::access_control::Role; #[odra::event] pub struct RoleGranted { pub role: Role, pub address: Address, pub sender: Address } #[odra::event] pub struct RoleRevoked { pub role: Role, pub address: Address, pub sender: Address } #[odra::event] pub struct RoleAdminChanged { pub role: Role, pub previous_admin_role: Role, pub new_admin_role: Role }  L4-L16 - to describe the grant or revoke actions, our events specify the Role, and Addresses indicating who receives or loses access and who provides or withdraws it.L18-L23 - the event describing the admin role change, requires the subject Role, the previous and the current admin Role. errors.rs #[odra::odra_error] pub enum Error { MissingRole = 20_000, RoleRenounceForAnotherAddress = 20_001, }  Errors definition is straightforward - there are only two invalid states: An action is triggered by an unauthorized actor.The caller is attempting to resign the Role on someone's behalf.  ","version":"2.3.0","tagName":"h3"},{"title":"Module​","type":1,"pageTitle":"Access Control","url":"/docs/2.3.0/tutorials/access-control#module","content":"Now, we are stepping into the most interesting part: the module definition and implementation. access_control.rs use super::events::*; use super::errors::Error; use odra::prelude::*; pub type Role = [u8; 32]; pub const DEFAULT_ADMIN_ROLE: Role = [0u8; 32]; #[odra::module(events = [RoleAdminChanged, RoleGranted, RoleRevoked], errors = Error)] pub struct AccessControl { roles: Mapping&lt;(Role, Address), bool&gt;, role_admin: Mapping&lt;Role, Role&gt; } #[odra::module] impl AccessControl { pub fn has_role(&amp;self, role: &amp;Role, address: &amp;Address) -&gt; bool { self.roles.get_or_default(&amp;(*role, *address)) } pub fn get_role_admin(&amp;self, role: &amp;Role) -&gt; Role { let admin_role = self.role_admin.get(role); if let Some(admin) = admin_role { admin } else { DEFAULT_ADMIN_ROLE } } pub fn grant_role(&amp;mut self, role: &amp;Role, address: &amp;Address) { self.check_role(&amp;self.get_role_admin(role), &amp;self.env().caller()); self.unchecked_grant_role(role, address); } pub fn revoke_role(&amp;mut self, role: &amp;Role, address: &amp;Address) { self.check_role(&amp;self.get_role_admin(role), &amp;self.env().caller()); self.unchecked_revoke_role(role, address); } pub fn renounce_role(&amp;mut self, role: &amp;Role, address: &amp;Address) { if address != &amp;self.env().caller() { self.env().revert(Error::RoleRenounceForAnotherAddress); } self.unchecked_revoke_role(role, address); } } impl AccessControl { pub fn check_role(&amp;self, role: &amp;Role, address: &amp;Address) { if !self.has_role(role, address) { self.env().revert(Error::MissingRole); } } pub fn set_admin_role(&amp;mut self, role: &amp;Role, admin_role: &amp;Role) { let previous_admin_role = self.get_role_admin(role); self.role_admin.set(role, *admin_role); self.env().emit_event(RoleAdminChanged { role: *role, previous_admin_role, new_admin_role: *admin_role }); } pub fn unchecked_grant_role(&amp;mut self, role: &amp;Role, address: &amp;Address) { if !self.has_role(role, address) { self.roles.set(&amp;(*role, *address), true); self.env().emit_event(RoleGranted { role: *role, address: *address, sender: self.env().caller() }); } } pub fn unchecked_revoke_role(&amp;mut self, role: &amp;Role, address: &amp;Address) { if self.has_role(role, address) { self.roles.set(&amp;(*role, *address), false); self.env().emit_event(RoleRevoked { role: *role, address: *address, sender: self.env().caller() }); } } }  L5 - Firstly, we need the Role type. It is simply an alias for a 32-byte array.L7 - The default role is an array filled with zeros.L10-L13 - The storage consists of two mappings: roles - a nested mapping that stores information about whether a certain Role is granted to a given Address.role_admin - each Role can have a single admin Role. L17-L19 - This is a simple check to determine if a Role has been granted to a given Address. It is an exposed entry point and an important building block widely used throughout the entire module.L48 - This is a non-exported block containing helper functions.L49-L53 - The check_role() function serves as a guard function. Before a Role is granted or revoked, we must ensure that the caller is allowed to do so. For this purpose, the function reads the roles mapping. If the role has not been granted to the address, the contract reverts with Error::MissingRole.L55-L63 - The set_admin_role() function simply updates the role_admin mapping and emits the RoleAdminChanged event.L65-L85 - The unchecked_grant_role() and unchecked_revoke_role() functions are mirror functions that update the roles mapping and post RoleGranted or RoleRevoked events. If the role is already granted, unchecked_grant_role() has no effect (the opposite check is made in the case of revoking a role).L21-L28 - The get_role_admin() entry point reads the role_admin. If there is no admin role for a given role, it returns the default role.L30-L45 - This is a combination of check_role() and unchecked_*_role(). Entry points fail on unauthorized access. ","version":"2.3.0","tagName":"h3"},{"title":"Migration guide to v0.9.0","type":0,"sectionRef":"#","url":"/docs/2.3.0/migrations/to-0.9.0","content":"","keywords":"","version":"2.3.0"},{"title":"1. Prerequisites​","type":1,"pageTitle":"Migration guide to v0.9.0","url":"/docs/2.3.0/migrations/to-0.9.0#1-prerequisites","content":"","version":"2.3.0","tagName":"h2"},{"title":"1.1. Update cargo-odra​","type":1,"pageTitle":"Migration guide to v0.9.0","url":"/docs/2.3.0/migrations/to-0.9.0#11-update-cargo-odra","content":"Before you begin the migration process, make sure you installed the latest version of the Cargo Odra toolchain. You can install it by running the following command: cargo install cargo-odra --force --locked  ","version":"2.3.0","tagName":"h3"},{"title":"1.2. Review the Changelog​","type":1,"pageTitle":"Migration guide to v0.9.0","url":"/docs/2.3.0/migrations/to-0.9.0#12-review-the-changelog","content":"Before you move to changing your code, start by reviewing the Changelog to understand the changes introduced in v0.9.0. ","version":"2.3.0","tagName":"h3"},{"title":"2. Migration Steps​","type":1,"pageTitle":"Migration guide to v0.9.0","url":"/docs/2.3.0/migrations/to-0.9.0#2-migration-steps","content":"","version":"2.3.0","tagName":"h2"},{"title":"2.1 Update build_schema.rs bin​","type":1,"pageTitle":"Migration guide to v0.9.0","url":"/docs/2.3.0/migrations/to-0.9.0#21-update-build_schemars-bin","content":"Odra 0.9.0 adds a new standardized way of generating contract schema - Casper Contract Schema. You can find the updated build_schema.rs file in templates directory in the Odra main repository. You can choose whatever template you want to use and copy the files to your project. In both files, you should replace {{project-name}} with the name of your project. ","version":"2.3.0","tagName":"h3"},{"title":"2.2 Update smart contract code​","type":1,"pageTitle":"Migration guide to v0.9.0","url":"/docs/2.3.0/migrations/to-0.9.0#22-update-smart-contract-code","content":"The main changes in the smart contract code are related to the way of defining custom types, events and errors. The following sections will guide you through the necessary changes. 2.2.1. Update custom types definitions.​ #[derive(OdraType)] attribute has been replace with #[odra::odra_type] attribute. 0.9.00.8.0 use odra::Address; #[odra::odra_type] pub struct Dog { pub name: String, pub age: u8, pub owner: Option&lt;Address&gt; }  2.2.2. Update errors definitions.​ #[derive(OdraError)] attribute has been replace with #[odra::odra_error] attribute. Error enum should be passed as a parameter to the #[odra::module] attribute. 0.9.00.8.0 #[odra::module(events = [/* events go here */], errors = Error)] pub struct Erc20 { // fields } #[odra::odra_error] pub enum Error { InsufficientBalance = 30_000, InsufficientAllowance = 30_001, NameNotSet = 30_002, SymbolNotSet = 30_003, DecimalsNotSet = 30_004 }  2.2.3. Update events definitions.​ #[derive(Event)] attribute has been replace with #[odra::event] attribute. 0.9.00.8.0 use odra::prelude::*; use odra::{Address, casper_types::U256}; #[odra::event] pub struct Transfer { pub from: Option&lt;Address&gt;, pub to: Option&lt;Address&gt;, pub amount: U256 }  ","version":"2.3.0","tagName":"h3"},{"title":"3. Code Examples​","type":1,"pageTitle":"Migration guide to v0.9.0","url":"/docs/2.3.0/migrations/to-0.9.0#3-code-examples","content":"Here is a complete example of a smart contract after and before the migration to v0.9.0. 0.9.0Prev src/erc20.rs use crate::erc20::errors::Error; use crate::erc20::events::*; use odra::prelude::*; use odra::{casper_types::U256, Address, Mapping, Var}; #[odra::module(events = [Approval, Transfer], errors = Error)] pub struct Erc20 { decimals: Var&lt;u8&gt;, symbol: Var&lt;String&gt;, name: Var&lt;String&gt;, total_supply: Var&lt;U256&gt;, balances: Mapping&lt;Address, U256&gt;, allowances: Mapping&lt;(Address, Address), U256&gt; } #[odra::module] impl Erc20 { pub fn init( &amp;mut self, symbol: String, name: String, decimals: u8, initial_supply: Option&lt;U256&gt; ) { let caller = self.env().caller(); self.symbol.set(symbol); self.name.set(name); self.decimals.set(decimals); if let Some(initial_supply) = initial_supply { self.total_supply.set(initial_supply); self.balances.set(&amp;caller, initial_supply); if !initial_supply.is_zero() { self.env().emit_event(Transfer { from: None, to: Some(caller), amount: initial_supply }); } } } pub fn transfer(&amp;mut self, recipient: &amp;Address, amount: &amp;U256) { let caller = self.env().caller(); self.raw_transfer(&amp;caller, recipient, amount); } pub fn transfer_from(&amp;mut self, owner: &amp;Address, recipient: &amp;Address, amount: &amp;U256) { let spender = self.env().caller(); self.spend_allowance(owner, &amp;spender, amount); self.raw_transfer(owner, recipient, amount); } pub fn approve(&amp;mut self, spender: &amp;Address, amount: &amp;U256) { let owner = self.env().caller(); self.allowances.set(&amp;(owner, *spender), *amount); self.env().emit_event(Approval { owner, spender: *spender, value: *amount }); } pub fn name(&amp;self) -&gt; String { self.name.get_or_revert_with(Error::NameNotSet) } // Other getter functions... pub fn allowance(&amp;self, owner: &amp;Address, spender: &amp;Address) -&gt; U256 { self.allowances.get_or_default(&amp;(*owner, *spender)) } pub fn mint(&amp;mut self, address: &amp;Address, amount: &amp;U256) { self.total_supply.add(*amount); self.balances.add(address, *amount); self.env().emit_event(Transfer { from: None, to: Some(*address), amount: *amount }); } pub fn burn(&amp;mut self, address: &amp;Address, amount: &amp;U256) { if self.balance_of(address) &lt; *amount { self.env().revert(Error::InsufficientBalance); } self.total_supply.subtract(*amount); self.balances.subtract(address, *amount); self.env().emit_event(Transfer { from: Some(*address), to: None, amount: *amount }); } } impl Erc20 { fn raw_transfer(&amp;mut self, owner: &amp;Address, recipient: &amp;Address, amount: &amp;U256) { if *amount &gt; self.balances.get_or_default(owner) { self.env().revert(Error::InsufficientBalance) } self.balances.subtract(owner, *amount); self.balances.add(recipient, *amount); self.env().emit_event(Transfer { from: Some(*owner), to: Some(*recipient), amount: *amount }); } fn spend_allowance(&amp;mut self, owner: &amp;Address, spender: &amp;Address, amount: &amp;U256) { let allowance = self.allowances.get_or_default(&amp;(*owner, *spender)); if allowance &lt; *amount { self.env().revert(Error::InsufficientAllowance) } self.allowances.subtract(&amp;(*owner, *spender), *amount); self.env().emit_event(Approval { owner: *owner, spender: *spender, value: allowance - *amount }); } } pub mod events { use odra::prelude::*; use odra::{casper_types::U256, Address}; #[odra::event] pub struct Transfer { pub from: Option&lt;Address&gt;, pub to: Option&lt;Address&gt;, pub amount: U256 } #[odra::event] pub struct Approval { pub owner: Address, pub spender: Address, pub value: U256 } } pub mod errors { #[odra::odra_error] pub enum Error { InsufficientBalance = 30_000, InsufficientAllowance = 30_001, NameNotSet = 30_002, SymbolNotSet = 30_003, DecimalsNotSet = 30_004 } } #[cfg(test)] mod tests { // nothing changed in the tests }  ","version":"2.3.0","tagName":"h2"},{"title":"4. Troubleshooting​","type":1,"pageTitle":"Migration guide to v0.9.0","url":"/docs/2.3.0/migrations/to-0.9.0#4-troubleshooting","content":"If you encounter any further issues after completing the migration steps, please don't hesitate to reach out to us on Discord or explore the other sections this documentation. You can also refer to the technical documentation for more detailed information. Additionally, our examples repository offers a wide range of examples to assist you in understanding the new features and APIs. Be sure to carefully review any compilation errors and warnings, as they may provide valuable insights into the necessary adjustments. ","version":"2.3.0","tagName":"h2"},{"title":"5. References​","type":1,"pageTitle":"Migration guide to v0.9.0","url":"/docs/2.3.0/migrations/to-0.9.0#5-references","content":"ChangelogOdra DocumentationDocs.rsExamples ","version":"2.3.0","tagName":"h2"},{"title":"Build, Deploy and Read the State of a Contract","type":0,"sectionRef":"#","url":"/docs/2.3.0/tutorials/build-deploy-read","content":"","keywords":"","version":"2.3.0"},{"title":"Contract​","type":1,"pageTitle":"Build, Deploy and Read the State of a Contract","url":"/docs/2.3.0/tutorials/build-deploy-read#contract","content":"Let's write a contract with complex storage layout. The contract stores a plain numeric value, a custom nested type and a submodule with another submodule with stores a Mapping. We will expose two methods: The constructor init which sets the metadata and the version of the contract.The method set_data which sets the value of the numeric field and the values of the mapping. custom_item.rs use odra::{casper_types::U256, prelude::*}; // A custom type with a vector of another custom type #[odra::odra_type] pub struct Metadata { name: String, description: String, prices: Vec&lt;Price&gt;, } #[odra::odra_type] pub struct Price { value: U256, } // The main contract with a version, metadata and a submodule #[odra::module] pub struct CustomItem { version: Var&lt;u32&gt;, meta: Var&lt;Metadata&gt;, data: SubModule&lt;Data&gt; } #[odra::module] impl CustomItem { pub fn init(&amp;mut self, name: String, description: String, price_1: U256, price_2: U256) { let meta = Metadata { name, description, prices: vec![ Price { value: price_1 }, Price { value: price_2 } ] }; self.meta.set(meta); self.version.set(self.version.get_or_default() + 1); } pub fn set_data(&amp;mut self, value: u32, name: String, name2: String) { self.data.value.set(value); self.data.inner.named_values.set(&amp;name, 10); self.data.inner.named_values.set(&amp;name2, 20); } } // A submodule with a numeric value and another submodule #[odra::module] struct Data { value: Var&lt;u32&gt;, inner: SubModule&lt;InnerData&gt;, } // A submodule with a mapping #[odra::module] struct InnerData { named_values: Mapping&lt;String, u32&gt;, }  ","version":"2.3.0","tagName":"h3"},{"title":"Deploying the contract​","type":1,"pageTitle":"Build, Deploy and Read the State of a Contract","url":"/docs/2.3.0/tutorials/build-deploy-read#deploying-the-contract","content":"First, we need to setup the chain. We will use the NCTL docker image to run a local network. docker run --rm -it --name mynctl -d -p 11101:11101 -p 14101:14101 -p 18101:18101 makesoftware/casper-nctl  Next, we need to compile the contract to a Wasm file. cargo odra build -c custom_item  Then, we can deploy the contract using the casper-client tool. casper-client put-transaction session \\ --node-address http://localhost:11101 \\ --chain-name casper-net-1 \\ --secret-key path/to/your/secret_key.pem \\ --wasm-path ./wasm/Erc20.wasm \\ --payment-amount 450000000000 \\ --gas-price-tolerance 1 \\ --standard-payment true \\ --session-arg &quot;odra_cfg_package_hash_key_name:string:'test_contract_package_hash'&quot; \\ --session-arg &quot;odra_cfg_allow_key_override:bool:'true'&quot; \\ --session-arg &quot;odra_cfg_is_upgradable:bool:'true'&quot; \\ --session-arg &quot;odra_cfg_is_upgrade:bool:'false'&quot; \\ --session-arg &quot;name:string='My Name'&quot; \\ --session-arg &quot;description:string='My Description'&quot; \\ --session-arg &quot;price_1:u256='101'&quot; \\ --session-arg &quot;price_2:u256='202'&quot;  Finally, we can call the set_data method to set the values of the contract. casper-client put-transaction package \\ --node-address http://localhost:11101 \\ --chain-name casper-net-1 \\ --secret-key path/to/your/secret_key.pem \\ --gas-price-tolerance 1 \\ --contract-package-hash &quot;hash-...&quot; \\ --payment-amount 2500000000 \\ --standard-payment &quot;true&quot; \\ --session-entry-point &quot;set_data&quot; \\ --session-arg &quot;value:u32:'666'&quot; \\ --session-arg &quot;name:string='alice'&quot; \\ --session-arg &quot;name2:string='bob'&quot;  ","version":"2.3.0","tagName":"h3"},{"title":"Storage Layout​","type":1,"pageTitle":"Build, Deploy and Read the State of a Contract","url":"/docs/2.3.0/tutorials/build-deploy-read#storage-layout","content":"To read the state of the contract, we need to understand the storage layout. The first step is to calculate the index of the keys. Storage Layout CustomItem: prefix: 0x0..._0000_0000_0000 0 version: u32, 0x0..._0000_0000_0001 1 meta: Metadata, 0x0..._0000_0000_0010 2 data: Data: prefix: 0x0..._0000_0000_0011 3 value: u32, 0x0..._0000_0011_0001 (3 &lt;&lt; 4) + 1 inner: InnerData: prefix: 0x0..._0000_0011_0010 (3 &lt;&lt; 4) + 2 named_values: Mapping 0x0..._0011_0010_0001 ((3 &lt;&lt; 4) + 2) &lt;&lt; 4 + 1  The actual key is obtained as follows: Convert the index to a big-endian byte array.Concatenate the index with the mapping data.Hash the concatenated bytes using blake2b.Return the hex representation of the hash (the stored key must be utf-8 encoded). In more detail, the storage layout is described in the Storage Layout article. ","version":"2.3.0","tagName":"h3"},{"title":"Reading the state​","type":1,"pageTitle":"Build, Deploy and Read the State of a Contract","url":"/docs/2.3.0/tutorials/build-deploy-read#reading-the-state","content":"RustTypeScript main.rs use casper_client::{rpcs::DictionaryItemIdentifier, types::StoredValue, Verbosity}; use casper_types::{ bytesrepr::{FromBytes, ToBytes}, U256, }; // replace with your contract hash const CONTRACT_HASH: &amp;str = &quot;hash-...&quot;; const NODE_ADDRESS: &amp;str = &quot;http://localhost:11101/rpc&quot;; const RPC_ID: &amp;str = &quot;casper-net-1&quot;; const DICTIONARY_NAME: &amp;str = &quot;state&quot;; #[derive(Debug, PartialEq, Eq, Hash)] pub struct Metadata { name: String, description: String, prices: Vec&lt;Price&gt;, } #[derive(Debug, PartialEq, Eq, Hash)] pub struct Price { value: U256, } async fn read_state_key(key: String) -&gt; Vec&lt;u8&gt; { let state_root_hash = casper_client::get_state_root_hash( RPC_ID.to_string().into(), NODE_ADDRESS, Verbosity::Low, None, ) .await .unwrap() .result .state_root_hash .unwrap(); // Read the value from the `state` dictionary. let result = casper_client::get_dictionary_item( RPC_ID.to_string().into(), NODE_ADDRESS, Verbosity::Low, state_root_hash, DictionaryItemIdentifier::ContractNamedKey { key: CONTRACT_HASH.to_string(), dictionary_name: DICTIONARY_NAME.to_string(), dictionary_item_key: key, }, ) .await .unwrap() .result .stored_value; // We expect the value to be a CLValue if let StoredValue::CLValue(cl_value) = result { // Ignore the first 4 bytes, which are the length of the CLType. cl_value.inner_bytes()[4..].to_vec() } else { vec![] } } async fn metadata() -&gt; Metadata { // The key for the metadata is 2, and it has no mapping data let key = key(2, &amp;[]); let bytes = read_state_key(key).await; // Read the name and store the remaining bytes let (name, bytes) = String::from_bytes(&amp;bytes).unwrap(); // Read the description and store the remaining bytes let (description, bytes) = String::from_bytes(&amp;bytes).unwrap(); // A vector is stored as a u32 size followed by the elements // Read the size of the vector and store the remaining bytes let (size, mut bytes) = u32::from_bytes(&amp;bytes).unwrap(); let mut prices = vec![]; // As we know the size of the vector, we can loop over it for _ in 0..size { // Read the value and store the remaining bytes let (value, rem) = U256::from_bytes(&amp;bytes).unwrap(); bytes = rem; prices.push(Price { value }); } // Anytime you finish parsing a value, you should check if there are any remaining bytes // if there are, it means you have a bug in your parsing logic. // For simplicity, we will ignore the remaining bytes here. Metadata { name, description, prices } } async fn value() -&gt; u32 { // The key for the value is (3 &lt;&lt; 4) + 1, and it has no mapping data let key = key((3 &lt;&lt; 4) + 1, &amp;[]); let bytes = read_state_key(key).await; // Read the value and ignore the remaining bytes for simplicity u32::from_bytes(&amp;bytes).unwrap().0 } async fn named_value(name: &amp;str) -&gt; u32 { // The key for the named value is (((3 &lt;&lt; 4) + 2) &lt;&lt; 4) + 1, and the mapping data is the name as bytes let mapping_data = name.to_bytes().unwrap(); let key = key((((3 &lt;&lt; 4) + 2) &lt;&lt; 4) + 1, &amp;mapping_data); let bytes = read_state_key(key).await; // Read the value and ignore the remaining bytes for simplicity u32::from_bytes(&amp;bytes).unwrap().0 } fn main() { let runtime = tokio::runtime::Runtime::new().unwrap(); dbg!(runtime.block_on(metadata())); dbg!(runtime.block_on(value())); dbg!(runtime.block_on(named_value(&quot;alice&quot;))); dbg!(runtime.block_on(named_value(&quot;bob&quot;))); } // The key is a combination of the index and the mapping data // The algorithm is as follows: // 1. Convert the index to a big-endian byte array // 2. Concatenate the index with the mapping data // 3. Hash the concatenated bytes using blake2b // 4. Return the hex representation of the hash (the stored key must be utf-8 encoded) fn key(idx: u32, mapping_data: &amp;[u8]) -&gt; String { let mut key = Vec::new(); key.extend_from_slice(idx.to_be_bytes().as_ref()); key.extend_from_slice(mapping_data); let hashed_key = blake2b(&amp;key); hex::encode(&amp;hashed_key) } fn blake2b(bytes: &amp;[u8]) -&gt; [u8; 32] { let mut result = [0u8; 32]; let mut hasher = &lt;blake2::Blake2bVar as blake2::digest::VariableOutput&gt;::new(32) .expect(&quot;should create hasher&quot;); let _ = std::io::Write::write(&amp;mut hasher, bytes); blake2::digest::VariableOutput::finalize_variable(hasher, &amp;mut result) .expect(&quot;should copy hash to the result array&quot;); result } cargo run [src/main.rs:116:5] runtime.block_on(metadata()) = Metadata { name: &quot;My Contract&quot;, description: &quot;My Description&quot;, prices: [ Price { value: 123, }, Price { value: 321, }, ], } [src/main.rs:117:5] runtime.block_on(value()) = 666 [src/main.rs:118:5] runtime.block_on(named_value(&quot;alice&quot;)) = 20 [src/main.rs:119:5] runtime.block_on(named_value(&quot;bob&quot;)) = 10  ","version":"2.3.0","tagName":"h3"},{"title":"Deploying a Token on Casper Livenet","type":0,"sectionRef":"#","url":"/docs/2.3.0/tutorials/deploying-on-casper","content":"","keywords":"","version":"2.3.0"},{"title":"Casper Wallet​","type":1,"pageTitle":"Deploying a Token on Casper Livenet","url":"/docs/2.3.0/tutorials/deploying-on-casper#casper-wallet","content":"We will be using Casper Wallet to do some tasks in this tutorial. To install it, please follow the instructions on the official website. After setting up the wallet, extract the private key of the account you want to use for our testing. You can do this by clicking on the Menu &gt; Download account keys. danger You are solely responsible for the security of your private keys. We recommend creating a new account for the testing purposes. Why do we need the private key? We will use it in Odra to deploy our contract to the Casper network using Livenet backend. ","version":"2.3.0","tagName":"h2"},{"title":"Getting tokens​","type":1,"pageTitle":"Deploying a Token on Casper Livenet","url":"/docs/2.3.0/tutorials/deploying-on-casper#getting-tokens","content":"To deploy the contract on the Livenet, we need to have some CSPR. The easiest way to get them is to use the faucet, which will send us 1000 CSPR for free. Unfortunately, only on the Testnet. To use the faucet, go to the Casper Testnet Faucet. Log in using your Casper Wallet account and click on the &quot;Request Tokens&quot; button. note One account can request tokens only once. If you run out of tokens, you can either ask someone in the Casper community to send you some, or simply create a new account in the wallet. Now, when we have the tokens, we can deploy the contract. Let's do it using Odra! ","version":"2.3.0","tagName":"h2"},{"title":"Odra Livenet​","type":1,"pageTitle":"Deploying a Token on Casper Livenet","url":"/docs/2.3.0/tutorials/deploying-on-casper#odra-livenet","content":"Odra Livenet is described in detail in thebackends section of this documentation. We will then briefly describe how to use set it up in this tutorial. In your contract code, create a new file in the bin folder: bin/our_token_livenet.rs //! Deploys a new OurToken contract on the Casper livenet and mints some tokens for the tutorial //! creator. use std::str::FromStr; use odra::casper_types::U256; use odra::host::{Deployer, HostEnv, HostRef, HostRefLoader}; use odra::prelude::Address; use ourcoin::token::{OurToken, OurToken, OurTokenInitArgs}; fn main() { // Load the Casper livenet environment. let env = odra_casper_livenet_env::env(); // Caller is the deployer and the owner of the private key. let owner = env.caller(); // Just some random address... let recipient = &quot;hash-48bd92253a1370d1d913c56800296145547a243d13ff4f059ba4b985b1e94c26&quot;; let recipient = Address::from_str(recipient).unwrap(); // Deploy new contract. let mut token = deploy_our_token(&amp;env); println!(&quot;Token address: {}&quot;, token.address().to_string()); env.set_gas(2_500_000_000u64); // Propose minting new tokens. token.propose_new_mint(recipient, U256::from(1_000)); // Vote, we are the only voter. token.vote(true, U256::from(1_000)); // Let's advance the block time by 11 minutes, as // we set the voting time to 10 minutes. // OH NO! It is the Livenet, so we need to wait real time... // Hopefully you are not in a hurry. env.advance_block_time(11 * 60 * 1000); // Tally the votes. token.tally(); // Check the balances. println!(&quot;Owner's balance: {:?}&quot;, token.balance_of(&amp;owner)); println!( &quot;Tutorial creator's balance: {:?}&quot;, token.balance_of(&amp;recipient) ); } /// Deploys a contract. pub fn deploy_our_token(env: &amp;HostEnv) -&gt; OurTokenHostRef { let name = String::from(&quot;OurToken&quot;); let symbol = String::from(&quot;OT&quot;); let decimals = 0; let initial_supply = U256::from(1_000); let init_args = OurTokenInitArgs { name, symbol, decimals, initial_supply, }; env.set_gas(400_000_000_000u64); OurToken::deploy(env, init_args) // OurToken::deploy_with_cfg(env, init_args, odra::host::InstallConfig { // package_named_key: String::from(&quot;OurToken&quot;), // is_upgradable: true, // allow_key_override: true, // }) } /// Loads a contract. Just in case you need to load an existing contract later... fn _load_our_token(env: &amp;HostEnv) -&gt; OurTokenHostRef { let address = &quot;hash-XXXXX&quot;; let address = Address::from_str(address).unwrap(); OurToken::load(env, address) }  You can deploy a contract with the default configuration or with a custom configuration calling deploy_with_cfg. Read more about InstallConfig in the Odra documentation. In your Cargo.toml file, we need to add a new dependency, a feature and register the new binary. In the end, it should look like this: Cargo.toml [package] name = &quot;ourcoin&quot; version = &quot;0.1.0&quot; edition = &quot;2021&quot; [dependencies] odra = { version = &quot;2.2.0&quot;, features = [], default-features = false } odra-modules = { version = &quot;2.2.0&quot;, features = [], default-features = false } odra-casper-livenet-env = { version = &quot;2.2.0&quot;, optional = true } [dev-dependencies] odra-test = { version = &quot;2.2.0&quot;, features = [], default-features = false } [build-dependencies] odra-build = { version = &quot;2.2.0&quot;, features = [], default-features = false } [features] default = [] livenet = [&quot;odra-casper-livenet-env&quot;] [[bin]] name = &quot;ourcoin_build_contract&quot; path = &quot;bin/build_contract.rs&quot; test = false [[bin]] name = &quot;ourcoin_build_schema&quot; path = &quot;bin/build_schema.rs&quot; test = false [[bin]] name = &quot;our_token_livenet&quot; path = &quot;bin/our_token_livenet.rs&quot; required-features = [&quot;livenet&quot;] [profile.release] codegen-units = 1 lto = true [profile.dev.package.&quot;*&quot;] opt-level = 3  Finally, add the .env file with the following content: .env # Path to the secret key of the account that will be used to deploy the contracts. ODRA_CASPER_LIVENET_SECRET_KEY_PATH=folder_with_your_secret_key/secret_key.pem # RPC address of the node that will be used to deploy the contracts. # For CSPR.cloud, you can use the following addresses: # - https://node.cspr.cloud # - https://node.testnet.cspr.cloud # For nctl, default is: # - http://localhost:11101 ODRA_CASPER_LIVENET_NODE_ADDRESS=&lt;node_address&gt; # Chain name of the network. The mainnet is &quot;casper&quot; and test net is &quot;casper-test&quot;. # The integration network uses the &quot;integration-test&quot; chain name. # For nctl default is &quot;casper-net-1&quot; ODRA_CASPER_LIVENET_CHAIN_NAME=&lt;chain_name&gt; # Events url # For CSPR.cloud, you can use the following addresses: # - https://node.cspr.cloud/events # For nctl, default is: # - http://localhost:18101/events ODRA_CASPER_LIVENET_EVENTS_URL=&lt;events url&gt;  Of course, you need to replace the secret key's path with the path to the secret key file you downloaded from the Casper Wallet. note One of the problems you may encounter is that the node you are using will be down or will not accept your calls. In this case, you will have to find and use another node IP address. Now, we will run our code: cargo run --bin our_token_livenet --features livenet  If everything is set up correctly, you should see the output similar to this: cargo run --bin our_token_livenet --features livenet Compiling ourcoin v0.1.0 (/Users/kpob/workspace/odra/examples/ourcoin) Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.33s Running `../../target/debug/our_token_livenet` 💁 INFO : Found wasm under &quot;/Users/kpob/workspace/odra/examples/ourcoin/wasm/OurToken.wasm&quot;. 💁 INFO : Deploying &quot;OurToken&quot;. 🙄 WAIT : Waiting 10 for V1(TransactionV1Hash(c856983e995c79d8459540bd9d29d196535f63ceb8bac0f73ea747c5c9c74d76)). 💁 INFO : Transaction &quot;c856983e995c79d8459540bd9d29d196535f63ceb8bac0f73ea747c5c9c74d76&quot; successfully executed. 🔗 LINK : https://testnet.cspr.live/transaction/c856983e995c79d8459540bd9d29d196535f63ceb8bac0f73ea747c5c9c74d76 💁 INFO : Contract &quot;contract-package-e39aa2f8e4d509c0253dcd1709a9f08449477eef0f22f0ad5912fff327f509c8&quot; deployed. Token address: hash-e39aa2f8e4d509c0253dcd1709a9f08449477eef0f22f0ad5912fff327f509c8 💁 INFO : Calling &quot;contract-package-e39aa2f8e4d509c0253dcd1709a9f08449477eef0f22f0ad5912fff327f509c8&quot; directly with entrypoint &quot;propose_new_mint&quot;. 🙄 WAIT : Waiting 10 for V1(TransactionV1Hash(2d1aafe8f06748c7cfaf7972caee6b701de7a817430b52a73215f5ad9a175e77)). 💁 INFO : Transaction &quot;2d1aafe8f06748c7cfaf7972caee6b701de7a817430b52a73215f5ad9a175e77&quot; successfully executed. 🔗 LINK : https://testnet.cspr.live/transaction/2d1aafe8f06748c7cfaf7972caee6b701de7a817430b52a73215f5ad9a175e77 💁 INFO : Calling &quot;contract-package-e39aa2f8e4d509c0253dcd1709a9f08449477eef0f22f0ad5912fff327f509c8&quot; directly with entrypoint &quot;vote&quot;. 🙄 WAIT : Waiting 10 for V1(TransactionV1Hash(b565acd01c2ebbab78fa91a3f0091b849a037f1984ca4c996788b92fcd9521db)). 🙄 WAIT : Waiting 10 for V1(TransactionV1Hash(b565acd01c2ebbab78fa91a3f0091b849a037f1984ca4c996788b92fcd9521db)). 💁 INFO : Transaction &quot;b565acd01c2ebbab78fa91a3f0091b849a037f1984ca4c996788b92fcd9521db&quot; successfully executed. 🔗 LINK : https://testnet.cspr.live/transaction/b565acd01c2ebbab78fa91a3f0091b849a037f1984ca4c996788b92fcd9521db 💁 INFO : advance_block_time called - Waiting for 660000 ms 💁 INFO : Calling &quot;contract-package-e39aa2f8e4d509c0253dcd1709a9f08449477eef0f22f0ad5912fff327f509c8&quot; directly with entrypoint &quot;tally&quot;. 🙄 WAIT : Waiting 10 for V1(TransactionV1Hash(8d24de09298522b028073be5ba05542bf4efd0f03d0e8771d5c5a727832eba94)). 🙄 WAIT : Waiting 10 for V1(TransactionV1Hash(8d24de09298522b028073be5ba05542bf4efd0f03d0e8771d5c5a727832eba94)). 💁 INFO : Transaction &quot;8d24de09298522b028073be5ba05542bf4efd0f03d0e8771d5c5a727832eba94&quot; successfully executed. 🔗 LINK : https://testnet.cspr.live/transaction/8d24de09298522b028073be5ba05542bf4efd0f03d0e8771d5c5a727832eba94 Owner's balance: 1000 Tutorial creator's balance: 1000  Congratulations, your contract is now deployed on the Casper network! Before we move on, note the address of the token! We will use it in the next section to interact with the token. In our case it ishash-e39aa2f8e4d509c0253dcd1709a9f08449477eef0f22f0ad5912fff327f509c8. ","version":"2.3.0","tagName":"h2"},{"title":"Cspr.live​","type":1,"pageTitle":"Deploying a Token on Casper Livenet","url":"/docs/2.3.0/tutorials/deploying-on-casper#csprlive","content":"The first thing we will do is to explore Casper's network block explorer,cspr.live. We can put the address of our token in the search bar to find it. note If you deployed your contract on the Testnet, remember to make sure that the Testnet network is selected in the dropdown menu in the top right corner. If everything is set up correctly, you should see the contract package's details. Besides the owner, keys etc., you can also see the contract's metdata, if it was developed using a standard that cspr.live supports. Indeed, we can see that it detected that our contract is a CEP-18 token! We see the name, symbol and total supply. All the mentions of the contract on the website will use the token name instead of the contract address.  Additionally, on the Token Txs tab, we can see the transactions that happened with the token. We can see the minting transaction we did in the previous section and transfers done during the voting process.  If we click on one of the accounts that recieved the tokens, we will go to the account page. Here, on the Tokens tab, we can see all the tokens that the account has - and OurToken is one of them! If you wish, you can check the status of the contract deployed during the development of this tutorial here. ","version":"2.3.0","tagName":"h2"},{"title":"Transferring Tokens using Casper Wallet​","type":1,"pageTitle":"Deploying a Token on Casper Livenet","url":"/docs/2.3.0/tutorials/deploying-on-casper#transferring-tokens-using-casper-wallet","content":"Casper wallet can do much more than just logging in to the faucet, exporting the private keys and transferring CSPR. It can also interact with the contracts deployed on the network. If you deployed the contract and left some OT tokens to yourself, you should see them in the Casper Wallet window. You should also be able to transfer them to another account!  ","version":"2.3.0","tagName":"h2"},{"title":"Conclusion​","type":1,"pageTitle":"Deploying a Token on Casper Livenet","url":"/docs/2.3.0/tutorials/deploying-on-casper#conclusion","content":"We've successfully deployed a token on the Casper network and interacted with it using the Odra backend and Casper Wallet. We've also learned how to use the cspr.live block explorer to check the status of your contract. Odra, Cspr.live and Casper Wallet are just a few of the tools that the Casper ecosystem provides. Feel free to explore them on casperecosystem.io. ","version":"2.3.0","tagName":"h2"},{"title":"Migration guide to v0.8.0","type":0,"sectionRef":"#","url":"/docs/2.3.0/migrations/to-0.8.0","content":"","keywords":"","version":"2.3.0"},{"title":"1. Prerequisites​","type":1,"pageTitle":"Migration guide to v0.8.0","url":"/docs/2.3.0/migrations/to-0.8.0#1-prerequisites","content":"","version":"2.3.0","tagName":"h2"},{"title":"1.1. Update cargo-odra​","type":1,"pageTitle":"Migration guide to v0.8.0","url":"/docs/2.3.0/migrations/to-0.8.0#11-update-cargo-odra","content":"Before you begin the migration process, make sure you installed the latest version of the Cargo Odra toolchain. You can install it by running the following command: cargo install cargo-odra --force --locked  ","version":"2.3.0","tagName":"h3"},{"title":"1.2. Review the Changelog​","type":1,"pageTitle":"Migration guide to v0.8.0","url":"/docs/2.3.0/migrations/to-0.8.0#12-review-the-changelog","content":"Before you move to changing your code, start by reviewing the Changelog to understand the changes introduced in v0.8.0. ","version":"2.3.0","tagName":"h3"},{"title":"2. Migration Steps​","type":1,"pageTitle":"Migration guide to v0.8.0","url":"/docs/2.3.0/migrations/to-0.8.0#2-migration-steps","content":"","version":"2.3.0","tagName":"h2"},{"title":"2.1 Add bin directory​","type":1,"pageTitle":"Migration guide to v0.8.0","url":"/docs/2.3.0/migrations/to-0.8.0#21-add-bin-directory","content":"Odra 0.8.0 introduces a new way to build smart contracts. The .builder_casper directory is no longer used. Instead, you should create a new directory called bin in the root of your project and add the build_contract.rs and build_schema.rs files to the bin directory. You can find the build_contract.rs and build_schema.rs files in templates directory in the Odra main repository. You can choose whatever template you want to use and copy the files to your project. In both files, you should replace {{project-name}} with the name of your project. ","version":"2.3.0","tagName":"h3"},{"title":"2.2. Update Cargo.toml​","type":1,"pageTitle":"Migration guide to v0.8.0","url":"/docs/2.3.0/migrations/to-0.8.0#22-update-cargotoml","content":"There a bunch of changes in the Cargo.toml file. You don't have to specify the features anymore - remove the features section and default-features flag from the odra dependency.Register bins you added in the previous step.Add dev-dependencies section with odra-test crate.Add recommended profiles for release and dev to optimize the build process. Below you can compare the Cargo.toml file after and before the migration to v0.8.0: 0.8.0Prev [package] name = &quot;my_project&quot; version = &quot;0.1.0&quot; edition = &quot;2021&quot; [dependencies] odra = &quot;0.8.0&quot; [dev-dependencies] odra-test = &quot;0.8.0&quot; [[bin]] name = &quot;my_project_build_contract&quot; path = &quot;bin/build_contract.rs&quot; test = false [[bin]] name = &quot;my_project_build_schema&quot; path = &quot;bin/build_schema.rs&quot; test = false [profile.release] codegen-units = 1 lto = true [profile.dev.package.&quot;*&quot;] opt-level = 3  ","version":"2.3.0","tagName":"h3"},{"title":"2.2. Update Odra.toml​","type":1,"pageTitle":"Migration guide to v0.8.0","url":"/docs/2.3.0/migrations/to-0.8.0#22-update-odratoml","content":"Due to the changes in cargo-odra, the Odra.toml file has been simplified. The name property is no longer required. 0.8.0Prev [[contracts]] fqn = &quot;my_project::Flipper&quot;  ","version":"2.3.0","tagName":"h3"},{"title":"2.3. Update Smart Contracts​","type":1,"pageTitle":"Migration guide to v0.8.0","url":"/docs/2.3.0/migrations/to-0.8.0#23-update-smart-contracts","content":"The smart contracts themselves will need to be updated to work with the new version of the framework. The changes will depend on the specific features and APIs used in the contracts. Here are some common changes you might need to make: 2.3.1. Update the use statements to reflect the new module structure.​ Big integer types are now located in the odra::casper_types module.odra::types::Address is now odra::Address.Variable is now Var.Remove odra::contract_env.Remove odra::types::event::OdraEvent.Remove odra::types::OdraType as it is no longer required.Change odra::types::casper_types::*; to odra::casper_types::*;. 2.3.2. Some type aliases are no longer in use.​ Balance - use odra::casper_types::U512.BlockTime - use u64.EventData - use odra::casper_types::bytesrepr::Bytes. 2.3.3. Consider import odra::prelude::* in your module files.​ 2.3.4. Flatten nested Mappings.​ // Before #[odra::module(events = [Approval, Transfer])] pub struct Erc20 { ... allowances: Mapping&lt;Address, Mapping&lt;Address, U256&gt;&gt; } // After #[odra::module(events = [Approval, Transfer])] pub struct Erc20 { ... allowances: Mapping&lt;(Address, Address), U256&gt; }  2.3.5. Update errors definitions.​ execution_error! macro has been replace with OdraError derive macro. 0.8.0Prev use odra::OdraError; #[derive(OdraError)] pub enum Error { InsufficientBalance = 30_000, InsufficientAllowance = 30_001, NameNotSet = 30_002, SymbolNotSet = 30_003, DecimalsNotSet = 30_004 }  2.3.6. Update events definitions.​ 0.8.0Prev use odra::prelude::*; use odra::Event; #[derive(Event, Eq, PartialEq, Debug)] pub struct Transfer { pub from: Option&lt;Address&gt;, pub to: Option&lt;Address&gt;, pub amount: U256 } // Emitting the event self.env().emit_event(Transfer { from: None, to: Some(*address), amount: *amount });  2.3.7. Replace contract_env with self.env() in your modules.​ self.env() is a new way to access the contract environment, returns a reference to ContractEnv. The API is similar to the previous contract_env but with some changes. fn get_var&lt;T: FromBytes&gt;(key: &amp;[u8]) -&gt; Option&lt;T&gt; is now fn get_value&lt;T: FromBytes&gt;(&amp;self, key: &amp;[u8]) -&gt; Option&lt;T&gt;.fn set_var&lt;T: CLTyped + ToBytes&gt;(key: &amp;[u8], value: T) is now fn set_value&lt;T: ToBytes + CLTyped&gt;(&amp;self, key: &amp;[u8], value: T).set_dict_value() and get_dict_value() has been removed. All the dictionary operations should be performed using Mapping type, internally using set_var() and get_var() functions. fn hash&lt;T: AsRef&lt;[u8]&gt;&gt;(input: T) -&gt; Vec&lt;u8&gt; is now fn hash&lt;T: ToBytes&gt;(&amp;self, value: T) -&gt; [u8; 32].fn revert&lt;E: Into&lt;ExecutionError&gt;&gt;(error: E) -&gt; ! is now fn revert&lt;E: Into&lt;OdraError&gt;&gt;(&amp;self, error: E) -&gt; !.fn emit_event&lt;T: ToBytes + OdraEvent&gt;(event: T) is now fn emit_event&lt;T: ToBytes&gt;(&amp;self, event: T).fn call_contract&lt;T: CLTyped + FromBytes&gt;(address: Address, entrypoint: &amp;str, args: &amp;RuntimeArgs, amount: Option&lt;U512&gt;) -&gt; T is now fn call_contract&lt;T: FromBytes&gt;(&amp;self, address: Address, call: CallDef) -&gt; T.functions native_token_metadata() and one_token() have been removed. 2.3.8. Wrap submodules of your module with odra::SubModule&lt;T&gt;.​ 0.8.0Prev #[odra::module(events = [Transfer])] pub struct Erc721Token { core: SubModule&lt;Erc721Base&gt;, metadata: SubModule&lt;Erc721MetadataExtension&gt;, ownable: SubModule&lt;Ownable&gt; }  2.3.9. Update external contract calls.​ However the definition of an external contract remains the same, the way you call it has changed. A reference to an external contract is named {{ModuleName}}ContractRef (former {{ModuleName}}Ref) and you can call it using {{ModuleName}}ContractRef::new(env, address) (former {{ModuleName}}Ref::at()). 0.8.0Prev #[odra::external_contract] pub trait Token { fn balance_of(&amp;self, owner: &amp;Address) -&gt; U256; } // Usage TokenContractRef::new(env, token).balance_of(account)  2.3.10. Update constructors.​ Remove the #[odra::init] attribute from the constructor and ensure that the constructor function is named init. 2.3.11. Update UnwrapOrRevert calls.​ The functions unwrap_or_revert and unwrap_or_revert_with now require &amp;HostEnv as the first parameter. 2.3.12. Remove #[odra(using)] attribute from your module definition.​ Sharing the same instance of a module is no longer supported. A redesign of the module structure might be required. ","version":"2.3.0","tagName":"h3"},{"title":"2.4. Update Tests​","type":1,"pageTitle":"Migration guide to v0.8.0","url":"/docs/2.3.0/migrations/to-0.8.0#24-update-tests","content":"Once you've updated your smart contracts, you'll need to update your tests to reflect the changes. The changes will depend on the specific features and APIs used in the tests. Here are some common changes you might need to make: 2.4.1. Contract deployment.​ The way you deploy a contract has changed: You should use {{ModuleName}}HostRef::deploy(&amp;env, args) instead of {{ModuleName}}Deployer::init(). The {{ModuleName}}HostRef implements odra::host::Deployer.Instantiate the HostEnv using odra_test::env(), required by the odra::host::Deployer::deploy() function.If the contract doesn't have init args, you should use odra::host::NoArgs as the second argument of the deploy function.If the contract has init args, you should pass the autogenerated {{ModuleName}}InitArgs as the second argument of the deploy function. 0.8.0Prev // A contract without init args use super::OwnableHostRef; use odra::host::{Deployer, HostEnv, HostRef, NoArgs}; let env: HostEnv = odra_test::env(); let ownable = OwnableHostRef::deploy(&amp;env, NoArgs) // A contract with init args use super::{Erc20HostRef, Erc20InitArgs}; use odra::host::{Deployer, HostEnv}; let env: HostEnv = odra_test::env(); let init_args = Erc20InitArgs { symbol: SYMBOL.to_string(), name: NAME.to_string(), decimals: DECIMALS, initial_supply: Some(INITIAL_SUPPLY.into()) }; let erc20 = Erc20HostRef::deploy(&amp;env, init_args);  2.4.2. Host interactions.​ Replace odra::test_env with odra_test::env().The API of odra::test_env and odra_test::env() are similar, but there are some differences: test_env::advance_block_time_by(BlockTime) is now env.advance_block_time(u64).test_env::token_balance(Address) is now env.balance_of(&amp;Address).functions test_env::last_call_contract_gas_cost(), test_env::last_call_contract_gas_used(), test_env::total_gas_used(Address), test_env::gas_report() have been removed. You should use HostRef::last_call() and extract the data from a odra::ContractCallResult instance. HostRef is a trait implemented by {{ModuleName}}HostRef. 2.4.3. Testing failing scenarios.​ test_env::assert_exception() has been removed. You should use the try_ prefix to call the function and then assert the result.try_ prefix is a new way to call a function that might fail. It returns a OdraResult type, which you can then assert using the standard Rust assert_eq! macro. 0.8.0Prev #[test] fn transfer_from_error() { let (env, mut erc20) = setup(); let (owner, spender, recipient) = (env.get_account(0), env.get_account(1), env.get_account(2)); let amount = 1_000.into(); env.set_caller(spender); assert_eq!( erc20.try_transfer_from(owner, recipient, amount), Err(Error::InsufficientAllowance.into()) ); }  2.4.4. Testing events.​ assert_events! macro has been removed. You should use HostEnv::emitted_event() to assert the emitted events. The new API doesn't allow to assert multiple events at once, but adds alternative ways to assert the emitted events. Check the HostEnv documentation to explore the available options. 0.8.0Prev let env: HostEnv = odra_test::env(); let erc20 = Erc20HostRef::deploy(&amp;env, init_args); ... assert!(env.emitted_event( erc20.address(), &amp;Approval { owner, spender, value: approved_amount - transfer_amount } )); assert!(env.emitted_event( erc20.address(), &amp;Transfer { from: Some(owner), to: Some(recipient), amount: transfer_amount } ));  ","version":"2.3.0","tagName":"h3"},{"title":"3. Code Examples​","type":1,"pageTitle":"Migration guide to v0.8.0","url":"/docs/2.3.0/migrations/to-0.8.0#3-code-examples","content":"Here is a complete example of a smart contract after and before the migration to v0.8.0. 0.8.0Prev src/erc20.rs use crate::erc20::errors::Error::*; use crate::erc20::events::*; use odra::prelude::*; use odra::{casper_types::U256, Address, Mapping, Var}; #[odra::module(events = [Approval, Transfer])] pub struct Erc20 { decimals: Var&lt;u8&gt;, symbol: Var&lt;String&gt;, name: Var&lt;String&gt;, total_supply: Var&lt;U256&gt;, balances: Mapping&lt;Address, U256&gt;, allowances: Mapping&lt;(Address, Address), U256&gt; } #[odra::module] impl Erc20 { pub fn init( &amp;mut self, symbol: String, name: String, decimals: u8, initial_supply: Option&lt;U256&gt; ) { let caller = self.env().caller(); self.symbol.set(symbol); self.name.set(name); self.decimals.set(decimals); if let Some(initial_supply) = initial_supply { self.total_supply.set(initial_supply); self.balances.set(&amp;caller, initial_supply); if !initial_supply.is_zero() { self.env().emit_event(Transfer { from: None, to: Some(caller), amount: initial_supply }); } } } pub fn transfer(&amp;mut self, recipient: &amp;Address, amount: &amp;U256) { let caller = self.env().caller(); self.raw_transfer(&amp;caller, recipient, amount); } pub fn transfer_from(&amp;mut self, owner: &amp;Address, recipient: &amp;Address, amount: &amp;U256) { let spender = self.env().caller(); self.spend_allowance(owner, &amp;spender, amount); self.raw_transfer(owner, recipient, amount); } pub fn approve(&amp;mut self, spender: &amp;Address, amount: &amp;U256) { let owner = self.env().caller(); self.allowances.set(&amp;(owner, *spender), *amount); self.env().emit_event(Approval { owner, spender: *spender, value: *amount }); } pub fn name(&amp;self) -&gt; String { self.name.get_or_revert_with(NameNotSet) } // Other getter functions... pub fn allowance(&amp;self, owner: &amp;Address, spender: &amp;Address) -&gt; U256 { self.allowances.get_or_default(&amp;(*owner, *spender)) } pub fn mint(&amp;mut self, address: &amp;Address, amount: &amp;U256) { self.total_supply.add(*amount); self.balances.add(address, *amount); self.env().emit_event(Transfer { from: None, to: Some(*address), amount: *amount }); } pub fn burn(&amp;mut self, address: &amp;Address, amount: &amp;U256) { if self.balance_of(address) &lt; *amount { self.env().revert(InsufficientBalance); } self.total_supply.subtract(*amount); self.balances.subtract(address, *amount); self.env().emit_event(Transfer { from: Some(*address), to: None, amount: *amount }); } } impl Erc20 { fn raw_transfer(&amp;mut self, owner: &amp;Address, recipient: &amp;Address, amount: &amp;U256) { if *amount &gt; self.balances.get_or_default(owner) { self.env().revert(InsufficientBalance) } self.balances.subtract(owner, *amount); self.balances.add(recipient, *amount); self.env().emit_event(Transfer { from: Some(*owner), to: Some(*recipient), amount: *amount }); } fn spend_allowance(&amp;mut self, owner: &amp;Address, spender: &amp;Address, amount: &amp;U256) { let allowance = self.allowances.get_or_default(&amp;(*owner, *spender)); if allowance &lt; *amount { self.env().revert(InsufficientAllowance) } self.allowances.subtract(&amp;(*owner, *spender), *amount); self.env().emit_event(Approval { owner: *owner, spender: *spender, value: allowance - *amount }); } } pub mod events { use odra::prelude::*; use odra::{casper_types::U256, Address, Event}; #[derive(Event, Eq, PartialEq, Debug)] pub struct Transfer { pub from: Option&lt;Address&gt;, pub to: Option&lt;Address&gt;, pub amount: U256 } #[derive(Event, Eq, PartialEq, Debug)] pub struct Approval { pub owner: Address, pub spender: Address, pub value: U256 } } pub mod errors { use odra::OdraError; #[derive(OdraError)] pub enum Error { InsufficientBalance = 30_000, InsufficientAllowance = 30_001, NameNotSet = 30_002, SymbolNotSet = 30_003, DecimalsNotSet = 30_004 } } #[cfg(test)] mod tests { use super::{ errors::Error, events::{Approval, Transfer}, Erc20HostRef, Erc20InitArgs }; use odra::{ casper_types::U256, host::{Deployer, HostEnv, HostRef}, prelude::* }; const NAME: &amp;str = &quot;Plascoin&quot;; const SYMBOL: &amp;str = &quot;PLS&quot;; const DECIMALS: u8 = 10; const INITIAL_SUPPLY: u32 = 10_000; fn setup() -&gt; (HostEnv, Erc20HostRef) { let env = odra_test::env(); ( env.clone(), Erc20HostRef::deploy( &amp;env, Erc20InitArgs { symbol: SYMBOL.to_string(), name: NAME.to_string(), decimals: DECIMALS, initial_supply: Some(INITIAL_SUPPLY.into()) } ) ) } #[test] fn initialization() { // When deploy a contract with the initial supply. let (env, erc20) = setup(); // Then the contract has the metadata set. assert_eq!(erc20.symbol(), SYMBOL.to_string()); assert_eq!(erc20.name(), NAME.to_string()); assert_eq!(erc20.decimals(), DECIMALS); // Then the total supply is updated. assert_eq!(erc20.total_supply(), INITIAL_SUPPLY.into()); // Then a Transfer event was emitted. assert!(env.emitted_event( erc20.address(), &amp;Transfer { from: None, to: Some(env.get_account(0)), amount: INITIAL_SUPPLY.into() } )); } #[test] fn transfer_works() { // Given a new contract. let (env, mut erc20) = setup(); // When transfer tokens to a recipient. let sender = env.get_account(0); let recipient = env.get_account(1); let amount = 1_000.into(); erc20.transfer(&amp;recipient, &amp;amount); // Then the sender balance is deducted. assert_eq!( erc20.balance_of(&amp;sender), U256::from(INITIAL_SUPPLY) - amount ); // Then the recipient balance is updated. assert_eq!(erc20.balance_of(&amp;recipient), amount); // Then Transfer event was emitted. assert!(env.emitted_event( erc20.address(), &amp;Transfer { from: Some(sender), to: Some(recipient), amount } )); } #[test] fn transfer_error() { // Given a new contract. let (env, mut erc20) = setup(); // When the transfer amount exceeds the sender balance. let recipient = env.get_account(1); let amount = U256::from(INITIAL_SUPPLY) + U256::one(); // Then an error occurs. assert!(erc20.try_transfer(&amp;recipient, &amp;amount).is_err()); } // Other tests... }  ","version":"2.3.0","tagName":"h2"},{"title":"4. Troubleshooting​","type":1,"pageTitle":"Migration guide to v0.8.0","url":"/docs/2.3.0/migrations/to-0.8.0#4-troubleshooting","content":"If you encounter any further issues after completing the migration steps, please don't hesitate to reach out to us on Discord or explore the other sections this documentation. You can also refer to the technical documentation for more detailed information. Additionally, our examples repository offers a wide range of examples to assist you in understanding the new features and APIs. Be sure to carefully review any compilation errors and warnings, as they may provide valuable insights into the necessary adjustments. ","version":"2.3.0","tagName":"h2"},{"title":"5. References​","type":1,"pageTitle":"Migration guide to v0.8.0","url":"/docs/2.3.0/migrations/to-0.8.0#5-references","content":"ChangelogOdra DocumentationDocs.rsExamples ","version":"2.3.0","tagName":"h2"},{"title":"CEP-18","type":0,"sectionRef":"#","url":"/docs/2.3.0/tutorials/cep18","content":"","keywords":"","version":"2.3.0"},{"title":"Self-governing token​","type":1,"pageTitle":"CEP-18","url":"/docs/2.3.0/tutorials/cep18#self-governing-token","content":"There are many ways to implement a governance mechanism for a token, each more complex than the other. In our example, we will use a simple one, where the community of token holders can vote to mint new tokens. ","version":"2.3.0","tagName":"h2"},{"title":"Token implementation​","type":1,"pageTitle":"CEP-18","url":"/docs/2.3.0/tutorials/cep18#token-implementation","content":"Let's start by creating a new project, choosing a clever name and using cep18 as our starting template: cargo odra new --name ourcoin --template cep18  Let's glance at our token code: src/token.rs #[odra::module] pub struct MyToken { token: SubModule&lt;Cep18&gt;, } impl MyToken { // Delegate all Cep18 functions to the token sub-module. delegate! { to self.token { ... fn name(&amp;self) -&gt; String; fn symbol(&amp;self) -&gt; String; ...  As we can see, it indeed uses the Cep18 module and delegates all the methods to it. The only thing to do is to change the name of the struct to more appropriate OurToken, run the provided tests using cargo odra test, and continue with the implementation of the governance. note Remember to change the name of the struct and its usages as well as the struct name in the Odra.toml file! ","version":"2.3.0","tagName":"h2"},{"title":"Governance implementation​","type":1,"pageTitle":"CEP-18","url":"/docs/2.3.0/tutorials/cep18#governance-implementation","content":"Let's go through the process of implementing the governance mechanism. If we don't want to, we don't have to hide entrypoints from the public responsible for minting new tokens. By default, minting Modalityis turned off, so any attempt of direct minting will result in an error. We will however implement a voting mechanism, where the token holders can vote to mint new tokens. ","version":"2.3.0","tagName":"h2"},{"title":"Voting mechanism​","type":1,"pageTitle":"CEP-18","url":"/docs/2.3.0/tutorials/cep18#voting-mechanism","content":"Our voting system will be straightforward: Anyone with the tokens can propose a new mint.Anyone with the tokens can vote for the new mint by staking their tokens.If the majority of the token holders vote for the mint, it is executed. Storage​ We will need to store some additional information about the votes, so let's add some fields to our token struct: src/token.rs #[odra::module] pub struct OurToken { /// A sub-module that implements the CEP-18 token standard. token: SubModule&lt;Cep18&gt;, /// The proposed mint. proposed_mint: Var&lt;(Address, U256)&gt;, /// The list of votes cast in the current vote. votes: List&lt;Ballot&gt;, /// Whether a vote is open. is_vote_open: Var&lt;bool&gt;, /// The time when the vote ends. vote_end_time: Var&lt;u64&gt;, } /// A ballot cast by a voter. #[odra::odra_type] struct Ballot { voter: Address, choice: bool, amount: U256, }  Notice that proposed_mint contains a tuple containing the address of the proposer and the amount of tokens to mint. Moreover, we need to keep track if the vote time has ended, but also if it was already tallied, that's why we need both is_vote_open and vote_end_time. We will also use the power of the Listtype to store the Ballots. Proposing a new mint​ To implement the endpoint that allows token holders to propose a new mint, we need to add a new function to our token module: src/token.rs /// Proposes a new mint for the contract. pub fn propose_new_mint(&amp;mut self, account: Address, amount: U256) { // Only allow proposing a new mint if there is no vote in progress. if self.is_vote_open().get_or_default() { self.env().revert(GovernanceError::VoteAlreadyOpen); } // Only the token holders can propose a new mint. if self.balance_of(&amp;self.env().caller()) == U256::zero() { self.env().revert(GovernanceError::OnlyTokenHoldersCanPropose); } // Set the proposed mint. self.proposed_mint.set((account, amount)); // Open a vote. self.is_vote_open.set(true); // Set the vote end time to 10 minutes from now. self.vote_end_time .set(self.env().get_block_time() + 60 * 10 * 1000); }  As a parameters to the function, we pass the address of the account that should be the receiver of the minted tokens, and the amount. After some validation, we open the vote by setting the is_vote_open to true, and setting the vote_end_time to 10 minutes. In real-world scenarios, the time could be configurable, but for the sake of simplicity, we hardcoded it. Also, it should be quite longer than 10 minutes, but it will come in handy when we test it on Livenet. Voting for the mint​ Next, we need an endpoint that will allow us to cast a ballot: src/token.rs /// Votes on the proposed mint. pub fn vote(&amp;mut self, choice: bool, amount: U256) { // Only allow voting if there is a vote in progress. self.assert_vote_in_progress(); let voter = self.env().caller(); let contract = self.env().self_address(); // Transfer the voting tokens from the voter to the contract. self.token .transfer(&amp;contract, &amp;amount); // Add the vote to the list. self.votes.push(Ballot { voter, choice, amount, }); }  The most interesting thing here is that we are using a mechanism of staking, where we transfer our tokens to the contract, to show that we really mean it. The tokens will be locked until the vote is over, and tallied. Speaking of tallying... Tallying the votes​ The last step is to tally the votes and mint the tokens if the majority of voters agreed to do so: src/token.rs /// Count the votes and perform the action pub fn tally(&amp;mut self) { // Only allow tallying the votes once. if !self.is_vote_open.get_or_default() { self.env().revert(GovernanceError::NoVoteInProgress); } // Only allow tallying the votes after the vote has ended. let finish_time = self .vote_end_time .get_or_revert_with(GovernanceError::NoVoteInProgress); if self.env().get_block_time() &lt; finish_time { self.env().revert(GovernanceError::VoteNotYetEnded); } // Count the votes let mut yes_votes = U256::zero(); let mut no_votes = U256::zero(); let contract = self.env().self_address(); while let Some(vote) = self.votes.pop() { if vote.choice { yes_votes += vote.amount; } else { no_votes += vote.amount; } // Transfer back the voting tokens to the voter. self.token.raw_transfer(&amp;contract, &amp;vote.voter, &amp;vote.amount); } // Perform the action if the vote has passed. if yes_votes &gt; no_votes { let (account, amount) = self .proposed_mint .get_or_revert_with(GovernanceError::NoVoteInProgress); self.token.raw_mint(&amp;account, &amp;amount); } // Close the vote. self.is_vote_open.set(false); }  Notice how we used raw_transfer from the Cep18 module. We used it to set the sender, so the contract's balance will be used, instead of the caller's. Additonally, we used raw_mint to mint the tokens, skipping the security checks. We have no modality for minting, but even if we had, we don't have anyone with permissions! The Contract needs to mint the tokens itself. ","version":"2.3.0","tagName":"h3"},{"title":"Testing​","type":1,"pageTitle":"CEP-18","url":"/docs/2.3.0/tutorials/cep18#testing","content":"Now, we will put our implementation to the test. One unit test, that we can run both on OdraVM and on the CasperVM. src/token.rs #[test] fn it_works() { let env = odra_test::env(); let init_args = OurTokenInitArgs { name: &quot;OurToken&quot;.to_string(), symbol: &quot;OT&quot;.to_string(), decimals: 0, initial_supply: U256::from(1_000u64), }; let mut token = OurToken::deploy(&amp;env, init_args); // The deployer, as the only token holder, // starts a new voting to mint 1000 tokens to account 1. // There is only 1 token holder, so there is one Ballot cast. token.propose_new_mint(env.get_account(1), U256::from(2000)); token.vote(true, U256::from(1000)); // The tokens should now be staked. assert_eq!(token.balance_of(&amp;env.get_account(0)), U256::zero()); // Wait for the vote to end. env.advance_block_time(60 * 11 * 1000); // Finish the vote. token.tally(); // The tokens should now be minted. assert_eq!(token.balance_of(&amp;env.get_account(1)), U256::from(2000)); assert_eq!(token.total_supply(), 3000.into()); // The stake should be returned. assert_eq!(token.balance_of(&amp;env.get_account(0)), U256::from(1000)); // Now account 1 can mint new tokens with their voting power... env.set_caller(env.get_account(1)); token.propose_new_mint(env.get_account(1), U256::from(2000)); token.vote(true, U256::from(2000)); // ...Even if the deployer votes against it. env.set_caller(env.get_account(0)); token.vote(false, U256::from(1000)); env.advance_block_time(60 * 11 * 1000); token.tally(); // The power of community governance! assert_eq!(token.balance_of(&amp;env.get_account(1)), U256::from(4000)); }  We can run the test using both methods: cargo odra test cargo odra test -b casper  It is all nice and green, but it would be really nice to see it in action. How about deploying it on the Casper network? ","version":"2.3.0","tagName":"h3"},{"title":"What's next​","type":1,"pageTitle":"CEP-18","url":"/docs/2.3.0/tutorials/cep18#whats-next","content":"We will se our token in action, by deploying it on the Casper network, and using tools from the Casper Ecosystem to interact with it. ","version":"2.3.0","tagName":"h2"},{"title":"Complete code​","type":1,"pageTitle":"CEP-18","url":"/docs/2.3.0/tutorials/cep18#complete-code","content":"Here is the complete code of the OurToken module: src/token.rs use odra::{casper_types::U256, prelude::*}; use odra_modules::cep18_token::Cep18; /// A ballot cast by a voter. #[odra::odra_type] struct Ballot { voter: Address, choice: bool, amount: U256, } /// Errors for the governed token. #[odra::odra_error] pub enum GovernanceError { /// The vote is already in progress. VoteAlreadyOpen = 0, /// No vote is in progress. NoVoteInProgress = 1, /// Cannot tally votes yet. VoteNotYetEnded = 2, /// Vote ended VoteEnded = 3, /// Only the token holders can propose a new mint. OnlyTokenHoldersCanPropose = 4, } /// A module definition. Each module struct consists of Vars and Mappings /// or/and other modules. #[odra::module(errors = GovernanceError)] pub struct OurToken { /// A submodule that implements the CEP-18 token standard. token: SubModule&lt;Cep18&gt;, /// The proposed mint. proposed_mint: Var&lt;(Address, U256)&gt;, /// The list of votes cast in the current vote. votes: List&lt;Ballot&gt;, /// Whether a vote is open. is_vote_open: Var&lt;bool&gt;, /// The time when the vote ends. vote_end_time: Var&lt;u64&gt;, } /// Module implementation. /// /// To generate entrypoints, /// an implementation block must be marked as #[odra::module]. #[odra::module] impl OurToken { /// Initializes the contract with the given metadata and initial supply. pub fn init(&amp;mut self, name: String, symbol: String, decimals: u8, initial_supply: U256) { // We put the token address as an admin, so it can govern itself. Self-governing token! self.token.init(symbol, name, decimals, initial_supply); } // Delegate all Cep18 functions to the token submodule. delegate! { to self.token { /// Returns the name of the token. fn name(&amp;self) -&gt; String; /// Returns the symbol of the token. fn symbol(&amp;self) -&gt; String; /// Returns the number of decimals the token uses. fn decimals(&amp;self) -&gt; u8; /// Returns the total supply of the token. fn total_supply(&amp;self) -&gt; U256; /// Returns the balance of the given address. fn balance_of(&amp;self, address: &amp;Address) -&gt; U256; /// Returns the amount of tokens the owner has allowed the spender to spend. fn allowance(&amp;self, owner: &amp;Address, spender: &amp;Address) -&gt; U256; /// Approves the spender to spend the given amount of tokens on behalf of the caller. fn approve(&amp;mut self, spender: &amp;Address, amount: &amp;U256); /// Decreases the allowance of the spender by the given amount. fn decrease_allowance(&amp;mut self, spender: &amp;Address, decr_by: &amp;U256); /// Increases the allowance of the spender by the given amount. fn increase_allowance(&amp;mut self, spender: &amp;Address, inc_by: &amp;U256); /// Transfers tokens from the caller to the recipient. fn transfer(&amp;mut self, recipient: &amp;Address, amount: &amp;U256); /// Transfers tokens from the owner to the recipient using the spender's allowance. fn transfer_from(&amp;mut self, owner: &amp;Address, recipient: &amp;Address, amount: &amp;U256); } } /// Burns the given amount of tokens from the given address. pub fn burn(&amp;mut self, owner: &amp;Address, amount: &amp;U256) { self.token.assert_caller(owner); // Burn the tokens. self.token.raw_burn(owner, amount); } /// Proposes a new mint for the contract. pub fn propose_new_mint(&amp;mut self, account: Address, amount: U256) { // Only allow proposing a new mint if there is no vote in progress. if self.is_vote_open.get_or_default() { self.env().revert(GovernanceError::VoteAlreadyOpen); } // Only the token holders can propose a new mint. if self.balance_of(&amp;self.env().caller()) == U256::zero() { self.env() .revert(GovernanceError::OnlyTokenHoldersCanPropose); } // Set the proposed mint. self.proposed_mint.set((account, amount)); // Open a vote. self.is_vote_open.set(true); // Set the vote end time to 10 minutes from now. self.vote_end_time .set(self.env().get_block_time() + 10 * 60 * 1000); } /// Votes on the proposed mint. pub fn vote(&amp;mut self, choice: bool, amount: U256) { // Only allow voting if there is a vote in progress. self.assert_vote_in_progress(); let voter = self.env().caller(); let contract = self.env().self_address(); // Transfer the voting tokens from the voter to the contract. self.token.transfer(&amp;contract, &amp;amount); // Add the vote to the list. self.votes.push(Ballot { voter, choice, amount, }); } /// Count the votes and perform the action pub fn tally(&amp;mut self) { // Only allow tallying the votes once. if !self.is_vote_open.get_or_default() { self.env().revert(GovernanceError::NoVoteInProgress); } // Only allow tallying the votes after the vote has ended. let finish_time = self .vote_end_time .get_or_revert_with(GovernanceError::NoVoteInProgress); if self.env().get_block_time() &lt; finish_time { self.env().revert(GovernanceError::VoteNotYetEnded); } // Count the votes let mut yes_votes = U256::zero(); let mut no_votes = U256::zero(); let contract = self.env().self_address(); while let Some(vote) = self.votes.pop() { if vote.choice { yes_votes += vote.amount; } else { no_votes += vote.amount; } // Transfer back the voting tokens to the voter. self.token .raw_transfer(&amp;contract, &amp;vote.voter, &amp;vote.amount); } // Perform the action if the vote has passed. if yes_votes &gt; no_votes { let (account, amount) = self .proposed_mint .get_or_revert_with(GovernanceError::NoVoteInProgress); self.token.raw_mint(&amp;account, &amp;amount); } // Close the vote. self.is_vote_open.set(false); } fn assert_vote_in_progress(&amp;self) { if !self.is_vote_open.get_or_default() { self.env().revert(GovernanceError::NoVoteInProgress); } let finish_time = self .vote_end_time .get_or_revert_with(GovernanceError::NoVoteInProgress); if self.env().get_block_time() &gt; finish_time { self.env().revert(GovernanceError::VoteEnded); } } } #[cfg(test)] mod tests { use super::*; use odra::host::Deployer; #[test] fn it_works() { let env = odra_test::env(); let init_args = OurTokenInitArgs { name: &quot;OurToken&quot;.to_string(), symbol: &quot;OT&quot;.to_string(), decimals: 0, initial_supply: U256::from(1_000u64), }; let mut token = OurToken::deploy(&amp;env, init_args); // The deployer, as the only token holder, // starts a new voting to mint 1000 tokens to account 1. // There is only 1 token holder, so there is one Ballot cast. token.propose_new_mint(env.get_account(1), U256::from(2000)); token.vote(true, U256::from(1000)); // The tokens should now be staked. assert_eq!(token.balance_of(&amp;env.get_account(0)), U256::zero()); // Wait for the vote to end. env.advance_block_time(60 * 11 * 1000); // Finish the vote. token.tally(); // The tokens should now be minted. assert_eq!(token.balance_of(&amp;env.get_account(1)), U256::from(2000)); assert_eq!(token.total_supply(), 3000.into()); // The stake should be returned. assert_eq!(token.balance_of(&amp;env.get_account(0)), U256::from(1000)); // Now account 1 can mint new tokens with their voting power... env.set_caller(env.get_account(1)); token.propose_new_mint(env.get_account(1), U256::from(2000)); token.vote(true, U256::from(2000)); // ...Even if the deployer votes against it. env.set_caller(env.get_account(0)); token.vote(false, U256::from(1000)); env.advance_block_time(60 * 11 * 1000); token.tally(); // The power of community governance! assert_eq!(token.balance_of(&amp;env.get_account(1)), U256::from(4000)); } }  ","version":"2.3.0","tagName":"h2"},{"title":"ERC-20","type":0,"sectionRef":"#","url":"/docs/2.3.0/tutorials/erc20","content":"","keywords":"","version":"2.3.0"},{"title":"Framework features​","type":1,"pageTitle":"ERC-20","url":"/docs/2.3.0/tutorials/erc20#framework-features","content":"A module we will write in a minute, will help you master a few Odra features: Advanced storage using key-value pairs,Odra types such as Address,Advanced event assertion. ","version":"2.3.0","tagName":"h2"},{"title":"Code​","type":1,"pageTitle":"ERC-20","url":"/docs/2.3.0/tutorials/erc20#code","content":"Our module features a considerably more complex storage layout compared to the previous example. It is designed to store the following data: Immutable metadata - name, symbol, and decimals.Total supply.Balances of individual users.Allowances, essentially indicating who is permitted to spend tokens on behalf of another user. ","version":"2.3.0","tagName":"h2"},{"title":"Module definition​","type":1,"pageTitle":"ERC-20","url":"/docs/2.3.0/tutorials/erc20#module-definition","content":"erc20.rs use odra::prelude::*; use odra::casper_types::U256; #[odra::module(events = [Transfer, Approval], errors = Error)] pub struct Erc20 { decimals: Var&lt;u8&gt;, symbol: Var&lt;String&gt;, name: Var&lt;String&gt;, total_supply: Var&lt;U256&gt;, balances: Mapping&lt;Address, U256&gt;, allowances: Mapping&lt;(Address, Address), U256&gt; }  L10 - For the first time, we need to store key-value pairs. In order to do that, we use Mapping. The name is taken after Solidity's native type mapping.L11 - Odra does not allows nested Mappings as Solidity does. Instead, you can create a compound key using a tuple of keys. ","version":"2.3.0","tagName":"h2"},{"title":"Metadata​","type":1,"pageTitle":"ERC-20","url":"/docs/2.3.0/tutorials/erc20#metadata","content":"erc20.rs #[odra::module] impl Erc20 { pub fn init(&amp;mut self, name: String, symbol: String, decimals: u8, initial_supply: U256) { let caller = self.env().caller(); self.name.set(name); self.symbol.set(symbol); self.decimals.set(decimals); self.mint(&amp;caller, &amp;initial_supply); } pub fn name(&amp;self) -&gt; String { self.name.get_or_default() } pub fn symbol(&amp;self) -&gt; String { self.symbol.get_or_default() } pub fn decimals(&amp;self) -&gt; u8 { self.decimals.get_or_default() } pub fn total_supply(&amp;self) -&gt; U256 { self.total_supply.get_or_default() } } impl Erc20 { pub fn mint(&amp;mut self, address: &amp;Address, amount: &amp;U256) { self.balances.add(address, *amount); self.total_supply.add(*amount); self.env().emit_event(Transfer { from: None, to: Some(*address), amount: *amount }); } } #[odra::event] pub struct Transfer { pub from: Option&lt;Address&gt;, pub to: Option&lt;Address&gt;, pub amount: U256 }  L1 - The first impl block, marked as a module, contains functions defined in the ERC-20 standard.L3-L9 - A constructor sets the token metadata and mints the initial supply.L28 - The second impl is not an Odra module; in other words, these functions will not be part of the contract's public interface.L29-L38 - The mint function is public, so, like in regular Rust code, it will be accessible from the outside. mint() uses the notation self.balances.add(address, *amount);, which is syntactic sugar for: let current_balance = self.balances.get(address).unwrap_or_default(); let new_balance = &lt;U256 as OverflowingAdd&gt;::overflowing_add(current_balance, current_balance).unwrap_or_revert(&amp;self.env()); self.balances.set(address, new_balance);  ","version":"2.3.0","tagName":"h3"},{"title":"Core​","type":1,"pageTitle":"ERC-20","url":"/docs/2.3.0/tutorials/erc20#core","content":"To ensure comprehensive functionality, let's implement the remaining features such as transfer, transfer_from, and approve. Since they do not introduce any new concepts, we will present them without additional remarks. erc20.rs #[odra::module] impl Erc20 { ... pub fn transfer(&amp;mut self, recipient: &amp;Address, amount: &amp;U256) { let caller = self.env().caller(); self.raw_transfer(&amp;caller, recipient, amount); } pub fn transfer_from(&amp;mut self, owner: &amp;Address, recipient: &amp;Address, amount: &amp;U256) { let spender = self.env().caller(); self.spend_allowance(owner, &amp;spender, amount); self.raw_transfer(owner, recipient, amount); } pub fn approve(&amp;mut self, spender: &amp;Address, amount: &amp;U256) { let owner = self.env().caller(); self.allowances.set(&amp;(owner, *spender), *amount); self.env().emit_event(Approval { owner, spender: *spender, value: *amount }); } pub fn balance_of(&amp;self, address: &amp;Address) -&gt; U256 { self.balances.get_or_default(&amp;address) } pub fn allowance(&amp;self, owner: &amp;Address, spender: &amp;Address) -&gt; U256 { self.allowances.get_or_default(&amp;(*owner, *spender)) } } impl Erc20 { ... fn raw_transfer(&amp;mut self, owner: &amp;Address, recipient: &amp;Address, amount: &amp;U256) { let owner_balance = self.balances.get_or_default(&amp;owner); if *amount &gt; owner_balance { self.env().revert(Error::InsufficientBalance) } self.balances.set(owner, owner_balance - *amount); self.balances.add(recipient, *amount); self.env().emit_event(Transfer { from: Some(*owner), to: Some(*recipient), amount: *amount }); } fn spend_allowance(&amp;mut self, owner: &amp;Address, spender: &amp;Address, amount: &amp;U256) { let allowance = self.allowance(owner, spender); if allowance &lt; *amount { self.env().revert(Error::InsufficientAllowance) } let new_allowance = allowance - *amount; self.allowances .set(&amp;(*owner, *spender), new_allowance); self.env().emit_event(Approval { owner: *owner, spender: *spender, value: allowance - *amount }); } } #[odra::event] pub struct Approval { pub owner: Address, pub spender: Address, pub value: U256 } #[odra::odra_error] pub enum Error { InsufficientBalance = 1, InsufficientAllowance = 2, }  Now, compare the code we have written, with Open Zeppelin code. Out of 10, how Solidity-ish is our implementation? ","version":"2.3.0","tagName":"h3"},{"title":"Test​","type":1,"pageTitle":"ERC-20","url":"/docs/2.3.0/tutorials/erc20#test","content":"erc20.rs #[cfg(test)] pub mod tests { use super::*; use odra::{ casper_types::U256, host::{Deployer, HostEnv}, prelude::* }; const NAME: &amp;str = &quot;Plascoin&quot;; const SYMBOL: &amp;str = &quot;PLS&quot;; const DECIMALS: u8 = 10; const INITIAL_SUPPLY: u32 = 10_000; fn setup() -&gt; (HostEnv, Erc20HostRef) { let env = odra_test::env(); ( env.clone(), Erc20::deploy( &amp;env, Erc20InitArgs { symbol: SYMBOL.to_string(), name: NAME.to_string(), decimals: DECIMALS, initial_supply: INITIAL_SUPPLY.into() } ) ) } #[test] fn initialization() { // When deploy a contract with the initial supply. let (env, erc20) = setup(); // Then the contract has the metadata set. assert_eq!(erc20.symbol(), SYMBOL.to_string()); assert_eq!(erc20.name(), NAME.to_string()); assert_eq!(erc20.decimals(), DECIMALS); // Then the total supply is updated. assert_eq!(erc20.total_supply(), INITIAL_SUPPLY.into()); // Then a Transfer event was emitted. assert!(env.emitted_event( &amp;erc20, &amp;Transfer { from: None, to: Some(env.get_account(0)), amount: INITIAL_SUPPLY.into() } )); } #[test] fn transfer_works() { // Given a new contract. let (env, mut erc20) = setup(); // When transfer tokens to a recipient. let sender = env.get_account(0); let recipient = env.get_account(1); let amount = 1_000.into(); erc20.transfer(&amp;recipient, &amp;amount); // Then the sender balance is deducted. assert_eq!( erc20.balance_of(&amp;sender), U256::from(INITIAL_SUPPLY) - amount ); // Then the recipient balance is updated. assert_eq!(erc20.balance_of(&amp;recipient), amount); // Then Transfer event was emitted. assert!(env.emitted_event( &amp;erc20, &amp;Transfer { from: Some(sender), to: Some(recipient), amount } )); } #[test] fn transfer_error() { // Given a new contract. let (env, mut erc20) = setup(); // When the transfer amount exceeds the sender balance. let recipient = env.get_account(1); let amount = U256::from(INITIAL_SUPPLY) + U256::one(); // Then an error occurs. assert!(erc20.try_transfer(&amp;recipient, &amp;amount).is_err()); } #[test] fn transfer_from_and_approval_work() { let (env, mut erc20) = setup(); let (owner, recipient, spender) = (env.get_account(0), env.get_account(1), env.get_account(2)); let approved_amount = 3_000.into(); let transfer_amount = 1_000.into(); assert_eq!(erc20.balance_of(&amp;owner), U256::from(INITIAL_SUPPLY)); // Owner approves Spender. erc20.approve(&amp;spender, &amp;approved_amount); // Allowance was recorded. assert_eq!(erc20.allowance(&amp;owner, &amp;spender), approved_amount); assert!(env.emitted_event( &amp;erc20, Approval { owner, spender, value: approved_amount } )); // Spender transfers tokens from Owner to Recipient. env.set_caller(spender); erc20.transfer_from(&amp;owner, &amp;recipient, &amp;transfer_amount); // Tokens are transferred and allowance decremented. assert_eq!( erc20.balance_of(&amp;owner), U256::from(INITIAL_SUPPLY) - transfer_amount ); assert_eq!(erc20.balance_of(&amp;recipient), transfer_amount); assert!(env.emitted_event( &amp;erc20, Approval { owner, spender, value: approved_amount - transfer_amount } )); assert!(env.emitted_event( &amp;erc20, Transfer { from: Some(owner), to: Some(recipient), amount: transfer_amount } )); // assert!(env.emitted(&amp;erc20, &quot;Transfer&quot;)); } #[test] fn transfer_from_error() { // Given a new instance. let (env, mut erc20) = setup(); // When the spender's allowance is zero. let (owner, spender, recipient) = (env.get_account(0), env.get_account(1), env.get_account(2)); let amount = 1_000.into(); env.set_caller(spender); // Then transfer fails. assert_eq!( erc20.try_transfer_from(&amp;owner, &amp;recipient, &amp;amount), Err(Error::InsufficientAllowance.into()) ); } }  L146 - Alternatively, if you don't want to check the entire event, you may assert only its type. ","version":"2.3.0","tagName":"h3"},{"title":"What's next​","type":1,"pageTitle":"ERC-20","url":"/docs/2.3.0/tutorials/erc20#whats-next","content":"Having two modules: Ownable and Erc20, let's combine them, and create an ERC-20 on steroids. ","version":"2.3.0","tagName":"h2"},{"title":"Odra CLI","type":0,"sectionRef":"#","url":"/docs/2.3.0/tutorials/odra-cli","content":"","keywords":"","version":"2.3.0"},{"title":"Example​","type":1,"pageTitle":"Odra CLI","url":"/docs/2.3.0/tutorials/odra-cli#example","content":"Let's go through an example available in the odra repository to see how to use the Odra CLI library. It creates a CLI tool for a useful DogContract. ","version":"2.3.0","tagName":"h2"},{"title":"Cargo.toml​","type":1,"pageTitle":"Odra CLI","url":"/docs/2.3.0/tutorials/odra-cli#cargotoml","content":"To use the Odra CLI library in your project, you need to add odra-cli to your Cargo.toml file, alongside a new binary: [dependencies] ... odra-cli = &quot;2&quot; ... [[bin]] name = &quot;odra-cli&quot; path = &quot;bin/odra-cli.rs&quot;  Then, create an empty file in the bin directory named odra-cli.rs. ","version":"2.3.0","tagName":"h3"},{"title":"Deploy script​","type":1,"pageTitle":"Odra CLI","url":"/docs/2.3.0/tutorials/odra-cli#deploy-script","content":"The first type of script we can create is a deploy script. It is used to deploy the contract to the network and store the address of the deployed contract in a container for later use. Only one deploy script can be used in a single CLI tool, and it is executed when the user runs the deploy command. bin/odra-cli.rs use odra::host::HostEnv; use odra_cli::{ deploy::DeployScript, DeployerExt, DeployedContractsContainer, }; use odra_examples::features::storage::variable::{DogContract, DogContractInitArgs}; /// Deploys the `DogContract` and adds it to the container. pub struct DeployDogScript; impl DeployScript for DeployDogScript { fn deploy( &amp;self, env: &amp;HostEnv, container: &amp;mut DeployedContractsContainer ) -&gt; Result&lt;(), odra_cli::deploy::Error&gt; { env.set_gas(350_000_000_000); let dog_contract = DogContract::try_deploy( env, DogContractInitArgs { barks: true, weight: 10, name: &quot;Mantus&quot;.to_string() } )?; container.add_contract(&amp;dog_contract)?; // By default, a contract is non-upgradeable, you can change it by passing `InstallConfig` _ = DogContract::try_deploy_with_cfg( env, DogContractInitArgs { barks: true, weight: 10, name: &quot;Mantus&quot;.to_string() }, InstallConfig::upgradable::&lt;DogContract&gt;(), )?; // Alternatively, you can use the `DeployerExt` trait to deploy the contract: _ = DogContract::load_or_deploy( env, DogContractInitArgs { barks: true, weight: 10, name: &quot;Mantus&quot;.to_string() }, container, 350_000_000_000 )?; // You can use `load_or_deploy_with_cfg` to deploy the contract with a custom configuration _ = DogContract::load_or_deploy_with_cfg( env, DogContractInitArgs { barks: true, weight: 10, name: &quot;Mantus&quot;.to_string() }, InstallConfig::upgradable::&lt;DogContract&gt;(), container, 350_000_000_000 )?; Ok(()) } }  In the example above, we see a few alternative implementations of a simple DeployScript for our DogContract. All of them set the gas limit, deploy the contract and adds it to a container. DogContract::try_deploy method, which deploys the contract every time the script is run. DogContract::try_deploy_with_cfg also deploys a contract everytime, but passes InstallConfig instance to configure the deployment using a factory method InstallConfig::upgradable.Utilizes the DeployerExt trait, which checks if the contract is already deployed and returns the existing instance if it is, or deploys it if it is not. It is a convenient way to ensure that the contract is deployed only once. It is useful when you want to add more contracts to the script in the future and avoid redeploying previously deployed contracts. The last option is to use DeployerExt::load_or_deploy_with_cfg that works like the previous one, but accepts a custom configuration. The address of the deployed contract is stored in a TOML file in the resources directory, which is created automatically by the Odra CLI library. ","version":"2.3.0","tagName":"h3"},{"title":"Scenarios​","type":1,"pageTitle":"Odra CLI","url":"/docs/2.3.0/tutorials/odra-cli#scenarios","content":"Scenarios are a way to run multiple calls one after another, and can be used to test the contract or perform complex operations like setting up the dependencies between contracts. To create a scenario, you need to implement the Scenario trait and add it to the OdraCli instance in the main function. A scenario also implements the ScenarioMetadata trait, which provides metadata about the scenario, such as its name and description. You can use this metadata to display the scenario in the CLI tool and provide a description of what it does. bin/odra-cli.rs use odra_cli::{ scenario::{Args, Error, Scenario, ScenarioMetadata}, CommandArg, ContractProvider, DeployedContractsContainer, }; use std::vec; pub struct DogCheckScenario; impl Scenario for DogCheckScenario { fn args(&amp;self) -&gt; Vec&lt;CommandArg&gt; { vec![CommandArg::new( &quot;name&quot;, &quot;The name of the dog&quot;, NamedCLType::String, ).required()] } fn run( &amp;self, env: &amp;HostEnv, container: &amp;DeployedContractsContainer, args: Args ) -&gt; Result&lt;(), Error&gt; { let dog_contract = container.contract_ref::&lt;DogContract&gt;(env)?; let test_name = args.get_single::&lt;String&gt;(&quot;name&quot;)?; env.set_gas(50_000_000); let actual_name = dog_contract.try_name()?; assert_eq!(test_name, actual_name, &quot;Dog name mismatch&quot;); Ok(()) } } impl ScenarioMetadata for DogCheckScenario { const NAME: &amp;'static str = &quot;check&quot;; const DESCRIPTION: &amp;'static str = &quot;Checks if the name of the deployed dog matches the provided name&quot;; }  A scenario must implement the Scenario trait, which requires defining the args and run methods. The args method returns a vector of CommandArg that defines the arguments that the scenario accepts. In this case, we define a single argument name of type String, which is required - the program will fail at parse time if the argument is not provided. The run method is where the scenario logic is implemented. It receives the HostEnv, a container with deployed contracts, and the arguments passed to the scenario. To load the contract, we use the ContractProvider trait, which allows us to get a reference to the contract by its type. The trait is implemented for the DeployedContractsContainer, which is passed to the run method. To read the arguments, we use the Args type, which provides two methods: get_single and get_many. In this case, we use get_single to get the value of the name argument. If we want to get multiple values for an argument, we must define the argument as CommandArg::new(&quot;name&quot;, &quot;The name of the dog&quot;, NamedCLType::String).list(), where list() indicates that the argument can be provided multiple times. The example above performs a simple check on the return value of one of the methods. Of course, there is no limit to how complex a scenario can be. ","version":"2.3.0","tagName":"h3"},{"title":"Contract methods​","type":1,"pageTitle":"Odra CLI","url":"/docs/2.3.0/tutorials/odra-cli#contract-methods","content":"To interact with the contract methods, we can use the contract command. The Odra CLI automatically generates commands for each contract method, allowing us to call them directly by name. But first, we need to register the contract in the OdraCli instance. ","version":"2.3.0","tagName":"h3"},{"title":"Builder​","type":1,"pageTitle":"Odra CLI","url":"/docs/2.3.0/tutorials/odra-cli#builder","content":"Now, let's put everything together in the main function. We will use the OdraCli builder to create a CLI tool that can deploy the contract, call its methods, and run scenarios. bin/odra-cli.rs use odra_cli::OdraCli; /// Main function to run the CLI tool. pub fn main() { OdraCli::new() .about(&quot;Dog contract cli tool&quot;) .deploy(DeployDogScript) .contract::&lt;DogContract&gt;() .scenario(DogCheckScenario) .build() .run(); }  This code creates a new OdraCli instance, sets the description of the tool, adds the deploy script, registers the DogContract, and adds the scenario. Finally, it builds the CLI tool and runs it. ","version":"2.3.0","tagName":"h3"},{"title":"How to use it​","type":1,"pageTitle":"Odra CLI","url":"/docs/2.3.0/tutorials/odra-cli#how-to-use-it","content":"Assuming the correct livenet environment is set up, you can run the CLI tool using the following command: cargo run --bin odra-cli  This will display all of our options: Dog contract cli tool Usage: odra_cli [OPTIONS] &lt;COMMAND&gt; Commands: deploy Runs the deploy script contract Commands for interacting with contracts scenario Commands for interacting with scenarios print-events Prints the most recent events emitted by a contract help Print this message or the help of the given subcommand(s) Options: -c, --contracts-toml &lt;PathBuf&gt; The path to the file with the deployed contracts. Relative to the project root. -h, --help Print help  By default, contracts are written/read to/from the contracts.toml file, which is located in the resources directory, but you can specify a different path using the -c or --contracts-toml option. ","version":"2.3.0","tagName":"h2"},{"title":"Deploy command​","type":1,"pageTitle":"Odra CLI","url":"/docs/2.3.0/tutorials/odra-cli#deploy-command","content":"First, we need to deploy the contract: cargo run --bin odra_cli deploy  This gives us the following output: cargo run --bin odra_cli -- deploy Compiling odra-examples v2.1.0 (/home/kuba/Projekty/odra/odra/examples) Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.65s Running `../target/debug/odra_cli deploy` 💁 INFO : Found wasm under &quot;wasm/DogContract.wasm&quot;. 💁 INFO : Deploying &quot;DogContract&quot;. 🙄 WAIT : Waiting 10 for V1(TransactionV1Hash(4230d5ca3113d87190e4136cefe097bd08fea03c841ce5e4df73a049e10208f1)). 💁 INFO : Transaction &quot;4230d5ca3113d87190e4136cefe097bd08fea03c841ce5e4df73a049e10208f1&quot; successfully executed. 🔗 LINK : 💁 INFO : Contract &quot;contract-package-53b3486180b2a9506fbb0523ed159b1908cec628d091b19cbe74e057e7ebbc8b&quot; deployed. 💁 INFO : Command executed successfully  This will run the deploy script and create a new file in the resources directory named contracts.toml: last_updated = &quot;2025-07-03T10:33:55Z&quot; [[contracts]] name = &quot;DogContract&quot; package_hash = &quot;hash-53b3486180b2a9506fbb0523ed159b1908cec628d091b19cbe74e057e7ebbc8b&quot;  All the calls to the contract will be made using this package hash, unless you specify a different one using the -c or --contracts-toml option. ","version":"2.3.0","tagName":"h3"},{"title":"Contract command​","type":1,"pageTitle":"Odra CLI","url":"/docs/2.3.0/tutorials/odra-cli#contract-command","content":"To call a contract method, we need to use the contract command. The command itself will display all the available contracts: cargo run --bin odra_cli -- contract  This outputs: Commands for interacting with contracts Usage: odra_cli contract &lt;COMMAND&gt; Commands: DogContract Commands for interacting with the DogContract contract help Print this message or the help of the given subcommand(s)  And when a contract is selected, it will show us the available methods: cargo run --bin odra_cli -- contract DogContract  Commands for interacting with the DogContract contract Usage: odra_cli contract DogContract &lt;COMMAND&gt; Commands: barks Returns true if the dog barks. weight Returns the dog's weight. name Returns the dog's name. walks_amount Adds a walk to the dog's walks. walks_total_length Returns the total length of the dog's walks. help Print this message or the help of the given subcommand(s)  To run a command, compose a command like this: cargo run --bin odra_cli -- contract DogContract barks  This will result in: 💁 INFO : Call result: true 💁 INFO : Command executed successfully  If you run a command that requires arguments, it will display an error message: cargo run --bin odra_cli -- contract DogContract rename error: the following required arguments were not provided: --new_name &lt;String&gt; --gas &lt;U64&gt; Usage: odra_cli contract DogContract rename --new_name &lt;String&gt; --gas &lt;U64&gt; For more information, try '--help'.  The error message above indicates that the rename method requires two arguments: new_name and gas. In the code, the rename method is mutable and takes a single argument new_name of type String. As the entry point is mutable and requires a real transaction, the gas argument is also required to specify how much gas to use for the call. The gas amount is denominated in motes. Let's run the command with the required arguments: cargo run --bin odra_cli -- contract DogContract rename --new_name &quot;Doggy&quot; --gas 200000000 error: invalid value '200000000' for '--gas &lt;U64&gt;': 200000000 is not in 2500000000..18446744073709551615  As the minimum gas amount for a transaction is 2.5 CSPRs, we need to increase the gas amount to at least that value: cargo run --bin odra_cli -- contract DogContract rename --new_name &quot;Doggy&quot; --gas 2500000000 💁 INFO : Calling &quot;contract-package-0eda9544d667775d8e5503543dd8ba0996d439fd9ded79cfe28454d07f42df3a&quot; directly with entrypoint &quot;rename&quot;. 🙄 WAIT : Waiting 10 for V1(TransactionV1Hash(e9d2e7f9d7d832cbf64e6e9eb09404423757e354a1ed7420c0398d851fea3a40)). 💁 INFO : Transaction &quot;e9d2e7f9d7d832cbf64e6e9eb09404423757e354a1ed7420c0398d851fea3a40&quot; successfully executed. 🔗 LINK : 💁 INFO : Call executed successfully, but no result was returned. 💁 INFO : Command executed successfully # Verifying the name change cargo run --bin odra_cli -- contract DogContract name 💁 INFO : Call result: Doggy 💁 INFO : Command executed successfully  There are more options available for the contract command that we can discover by running the help command: cargo run --bin odra_cli -- contract DogContract rename --help It is uncommon but you can change the dog's name. Usage: odra_cli contract DogContract rename [OPTIONS] --new_name &lt;String&gt; --gas &lt;U64&gt; Options: --new_name &lt;String&gt; --attached_value &lt;U512&gt; The amount of CSPRs attached to the call --gas &lt;U64&gt; The amount of gas to attach to the call -p, --print-events Print events emitted by the contract -h, --help  If you want to print the events emitted by the contract, you can use the --print-events option. This will print all the events emitted by the contract during the call. cargo run --bin odra_cli -- contract DogContract rename --new_name &quot;Doggy&quot; --gas 2500000000 --print-events 💁 INFO : Syncing events for the call... 💁 INFO : Calling &quot;contract-package-0eda9544d667775d8e5503543dd8ba0996d439fd9ded79cfe28454d07f42df3a&quot; directly with entrypoint &quot;rename&quot;. 🙄 WAIT : Waiting 10 for V1(TransactionV1Hash(f2f473d46b59c136052f687539ab76e5fbb3af958c483e3a382b5a0e498227c4)). 💁 INFO : Transaction &quot;f2f473d46b59c136052f687539ab76e5fbb3af958c483e3a382b5a0e498227c4&quot; successfully executed. 🔗 LINK : 💁 INFO : Captured 1 events for contract 'DogContract' 💁 INFO : Event 1: 'NamedChanged': 'old_name': Mantus 'new_name': Doggy 💁 INFO : Call executed successfully, but no result was returned. 💁 INFO : Command executed successfully  For a payable method, you can use the --attached_value option to specify the amount of CSPRs to attach to the call. The value is denominated in motes. ","version":"2.3.0","tagName":"h3"},{"title":"Print-events command​","type":1,"pageTitle":"Odra CLI","url":"/docs/2.3.0/tutorials/odra-cli#print-events-command","content":"The print-events command allows you to print the most recent events emitted by a contract. It is useful for debugging and understanding what is happening in the contract. You can run it like this: cargo run --bin odra_cli -- print-events DogContract --help Print events of the DogContract contract Usage: odra_cli print-events DogContract [OPTIONS] Options: -n, --number &lt;N&gt; Number of events to print [default: 10] -h, --help Print help cargo run --bin odra_cli -- print-events DogContract -n 2 💁 INFO : Printing 4 the most recent events for contract 'DogContract' 💁 INFO : Event 1: 'NamedChanged': 'old_name': Mantus 'new_name': Doggy 💁 INFO : Event 2: 'NamedChanged': 'old_name': Rex 'new_name': Mantus 💁 INFO : Command executed successfully  By default, it prints the last 10 events, but you can specify a different number using the -n or --number option. ","version":"2.3.0","tagName":"h3"},{"title":"Scenario command​","type":1,"pageTitle":"Odra CLI","url":"/docs/2.3.0/tutorials/odra-cli#scenario-command","content":"Scenarios registered in the OdraCli instance can be run using the scenario command. It displays all the available scenarios: cargo run --bin odra_cli -- scenario  This will output: Commands for running user-defined scenarios Usage: odra_cli scenario &lt;COMMAND&gt; Commands: check Checks if the name of the deployed dog matches the provided name help Print this message or the help of the given subcommand(s)  It can be run like this: cargo run --bin odra_cli -- scenario check --name Doggy  This will output: thread 'main' panicked at examples/bin/odra_cli.rs:59:9: assertion `left == right` failed: Dog name mismatch left: &quot;Doggy&quot; right: &quot;Mantus&quot; ## Conclusion The Odra CLI library provides a powerful and convenient way to create command-line tools for your Odra contracts. It simplifies the process of deploying, interacting with, and testing your contracts, allowing you to focus on the business logic of your application. By following the examples in this tutorial, you can create your own CLI tools and streamline your development workflow.  ","version":"2.3.0","tagName":"h3"},{"title":"Ticketing System","type":0,"sectionRef":"#","url":"/docs/2.3.0/tutorials/nft","content":"","keywords":"","version":"2.3.0"},{"title":"Ticket Office Contract​","type":1,"pageTitle":"Ticketing System","url":"/docs/2.3.0/tutorials/nft#ticket-office-contract","content":"Our TicketOffice contract will include the following features: Compliance with the CEP-78 standard.Ownership functionality.Only the owner can issue new event tickets.Users can purchase tickets for events.Tickets are limited to a one-time sale.Public access to view the total income of the TicketOffice. ","version":"2.3.0","tagName":"h2"},{"title":"Setup the project​","type":1,"pageTitle":"Ticketing System","url":"/docs/2.3.0/tutorials/nft#setup-the-project","content":"Creating a new NFT token with Odra is straightforward. Use the cargo odra new command to create a new project with the CEP-95 template: cargo odra new --name ticket-office --template cep95  ","version":"2.3.0","tagName":"h2"},{"title":"Contract implementation​","type":1,"pageTitle":"Ticketing System","url":"/docs/2.3.0/tutorials/nft#contract-implementation","content":"Let's start implementing the TicketOffice contract by modify the code generated from the template. src/token.rs use odra::{casper_types::{U256, U512}, prelude::*}; use odra_modules::access::Ownable; use odra_modules::cep95::{CEP95Interface, Cep95}; pub type TicketId = U256; #[odra::odra_type] pub enum TicketStatus { Available, Sold, } #[odra::odra_type] pub struct TicketInfo { event_name: String, price: U512, status: TicketStatus, } #[odra::event] pub struct OnTicketIssue { ticket_id: TicketId, event_name: String, price: U512, } #[odra::event] pub struct OnTicketSell { ticket_id: TicketId, buyer: Address, } #[odra::odra_error] pub enum Error { TicketNotAvailableForSale = 200, InsufficientFunds = 201, InvalidTicketId = 202, TicketDoesNotExist = 203, } #[odra::module( events = [OnTicketIssue, OnTicketSell], errors = Error )] pub struct TicketOffice { token: SubModule&lt;Cep95&gt;, ownable: SubModule&lt;Ownable&gt;, tickets: Mapping&lt;TicketId, TicketInfo&gt;, token_id_counter: Var&lt;TicketId&gt;, total_supply: Var&lt;u64&gt;, } #[odra::module] impl TicketOffice { pub fn init(&amp;mut self, collection_name: String, collection_symbol: String, total_supply: u64) { let caller = self.env().caller(); self.ownable.init(caller); self.token.init(collection_name, collection_symbol); } pub fn issue_ticket(&amp;mut self, event_name: String, price: U512) { let env = self.env(); let caller = env.caller(); self.ownable.assert_owner(&amp;caller); // mint a new token let ticket_id = self.token_id_counter.get_or_default(); self.token.mint(caller, ticket_id, Default::default()); // store ticket info self.tickets.set( &amp;ticket_id, TicketInfo { event_name: event_name.clone(), price, status: TicketStatus::Available, }, ); self.token_id_counter.set(ticket_id + 1); // emit an event env.emit_event(OnTicketIssue { ticket_id, event_name, price, }); } #[odra(payable)] pub fn buy_ticket(&amp;mut self, ticket_id: TicketId) { let env = self.env(); let owner = self.ownable.get_owner(); let buyer = env.caller(); let value = env.attached_value(); // only tokens owned by the owner can be sold if self.token.owner_of(ticket_id) != Some(owner) { env.revert(Error::TicketNotAvailableForSale); } let mut ticket = self .tickets .get(&amp;ticket_id) .unwrap_or_revert_with(&amp;env, Error::TicketDoesNotExist); // only available tickets can be sold if ticket.status != TicketStatus::Available { env.revert(Error::TicketNotAvailableForSale); } // check if the buyer sends enough funds if value &lt; ticket.price { env.revert(Error::InsufficientFunds); } // transfer csprs to the owner env.transfer_tokens(&amp;owner, &amp;value); // transfer the ticket to the buyer self.token.transfer_from(owner, buyer, ticket_id); ticket.status = TicketStatus::Sold; self.tickets.set(&amp;ticket_id, ticket); env.emit_event(OnTicketSell { ticket_id, buyer }); } pub fn balance_of(&amp;self) -&gt; U512 { self.env().self_balance() } }  L7-L39 - We define structures and enums that will be used in our contract. TicketStatus enum represents the status of a ticket, TicketInfo struct contains information about a ticket that is written to the storage, TicketId is a type alias for u64. OnTicketIssue and OnTicketSell are events that will be emitted when a ticket is issued or sold.L41-L44 - Register errors and events that will be used in our contract, required to produce a complete contract schema.L45-L51 - TicketOffice module definition. The module contains a Cep95 token, an Ownable module, a Mapping that stores information about tickets and Vars token_id_counter and total_supply to keep track of the total number of tickets issued.L55-L59 - The init function has been generated from the template and there is no need to modify it, except the Ownable module initialization.L61-L84 - The issue_ticket function allows the owner to issue a new ticket. The function mints a new token, stores information about the ticket, and emits an OnTicketIssue event.L86 - The payable attribute indicates that the buy_ticket function can receive funds.L87-L116 - The buy_ticket function checks if the ticket is available for sale, if the buyer sends enough funds, and transfers the ticket to the buyer. Finally, the function updates the ticket status and emits an OnTicketSell event. Lets test the contract. The test scenario will be as follows: Deploy the contract.Issue two tickets.Try to buy a ticket with insufficient funds.Buy tickets.Try to buy the same ticket again.Check the balance of the contract. src/tests.rs use odra::{ casper_types::U512, host::{Deployer, HostRef}, }; use crate::token::{Error, TicketOfficeHostRef, TicketOfficeInitArgs}; #[test] fn it_works() { let env = odra_test::env(); let init_args = TicketOfficeInitArgs { collection_name: &quot;Ticket&quot;.to_string(), collection_symbol: &quot;T&quot;.to_string(), total_supply: 100, }; let mut contract = TicketOffice::deploy(&amp;env, init_args); contract.issue_ticket(&quot;Ev&quot;.to_string(), U512::from(100)); contract.issue_ticket(&quot;Ev&quot;.to_string(), U512::from(50)); let buyer = env.get_account(1); env.set_caller(buyer); assert_eq!( contract .with_tokens(U512::from(50)) .try_buy_ticket(0.into()), Err(Error::InsufficientFunds.into()) ); assert_eq!( contract .with_tokens(U512::from(100)) .try_buy_ticket(0.into()), Ok(()) ); assert_eq!( contract .with_tokens(U512::from(50)) .try_buy_ticket(1.into()), Ok(()) ); assert_eq!( contract .with_tokens(U512::from(100)) .try_buy_ticket(0.into()), Err(Error::TicketNotAvailableForSale.into()) ); }  Unfortunately, the test failed. The first assertion succeeds because the buyer sends insufficient funds to buy the ticket. However, the second assertion fails even though the buyer sends enough funds to purchase the ticket. The buy_ticket function reverts with CEP-95 Error::NotAnOwnerOrApproved because the buyer attempts to transfer a token that they do not own, are not approved for, or are not an operator of. odra/modules/src/cep95.rs fn transfer_from(&amp;mut self, from: Address, to: Address, token_id: U256) { self.assert_exists(&amp;token_id); let caller = self.env().caller(); let owner = self .owner_of(token_id) .unwrap_or_revert_with(self, Error::ValueNotSet); // Only the owner or an approved spender can transfer the token. if (owner != from || owner != caller) &amp;&amp; !self.is_approved_for_all(from, caller) { if let Some(approved) = self.approved_for(token_id) { if approved != caller { self.env().revert(Error::NotAnOwnerOrApproved); } } else { self.env().revert(Error::NotAnOwnerOrApproved); } } ... }  Let's fix it by redesigning our little system. ","version":"2.3.0","tagName":"h2"},{"title":"Redesign​","type":1,"pageTitle":"Ticketing System","url":"/docs/2.3.0/tutorials/nft#redesign","content":"Since a buyer cannot purchase a ticket directly, we need to introduce an intermediary — an operator who will be responsible for buying tickets on behalf of the buyer. The operator will be approved by the ticket office to transfer tickets. The sequence diagram below illustrates the new flow: ","version":"2.3.0","tagName":"h2"},{"title":"Ticket Operator Contract​","type":1,"pageTitle":"Ticketing System","url":"/docs/2.3.0/tutorials/nft#ticket-operator-contract","content":"As shown in the sequence diagram, a new contract will act as an operator for the ticket office. To create this new contract, use the cargo odra generate command. cargo odra generate -c ticket_operator  src/ticket_operator.rs use crate::token::{TicketId, TicketOfficeContractRef}; use odra::{casper_types::{U256, U512}, ContractRef, prelude::*}; #[odra::odra_error] pub enum Error { UnknownTicketOffice = 300, } #[odra::module(errors = Error)] pub struct TicketOperator { ticket_office_address: Var&lt;Address&gt;, } #[odra::module] impl TicketOperator { pub fn register(&amp;mut self, ticket_office_address: Address) { self.ticket_office_address.set(ticket_office_address); } // now the operator's `buy_ticket` receives funds. #[odra(payable)] pub fn buy_ticket(&amp;mut self, ticket_id: TicketId) { let env = self.env(); let buyer = env.caller(); let value = env.attached_value(); let center = self .ticket_office_address .get() .unwrap_or_revert_with(&amp;env, Error::UnknownTicketOffice); let mut ticket_contract = TicketOfficeContractRef::new(env, center); // now and approved entity - the operator - buys the ticket on behalf of the buyer ticket_contract.buy_ticket(ticket_id, buyer, value); } pub fn balance_of(&amp;self) -&gt; U512 { self.env().self_balance() } }  L4-L7 - Define errors that will be used in the contract.L9-L13 - Define the TicketOperator module that stores the address of the ticketing office.L16-L18 - The register function sets the address of the ticketing office.L20-L32 - The buy_ticket function buys a ticket on behalf of the buyer using the ticket office address. The function forwards the call to the ticketing office contract. We simply create a TicketOfficeContractRef to interact we the TicketOffice contract. Note that, the operator's buy_ticket now receives funds. Now we need to adjust the TicketOffice contract to use the TicketOperator contract to buy tickets. src/token.rs #[odra::odra_error] pub enum Error { ... MissingOperator = 204, Unauthorized = 205, } #[odra::module] pub struct TicketOffice { ... operator: Var&lt;Address&gt;, } #[odra::module] impl TicketOffice { ... pub fn register_operator(&amp;mut self, operator: Address) { // only the owner can register an operator let caller = self.env().caller(); self.ownable.assert_owner(&amp;caller); // store the ticketing center address in the operator contract TicketOperatorContractRef::new(self.env(), operator).register(self.env().self_address()); self.operator.set(operator); } pub fn issue_ticket(&amp;mut self, event_name: String, price: U512) { // minting logic remains the same... ... // approve the operator to transfer the ticket let operator = self.operator(); self.token.approve(operator, ticket_id); // emit an event ... } pub fn buy_ticket(&amp;mut self, ticket_id: TicketId, buyer: Address, value: U512) { let env = self.env(); let owner = self.ownable.get_owner(); let caller = env.caller(); // make sure the caller is the operator if !self.is_operator(caller) { env.revert(Error::Unauthorized); } ... // the logic remains the same, except for the csprs transfer // it is now handled by the operator contract. // env.transfer_tokens(&amp;owner, &amp;value); } #[inline] fn is_operator(&amp;self, caller: Address) -&gt; bool { Some(caller) == self.operator.get() } #[inline] fn operator(&amp;self) -&gt; Address { self.operator .get() .unwrap_or_revert_with(&amp;self.env(), Error::MissingOperator) } }  L11 - the contract stores the operator address.L18-L25 - a new function register_operator allows the owner to register an operator. Also calls the register entry point on the operator contract.L32-36 - modify the issue_ticket function: once a new token is minted, approves the operator to transfer the ticket later.L40-L53 - modify the buy_ticket function: check if the caller is the operator, do not transfer cspr to the contract - now the operator collect funds.We also added two helper functions: is_operator and operator to check if the caller is the operator and get the operator address. Two new errors were added: MissingOperator and Unauthorized. Now we need to update our tests to create a scenario we presented in the sequence diagram. src/tests.rs use odra::{ casper_types::U512, host::{Deployer, HostRef, NoArgs}, prelude::* }; use crate::{ ticket_operator::TicketOperatorHostRef, token::{Error, TicketId, TicketOfficeContractRef, TicketOfficeInitArgs}, }; #[test] fn it_works() { let env = odra_test::env(); let init_args = TicketOfficeInitArgs { collection_name: &quot;Ticket&quot;.to_string(), collection_symbol: &quot;T&quot;.to_string(), total_supply: 100, }; let operator = TicketOperator::deploy(&amp;env, NoArgs); let mut ticket_office = TicketOfficeContractRef::deploy(&amp;env, init_args); ticket_office.register_operator(operator.address().clone()); ticket_office.issue_ticket(&quot;Ev&quot;.to_string(), U512::from(100)); ticket_office.issue_ticket(&quot;Ev&quot;.to_string(), U512::from(50)); let buyer = env.get_account(1); env.set_caller(buyer); assert_eq!( buy_ticket(&amp;operator, 0.into(), 50), Err(Error::InsufficientFunds.into()) ); assert_eq!(buy_ticket(&amp;operator, 0.into(), 100), Ok(())); assert_eq!(buy_ticket(&amp;operator, 1.into(), 50), Ok(())); assert_eq!( buy_ticket(&amp;operator, 0.into(), 100), Err(Error::TicketNotAvailableForSale.into()) ); assert_eq!(operator.balance_of(), U512::from(150)); } fn buy_ticket(operator: &amp;TicketOperatorHostRef, id: TicketId, price: u64) -&gt; OdraResult&lt;()&gt; { operator.with_tokens(U512::from(price)).try_buy_ticket(id) }  ","version":"2.3.0","tagName":"h3"},{"title":"Conclusion​","type":1,"pageTitle":"Ticketing System","url":"/docs/2.3.0/tutorials/nft#conclusion","content":"In this tutorial, we created a simple ticketing system using the CEP-95 standard. This guide demonstrates how to combine various Odra features, including modules, events, errors, payable functions, and cross-contract calls. ","version":"2.3.0","tagName":"h2"},{"title":"Ownable","type":0,"sectionRef":"#","url":"/docs/2.3.0/tutorials/ownable","content":"","keywords":"","version":"2.3.0"},{"title":"Framework features​","type":1,"pageTitle":"Ownable","url":"/docs/2.3.0/tutorials/ownable#framework-features","content":"A module we will write in a minute, will help you master a few Odra features: storing a single value,defining a constructor,error handling,defining and emitting events.registering a contact in a test environment,interactions with the test environment,assertions (value, events, errors assertions). ","version":"2.3.0","tagName":"h2"},{"title":"Code​","type":1,"pageTitle":"Ownable","url":"/docs/2.3.0/tutorials/ownable#code","content":"Before we write any code, we define functionalities we would like to implement. Module has an initializer that should be called once. Only the current owner can set a new owner.Read the current owner.A function that fails if called by a non-owner account. ","version":"2.3.0","tagName":"h2"},{"title":"Define a module​","type":1,"pageTitle":"Ownable","url":"/docs/2.3.0/tutorials/ownable#define-a-module","content":"ownable.rs use odra::prelude::*; #[odra::module(events = [OwnershipChanged])] pub struct Ownable { owner: Var&lt;Option&lt;Address&gt;&gt; }  That was easy, but it is crucial to understand the basics before we move on. L3 - Firstly, we need to create a struct called Ownable and apply #[odra::module(events = [OwnershipChanged])] attribute to it. The events attribute is optional but informs the Odra toolchain about the events that will be emitted by the module and includes them in the contract's metadata. OwnershipChanged is a type that will be defined later.L5 - Then we can define the layout of our module. It is extremely simple - just a single state value. What is most important is that you can never leave a raw type; you must always wrap it with Var. ","version":"2.3.0","tagName":"h3"},{"title":"Init the module​","type":1,"pageTitle":"Ownable","url":"/docs/2.3.0/tutorials/ownable#init-the-module","content":"ownable.rs #[odra::module] impl Ownable { pub fn init(&amp;mut self, owner: Address) { if self.owner.get_or_default().is_some() { self.env().revert(Error::OwnerIsAlreadyInitialized) } self.owner.set(Some(owner)); self.env().emit_event(OwnershipChanged { prev_owner: None, new_owner: owner }); } } #[odra::odra_error] pub enum Error { OwnerIsAlreadyInitialized = 1, } #[odra::event] pub struct OwnershipChanged { pub prev_owner: Option&lt;Address&gt;, pub new_owner: Address }  Ok, we have done a couple of things, let's analyze them one by one: L1 - The impl should be an Odra module, so add #[odra::module].L3 - The init function is a constructor. This matters if we would like to deploy the Ownable module as a standalone contract.L17-L20 - Before we set a new owner, we must assert there was no owner before and raise an error otherwise. For that purpose, we defined an Error enum. Notice that the #[odra::odra_error] attribute is applied to the enum. It generates, among others, the required Into&lt;odra::OdraError&gt; binding.L4-L6 - If the owner has been set already, we call ContractEnv::revert() function with an Error::OwnerIsAlreadyInitialized argument. L8 - Then we write the owner passed as an argument to the storage. To do so, we call the set() on Var.L22-L26 - Once the owner is set, we would like to inform the outside world. The first step is to define an event struct. The struct annotated with #[odra::event] attribute.L10 - Finally, call ContractEnv::emit_event() passing the OwnershipChanged instance to the function. Hence, we set the first owner, we set the prev_owner value to None.  ","version":"2.3.0","tagName":"h3"},{"title":"Features implementation​","type":1,"pageTitle":"Ownable","url":"/docs/2.3.0/tutorials/ownable#features-implementation","content":"ownable.rs #[odra::module] impl Ownable { ... pub fn ensure_ownership(&amp;self, address: &amp;Address) { if Some(address) != self.owner.get_or_default().as_ref() { self.env().revert(Error::NotOwner) } } pub fn change_ownership(&amp;mut self, new_owner: &amp;Address) { self.ensure_ownership(&amp;self.env().caller()); let current_owner = self.get_owner(); self.owner.set(Some(*new_owner)); self.env().emit_event(OwnershipChanged { prev_owner: Some(current_owner), new_owner: *new_owner }); } pub fn get_owner(&amp;self) -&gt; Address { match self.owner.get_or_default() { Some(owner) =&gt; owner, None =&gt; self.env().revert(Error::OwnerIsNotInitialized) } } } #[odra::odra_error] pub enum Error { NotOwner = 1, OwnerIsAlreadyInitialized = 2, OwnerIsNotInitialized = 3, }  The above implementation relies on the concepts we have already used in this tutorial, so it should be easy for you to get along. L7,L31 - ensure_ownership() reads the current owner and reverts if it does not match the input Address. Also, we need to update our Error enum by adding a new variant NotOwner.L11 - The function defined above can be reused in the change_ownership() implementation. We pass to it the current caller, using the ContractEnv::caller() function. Then we update the state and emit OwnershipChanged.L21,L33 - Lastly, a getter function. Read the owner from storage, if the getter is called on an uninitialized module, it should revert with a new Error variant OwnerIsNotInitialized. There is one worth-mentioning subtlety: Var::get() function returns Option&lt;T&gt;. If the type implements the Default trait, you can call the get_or_default() function, and the contract does not fail even if the value is not initialized. As the owner is of type Option&lt;Address&gt; the Var::get() would return Option&lt;Option&lt;Address&gt;&gt;, we use Var::get_or_default() instead. ","version":"2.3.0","tagName":"h3"},{"title":"Test​","type":1,"pageTitle":"Ownable","url":"/docs/2.3.0/tutorials/ownable#test","content":"ownable.rs #[cfg(test)] mod tests { use super::*; use odra::host::{Deployer, HostEnv}; fn setup() -&gt; (OwnableHostRef, HostEnv, Address) { let env: HostEnv = odra_test::env(); let init_args = OwnableInitArgs { owner: env.get_account(0) }; (Ownable::deploy(&amp;env, init_args), env.clone(), env.get_account(0)) } #[test] fn initialization_works() { let (ownable, env, owner) = setup(); assert_eq!(ownable.get_owner(), owner); env.emitted_event( &amp;ownable, OwnershipChanged { prev_owner: None, new_owner: owner } ); } #[test] fn owner_can_change_ownership() { let (mut ownable, env, owner) = setup(); let new_owner = env.get_account(1); env.set_caller(owner); ownable.change_ownership(&amp;new_owner); assert_eq!(ownable.get_owner(), new_owner); env.emitted_event( &amp;ownable, OwnershipChanged { prev_owner: Some(owner), new_owner } ); } #[test] fn non_owner_cannot_change_ownership() { let (mut ownable, env, _) = setup(); let new_owner = env.get_account(1); ownable.change_ownership(&amp;new_owner); assert_eq!( ownable.try_change_ownership(&amp;new_owner), Err(Error::NotOwner.into()) ); } }  L6 - Each test case starts with the same initialization process, so for convenience, we have defined the setup() function, which we call in the first statement of each test. Take a look at the signature: fn setup() -&gt; (OwnableHostRef, HostEnv, Address). OwnableHostRef is a contract reference generated by Odra. This reference allows us to call all the defined entrypoints, namely: ensure_ownership(), change_ownership(), get_owner(), but not init(), which is a constructor.L7-L11 - The starting point of every test is getting an instance of HostEnv by calling odra_test::env(). Our function returns a triple: a contract ref, an env, and an address (the initial owner). Odra's #[odra::module] attribute implements a odra::host::Deployer for Ownable, and OwnableInitArgs that we pass as the second argument of the odra::host::Deployer::deploy() function. Lastly, the module needs an owner. The easiest way is to take one from the HostEnv. We choose the address of first account (which is the default one). L14 - It is time to define the first test. As you see, it is a regular Rust test.L16-17 - Using the setup() function, we get the owner and a reference (in this test, we don't use the env, so we ignore it). We make a standard assertion, comparing the owner we know with the value returned from the contract. note You may have noticed, we use here the term module interchangeably with contract. The reason is once we deploy our module onto a virtual blockchain it may be considered a contract. L19-25 - On the contract, only the init() function has been called, so we expect one event to have been emitted. To assert that, let's use HostEnv. To get the env, we call env() on the contract, then call HostEnv::emitted_event. As the first argument, pass the contract you want to read events from, followed by an event as you expect it to have occurred.L31 - Because we know the initial owner is the 0th account, we must select a different account. It could be any index from 1 to 19 - the HostEnv predefines 20 accounts.L33 - As mentioned, the default is the 0th account, if you want to change the executor, call the HostEnv::set_caller() function. note The caller switch applies only the next contract interaction, the second call will be done as the default account. L46-55 - If a non-owner account tries to change ownership, we expect it to fail. To capture the error, call HostEnv::try_change_ownership() instead of HostEnv::change_ownership(). HostEnv provides try_ functions for each contract's entrypoint. The try functions return OdraResult (an alias for Result&lt;T, OdraError&gt;) instead of panicking and halting the execution. In our case, we expect the contract to revert with the Error::NotOwner error. To compare the error, we use the Error::into() function, which converts the error into the OdraError type. ","version":"2.3.0","tagName":"h3"},{"title":"Summary​","type":1,"pageTitle":"Ownable","url":"/docs/2.3.0/tutorials/ownable#summary","content":"The Ownable module is ready, and we can test it against any defined backend. Theoretically it can be deployed as a standalone contract, but in upcoming tutorials you will see how to use it to compose a more complex contract. ","version":"2.3.0","tagName":"h2"},{"title":"What's next​","type":1,"pageTitle":"Ownable","url":"/docs/2.3.0/tutorials/ownable#whats-next","content":"In the next tutorial we will implement a ERC20 standard. ","version":"2.3.0","tagName":"h2"},{"title":"OwnedToken","type":0,"sectionRef":"#","url":"/docs/2.3.0/tutorials/owned-token","content":"","keywords":"","version":"2.3.0"},{"title":"Code​","type":1,"pageTitle":"OwnedToken","url":"/docs/2.3.0/tutorials/owned-token#code","content":"What should our module be capable of? Conform the Erc20 interface.Allow only the module owner to mint tokens.Enable the current owner to designate a new owner. ","version":"2.3.0","tagName":"h2"},{"title":"Module definition​","type":1,"pageTitle":"OwnedToken","url":"/docs/2.3.0/tutorials/owned-token#module-definition","content":"Let's define a module called OwnedToken that is a composition of Ownable and Erc20 modules. owned_token.rs use crate::{erc20::Erc20, ownable::Ownable}; use odra::prelude::*; #[odra::module] pub struct OwnedToken { ownable: SubModule&lt;Ownable&gt;, erc20: SubModule&lt;Erc20&gt; }  As you can see, we do not need any storage definition - we just take advantage of the already-defined modules! ","version":"2.3.0","tagName":"h3"},{"title":"Delegation​","type":1,"pageTitle":"OwnedToken","url":"/docs/2.3.0/tutorials/owned-token#delegation","content":"owned_token.rs ... use odra::casper_types::U256; ... #[odra::module] impl OwnedToken { pub fn init(&amp;mut self, name: String, symbol: String, decimals: u8, initial_supply: U256) { let deployer = self.env().caller(); self.ownable.init(deployer); self.erc20.init(name, symbol, decimals, initial_supply); } pub fn name(&amp;self) -&gt; String { self.erc20.name() } pub fn symbol(&amp;self) -&gt; String { self.erc20.symbol() } pub fn decimals(&amp;self) -&gt; u8 { self.erc20.decimals() } pub fn total_supply(&amp;self) -&gt; U256 { self.erc20.total_supply() } pub fn balance_of(&amp;self, address: &amp;Address) -&gt; U256 { self.erc20.balance_of(address) } pub fn allowance(&amp;self, owner: &amp;Address, spender: &amp;Address) -&gt; U256 { self.erc20.allowance(owner, spender) } pub fn transfer(&amp;mut self, recipient: &amp;Address, amount: &amp;U256) { self.erc20.transfer(recipient, amount); } pub fn transfer_from(&amp;mut self, owner: &amp;Address, recipient: &amp;Address, amount: &amp;U256) { self.erc20.transfer_from(owner, recipient, amount); } pub fn approve(&amp;mut self, spender: &amp;Address, amount: &amp;U256) { self.erc20.approve(spender, amount); } pub fn get_owner(&amp;self) -&gt; Address { self.ownable.get_owner() } pub fn change_ownership(&amp;mut self, new_owner: &amp;Address) { self.ownable.change_ownership(new_owner); } pub fn mint(&amp;mut self, address: &amp;Address, amount: &amp;U256) { self.ownable.ensure_ownership(&amp;self.env().caller()); self.erc20.mint(address, amount); } }  Easy. However, there are a few worth mentioning subtleness: L9-L10 - A constructor is an excellent place to initialize both modules at once.L13-L15 - Most of the entrypoints do not need any modification, so we simply delegate them to the erc20 module.L49-L51 - The same is done with the ownable module.L57-L60 - Minting should not be unconditional, we need some control over it. First, using ownable we make sure the caller really is indeed the owner. ","version":"2.3.0","tagName":"h3"},{"title":"Summary​","type":1,"pageTitle":"OwnedToken","url":"/docs/2.3.0/tutorials/owned-token#summary","content":"The Odra Framework encourages a modularized design of your smart contracts. You can encapsulate features in smaller units and test them in isolation, ensuring your project is easy to maintain. Finally, unleash their full potential by combining modules. You do not need any magic bindings for that. ","version":"2.3.0","tagName":"h2"},{"title":"Pausable","type":0,"sectionRef":"#","url":"/docs/2.3.0/tutorials/pauseable","content":"","keywords":"","version":"2.3.0"},{"title":"Code​","type":1,"pageTitle":"Pausable","url":"/docs/2.3.0/tutorials/pauseable#code","content":"As always, we will start with defining functionalities of our module. Check the state - is it paused or not.State guards - a contract should stop execution if is in a state we don't expect.Switch the state. ","version":"2.3.0","tagName":"h2"},{"title":"Events and Error​","type":1,"pageTitle":"Pausable","url":"/docs/2.3.0/tutorials/pauseable#events-and-error","content":"There just two errors that may occur: PausedRequired, UnpausedRequired. We define them in a standard Odra way. Events definition is highly uncomplicated: Paused and Unpaused events holds only the address of the pauser. pauseable.rs use odra::prelude::*; #[odra::odra_error] pub enum Error { PausedRequired = 1_000, UnpausedRequired = 1_001, } #[odra::event] pub struct Paused { pub account: Address } #[odra::event] pub struct Unpaused { pub account: Address }  ","version":"2.3.0","tagName":"h3"},{"title":"Module definition​","type":1,"pageTitle":"Pausable","url":"/docs/2.3.0/tutorials/pauseable#module-definition","content":"The module storage is extremely simple - has a single Var of type bool, that indicates if a contract is paused. pauseable.rs #[odra::module(events = [Paused, Unpaused], errors = Error)] pub struct Pausable { is_paused: Var&lt;bool&gt; }  ","version":"2.3.0","tagName":"h3"},{"title":"Checks and guards​","type":1,"pageTitle":"Pausable","url":"/docs/2.3.0/tutorials/pauseable#checks-and-guards","content":"Now, let's move to state checks and guards. pauseable.rs impl Pausable { pub fn is_paused(&amp;self) -&gt; bool { self.is_paused.get_or_default() } pub fn require_not_paused(&amp;self) { if self.is_paused() { self.env().revert(Error::UnpausedRequired); } } pub fn require_paused(&amp;self) { if !self.is_paused() { self.env().revert(Error::PausedRequired); } } }  L1 - as mentioned in the intro, the module is not intended to be a standalone contract, so the only impl block is not annotated with odra::module and hence does not expose any entrypoint.L2 - is_paused() checks the contract state, if the Var is_paused has not been initialized, the default value (false) is returned.L6 - to guarantee the code is executed when the contract is not paused, require_not_paused() function reads the state and reverts if the contract is paused. L12 - require_paused() is a mirror function - stops the contract execution if the contract is not paused. ","version":"2.3.0","tagName":"h3"},{"title":"Actions​","type":1,"pageTitle":"Pausable","url":"/docs/2.3.0/tutorials/pauseable#actions","content":"Finally, we will add the ability to switch the module state. pauseable.rs impl Pausable { pub fn pause(&amp;mut self) { self.require_not_paused(); self.is_paused.set(true); self.env().emit_event(Paused { account: self.env().caller() }); } pub fn unpause(&amp;mut self) { self.require_paused(); self.is_paused.set(false); self.env().emit_event(Unpaused { account: self.env().caller() }); } }  pause() and unpause() functions do three things: ensure the contract is the right state (unpaused for pause(), not paused for unpause()), updates the state, and finally emits events (Paused/Unpaused). ","version":"2.3.0","tagName":"h3"},{"title":"Pausable counter​","type":1,"pageTitle":"Pausable","url":"/docs/2.3.0/tutorials/pauseable#pausable-counter","content":"In the end, let's use the module in a contract. For this purpose, we will implement a mock contract called PausableCounter. The contract consists of a Var value and a Pausable module. The counter can only be incremented if the contract is in a normal state (is not paused). pauseable.rs ... #[odra::module] pub struct PausableCounter { value: Var&lt;u32&gt;, pauseable: SubModule&lt;Pausable&gt; } #[odra::module] impl PausableCounter { pub fn increment(&amp;mut self) { self.pauseable.require_not_paused(); let new_value = self.value.get_or_default() + 1; self.value.set(new_value); } pub fn pause(&amp;mut self) { self.pauseable.pause(); } pub fn unpause(&amp;mut self) { self.pauseable.unpause(); } pub fn get_value(&amp;self) -&gt; u32 { self.value.get_or_default() } } #[cfg(test)] mod test { use super::*; use odra::host::{Deployer, NoArgs}; #[test] fn increment_only_if_unpaused() { let test_env = odra_test::env(); let mut contract = PausableCounter::deploy(&amp;test_env, NoArgs); contract.increment(); contract.pause(); assert_eq!( contract.try_increment().unwrap_err(), Error::UnpausedRequired.into() ); assert_eq!(contract.get_value(), 1); } }  As we see in the test, in a simple way, using a single function call we can turn off the counter for a while and freeze the counter. Any time we want we can turn it back on. Easy! ","version":"2.3.0","tagName":"h2"},{"title":"Upgrading Contracts","type":0,"sectionRef":"#","url":"/docs/2.3.0/tutorials/upgrades","content":"","keywords":"","version":"2.3.0"},{"title":"Livenet Example​","type":1,"pageTitle":"Upgrading Contracts","url":"/docs/2.3.0/tutorials/upgrades#livenet-example","content":"In this example, we will deploy a simple counter contract and then upgrade it to a new version with additional features. We will skip the details of the contract implementation and focus on the deployment and upgrade process. Our example deploys a simple counter contract making it upgradable and then upgrades it twice: first to CounterV2, and then back to CounterV1. examples/bin/upgrades_on_livenet.rs //! This example demonstrates how to deploy and upgrade a contract on the Livenet environment. use odra::casper_types::U256; use odra::host::{Deployer, HostRef, InstallConfig, NoArgs}; use odra_examples::features::upgrade::{CounterV1, CounterV2, CounterV2UpgradeArgs}; fn main() { let env = odra_casper_livenet_env::env(); env.set_gas(500_000_000_000u64); // Contracts can be upgraded let mut counter = CounterV1::deploy_with_cfg(&amp;env, NoArgs, InstallConfig::upgradable::&lt;CounterV1&gt;()); env.set_gas(50_000_000_000u64); counter.increment(); assert_eq!(counter.get(), 1); env.set_gas(500_000_000_000u64); let mut counter2 = CounterV2::try_upgrade( &amp;env, counter.contract_address(), CounterV2UpgradeArgs { new_start: None } ) .unwrap(); env.set_gas(50_000_000_000u64); counter2.increment(); assert_eq!(counter2.get(), U256::from(2)); env.set_gas(500_000_000_000u64); let mut counter3 = CounterV1::try_upgrade(&amp;env, counter.contract_address(), NoArgs).unwrap(); env.set_gas(50_000_000_000u64); counter3.increment(); assert_eq!(counter3.get(), 2); }  The Deployer trait has two functions that allow upgrading contracts: try_upgrade: upgrades a contract to a new version. It takes the environment, the address of the contract to be upgraded, and the arguments for the new version of the contract. The function try_upgrade_with_cfg: same as try_upgrade, but allows specifying a custom upgrade configuration. Let's take a quick look at the CounterV2 implementation: #[odra::module] impl CounterV2 { pub fn init(&amp;mut self, start_from: Option&lt;U256&gt;) { if let Some(start) = start_from { self.new_counter.set(start); } else { self.new_counter.set(U256::from(0)); } } pub fn upgrade(&amp;mut self, new_start: Option&lt;U256&gt;) { if let Some(start) = new_start { self.new_counter.set(start); } else { // If no new value is provided, we keep the current value self.new_counter.set(self.counter.get_or_default().into()); } } ... }  The contract implements the upgrade function, which allows executing the upgrade logic for the contract. When upgrading to a new version, the upgrade function is called with the new initialization parameters. We call the try_upgrade function with CounterV2UpgradeArgs - a struct automatically generated by the Odra framework. It is a mirror feature of the contract's initialization parameters. ","version":"2.3.0","tagName":"h2"},{"title":"Run the example​","type":1,"pageTitle":"Upgrading Contracts","url":"/docs/2.3.0/tutorials/upgrades#run-the-example","content":"Now, let's see the code in action! cargo run --bin our_token_livenet --features livenet  A sample output of the program might look like this:  Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.11s Running `../target/debug/upgrade_on_livenet` 💁 INFO : Found wasm under &quot;/Users/kpob/workspace/odra/examples/wasm/CounterV1.wasm&quot;. 💁 INFO : Deploying &quot;CounterV1&quot;. 🙄 WAIT : Waiting 10 for V1(TransactionV1Hash(301469239d731d7b7ca9aef7a42dcb1473a1388d59e1bac619a008e7b555aa0d)). 💁 INFO : Transaction &quot;301469239d731d7b7ca9aef7a42dcb1473a1388d59e1bac619a008e7b555aa0d&quot; successfully executed. 🔗 LINK : https://testnet.cspr.live/transaction/301469239d731d7b7ca9aef7a42dcb1473a1388d59e1bac619a008e7b555aa0d 💁 INFO : Contract &quot;contract-package-b8b5003fe3ba05b4cae2e8acaeb777520e025958e12bd15394bf42e96f3f7b12&quot; deployed. 💁 INFO : Calling &quot;contract-package-b8b5003fe3ba05b4cae2e8acaeb777520e025958e12bd15394bf42e96f3f7b12&quot; directly with entrypoint &quot;increment&quot;. 🙄 WAIT : Waiting 10 for V1(TransactionV1Hash(a0fb180018063702094cdd66bdda1a3eda6f90c2e726334f202d77cddd88e649)). 🙄 WAIT : Waiting 10 for V1(TransactionV1Hash(a0fb180018063702094cdd66bdda1a3eda6f90c2e726334f202d77cddd88e649)). 💁 INFO : Transaction &quot;a0fb180018063702094cdd66bdda1a3eda6f90c2e726334f202d77cddd88e649&quot; successfully executed. 🔗 LINK : https://testnet.cspr.live/transaction/a0fb180018063702094cdd66bdda1a3eda6f90c2e726334f202d77cddd88e649 💁 INFO : Found wasm under &quot;/Users/kpob/workspace/odra/examples/wasm/CounterV2.wasm&quot;. 💁 INFO : Deploying &quot;CounterV2&quot;. 🙄 WAIT : Waiting 10 for V1(TransactionV1Hash(ec4518f51a2b3ed19886d6cd2d67e138aeb24834362d8fad8adb4af45fa36f21)). 💁 INFO : Transaction &quot;ec4518f51a2b3ed19886d6cd2d67e138aeb24834362d8fad8adb4af45fa36f21&quot; successfully executed. 🔗 LINK : https://testnet.cspr.live/transaction/ec4518f51a2b3ed19886d6cd2d67e138aeb24834362d8fad8adb4af45fa36f21 💁 INFO : Contract &quot;contract-package-b8b5003fe3ba05b4cae2e8acaeb777520e025958e12bd15394bf42e96f3f7b12&quot; deployed. 💁 INFO : Calling &quot;contract-package-b8b5003fe3ba05b4cae2e8acaeb777520e025958e12bd15394bf42e96f3f7b12&quot; directly with entrypoint &quot;increment&quot;. 🙄 WAIT : Waiting 10 for V1(TransactionV1Hash(cc694727bf166c55e2080578fcf6dc944e2d9b931b8301fe5208c8e29e8c599a)). 🙄 WAIT : Waiting 10 for V1(TransactionV1Hash(cc694727bf166c55e2080578fcf6dc944e2d9b931b8301fe5208c8e29e8c599a)). 💁 INFO : Transaction &quot;cc694727bf166c55e2080578fcf6dc944e2d9b931b8301fe5208c8e29e8c599a&quot; successfully executed. 🔗 LINK : https://testnet.cspr.live/transaction/cc694727bf166c55e2080578fcf6dc944e2d9b931b8301fe5208c8e29e8c599a 💁 INFO : Found wasm under &quot;/Users/kpob/workspace/odra/examples/wasm/CounterV1.wasm&quot;. 💁 INFO : Deploying &quot;CounterV1&quot;. 🙄 WAIT : Waiting 10 for V1(TransactionV1Hash(58453efdf683f2271f558a22e406631edccff2771867069c2cbefb3386fc8833)). 💁 INFO : Transaction &quot;58453efdf683f2271f558a22e406631edccff2771867069c2cbefb3386fc8833&quot; successfully executed. 🔗 LINK : https://testnet.cspr.live/transaction/58453efdf683f2271f558a22e406631edccff2771867069c2cbefb3386fc8833 💁 INFO : Contract &quot;contract-package-b8b5003fe3ba05b4cae2e8acaeb777520e025958e12bd15394bf42e96f3f7b12&quot; deployed. 💁 INFO : Calling &quot;contract-package-b8b5003fe3ba05b4cae2e8acaeb777520e025958e12bd15394bf42e96f3f7b12&quot; directly with entrypoint &quot;increment&quot;. 🙄 WAIT : Waiting 10 for V1(TransactionV1Hash(5cd3920e6b7cab505e074eb5684cc1b191841d2f24a889079d9fb1a92167fd4f)). 🙄 WAIT : Waiting 10 for V1(TransactionV1Hash(5cd3920e6b7cab505e074eb5684cc1b191841d2f24a889079d9fb1a92167fd4f)). 💁 INFO : Transaction &quot;5cd3920e6b7cab505e074eb5684cc1b191841d2f24a889079d9fb1a92167fd4f&quot; successfully executed. 🔗 LINK : https://testnet.cspr.live/transaction/5cd3920e6b7cab505e074eb5684cc1b191841d2f24a889079d9fb1a92167fd4f  ","version":"2.3.0","tagName":"h2"},{"title":"Cspr.live​","type":1,"pageTitle":"Upgrading Contracts","url":"/docs/2.3.0/tutorials/upgrades#csprlive","content":"Let's take a look at cspr.live: https://testnet.cspr.live/contract-package/b8b5003fe3ba05b4cae2e8acaeb777520e025958e12bd15394bf42e96f3f7b12 It works! Now our contracts has three versions deployed:  ","version":"2.3.0","tagName":"h2"},{"title":"Conclusion​","type":1,"pageTitle":"Upgrading Contracts","url":"/docs/2.3.0/tutorials/upgrades#conclusion","content":"In this tutorial, we learned how to upgrade a smart contract on the blockchain using the Odra framework. We deployed a simple counter contract, made it upgradable, and then upgraded it twice: first to CounterV2, and then back to CounterV1. We also explored the testnet to verify our contract deployments. ","version":"2.3.0","tagName":"h2"},{"title":"Odra framework","type":0,"sectionRef":"#","url":"/docs/next/","content":"","keywords":"","version":"next"},{"title":"What's next​","type":1,"pageTitle":"Odra framework","url":"/docs/next/#whats-next","content":"See the Installation and our Flipper example to find out how to start your new project with Odra. ","version":"next","tagName":"h2"},{"title":"Attributes","type":0,"sectionRef":"#","url":"/docs/next/advanced/attributes","content":"","keywords":"","version":"next"},{"title":"Payable​","type":1,"pageTitle":"Attributes","url":"/docs/next/advanced/attributes#payable","content":"When writing a smart contract, you need to make sure that money can be both sent to and extracted from the contract. The 'payable' attribute helps wit this. Any function, except for a constructor, with the #[odra(payable)] attribute can send and take money in the form of native tokens. ","version":"next","tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"Attributes","url":"/docs/next/advanced/attributes#example","content":"examples/src/contracts/tlw.rs #[odra(payable)] pub fn deposit(&amp;mut self) { // Extract values let caller: Address = self.env().caller(); let amount: U256 = self.env().attached_value(); let current_block_time: u64 = self.env().get_block_time(); // Multiple lock check if self.balances.get(&amp;caller).is_some() { self.env.revert(Error::CannotLockTwice) } // Update state, emit event self.balances.set(&amp;caller, amount); self.lock_expiration_map .set(&amp;caller, current_block_time + self.lock_duration()); self.env() .emit_event(Deposit { address: caller, amount }); }  If you try to send tokens to a non-payable function, the transaction will be automatically rejected. ","version":"next","tagName":"h3"},{"title":"Non Reentrant​","type":1,"pageTitle":"Attributes","url":"/docs/next/advanced/attributes#non-reentrant","content":"Reentrancy attacks in smart contracts exploit the possibility of a function being called multiple times before its initial execution is completed, leading to the repeated unauthorized withdrawal of funds. To prevent such attacks, developers should ensure that all effects on the contract's state and balance checks occur before calling external contracts. They can also use reentrancy guards to block recursive calls to sensitive functions. In Odra you can just apply the #[odra(non_reentrant)] attribute to your function. ","version":"next","tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"Attributes","url":"/docs/next/advanced/attributes#example-1","content":"#[odra::module] pub struct NonReentrantCounter { counter: Var&lt;u32&gt; } #[odra::module] impl NonReentrantCounter { #[odra(non_reentrant)] pub fn count_ref_recursive(&amp;mut self, n: u32) { if n &gt; 0 { self.count(); ReentrancyMockRef::new(self.env(), self.env().self_address()).count_ref_recursive(n - 1); } } } impl NonReentrantCounter { fn count(&amp;mut self) { let c = self.counter.get_or_default(); self.counter.set(c + 1); } } #[cfg(test)] mod test { use super::*; use odra::host::{Deployer, NoArgs}; #[test] fn ref_recursion_not_allowed() { let test_env = odra_test::env(); let mut contract = NonReentrantCounter::deploy(&amp;test_env, NoArgs); let result = contract.count_ref_recursive(11); assert_eq!(result, ExecutionError::ReentrantCall.into()); } }  ","version":"next","tagName":"h3"},{"title":"Mixing attributes​","type":1,"pageTitle":"Attributes","url":"/docs/next/advanced/attributes#mixing-attributes","content":"A function can accept more than one attribute. The only exclusion is a constructor cannot be payable. To apply multiple attributes, you can write: #[odra(payable, non_reentrant)] fn deposit() { // your logic... }  or #[odra(payable)] #[odra(non_reentrant)] fn deposit() { // your logic... }  In both cases attributes order does not matter. ","version":"next","tagName":"h2"},{"title":"Advanced Storage Concepts","type":0,"sectionRef":"#","url":"/docs/next/advanced/advanced-storage","content":"","keywords":"","version":"next"},{"title":"Recap and Basic Concepts​","type":1,"pageTitle":"Advanced Storage Concepts","url":"/docs/next/advanced/advanced-storage#recap-and-basic-concepts","content":"Before we delve into the advanced features, let's recap some basic storage concepts in Odra. In the realm of basic storage interaction, Odra provides several types for interacting with contract storage, including Var, Mapping, and List. These types enable contracts to store and retrieve data in a structured manner. The Var type is used to store a single value, while the List and Mapping types store collections of values. Var: A Var in Odra is a fundamental building block used for storing single values. Each Var is uniquely identified by its name in the contract. Mapping: Mapping in Odra serves as a key-value storage system. It stores an association of unique keys to values, and the value can be retrieved using the key. List: Built on top of the Var and Mapping building blocks, List in Odra allows storing an ordered collection of values that can be iterated over. If you need a refresher on these topics, please refer to our guide on basic storage in Odra. ","version":"next","tagName":"h2"},{"title":"Advanced Storage Concepts​","type":1,"pageTitle":"Advanced Storage Concepts","url":"/docs/next/advanced/advanced-storage#advanced-storage-concepts-1","content":"","version":"next","tagName":"h2"},{"title":"Sequence​","type":1,"pageTitle":"Advanced Storage Concepts","url":"/docs/next/advanced/advanced-storage#sequence","content":"The Sequence in Odra is a basic module that stores a single value in the storage that can be read or incremented. Internally, holds a Var which keeps track of the current value. pub struct Sequence&lt;T&gt; where T: Num + One + ToBytes + FromBytes + CLTyped { value: Var&lt;T&gt; }  The Sequence module provides functions get_current_value and next_value to get the current value and increment the value respectively. ","version":"next","tagName":"h3"},{"title":"Advanced Mapping​","type":1,"pageTitle":"Advanced Storage Concepts","url":"/docs/next/advanced/advanced-storage#advanced-mapping","content":"In Odra, a Mapping is a key-value storage system where the key is associated with a value. In previous examples, the value of the Mapping typically comprised a standard serializable type (such as number, string, or bool) or a custom type marked with the #[odra::odra_type] attribute. However, there are more advanced scenarios where the value of the Mapping represents a module itself. This approach is beneficial when managing a collection of modules, each maintaining its unique state. Let's consider the following example: examples/src/features/storage/mapping.rs use odra::casper_types::U256; use odra::prelude::*; use crate::owned_token::OwnedToken; #[odra::module] pub struct Mappings { strings: Mapping&lt;(String, u32, String), String&gt;, tokens: Mapping&lt;String, OwnedToken&gt; } #[odra::module] impl Mappings { ... pub fn total_supply(&amp;mut self, token_name: String) -&gt; U256 { self.tokens.module(&amp;token_name).total_supply() } pub fn get_string_api( &amp;self, key1: String, key2: u32, key3: String ) -&gt; String { let opt_string = self.strings.get(&amp;(key1, key2, key3)); opt_string.unwrap_or_revert(&amp;self.env()) } }  As you can see, a Mapping key can consist of a tuple of values, not limited to a single value. note Accessing Odra modules differs from accessing regular values such as strings or numbers. Firstly, within a Mapping, you don't encapsulate the module with Submodule. Secondly, rather than utilizing the Mapping::get() function, call Mapping::module(), which returns SubModule&lt;T&gt; and sets the appropriate namespace for nested modules. ","version":"next","tagName":"h3"},{"title":"AdvancedStorage Contract​","type":1,"pageTitle":"Advanced Storage Concepts","url":"/docs/next/advanced/advanced-storage#advancedstorage-contract","content":"The given code snippet showcases the AdvancedStorage contract that incorporates these storage concepts. use odra::casper_types::U512; use odra::prelude::*; use crate::modules::Token; #[odra::module] pub struct AdvancedStorage { counter: Sequence&lt;u32&gt;, tokens: Mapping&lt;(String, String), Token&gt;, } impl AdvancedStorage { pub fn current_value(&amp;self) -&gt; u32 { self.counter.get_current_value() } pub fn increment_and_get(&amp;mut self) -&gt; u32 { self.counter.next_value() } pub fn balance_of(&amp;mut self, token_name: String, creator: String, address: Address) -&gt; U512 { let token = self.tokens.module(&amp;(token_name, creator)); token.balance_of(&amp;address) } pub fn mint(&amp;self, token_name: String, creator: String, amount: U512, to: Address) { let mut token = self.tokens.module(&amp;(token_name, creator)); token.mint(amount, to); } }  ","version":"next","tagName":"h2"},{"title":"Conclusion​","type":1,"pageTitle":"Advanced Storage Concepts","url":"/docs/next/advanced/advanced-storage#conclusion","content":"Advanced storage features in Odra offer robust options for managing contract state. Two key takeaways from this document are: Odra offers a Sequence module, enabling contracts to store and increment a single value.Mappings support composite keys expressed as tuples and can store modules as values. Understanding these concepts can help developers design and implement more efficient and flexible smart contracts. ","version":"next","tagName":"h2"},{"title":"Using Proxy Caller","type":0,"sectionRef":"#","url":"/docs/2.3.0/tutorials/using-proxy-caller","content":"","keywords":"","version":"2.3.0"},{"title":"Contract​","type":1,"pageTitle":"Using Proxy Caller","url":"/docs/2.3.0/tutorials/using-proxy-caller#contract","content":"For this tutorial, we will use the TimeLockWallet contract from our examples. examples/src/contracts/tlw.rs use odra::prelude::*; use odra::casper_types::U512; #[odra::module(errors = Error, events = [Deposit, Withdrawal])] pub struct TimeLockWallet { balances: Mapping&lt;Address, U512&gt;, lock_expiration_map: Mapping&lt;Address, u64&gt;, lock_duration: Var&lt;u64&gt; } #[odra::module] impl TimeLockWallet { /// Initializes the contract with the lock duration. pub fn init(&amp;mut self, lock_duration: u64) { self.lock_duration.set(lock_duration); } /// Deposits the tokens into the contract. #[odra(payable)] pub fn deposit(&amp;mut self) { // Extract values let caller: Address = self.env().caller(); let amount: U512 = self.env().attached_value(); let current_block_time: u64 = self.env().get_block_time(); // Multiple lock check if self.balances.get(&amp;caller).is_some() { self.env().revert(Error::CannotLockTwice) } // Update state, emit event self.balances.set(&amp;caller, amount); self.lock_expiration_map .set(&amp;caller, current_block_time + self.lock_duration()); self.env().emit_event(Deposit { address: caller, amount }); } /// Withdraws the tokens from the contract. pub fn withdraw(&amp;mut self, amount: &amp;U512) { // code omitted for brevity } /// Returns the balance of the given account. pub fn get_balance(&amp;self, address: &amp;Address) -&gt; U512 { // code omitted for brevity } /// Returns the lock duration. pub fn lock_duration(&amp;self) -&gt; u64 { // code omitted for brevity } } /// Errors that may occur during the contract execution. #[odra::odra_error] pub enum Error { LockIsNotOver = 1, CannotLockTwice = 2, InsufficientBalance = 3 } /// Deposit event. #[odra::event] pub struct Deposit { pub address: Address, pub amount: U512 } /// Withdrawal event. #[odra::event] pub struct Withdrawal { pub address: Address, pub amount: U512 }  Full code can be found in our Github repo. ","version":"2.3.0","tagName":"h2"},{"title":"Client​","type":1,"pageTitle":"Using Proxy Caller","url":"/docs/2.3.0/tutorials/using-proxy-caller#client","content":"Before we can interact with the node, we need to set it up. We will use the casper-nctl-docker image. docker run --rm -it --name mynctl -d -p 11101:11101 -p 14101:14101 -p 18101:18101 makesoftware/casper-nctl  Make sure you have the contract's wasm file and the secret key. # Build the contract cargo odra build -c TimeLockWallet # Extract secret key docker exec mynctl /bin/bash -c &quot;cat /home/casper/casper-node/utils/nctl/assets/net-1/users/user-1/secret_key.pem&quot; &gt; your/path/secret_key.pem  RustTypeScript To interact with the contract, we use the livenet backend. It allows to write the code in the same manner as the test code, but it interacts with the live network (a local node in our case). Cargo.toml [package] name = &quot;odra-examples&quot; version = &quot;2.2.0&quot; edition = &quot;2021&quot; [dependencies] odra = { path = &quot;../odra&quot;, default-features = false } ... # other dependencies odra-casper-livenet-env = { version = &quot;2.2.0&quot;, optional = true } ... # other sections [features] default = [] livenet = [&quot;odra-casper-livenet-env&quot;] ... # other sections [[bin]] name = &quot;tlw_on_livenet&quot; path = &quot;bin/tlw_on_livenet.rs&quot; required-features = [&quot;livenet&quot;] test = false ... # other sections examples/bin/tlw_on_livenet.rs //! Deploys an [odra_examples::contracts::tlw::TimeLockWallet] contract, then deposits and withdraw some CSPRs. use odra::casper_types::{AsymmetricType, PublicKey, U512}; use odra::host::{Deployer, HostRef}; use odra::prelude::*; use odra_examples::contracts::tlw::{TimeLockWallet, TimeLockWalletInitArgs}; const DEPOSIT: u64 = 100; const WITHDRAWAL: u64 = 99; const GAS: u64 = 20u64.pow(9); fn main() { let env = odra_casper_livenet_env::env(); let caller = env.get_account(0); env.set_caller(caller); env.set_gas(GAS); let mut contract = TimeLockWallet::deploy( &amp;env, TimeLockWalletInitArgs { lock_duration: 60 * 60 } ); // Send 100 CSPRs to the contract. contract .with_tokens(U512::from(DEPOSIT)) .deposit(); println!(&quot;Caller's balance: {:?}&quot;, contract.get_balance(&amp;caller)); // Withdraw 99 CSPRs from the contract. contract.withdraw(&amp;U512::from(WITHDRAWAL)); println!(&quot;Remaining balance: {:?}&quot;, contract.get_balance(&amp;caller)); } To run the code, execute the following command: ODRA_CASPER_LIVENET_SECRET_KEY_PATH=path/to/secret_key.pem \\ ODRA_CASPER_LIVENET_NODE_ADDRESS=[NODE_ADDRESS] \\ ODRA_CASPER_LIVENET_CHAIN_NAME=casper-test \\ ODRA_CASPER_LIVENET_EVENTS_URL=[EVENTS_STREAM_ADDRESS] \\ cargo run --bin tlw_on_livenet --features=livenet Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.09s Running `../target/debug/tlw_on_livenet` 💁 INFO : Found wasm under &quot;/Users/kpob/workspace/odra/examples/wasm/TimeLockWallet.wasm&quot;. 💁 INFO : Deploying &quot;TimeLockWallet&quot;. 🙄 WAIT : Waiting 10 for V1(TransactionV1Hash(5ab45ba29c9e7b9a91c4b5a5fbd2ba31735f03f99f94dce542d3584c8776ce8a)). 🙄 WAIT : Waiting 10 for V1(TransactionV1Hash(5ab45ba29c9e7b9a91c4b5a5fbd2ba31735f03f99f94dce542d3584c8776ce8a)). 💁 INFO : Transaction &quot;5ab45ba29c9e7b9a91c4b5a5fbd2ba31735f03f99f94dce542d3584c8776ce8a&quot; successfully executed. 🔗 LINK : https://testnet.cspr.live/transaction/5ab45ba29c9e7b9a91c4b5a5fbd2ba31735f03f99f94dce542d3584c8776ce8a 💁 INFO : Contract &quot;contract-package-fe69f4dd63445cda6cdc3b4c066760227208a752857950af6bda8a41600781ea&quot; deployed. 💁 INFO : Calling &quot;contract-package-fe69f4dd63445cda6cdc3b4c066760227208a752857950af6bda8a41600781ea&quot; with entrypoint &quot;deposit&quot; through proxy. 🙄 WAIT : Waiting 10 for V1(TransactionV1Hash(86d07f72dc9383f46144b5fdfd912ddf15c7be539cf2c34e43f1214244da25b3)). 💁 INFO : Transaction &quot;86d07f72dc9383f46144b5fdfd912ddf15c7be539cf2c34e43f1214244da25b3&quot; successfully executed. 🔗 LINK : https://testnet.cspr.live/transaction/86d07f72dc9383f46144b5fdfd912ddf15c7be539cf2c34e43f1214244da25b3 Owner's balance: 100 💁 INFO : Calling &quot;contract-package-fe69f4dd63445cda6cdc3b4c066760227208a752857950af6bda8a41600781ea&quot; directly with entrypoint &quot;withdraw&quot;. 🙄 WAIT : Waiting 10 for V1(TransactionV1Hash(cbdedd1d5f528754904feb23a0e2087a53ed6f6ed27298367a98bc2accc5792f)). 💁 INFO : Transaction &quot;cbdedd1d5f528754904feb23a0e2087a53ed6f6ed27298367a98bc2accc5792f&quot; successfully executed. 🔗 LINK : https://testnet.cspr.live/transaction/cbdedd1d5f528754904feb23a0e2087a53ed6f6ed27298367a98bc2accc5792f Remaining balance: 1 As observed, the contract was successfully deployed, and the Caller deposited tokens. Subsequently, the caller withdrew 99 CSPRs from the contract, leaving the contract's balance at 1 CSPR. The logs display deploy hashes, the contract's hash, and even indicate if the call was made through the proxy, providing a comprehensive overview of the on-chain activity. ","version":"2.3.0","tagName":"h2"},{"title":"Conclusion​","type":1,"pageTitle":"Using Proxy Caller","url":"/docs/2.3.0/tutorials/using-proxy-caller#conclusion","content":"In this tutorial, we learned how to use the proxy_caller wasm to make a payable function call. We deployed the TimeLockWallet contract, deposited tokens using the proxy_caller with attached CSPRs, and withdrew them. You got to try it out in both Rust and TypeScript, so you can choose whichever you prefer. Rust code seemed simpler, thanks to the Odra livenet backend making chain interactions easier to handle. ","version":"2.3.0","tagName":"h2"},{"title":"Building contracts manually","type":0,"sectionRef":"#","url":"/docs/next/advanced/building-manually","content":"","keywords":"","version":"next"},{"title":"Building the contract manually​","type":1,"pageTitle":"Building contracts manually","url":"/docs/next/advanced/building-manually#building-the-contract-manually","content":"To build the contract manually, cargo odra uses the following command: ODRA_MODULE=my_contract cargo build --release --target wasm32-unknown-unknown --bin my_project_build_contract  info Odra uses the environment variable ODRA_MODULE to determine which contract to build. Assuming that project's crate is named my_project, this command will build the my_contract contract in release mode and generate the wasm file. The file will be put into the target/wasm32-unknown-unknown/release directory under the name my_project_build_contract.wasm. The Odra Framework expects the contracts to be placed in the wasm directory, and to be named correctly, so the next step would be to move the file: mv target/wasm32-unknown-unknown/release/my_project_build_contract.wasm wasm/my_contract.wasm  ","version":"next","tagName":"h2"},{"title":"Optimizing the contract​","type":1,"pageTitle":"Building contracts manually","url":"/docs/next/advanced/building-manually#optimizing-the-contract","content":"To lower the size of the wasm file, cargo odra uses the wasm-strip tool: wasm-strip wasm/my_contract.wasm  To further optimize the wasm file, the wasm-opt tool is also used. wasm-opt --signext-lowering wasm/my_contract.wasm -o wasm/my_contract.wasm  danger This step is required, as the wasm file generated by the Rust compiler is not fully compatible with the Casper execution engine. ","version":"next","tagName":"h2"},{"title":"Running the tests manually​","type":1,"pageTitle":"Building contracts manually","url":"/docs/next/advanced/building-manually#running-the-tests-manually","content":"To run the tests manually, Odra needs to know which backend to use. To run tests against Casper backend, the following command needs to be used: ODRA_BACKEND=casper cargo test  ","version":"next","tagName":"h2"},{"title":"Wrapping up​","type":1,"pageTitle":"Building contracts manually","url":"/docs/next/advanced/building-manually#wrapping-up","content":"Let's say we want to build the my_contract in debug mode, run the tests against the casper backend and use the my-own-allocator feature from our my_project project. To do that, we can use the following set of commands: ODRA_MODULE=my_contract cargo build --target wasm32-unknown-unknown --bin my_project_build_contract mv target/wasm32-unknown-unknown/debug/my_project_build_contract.wasm wasm/my_contract.wasm wasm-strip wasm/my_contract.wasm wasm-opt --signext-lowering wasm/my_contract.wasm -o wasm/my_contract.wasm ODRA_BACKEND=casper cargo test --features my-own-allocator  ","version":"next","tagName":"h2"},{"title":"Delegate","type":0,"sectionRef":"#","url":"/docs/next/advanced/delegate","content":"","keywords":"","version":"next"},{"title":"Overview​","type":1,"pageTitle":"Delegate","url":"/docs/next/advanced/delegate#overview","content":"To utilize the delegate feature in your contract, use the delegate! macro provided by Odra. This macro allows you to list the functions you wish to delegate to the child modules. By using the delegate! macro, your parent module remains clean and easy to understand. You can delegate functions to as many child modules as you like. The functions will be available as if they were implemented in the parent module itself. ","version":"next","tagName":"h2"},{"title":"Code Examples​","type":1,"pageTitle":"Delegate","url":"/docs/next/advanced/delegate#code-examples","content":"Consider the following basic example for better understanding: use crate::{erc20::Erc20, ownable::Ownable}; use odra::{casper_types::U256, prelude::*}; #[odra::module] pub struct OwnedToken { ownable: SubModule&lt;Ownable&gt;, erc20: SubModule&lt;Erc20&gt; } #[odra::module] impl OwnedToken { pub fn init(&amp;mut self, name: String, symbol: String, decimals: u8, initial_supply: U256) { let deployer = self.env().caller(); self.ownable.init(deployer); self.erc20.init(name, symbol, decimals, initial_supply); } delegate! { to self.erc20 { fn transfer(&amp;mut self, recipient: Address, amount: U256); fn transfer_from(&amp;mut self, owner: Address, recipient: Address, amount: U256); fn approve(&amp;mut self, spender: Address, amount: U256); fn name(&amp;self) -&gt; String; fn symbol(&amp;self) -&gt; String; fn decimals(&amp;self) -&gt; u8; fn total_supply(&amp;self) -&gt; U256; fn balance_of(&amp;self, owner: Address) -&gt; U256; fn allowance(&amp;self, owner: Address, spender: Address) -&gt; U256; } to self.ownable { fn get_owner(&amp;self) -&gt; Address; fn change_ownership(&amp;mut self, new_owner: Address); } } pub fn mint(&amp;mut self, address: Address, amount: U256) { self.ownable.ensure_ownership(self.env().caller()); self.erc20.mint(address, amount); } }  This OwnedToken contract includes two modules: Erc20 and Ownable. We delegate various functions from both modules using the delegate! macro. As a result, the contract retains its succinctness without compromising on functionality. The above example basically merges the functionalities of modules and adds some control over the minting process. But you can use delegation to build more complex contracts, cherry-picking just a few module functionalities. Let's take a look at another example. use crate::{erc20::Erc20, ownable::Ownable, exchange::Exchange}; use odra::{casper_types::U256, prelude::*}; #[odra::module] pub struct DeFiPlatform { ownable: SubModule&lt;Ownable&gt;, erc20: SubModule&lt;Erc20&gt;, exchange: SubModule&lt;Exchange&gt; } #[odra::module] impl DeFiPlatform { pub fn init(&amp;mut self, name: String, symbol: String, decimals: u8, initial_supply: U256, exchange_rate: u64) { let deployer = self.env().caller(); self.ownable.init(deployer); self.erc20.init(name, symbol, decimals, initial_supply); self.exchange.init(exchange_rate); } delegate! { to self.erc20 { fn transfer(&amp;mut self, recipient: Address, amount: U256); fn balance_of(&amp;self, owner: Address) -&gt; U256; } to self.ownable { fn get_owner(&amp;self) -&gt; Address; } to self.exchange { fn swap(&amp;mut self, sender: Address, recipient: Address); fn set_exchange_rate(&amp;mut self, new_rate: u64); } } pub fn mint(&amp;mut self, address: Address, amount: U256) { self.ownable.ensure_ownership(self.env().caller()); self.erc20.mint(address, amount); } }  In this DeFiPlatform contract, we include Erc20, Ownable, and Exchange modules. By delegating functions from these modules, the parent contract becomes a powerhouse of functionality while retaining its readability and structure. Remember, the possibilities are endless with Odra's. By leveraging this feature, you can write cleaner, more efficient, and modular smart contracts. ","version":"next","tagName":"h2"},{"title":"Signatures","type":0,"sectionRef":"#","url":"/docs/next/advanced/signatures","content":"","keywords":"","version":"next"},{"title":"Signature verification​","type":1,"pageTitle":"Signatures","url":"/docs/next/advanced/signatures#signature-verification","content":"Signature verification is conducted by a function in contract's env(): pub fn verify_signature(message: &amp;Bytes, signature: &amp;Bytes, public_key: &amp;PublicKey) -&gt; bool;  Here's the simplest example of this function used in a contract: examples/src/features/signature_verifier.rs #[odra::module] impl SignatureVerifier { pub fn verify_signature( &amp;self, message: &amp;Bytes, signature: &amp;Bytes, public_key: &amp;PublicKey ) -&gt; bool { self.env().verify_signature(message, signature, public_key) } }  ","version":"next","tagName":"h2"},{"title":"Testing​","type":1,"pageTitle":"Signatures","url":"/docs/next/advanced/signatures#testing","content":"Besides the above function in the contract context, Odra provides corresponding functions in the HostEnv: pub fn sign_message(message: &amp;Bytes, address: &amp;Address) -&gt; Bytes; pub fn public_key(address: &amp;Address) -&gt; PublicKey;  sign_message will return a signed message. The signing itself will be performed using a private key of an account behind the address. public_key returns the PublicKey of an address account. Here's a complete example of how to test the signature verification in the contract: examples/src/features/signature_verifier.rs #[test] fn signature_verification_works() { let test_env = odra_test::env(); let message = &quot;Message to be signed&quot;; let message_bytes = Bytes::from(message.as_bytes()); let account = test_env.get_account(0); let signature = test_env.sign_message(&amp;message_bytes, &amp;account); let public_key = test_env.public_key(&amp;account); let signature_verifier = SignatureVerifier::deploy(&amp;test_env, NoArgs); assert!(signature_verifier.verify_signature(&amp;message_bytes, &amp;signature, &amp;public_key)); }  If you want, you can also test signatures created outside Odra: examples/src/features/signature_verifier.rs #[test] fn verify_signature_casper_wallet() { // Casper Wallet for the message &quot;Ahoj przygodo!&quot; signed using SECP256K1 key // produces the following signature: // 1e87e186238fa1df9c222b387a79910388c6ef56285924c7e4f6d7e77ed1d6c61815312cf66a5318db204c693b79e020b1d392dafe8c1b3841e1f6b4c41ca0fa // Casper Wallet adds &quot;Casper Message:\\n&quot; prefix to the message: let message = &quot;Casper Message:\\nAhoj przygodo!&quot;; let message_bytes = Bytes::from(message.as_bytes()); // Depending on the type of the key, we need to prefix the signature with a tag: // 0x01 for ED25519 // 0x02 for SECP256K1 let signature_hex = &quot;021e87e186238fa1df9c222b387a79910388c6ef56285924c7e4f6d7e77ed1d6c61815312cf66a5318db204c693b79e020b1d392dafe8c1b3841e1f6b4c41ca0fa&quot;; let signature: [u8; 65] = hex::decode(signature_hex).unwrap().try_into().unwrap(); let signature_bytes = Bytes::from(signature.as_slice()); // Similar to the above, the public key is tagged: let public_key_hex = &quot;02036d9b880e44254afaf34330e57703a63aec53b5918d4470059b67a4a906350105&quot;; let public_key_decoded = hex::decode(public_key_hex).unwrap(); let (public_key, _) = PublicKey::from_bytes(public_key_decoded.as_slice()).unwrap(); let signature_verifier = SignatureVerifier::deploy(&amp;odra_test::env(), NoArgs); assert!(signature_verifier.verify_signature(&amp;message_bytes, &amp;signature_bytes, &amp;public_key)); }  ","version":"next","tagName":"h2"},{"title":"Delegating CSPR to Validators","type":0,"sectionRef":"#","url":"/docs/next/advanced/delegating-cspr","content":"","keywords":"","version":"next"},{"title":"Sample implementation​","type":1,"pageTitle":"Delegating CSPR to Validators","url":"/docs/next/advanced/delegating-cspr#sample-implementation","content":"The following code shows how to implement a simple contract that allows delegating CSPR tokens to a validator. examples/src/features/validators.rs use odra::{ casper_types::{PublicKey, U512}, prelude::* }; #[odra::module] pub struct ValidatorsContract { /// In this variable we store the validator's public key, this is the only way we can identify the validator validator: Var&lt;PublicKey&gt; } /// Implementation of the TestingContract #[odra::module] impl ValidatorsContract { /// Initializes the contract with the validator's public key pub fn init(&amp;mut self, validator: PublicKey) { self.validator.set(validator); } /// Stake the amount of tokens #[odra(payable)] pub fn stake(&amp;mut self) { // Get the amount of tokens attached to the call let amount = self.env().attached_value(); if amount.is_zero() { self.env().revert(ValError::InsufficientBalance); } // Use the ContractEnv's delegate method to delegate the tokens to the validator self.env().delegate(self.validator.get().unwrap(), amount); } /// Undelegate the amount from the validator pub fn unstake(&amp;mut self, amount: U512) { self.env().undelegate(self.validator.get().unwrap(), amount); } /// Withdraw the amount from the validator pub fn withdraw(&amp;mut self, amount: U512) { self.env().transfer_tokens(&amp;self.env().caller(), &amp;amount); } ... }  ","version":"next","tagName":"h2"},{"title":"Explanation​","type":1,"pageTitle":"Delegating CSPR to Validators","url":"/docs/next/advanced/delegating-cspr#explanation","content":"The above example can be a good starting point for implementing a liquid staking solution. The main things to remember are the new api methods in ContractEnv: pub fn delegate(&amp;self, validator: PublicKey, amount: U512); pub fn undelegate(&amp;self, validator: PublicKey, amount: U512); pub fn delegated_amount(&amp;self, validator: PublicKey) -&gt; U512;  As you can see, we identify the validator by its public key. Funds delegated to the validator are assigned to the calling contract. Remember, that the delegation and undelegation takes some time, depending on the configuration of the blockchain - it's not instant. For example in the Casper mainnet, the delegation takes 1 era and the undelegation takes 7 eras. ","version":"next","tagName":"h2"},{"title":"Testing​","type":1,"pageTitle":"Delegating CSPR to Validators","url":"/docs/next/advanced/delegating-cspr#testing","content":"It is possible to test the delegation and undelegation of tokens in the contract. The following code shows how to do it: examples/src/features/validators.rs ... let test_env = odra_test::env(); let auction_delay = test_env.auction_delay(); let unbonding_delay = test_env.unbonding_delay(); test_env.set_caller(test_env.get_account(0)); let mut staking = ValidatorsContract::deploy( &amp;test_env, ValidatorsContractInitArgs { validator: test_env.get_validator(0) } ); let initial_account_balance = test_env.balance_of(&amp;test_env.get_account(0)); // Stake some amount let staking_amount = U512::from(1_000_000_000_000u64); staking.with_tokens(staking_amount).stake(); assert_eq!(staking.currently_delegated_amount(), staking_amount); assert_eq!( test_env.balance_of(&amp;test_env.get_account(0)), initial_account_balance - staking_amount ); // Advance time, run auctions and give off rewards test_env.advance_with_auctions(auction_delay * 2); // Check that the amount is greater than the staking amount let staking_with_reward = staking.currently_delegated_amount(); assert!(staking_with_reward &gt; staking_amount); ...  You can see, that we use the new methods from HostEnv, namely:  fn advance_with_auctions(&amp;self, time_diff: u64); fn auction_delay(&amp;self) -&gt; u64; fn unbonding_delay(&amp;self) -&gt; u64; fn delegated_amount(&amp;self, delegator: Address, validator: PublicKey) -&gt; U512;  advance_with_auctions works in a similar way to advance_block_time, but it also runs the auctions and gives off rewards. The auction_delay and unbonding_delay methods return the values of the auction and unbonding delays specific to the network or backend. We used currently_delegated_amount in the example, it uses delegated_amount method from ContractEnv, but it is also possible to query this information from the HostEnv using delegated_amount method. ","version":"next","tagName":"h2"},{"title":"Memory allocators","type":0,"sectionRef":"#","url":"/docs/next/advanced/using-different-allocator","content":"","keywords":"","version":"next"},{"title":"Using a different allocator​","type":1,"pageTitle":"Memory allocators","url":"/docs/next/advanced/using-different-allocator#using-a-different-allocator","content":"If the default allocator does not suit your needs, or you use a crate that already provides an allocator, you can disable the default allocator by enabling the disable-allocator feature in the odra dependency in your project: [dependencies] odra = { path = &quot;../odra&quot;, features = [&quot;disable-allocator&quot;] }  If you want to have a better control over the features that are enabled during the building and tests, see the next article on building manually. ","version":"next","tagName":"h2"},{"title":"Storage Layout","type":0,"sectionRef":"#","url":"/docs/next/advanced/storage-layout","content":"","keywords":"","version":"next"},{"title":"Casper VM Perspective​","type":1,"pageTitle":"Storage Layout","url":"/docs/next/advanced/storage-layout#casper-vm-perspective","content":"The Casper Execution Engine (VM) enables the storage of data in named keys or dictionaries. However, a smart contract has a limited number of named keys, making it unsuitable for storing substantial data volumes. Odra resolves this issue by storing all user-generated data in a dictionary called state. This dictionary operates as a key-value store, where keys are strings with a maximum length of 64 characters, and values are arbitrary byte arrays. Here is an example of what the interface for reading and writing data could look like: pub trait CasperStorage { fn read(key: &amp;str) -&gt; Option&lt;Vec&lt;u8&gt;&gt;; fn write(key: &amp;str, value: Vec&lt;u8&gt;); }  ","version":"next","tagName":"h2"},{"title":"Odra Perspective​","type":1,"pageTitle":"Storage Layout","url":"/docs/next/advanced/storage-layout#odra-perspective","content":"Odra was conceived with modularity and code reusability in mind. Additionally, we aimed to streamline storage definition through the struct object. Consider this straightforward storage definition: #[odra::module] pub struct Token { name: Var&lt;String&gt;, balances: Mapping&lt;Address, U256&gt; }  The Token structure contains two fields: name of type String andbalances, which functions as a key-value store with Address as keys andU256 as values. The Token module can be reused in another module, as demonstrated in a more complex example: #[odra::module] pub struct Loans { lenders: SubModule&lt;Token&gt;, borrowers: SubModule&lt;Token&gt;, }  The Loans module has two fields: lenders and borrowers, both of which have the same storage layout as defined by the Token module. Odra guarantees thatlenders and borrowers are stored under distinct keys within the storage dictionary. Both Token and Loans serve as examples to show how Odra's storage layout operates. ","version":"next","tagName":"h2"},{"title":"Key generation.​","type":1,"pageTitle":"Storage Layout","url":"/docs/next/advanced/storage-layout#key-generation","content":"Every element of a module (struct) with N elements is associated with an index ranging from 0 to N-1, represented as a u8 with a maximum of 256 elements. If an element of a module is another module (SubModule&lt;...&gt;), the associated index serves as a prefix for the indexes of the inner module. While this may initially appear complex, it is easily understood through an example. In the example, indexes are presented as bytes, reflecting the actual implementation. Loans { lenders: Token { // prefix: 0x0001 name: 1, // key: 0x0001_0001 balances: 2 // key: 0x0001_0010 }, borrowers: Token { // prefix: 0x0010 name: 1, // key: 0x0010_0001 balances: 2 // key: 0x0010_0010 } }  Additionally, it's worth mentioning how Mapping's keys are used in thestorage. They are simply concatenated with the index of the module, as demonstrated in the example. For instance, triggering borrowers.balances.get(0x1234abcd) would result in a key: 0x0001_0001_1234_abcd  Finally, the key must be hashed to fit within the 64-character limit and then encoded in hexadecimal format. ","version":"next","tagName":"h2"},{"title":"Value serialization​","type":1,"pageTitle":"Storage Layout","url":"/docs/next/advanced/storage-layout#value-serialization","content":"Before being stored in the storage, each value is serialized into bytes using the CLType serialization method and subsequently encapsulated with Casper'sBytes types. ","version":"next","tagName":"h2"},{"title":"Casper","type":0,"sectionRef":"#","url":"/docs/next/backends/casper","content":"","keywords":"","version":"next"},{"title":"Contract Env​","type":1,"pageTitle":"Casper","url":"/docs/next/backends/casper#contract-env","content":"As with any other backend, Casper Backend must implement the same features, but some do not have native support. Let's take a closer look at how Odra overcomes these hindrances. ","version":"next","tagName":"h2"},{"title":"Events​","type":1,"pageTitle":"Casper","url":"/docs/next/backends/casper#events","content":"An event is not a first-class citizen in Casper like in Ethereum, so Odra mimics it. As you've already learned from the events article, in Odra you emit an event, similarly, you would do it in Solidity. Under the hood, Odra integrates with Casper Event Standard and creates a few URefs in the global state when a contract is being installed: __events - a dictionary that stores events' data.__events_length - the evens count.__events_ces_version - the version of Casper Event Standard. __events_schema - a dictionary that stores event schemas. Besides that, all the events the contract emits are registered - events schemas are written to the storage under the __events_schema key. So, Events are nothing different from any other data stored by a contract. A struct to be an event must implement traits defined by Casper Event Standard, thankfully you can derive them using #[odra::event]. note Don't forget to expose events in the module using #[odra::module(events = [...])]. ","version":"next","tagName":"h3"},{"title":"Payable​","type":1,"pageTitle":"Casper","url":"/docs/next/backends/casper#payable","content":"The first Odra idiom is a Contract Main Purse. It is a purse associated with a contract. The purse is created lazily - when the first transfer to the contract occurs, a proper URef and a purse are created and stored under the __contract_main_purse key. Casper does not allow direct transfers from an account to a contract, so Odra comes up with the second idiom - a Cargo Purse. It is a one-time-use purse proxy between an account and a contract. First, motes go from the account to the cargo purse and then to the contract's main purse. Behind the scenes, Odra handles an account-contract transfer via a cargo purse when a function is marked as payable. If under the way something goes wrong with the transfer, the contract reverts. The transferred amount can be read inside the contract by calling self.env().attached_value(). note Odra expects the cargo_purse runtime argument to be attached to a contract call. In case of its absence, the contract_env::attached_value() returns zero. ","version":"next","tagName":"h3"},{"title":"Revert​","type":1,"pageTitle":"Casper","url":"/docs/next/backends/casper#revert","content":"In Casper, we can stop the execution pretty straightforwardly - call the runtime::revert(). Odra adds an extra abstraction layer - in a contract ExecutionErrors are defined, which ultimately are transformed into Casper's ApiError::User. ","version":"next","tagName":"h3"},{"title":"Context​","type":1,"pageTitle":"Casper","url":"/docs/next/backends/casper#context","content":"Casper equips developers with very low-level tooling, which can be cumbersome for newcomers. If you want to check who called the contract or its address, you can not do it off-hand - you must analyze the call stack. The self.env().self_address() function takes the first element of the callstack (runtime::get_call_stack()) and casts it to Address. The self.env().caller() function takes the second element of the call stack (runtime::get_call_stack()) and casts it to Address. As mentioned in the [Payable] section, to store CSPR, each contract creates its purse. To read the contract balance, you call self.env().self_balance(), which checks the balance of the purse stored under __contract_main_purse. ","version":"next","tagName":"h3"},{"title":"Test Env​","type":1,"pageTitle":"Casper","url":"/docs/next/backends/casper#test-env","content":"Test environment allows you to test wasm contracts before you deploy them onto the testnet or livenet. It is built on top of the Casper Execution Engine. In your test, you can freely switch execution context by setting as a caller (test_env::set_caller()) one of the 20 predefined accounts. Each account possesses the default amount of Motes (100_000_000_000_000_000). The Test Env internally keeps track of the current block time, error and attached value. Each test is executed on a fresh instance of the Test Env. ","version":"next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"Casper","url":"/docs/next/backends/casper#usage","content":"Name of the Casper backend in Odra is casper, so to run the tests against it, simply pass it as a -bparameter: cargo odra test -b casper  If you want to just generate a wasm file, simply run: cargo odra build -b casper  ","version":"next","tagName":"h2"},{"title":"Deploying a contract to Casper network​","type":1,"pageTitle":"Casper","url":"/docs/next/backends/casper#deploying-a-contract-to-casper-network","content":"There would be no point in writing a contract if you couldn't deploy it to the blockchain. You can do it in two ways: provided by the Casper itself: using the casper-client tool or using the Odra's Livenet integration. note In the commands below, we use casper-client version 5.0.0. Let's explore the first option to better understand the process. note If you wish, you can skip the following section and jump to the Livenet integration. ","version":"next","tagName":"h2"},{"title":"WASM arguments​","type":1,"pageTitle":"Casper","url":"/docs/next/backends/casper#wasm-arguments","content":"When deploying a new contract you can pass some arguments to it. Every contract written in Odra expects those arguments to be set: odra_cfg_package_hash_key_name - String type. The key under which the package hash of the contract will be stored.odra_cfg_allow_key_override - Bool type. If true and the key specified in odra_cfg_package_hash_key_name already exists, it will be overwritten.odra_cfg_is_upgradable - Bool type. If true, the contract will be deployed as upgradable.odra_cfg_is_upgrade - Bool type. If true, the contract will be upgraded. If we want to install a contract to should be set to false. Additionally, if required by the contract, you can pass constructor arguments. When working with the test env via cargo odra or when usingLivenet integration this is handled automatically. However, if you rather usecasper-client directly, you have to pass them manually: ","version":"next","tagName":"h3"},{"title":"Example: Deploy Counter​","type":1,"pageTitle":"Casper","url":"/docs/next/backends/casper#example-deploy-counter","content":"To deploy your contract with a constructor using casper-client, you need to pass the above arguments. Additionally, you need to pass the value argument, which sets the arbitrary initial value for the counter. casper-client put-transaction session \\ --node-address [NODE_ADDRESS] \\ --chain-name casper-test \\ --secret-key [PATH_TO_YOUR_KEY]/secret_key.pem \\ --payment-amount 5000000000000 \\ --gas-price-tolerance 1 \\ --standard-payment true \\ --wasm-path ./wasm/counter.wasm \\ --session-arg &quot;odra_cfg_package_hash_key_name:string:'counter_package_hash'&quot; \\ --session-arg &quot;odra_cfg_allow_key_override:bool:'true'&quot; \\ --session-arg &quot;odra_cfg_is_upgradable:bool:'true'&quot; \\ --session-arg &quot;odra_cfg_is_upgrade:bool:'false'&quot; \\ --session-arg &quot;value:u32:42&quot;  For a more in-depth tutorial, please refer to the Casper's 'Writing On-Chain Code'. ","version":"next","tagName":"h3"},{"title":"Example: Deploy ERC721​","type":1,"pageTitle":"Casper","url":"/docs/next/backends/casper#example-deploy-erc721","content":"Odra comes with a standard ERC721 token implementation. Clone the main Odra repo and navigate to the modules directory. Firstly contract needs to be compiled. cargo odra build -b casper -c erc721_token  It produces the erc721_token.wasm file in the wasm directory. Now it's time to deploy the contract. casper-client put-transaction session \\ --node-address [NODE_ADDRESS] \\ --chain-name casper-test \\ --secret-key [PATH_TO_YOUR_KEY]/secret_key.pem \\ --payment-amount 300000000000 \\ --gas-price-tolerance 1 \\ --standard-payment true \\ --wasm-path ./wasm/erc721_token.wasm \\ --session-arg &quot;odra_cfg_package_hash_key_name:string:'my_nft'&quot; \\ --session-arg &quot;odra_cfg_allow_key_override:bool:'false'&quot; \\ --session-arg &quot;odra_cfg_is_upgradable:bool:'true'&quot; \\ --session-arg &quot;odra_cfg_is_upgrade:bool:'false'&quot; \\ --session-arg &quot;name:string:'MyNFT'&quot; \\ --session-arg &quot;symbol:string:'NFT'&quot; \\ --session-arg &quot;base_uri:string:'https://example.com/'&quot;  It's done. The contract is deployed and ready to use. Your account is the owner of the contract and you can mint and burn tokens. For more details see the code of the ERC721 module. To obtain the package hash of the contract search for my_nft key in your account's named keys. ","version":"next","tagName":"h3"},{"title":"Example: Deploy ERC1155​","type":1,"pageTitle":"Casper","url":"/docs/next/backends/casper#example-deploy-erc1155","content":"The process is similar to the one described in the previous section. Contract compilation: cargo odra build -b casper -c erc1155_token  Contract deployment: casper-client put-transaction session \\ --node-address [NODE_ADDRESS] \\ --chain-name casper-test \\ --secret-key [PATH_TO_YOUR_KEY]/secret_key.pem \\ --payment-amount 300000000000 \\ --gas-price-tolerance 1 \\ --standard-payment true \\ --wasm-path ./wasm/erc1155_token.wasm \\ --session-arg &quot;odra_cfg_package_hash_key_name:string:'my_tokens'&quot; \\ --session-arg &quot;odra_cfg_allow_key_override:bool:'false'&quot; \\ --session-arg &quot;odra_cfg_is_upgradable:bool:'true'&quot; \\ --session-arg &quot;odra_cfg_is_upgrade:bool:'false'&quot; \\ --session-arg &quot;odra_cfg_constructor:string:'init'&quot; \\  As previously, your account is the owner and can mint and burn tokens. For more details see the code of the ERC1155 module. ","version":"next","tagName":"h3"},{"title":"Sending CSPR to a contract​","type":1,"pageTitle":"Casper","url":"/docs/next/backends/casper#sending-cspr-to-a-contract","content":"Defining payable entry points is described in Native Token section. What is happening under the hood is that Odra creates a new cargo_purse argument for each payable entry point. The cargo_purse needs to be top-upped with CSPR before calling the contract. When a contract adds CSPR to another contract call, Odra handles it for you. The problem arises when you want to call an entry point and attach CSPR as an account. The only way of doing that is by executing code in the sessions context, that top-ups the cargo_purse and then calls the contract. Odra provides a generic proxy_caller.wasm that does exactly that. You can build it by yourself from the main Odra repository, or use the proxy_caller.wasmwe maintain. ","version":"next","tagName":"h2"},{"title":"Using proxy_caller.wasm​","type":1,"pageTitle":"Casper","url":"/docs/next/backends/casper#using-proxy_callerwasm","content":"To use the proxy_caller.wasm you need to attach the following arguments: contract_package_hash - BytesArray(32) type. The package hash of the contract you want to call. Result of to_bytes on CasperPackageHash.entry_point - String type. The name of the entry point you want to call.args - Bytes type. It is a serialized RuntimeArgs with the arguments you want to pass to the entry point. To be specific it is the result of to_bytes method wrapped with Bytes type.attached_value. U512 type. The amount of CSPR you want to attach to the call.amount. U512 type. Should be the same value as attached_value if not None. It is a special Casper argument that enables the access to account's main purse. Currently casper-client doesn't allow building such arguments. You have to build it using your SDK. See an example in the Tutorial section. ","version":"next","tagName":"h3"},{"title":"Execution​","type":1,"pageTitle":"Casper","url":"/docs/next/backends/casper#execution","content":"First thing Odra does with your code, is similar to the one used in OdraVM - a list of entrypoints is generated, thanks to the #[odra::module] attribute. ","version":"next","tagName":"h2"},{"title":"OdraVM","type":0,"sectionRef":"#","url":"/docs/next/backends/odra-vm","content":"","keywords":"","version":"next"},{"title":"Usage​","type":1,"pageTitle":"OdraVM","url":"/docs/next/backends/odra-vm#usage","content":"The OdraVM is the default backend for Odra framework, so each time you run cargo odra test  You are running your code against it. ","version":"next","tagName":"h2"},{"title":"Architecture​","type":1,"pageTitle":"OdraVM","url":"/docs/next/backends/odra-vm#architecture","content":"OdraVM consists of two main parts: the Contract Register and the State. The Contract Register is a list of contracts deployed onto the OdraVM, identified by an Address. Contracts and Test Env functions can modify the State of the OdraVM. Contrary to the &quot;real&quot; backend, which holds the whole history of the blockchain, the OdraVM State holds only the current state of the OdraVM. Thanks to this and the fact that we do not need the blockchain itself, OdraVM starts instantly and runs the tests in the native speed. ","version":"next","tagName":"h2"},{"title":"Execution​","type":1,"pageTitle":"OdraVM","url":"/docs/next/backends/odra-vm#execution","content":"When the OdraVM backend is enabled, the #[odra::module] attribute is responsible for converting your pub functions into a list of Entrypoints, which are put into a Contract Container. When the contract is deployed, its Container registered into a Registry under an address. During the contract call, OdraVM finds an Entrypoint and executes the code. ","version":"next","tagName":"h2"},{"title":"Livenet","type":0,"sectionRef":"#","url":"/docs/next/backends/livenet","content":"","keywords":"","version":"next"},{"title":"Setup​","type":1,"pageTitle":"Livenet","url":"/docs/next/backends/livenet#setup","content":"To use Livenet backend, we need to provide Odra with some information - the network address, our private key and the name of the chain we want to use. Optionally, we can add multiple private keys to use more than one account in our tests. Those values are passed using environment variables. We can use .env file to store them - let's take a look at an example .env file, created from the .env.sample file from the examples folder: # .env file used by Livenet integration. You can use multiple .env files to manage deploys on multiple chains # by naming them casper-test.env, casper-livenet.env, etc. and calling the deploy script with the name of the # ennviroment provided in the &quot;ODRA_CASPER_LIVENET_ENV&quot; variable. For example: # ODRA_CASPER_LIVENET_ENV=casper-test cargo run --bin livenet_tests --features livenet # This will load integration.env file first, and then fill the missing values with the values from casper-test.env. # Path to the secret key of the account that will be used to deploy the contracts. # If you are using the nctl, you can use the following command to extract the secret key from the container: # docker exec mynctl /bin/bash -c &quot;cat /home/casper/casper-nctl/assets/net-1/users/user-1/secret_key.pem&quot; &gt; examples/.node-keys/secret_key.pem # docker exec mynctl /bin/bash -c &quot;cat /home/casper/casper-nctl/assets/net-1/users/user-2/secret_key.pem&quot; &gt; examples/.node-keys/secret_key_1.pem ODRA_CASPER_LIVENET_SECRET_KEY_PATH=&lt;path to secret_key.pem&gt; # RPC address of the node that will be used to deploy the contracts. # For CSPR.cloud, you can use the following addresses: # - https://node.cspr.cloud # - https://node.testnet.cspr.cloud # For nctl, default is: # - http://localhost:11101 ODRA_CASPER_LIVENET_NODE_ADDRESS=&lt;node address&gt; # Events url # For CSPR.cloud, you can use the following addresses: # - https://node.cspr.cloud/events # For nctl, default is: # - http://localhost:18101/events ODRA_CASPER_LIVENET_EVENTS_URL=&lt;events url&gt; # Chain name of the network. The mainnet is &quot;casper&quot; and test net is &quot;casper-test&quot;. # The integration network uses the &quot;integration-test&quot; chain name. # For nctl default is &quot;casper-net-1&quot; ODRA_CASPER_LIVENET_CHAIN_NAME=&lt;chain_name&gt; # Optionally, paths to the secret keys of the additional acccounts. Main secret key will be 0th account. # The following will work for nctl if you used the command above to extract the secret keys: # ODRA_CASPER_LIVENET_KEY_1=./keys/secret_key_1.pem #ODRA_CASPER_LIVENET_KEY_1=&lt;path to secret_key_1.pem&gt; # If using CSPR.cloud, you can set the auth token here. # CSPR_CLOUD_AUTH_TOKEN= # Optionally, you can set the TTL for the deploys. Default is 5 minutes. # ODRA_CASPER_LIVENET_TTL=  note CSPR.cloud is a service that provides mainnet and testnet Casper nodes on demand. With the proper value in place, we can write our tests or deploy scenarios. In the examples, we can find a simple binary that deploys a contract and calls it. The test is located in the erc20_on_livenet.rs file. Let's go through the code: //! Deploys an ERC20 contract and transfers some tokens to another address. use odra::casper_types::U256; use odra::host::{Deployer, HostEnv, HostRefLoader, InstallConfig}; use odra::prelude::*; use odra_modules::erc20::{Erc20, Erc20HostRef, Erc20InitArgs}; use std::str::FromStr; fn main() { let env = odra_casper_livenet_env::env(); let owner = env.caller(); let recipient = &quot;hash-2c4a6ce0da5d175e9638ec0830e01dd6cf5f4b1fbb0724f7d2d9de12b1e0f840&quot;; let recipient = Address::from_str(recipient).unwrap(); // Deploy new contract. let mut token = deploy_erc20(&amp;env); println!(&quot;Token address: {}&quot;, token.address().to_string()); // Uncomment to load existing contract. // let mut token = load_erc20(&amp;env); println!(&quot;Token name: {}&quot;, token.name()); env.set_gas(3_000_000_000u64); token.transfer(&amp;recipient, &amp;U256::from(1000)); println!(&quot;Owner's balance: {:?}&quot;, token.balance_of(&amp;owner)); println!(&quot;Recipient's balance: {:?}&quot;, token.balance_of(&amp;recipient)); } /// Loads an ERC20 contract. fn _load_erc20(env: &amp;HostEnv) -&gt; Erc20HostRef { let address = &quot;hash-d26fcbd2106e37be975d2045c580334a6d7b9d0a241c2358a4db970dfd516945&quot;; let address = Address::from_str(address).unwrap(); Erc20::load(env, address) } /// Deploys an ERC20 contract. pub fn deploy_erc20(env: &amp;HostEnv) -&gt; Erc20HostRef { let name = String::from(&quot;Plascoin&quot;); let symbol = String::from(&quot;PLS&quot;); let decimals = 10u8; let initial_supply = Some(U256::from(10_000)); let init_args = Erc20InitArgs { name, symbol, decimals, initial_supply }; env.set_gas(450_000_000_000u64); // You may configure a deploy passing `InstallConfig`. // Erc20::deploy_with_cfg(env, init_args, InstallConfig::upgradable::&lt;Erc20&gt;()) Erc20::deploy(env, init_args) }  note The above example is a rust binary, not a test. Note that it is also added as a section of theCargo.toml file: [bin] name = &quot;erc20_on_livenet&quot; path = &quot;src/bin/erc20_on_livenet.rs&quot; required-features = [&quot;livenet&quot;] test = false  ","version":"next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"Livenet","url":"/docs/next/backends/livenet#usage","content":"To run the above code, we simply need to run the binary with the livenet feature enabled: cargo run --bin erc20_on_livenet --features=livenet  note Before executing the binary, make sure you built a wasm file. A part of a sample output should look like this: ... 💁 INFO : Calling &quot;contract-package-b796cf8e527472d7ced8c4f8db5adb30eb577176f4c7ce956675590e0cac4bb8&quot; directly with entrypoint &quot;transfer&quot;. 🙄 WAIT : Waiting 10 for V1(TransactionV1Hash(775913daa0ffbded9aaf2216942217d682f03d1c04e6e2560d1e4b3329ebd2d6)). 💁 INFO : Transaction &quot;775913daa0ffbded9aaf2216942217d682f03d1c04e6e2560d1e4b3329ebd2d6&quot; successfully executed. 🔗 LINK : Owner's balance: 9000 Recipient's balance: 1000  Those logs are a result of the last 4 lines of the above listing. Each deployment or a call to the blockchain will be noted and will take some time to execute. We can see that the transfer call took over 15 seconds to execute. But calling balance_of was nearly instant and cost us nothing. How it is possible? info You can see the deployment on http://cspr.live/ - the transfer from the example can be seen here. ","version":"next","tagName":"h2"},{"title":"How Livenet backend works​","type":1,"pageTitle":"Livenet","url":"/docs/next/backends/livenet#how-livenet-backend-works","content":"All calls of entrypoints executed on a Casper blockchain cost gas - even if they do not change the state. It is possible, however, to query the state of the blockchain for free. This principle is used in the Livenet backend - all calls that do not change the state of the blockchain are really executed offline - the only thing that is requested from the node is the current state. This is why the balance_of call was almost instant and free. Basically, if the entrypoint function is not mutable or does not make a call to an unknown external contract (see Cross Calls), it is executed offline and node is used for the state query only. However, the Livenet needs to know the connection between the contracts and the code, so make sure to deploy or load already deployed contracts ","version":"next","tagName":"h2"},{"title":"Multiple environments​","type":1,"pageTitle":"Livenet","url":"/docs/next/backends/livenet#multiple-environments","content":"It is possible to have multiple environments for the Livenet backend. This is useful if we want to easily switch between multiple accounts, multiple nodes or even multiple chains. To do this, simply create a new .env file with a different prefix - for example, integration.env and mainnet.env. Then, pass the ODRA_CASPER_LIVENET_ENV variable with value either integration or mainnet to select which file has to be used first. If your integration.env file has a value that IS present in the .env file, it will override the value from the .env file. ODRA_CASPER_LIVENET_ENV=integration cargo run --bin erc20_on_livenet --features=livenet  To sum up - this command will firstly load the integration.env file and then load the missing values from .env file. ","version":"next","tagName":"h2"},{"title":"What is a backend?","type":0,"sectionRef":"#","url":"/docs/next/backends/what-is-a-backend","content":"","keywords":"","version":"next"},{"title":"Contract Env​","type":1,"pageTitle":"What is a backend?","url":"/docs/next/backends/what-is-a-backend#contract-env","content":"The Contract Env is a simple interface that each backend needs to implement, exposing features of the blockchain from the perspective of the contract. It gives Odra a set of functions, which allows implementing more complex concepts - for example, to implement Mapping, Odra requires some kind of storage integration. The exact implementation of those functions is a responsibility of a backend, making Odra and its user free to implement the contract logic, instead of messing with the blockchain internals. Other functions from Contract Env include handling transfers, addresses, block time, errors and events. ","version":"next","tagName":"h2"},{"title":"Host Env​","type":1,"pageTitle":"What is a backend?","url":"/docs/next/backends/what-is-a-backend#host-env","content":"Similarly to the Contract Env, the Host Env exposes a set of functions that allows the communication with the backend from the outside world - really useful for implementing tests. This ranges from interacting with the blockchain - like deploying new, loading existing and calling the contracts, to the more test-oriented - handling errors, forwarding the block time, etc. ","version":"next","tagName":"h2"},{"title":"What's next​","type":1,"pageTitle":"What is a backend?","url":"/docs/next/backends/what-is-a-backend#whats-next","content":"We will take a look at backends Odra implements in more detail. ","version":"next","tagName":"h2"},{"title":"Cargo Odra","type":0,"sectionRef":"#","url":"/docs/next/basics/cargo-odra","content":"","keywords":"","version":"next"},{"title":"Managing projects​","type":1,"pageTitle":"Cargo Odra","url":"/docs/next/basics/cargo-odra#managing-projects","content":"Two commands help you create a new project. The first one is cargo odra new. You need to pass one parameter, namely --name {PROJECT_NAME}: cargo odra new --name my-project  This creates a new project in the my_project folder and name it my_project. You can see it for yourself, for example by taking a look into a Cargo.toml file created in your project's folder: [package] name = &quot;my_project&quot; version = &quot;0.1.0&quot; edition = &quot;2021&quot;  The project is created using the template located in Odra's main repository. By default it uses full template, if you want, you can use minimalistic blank by running: cargo odra new -t blank --name my-project  The third available template is workspace, which creates a workspace with two projects, similar to the one created with the full template. There are also two templates which create a project with a sample tokens native to Casper Network: cep18 and cep78. By default, the latest release of Odra will be used for the template and as a dependency. You can pass a source of Odra you want to use, by using -s parameter: cargo odra new -n my-project -s ../odra # will use local folder of odra cargo odra new -n my-project -s release/0.9.0 # will use github branch, e.g. if you want to test new release cargo odra new -n my-project -s 1.1.0 # will use a version released on crates.io  The second way of creating a project is by using init command: cargo odra init --name my-project  It works in the same way as new, but instead of creating a new folder, it creates a project in the current, empty directory. ","version":"next","tagName":"h2"},{"title":"Generating code​","type":1,"pageTitle":"Cargo Odra","url":"/docs/next/basics/cargo-odra#generating-code","content":"If you want to quickly create a new contract code, you can use the generate command: cargo odra generate -c counter  This creates a new file src/counter.rs with sample code, add appropriate use and mod sections to src/lib.rs and update the Odra.toml file accordingly. To learn more about Odra.toml file, visit Odra.toml. ","version":"next","tagName":"h2"},{"title":"Testing​","type":1,"pageTitle":"Cargo Odra","url":"/docs/next/basics/cargo-odra#testing","content":"The most used command during the development of your project should be this one: cargo odra test  It runs your tests against Odra's MockVM. It is substantially faster than CasperVMand implements all the features Odra uses. When you want to run tests against a &quot;real&quot; VM, just provide the name of the backend using -boption: cargo odra test -b casper  In the example above, Cargo Odra builds the project, generates the wasm files, spin up CasperVM instance, deploys the contracts onto it and runs the tests against it. Pretty neat. Keep in mind that this is a lot slower than OdraVM and you cannot use the debugger. This is why OdraVM was created and should be your first choice when developing contracts. Of course, testing all of your code against a blockchain VM is a must in the end. If you want to run only some of the tests, you can pass arguments to the cargo test command (which is run in the background obviously): cargo odra test -- this-will-be-passed-to-cargo-test  If you want to run tests which names contain the word two, you can execute: cargo odra test -- two  Of course, you can do the same when using the backend: cargo odra test -b casper -- two  ","version":"next","tagName":"h2"},{"title":"Building code​","type":1,"pageTitle":"Cargo Odra","url":"/docs/next/basics/cargo-odra#building-code","content":"You can also build the code itself and generate the output contracts without running the tests. To do so, simply run: cargo odra build  If the build process finishes successfully, wasm files will be located in wasm folder. Notice, that this command does not require the -b option. If you want to build specific contract, you can use -c option: cargo odra build -c counter # you pass many comma separated contracts  ","version":"next","tagName":"h2"},{"title":"Skipping building​","type":1,"pageTitle":"Cargo Odra","url":"/docs/next/basics/cargo-odra#skipping-building","content":"As building wasm files can take a long time, especially if you have a lot of contracts. If you did not change anything in your contracts and you just want to rerun the tests for the casper backend, use the -s option: cargo odra test -b casper -s  ","version":"next","tagName":"h2"},{"title":"Generating contract schema​","type":1,"pageTitle":"Cargo Odra","url":"/docs/next/basics/cargo-odra#generating-contract-schema","content":"If you want to generate a schema (including the name, entrypoints, events, etc.) for your contract, you can use the schema command: cargo odra schema  This generates a schema file in JSON format for all your contracts and places them in the resources folder. If the resources folder does not exist, it creates the folder for you. Like with the build command, you can use the -c option to generate a schema for a specific contract. ","version":"next","tagName":"h2"},{"title":"What's next​","type":1,"pageTitle":"Cargo Odra","url":"/docs/next/basics/cargo-odra#whats-next","content":"In the next section, we will take a look at all the files and directories that cargo odra created for us and explain their purpose. ","version":"next","tagName":"h2"},{"title":"Host Communication","type":0,"sectionRef":"#","url":"/docs/next/basics/communicating-with-host","content":"","keywords":"","version":"next"},{"title":"What's next​","type":1,"pageTitle":"Host Communication","url":"/docs/next/basics/communicating-with-host#whats-next","content":"In the next article, we'll dive into testing your contracts with Odra, so you can check that the code we presented in fact works! ","version":"next","tagName":"h2"},{"title":"directory-structure","type":0,"sectionRef":"#","url":"/docs/next/basics/directory-structure","content":"","keywords":"","version":"next"},{"title":"Directory structure​","type":1,"pageTitle":"directory-structure","url":"/docs/next/basics/directory-structure#directory-structure","content":"After creating a new project using Odra and running the tests, you will be presented with the following files and directories: . ├── Cargo.lock ├── Cargo.toml ├── CHANGELOG.md ├── Odra.toml ├── README.md ├── rust-toolchain ├── src/ │ ├── flipper.rs │ └── lib.rs ├── bin/ | |── build_contract.rs | └── build_schema.rs ├── target/ └── wasm/  ","version":"next","tagName":"h2"},{"title":"Cargo.toml​","type":1,"pageTitle":"directory-structure","url":"/docs/next/basics/directory-structure#cargotoml","content":"Let's first take a look at Cargo.toml file: [package] name = &quot;sample&quot; version = &quot;0.1.0&quot; edition = &quot;2021&quot; [dependencies] odra = &quot;2.2.0&quot; [dev-dependencies] odra-test = &quot;2.2.0&quot; [build-dependencies] odra-build = &quot;2.2.0&quot; [[bin]] name = &quot;sample_build_contract&quot; path = &quot;bin/build_contract.rs&quot; test = false [[bin]] name = &quot;sample_build_schema&quot; path = &quot;bin/build_schema.rs&quot; test = false [profile.release] codegen-units = 1 lto = true [profile.dev.package.&quot;*&quot;] opt-level = 3  By default, your project will use the latest odra version available at crates.io. For testing purposes,odra-test is also added as a dev dependency. ","version":"next","tagName":"h3"},{"title":"Odra.toml​","type":1,"pageTitle":"directory-structure","url":"/docs/next/basics/directory-structure#odratoml","content":"This is the file that holds information about contracts that will be generated when running cargo odra build andcargo odra test: [[contracts]] fqn = &quot;sample::Flipper&quot;  As we can see, we have a single contract, its fqn (Fully Qualified Name) corresponds to the contract is located in src/flipper.rs. More contracts can be added here by hand, or by using cargo odra generate command. ","version":"next","tagName":"h3"},{"title":"src/​","type":1,"pageTitle":"directory-structure","url":"/docs/next/basics/directory-structure#src","content":"This is the folder where your smart contract files live. ","version":"next","tagName":"h3"},{"title":"bin/​","type":1,"pageTitle":"directory-structure","url":"/docs/next/basics/directory-structure#bin","content":"This is the folder where scripts that will be used to generate code or schemas live. You don't need to modify those files, they are generated by cargo odra new command and are used by cargo odra build, cargo odra test and cargo odra schema commands. ","version":"next","tagName":"h3"},{"title":"target/​","type":1,"pageTitle":"directory-structure","url":"/docs/next/basics/directory-structure#target","content":"Files generated by cargo during the build process are put here. ","version":"next","tagName":"h3"},{"title":"wasm/​","type":1,"pageTitle":"directory-structure","url":"/docs/next/basics/directory-structure#wasm","content":"WASM files generated by cargo odra build and cargo odra test are put here. You can grab those WASM files and deploy them on the blockchain. ","version":"next","tagName":"h3"},{"title":"What's next​","type":1,"pageTitle":"directory-structure","url":"/docs/next/basics/directory-structure#whats-next","content":"Now, let's take a look at one of the files mentioned above in more detail, namely the Odra.toml file. ","version":"next","tagName":"h2"},{"title":"Cross calls","type":0,"sectionRef":"#","url":"/docs/next/basics/cross-calls","content":"","keywords":"","version":"next"},{"title":"Contract Ref​","type":1,"pageTitle":"Cross calls","url":"/docs/next/basics/cross-calls#contract-ref","content":"We mentioned HostRef already in our Testing article - a host side reference to already deployed contract. In the module context we use a ContractRef instead, to call other contracts. Similarly to the HostRef trait implemetation for the module, the {{ModuleName}}ContractRef is generated automatically, by the #[odra::module] attribute. The reference implements all the public endpoints to the contract (those marked as pub in #[odra::module]impl), and the {{ModuleName}}ContractRef::address() function, which returns the address of the contract. External Contracts Sometimes in our contract, we would like to interact with a someone else's contract, already deployed onto the blockchain. The only thing we know about the contract is the ABI. For that purpose, we use #[odra:external_contract] attribute. This attribute should be applied to a trait. The trait defines the part of the ABI we would like to take advantage of. Let's pretend the MathEngine we defined is an external contract. There is a contract with add() function that adds two numbers somewhere. #[odra::external_contract] pub trait Adder { fn add(&amp;self, n1: u32, n2: u32) -&gt; u32; }  Odra automatically creates the AdderContractRef struct. Having an address, in the module context we can call: struct Contract { adder: External&lt;AdderContractRef&gt; } // in some function self.adder.add(3, 5) // or struct Contract { adder: Var&lt;Address&gt; } // in some function AdderContractRef::new(self.env(), address).add(3, 5)  ","version":"next","tagName":"h2"},{"title":"Loading the contract​","type":1,"pageTitle":"Cross calls","url":"/docs/next/basics/cross-calls#loading-the-contract","content":"Sometimes it is useful to load the deployed contract instead of deploying it by ourselves. This is especially useful when we want to test our contracts in Livenet backend. We can load the contract using load method on the Deployer: examples/bin/erc20_on_livenet.rs fn _load_erc20(env: &amp;HostEnv) -&gt; Erc20HostRef { let address = &quot;hash-d26fcbd2106e37be975d2045c580334a6d7b9d0a241c2358a4db970dfd516945&quot;; let address = Address::from_str(address).unwrap(); Erc20::load(env, address) }  ","version":"next","tagName":"h3"},{"title":"Testing​","type":1,"pageTitle":"Cross calls","url":"/docs/next/basics/cross-calls#testing","content":"Let's see how we can test our cross calls using this knowledge: examples/src/features/cross_calls.rs #[cfg(test)] mod tests { use super::{CrossContract, CrossContractInitArgs, MathEngineHostRef}; use odra::host::{Deployer, NoArgs}; use odra::prelude::*; #[test] fn test_cross_calls() { let test_env = odra_test::env(); let math_engine_contract = MathEngine::deploy(&amp;test_env, NoArgs); let cross_contract = CrossContract::deploy( &amp;test_env, CrossContractInitArgs { math_engine_address: *math_engine_contract.address() } ); assert_eq!(cross_contract.add_using_another(), 8); } }  Each test begins with a clean instance of the blockchain, with no contracts deployed. To test an external contract, we first deploy a MathEngine contract, although we won't directly utilize it. Instead, we only extract its address. Let's continue assuming there is a contract featuring the add() function that we intend to utilize. #[cfg(test)] mod tests { use super::*; use odra::host::{Deployer, NoArgs}; use odra::prelude::*; #[test] fn test_ext() { let test_env = odra_test::env(); let adder = Adder::new(&amp;test_env, get_adder_address(&amp;test_env)).add(3, 5) assert_eq!(adder.add(1, 2), 3); } fn get_adder_address(test_env: &amp;HostEnv) -&gt; Address { let contract = MathEngine::deploy(test_env, NoArgs); contract.address() } }  ","version":"next","tagName":"h2"},{"title":"Errors","type":0,"sectionRef":"#","url":"/docs/next/basics/errors","content":"","keywords":"","version":"next"},{"title":"Testing errors​","type":1,"pageTitle":"Errors","url":"/docs/next/basics/errors#testing-errors","content":"Okay, but how about testing it? Let's write a test that will check if the error is thrown when the caller is not an owner: examples/src/features/handling_errors.rs #[cfg(test)] mod tests { use super::{Error, OwnedContract, OwnedContractInitArgs}; use odra::{host::Deployer, prelude::*}; #[test] fn test_owner_error() { let test_env = odra_test::env(); let owner = test_env.get_account(0); let not_an_owner = test_env.get_account(1); test_env.set_caller(owner); let init_args = OwnedContractInitArgs { name: &quot;OwnedContract&quot;.to_string() }; let mut owned_contract = OwnedContract::deploy(&amp;test_env, init_args); test_env.set_caller(not_an_owner); assert_eq!( owned_contract .try_change_name(&quot;NewName&quot;.to_string()) .unwrap_err(), Error::NotAnOwner.into() ); } }  Each deployed contract is of {{ModuleName}}HostRef type and has try_{{entry_point_name}} functions that return an OdraResult.OwnedContractHostRef implements regular entrypoints: name, owner, change_name, and and safe its safe version: try_name, try_owner, try_change_name. In our example, we are calling try_change_name and expecting an error to be thrown. For assertions, we are using a standard assert_eq! macro. As the contract call returns an OdraError, we need to convert our custom error to OdraError using Into::into(). ","version":"next","tagName":"h2"},{"title":"What's next​","type":1,"pageTitle":"Errors","url":"/docs/next/basics/errors#whats-next","content":"We will learn how to emit and test events using Odra. ","version":"next","tagName":"h2"},{"title":"Casper Contract Schema","type":0,"sectionRef":"#","url":"/docs/next/basics/casper-contract-schema","content":"","keywords":"","version":"next"},{"title":"Odra and CCS​","type":1,"pageTitle":"Casper Contract Schema","url":"/docs/next/basics/casper-contract-schema#odra-and-ccs","content":"There is almost nothing you need to do to use CCS in your Odra project. The only thing to be taken care of is using odra attributes namely: module, event, odra_error and odra_type. The schema will be generated for you and available in the resources directory. note If you forget to register events and errors in the module attribute, the definition remains valid; however, the errors and events will not be incorporated into the schema. src/contract.rs use odra::prelude::*; #[odra::module( // the name of the contract, default is the module name name = &quot;MyContract&quot;, // the version of the contract, default is the version of the crate version = &quot;0.1.0&quot;, // events that the contract can emit, collected recursively if submodules are used events = [ Created, Updated ], // the error enum the contract can revert with, collected recursively if submodules are used errors = MyErrors )] pub struct MyContract { name: Var&lt;String&gt;, owner: Var&lt;Address&gt;, } #[odra::module] impl MyContract { /// Initializes the contract, sets the name and owner and emits an event pub fn init(&amp;mut self, name: String, owner: Address) { self.name.set(name.clone()); self.owner.set(owner.clone()); self.env().emit_event(Created { name }); } /// Updates the name of the contract and emits an event pub fn update(&amp;mut self, name: String) { self.name.set(name.clone()); self.env().emit_event(Updated { name }); } /// Returns the data of the contract pub fn get_data(&amp;self) -&gt; Data { Data { name: self.name.get_or_default(), owner: self.owner.get_or_revert_with(MyErrors::InvalidOwner), } } } // The struct will we visible in the schema in the types section #[odra::odra_type] pub struct Data { name: String, owner: Address, } // The enum variants will we visible in the schema in the errors section #[odra::odra_error] pub enum MyErrors { /// The owner is invalid InvalidOwner, /// The name is invalid InvalidName, } // The struct will we visible in the schema in the types and events section #[odra::event] pub struct Updated { name: String, } // The struct will we visible in the schema in the types section and events section #[odra::event] pub struct Created { name: String, }  ","version":"next","tagName":"h2"},{"title":"Generating the Schema​","type":1,"pageTitle":"Casper Contract Schema","url":"/docs/next/basics/casper-contract-schema#generating-the-schema","content":"To generate the schema run the following cargo-odra command: cargo odra schema # or pass -c flag to generate the schema for a specific contract  ","version":"next","tagName":"h2"},{"title":"Schema Output​","type":1,"pageTitle":"Casper Contract Schema","url":"/docs/next/basics/casper-contract-schema#schema-output","content":"The generated schema will be available in the resources directory. The schema is a JSON file that contains all the information about the contract. Here is an example of the generated schema: resources/my_contract_schema.json { &quot;casper_contract_schema_version&quot;: 1, &quot;toolchain&quot;: &quot;rustc 1.77.0-nightly (5bd5d214e 2024-01-25)&quot;, &quot;authors&quot;: [], &quot;repository&quot;: null, &quot;homepage&quot;: null, &quot;contract_name&quot;: &quot;MyContract&quot;, &quot;contract_version&quot;: &quot;0.1.0&quot;, &quot;types&quot;: [ { &quot;struct&quot;: { &quot;name&quot;: &quot;Created&quot;, &quot;description&quot;: null, &quot;members&quot;: [ { &quot;name&quot;: &quot;name&quot;, &quot;description&quot;: null, &quot;ty&quot;: &quot;String&quot; } ] } }, { &quot;struct&quot;: { &quot;name&quot;: &quot;Data&quot;, &quot;description&quot;: null, &quot;members&quot;: [ { &quot;name&quot;: &quot;name&quot;, &quot;description&quot;: null, &quot;ty&quot;: &quot;String&quot; }, { &quot;name&quot;: &quot;owner&quot;, &quot;description&quot;: null, &quot;ty&quot;: &quot;Key&quot; } ] } }, { &quot;struct&quot;: { &quot;name&quot;: &quot;Updated&quot;, &quot;description&quot;: null, &quot;members&quot;: [ { &quot;name&quot;: &quot;name&quot;, &quot;description&quot;: null, &quot;ty&quot;: &quot;String&quot; } ] } } ], &quot;errors&quot;: [ { &quot;name&quot;: &quot;InvalidName&quot;, &quot;description&quot;: &quot;The name is invalid&quot;, &quot;discriminant&quot;: 1 }, { &quot;name&quot;: &quot;InvalidOwner&quot;, &quot;description&quot;: &quot;The owner is invalid&quot;, &quot;discriminant&quot;: 0 } ], &quot;entry_points&quot;: [ { &quot;name&quot;: &quot;update&quot;, &quot;description&quot;: &quot;Updates the name of the contract and emits an event&quot;, &quot;is_mutable&quot;: true, &quot;arguments&quot;: [ { &quot;name&quot;: &quot;name&quot;, &quot;description&quot;: null, &quot;ty&quot;: &quot;String&quot;, &quot;optional&quot;: false } ], &quot;return_ty&quot;: &quot;Unit&quot;, &quot;is_contract_context&quot;: true, &quot;access&quot;: &quot;public&quot; }, { &quot;name&quot;: &quot;get_data&quot;, &quot;description&quot;: &quot;Returns the data of the contract&quot;, &quot;is_mutable&quot;: false, &quot;arguments&quot;: [], &quot;return_ty&quot;: &quot;Data&quot;, &quot;is_contract_context&quot;: true, &quot;access&quot;: &quot;public&quot; } ], &quot;events&quot;: [ { &quot;name&quot;: &quot;Created&quot;, &quot;ty&quot;: &quot;Created&quot; }, { &quot;name&quot;: &quot;Updated&quot;, &quot;ty&quot;: &quot;Updated&quot; } ], &quot;call&quot;: { &quot;wasm_file_name&quot;: &quot;MyContract.wasm&quot;, &quot;description&quot;: &quot;Initializes the contract, sets the name and owner and emits an event&quot;, &quot;arguments&quot;: [ { &quot;name&quot;: &quot;odra_cfg_package_hash_key_name&quot;, &quot;description&quot;: &quot;The arg name for the package hash key name.&quot;, &quot;ty&quot;: &quot;String&quot;, &quot;optional&quot;: false }, { &quot;name&quot;: &quot;odra_cfg_allow_key_override&quot;, &quot;description&quot;: &quot;The arg name for the allow key override.&quot;, &quot;ty&quot;: &quot;Bool&quot;, &quot;optional&quot;: false }, { &quot;name&quot;: &quot;odra_cfg_is_upgradable&quot;, &quot;description&quot;: &quot;The arg name for the contract upgradeability setting.&quot;, &quot;ty&quot;: &quot;Bool&quot;, &quot;optional&quot;: false }, { &quot;name&quot;: &quot;odra_cfg_is_upgrade&quot;, &quot;description&quot;: &quot;The arg name for the contract upgrade setting.&quot;, &quot;ty&quot;: &quot;Bool&quot;, &quot;optional&quot;: false }, { &quot;name&quot;: &quot;name&quot;, &quot;description&quot;: null, &quot;ty&quot;: &quot;String&quot;, &quot;optional&quot;: false }, { &quot;name&quot;: &quot;owner&quot;, &quot;description&quot;: null, &quot;ty&quot;: &quot;Key&quot;, &quot;optional&quot;: false } ] } }  ","version":"next","tagName":"h2"},{"title":"Schema Fields​","type":1,"pageTitle":"Casper Contract Schema","url":"/docs/next/basics/casper-contract-schema#schema-fields","content":"casper_contract_schema_version is the version of the schema.toolchain is the version of the Rust compiler used to compile the contract.Fields authors, repository, and homepage are optional and can be set in the Cargo.toml file.contract_name is the name of the contract - by default is the module name, may be overriden by the module attribute.contract_version denotes the version of the contract, defaulting to the version specified in the Cargo.toml file, but can be overridden by the module attribute.types comprises a list of custom structs and enums defined within the contract. Each struct or enum includes a name, description (not currently supported, with the value set to null), and a list of members.errors is a list of error enums defined within the contract. Each error includes a name, description (the first line of the variant documentation), and a discriminant.entry_points is a list of contract functions that can be called from the outside. Each entry point includes a name, description (not currently supported, with the value set to null), whether the function is mutable, a list of arguments, the return type, whether the function is called in the contract context, and the access level.events is a list of events that the contract can emit. Each event includes a name and the type (earlier defined in types) of the event.The call section provides details regarding the contract's call function, which executes upon contract deployment. It includes the name of the Wasm file, a description (reflecting the constructor's description, typically the init function), and a list of arguments. These arguments are a combination of Odra configuration arguments and constructor arguments. ","version":"next","tagName":"h2"},{"title":"Flipper Internals","type":0,"sectionRef":"#","url":"/docs/next/basics/flipper-internals","content":"","keywords":"","version":"next"},{"title":"Header​","type":1,"pageTitle":"Flipper Internals","url":"/docs/next/basics/flipper-internals#header","content":"flipper.rs use odra::prelude::*;  The first line of the file imports the odra crate. The prelude module contains all the necessary types and traits that you will need to write your contract. It is a good practice to import theodra::prelude::* module in every file that contains Odra code. This way, you will not have to import each type or trait separately. ","version":"next","tagName":"h2"},{"title":"Struct​","type":1,"pageTitle":"Flipper Internals","url":"/docs/next/basics/flipper-internals#struct","content":"flipper.rs /// A module definition. Each module struct consists of Vars and Mappings /// or/and other modules. #[odra::module] pub struct Flipper { /// The module itself does not store the value, /// it's a proxy that writes/reads value to/from the host. value: Var&lt;bool&gt;, }  In Odra, all contracts are also modules, which can be reused between contracts. That's why we need to mark the struct with the #[odra::module] attribute. In the struct definition itself, we state all the fields of the contract. Those fields can be regular Rust data types, however - those will not be persisted on the blockchain. They can also be Odra modules - defined in your project or coming from Odra itself. Finally, to make the data persistent on the blockchain, you can use something likeVar&lt;T&gt; showed above. To learn more about storage interaction, take a look at thenext article. ","version":"next","tagName":"h2"},{"title":"Impl​","type":1,"pageTitle":"Flipper Internals","url":"/docs/next/basics/flipper-internals#impl","content":"flipper.rs /// Module implementation. /// /// To generate entrypoints, /// an implementation block must be marked as #[odra::module]. #[odra::module] impl Flipper { /// Odra constructor. /// /// Initializes the contract with the value of value. pub fn init(&amp;mut self) { self.value.set(false); } ...  Similarly to the struct, we mark the impl section with the #[odra::module] attribute. Odra will take allpub functions from this section and create contract endpoints from them. So, if you wish to have functions that are not available for calling outside the contract, do not make them public. Alternatively, you can create a separate impl section without the attribute - all functions defined there, even marked with pub will be not callable. The function named init is the constructor of the contract. This function will be limited only to a single call, all further calls to it will result in an error. The init function is optional, if your contract does not need any initialization, you can skip it. flipper.rs ... /// Replaces the current value with the passed argument. pub fn set(&amp;mut self, value: bool) { self.value.set(value); } /// Replaces the current value with the opposite value. pub fn flip(&amp;mut self) { self.value.set(!self.get()); } ...  The endpoints above show you how to interact with the simplest type of storage - Var&lt;T&gt;. The data saved there using set function will be persisted in the blockchain. ","version":"next","tagName":"h2"},{"title":"Tests​","type":1,"pageTitle":"Flipper Internals","url":"/docs/next/basics/flipper-internals#tests","content":"flipper.rs #[cfg(test)] mod tests { use crate::flipper::Flipper; use odra::host::{Deployer, NoArgs}; #[test] fn flipping() { let env = odra_test::env(); // To test a module we need to deploy it. `Flipper` implements `Deployer` trait, // so we can use it to deploy the module. let mut contract = Flipper::deploy(&amp;env, NoArgs); assert!(!contract.get()); contract.flip(); assert!(contract.get()); } ...  You can write tests in any way you prefer and know in Rust. In the example above we are deploying the contract using Deployer::deploy function called on Flipper - a piece of code generated by the #[odra::module]. Because the module implements the constructor but does not accept any arguments, as the second argument of the deploy function, we pass NoArgs - one of the implementations of the InitArgs trait provided with the framework. The contract will be deployed on the VM you chose while running cargo odra test. ","version":"next","tagName":"h2"},{"title":"What's next​","type":1,"pageTitle":"Flipper Internals","url":"/docs/next/basics/flipper-internals#whats-next","content":"Now let's take a look at the different types of storage that Odra provides and how to use them. ","version":"next","tagName":"h2"},{"title":"Events","type":0,"sectionRef":"#","url":"/docs/next/basics/events","content":"","keywords":"","version":"next"},{"title":"Testing events​","type":1,"pageTitle":"Events","url":"/docs/next/basics/events#testing-events","content":"Odra's HostEnv comes with a few functions which lets you easily test the events that a given contract has emitted: examples/src/features/events.rs use super::{PartyContract, PartyStarted}; use odra::host::{Deployer, HostEnv, NoArgs}; #[test] fn test_party() { let test_env: HostEnv = odra_test::env(); let party_contract = PartyContract::deploy(&amp;test_env, NoArgs); assert!(test_env.emitted_event( &amp;party_contract, PartyStarted { caller: test_env.get_account(0), block_time: 0 } )); assert!(test_env.emitted_native_event( &amp;party_contract, NativePartyStarted { caller: test_env.get_account(0), block_time: 0 } )); // If you do not want to check the exact event, you can use `emitted` function assert!(test_env.emitted(&amp;party_contract, &quot;PartyStarted&quot;)); // Or `emitted_native` for the native events assert!(test_env.emitted_native(&amp;party_contract, &quot;NativePartyStarted&quot;)); // You can also check how many events were emitted: assert_eq!(test_env.events_count(&amp;party_contract), 1); assert_eq!(test_env.native_events_count(&amp;party_contract), 1); }  To explore more event testing functions, check the HostEnv documentation. ","version":"next","tagName":"h2"},{"title":"What's next​","type":1,"pageTitle":"Events","url":"/docs/next/basics/events#whats-next","content":"Read the next article to learn how to call other contracts from the contract context. ","version":"next","tagName":"h2"},{"title":"Modules","type":0,"sectionRef":"#","url":"/docs/next/basics/modules","content":"","keywords":"","version":"next"},{"title":"Testing​","type":1,"pageTitle":"Modules","url":"/docs/next/basics/modules#testing","content":"As we don't need to hold addresses, the test is really simple: examples/src/features/modules.rs #[cfg(test)] mod tests { use super::ModulesContract; use odra::host::{Deployer, NoArgs}; #[test] fn test_modules() { let test_env = odra_test::env(); let modules_contract = ModulesContract::deploy(&amp;test_env, NoArgs); assert_eq!(modules_contract.add_using_module(), 8); } }  ","version":"next","tagName":"h2"},{"title":"What's next​","type":1,"pageTitle":"Modules","url":"/docs/next/basics/modules#whats-next","content":"We will see how to handle native token transfers. ","version":"next","tagName":"h2"},{"title":"Odra.toml","type":0,"sectionRef":"#","url":"/docs/next/basics/odra-toml","content":"","keywords":"","version":"next"},{"title":"Adding a new contract manually​","type":1,"pageTitle":"Odra.toml","url":"/docs/next/basics/odra-toml#adding-a-new-contract-manually","content":"Besides using the cargo odra generate command, you can add a new contract to be compiled by hand. To do this, add another [[contracts]] element, name it and make sure that the fqn is set correctly. For example, if you want to create a new contract called counter, your Odra.toml file should finally look like this: [[contracts]] fqn = &quot;sample::Flipper&quot; [[contracts]] fqn = &quot;sample::Counter&quot;  ","version":"next","tagName":"h2"},{"title":"What's next​","type":1,"pageTitle":"Odra.toml","url":"/docs/next/basics/odra-toml#whats-next","content":"In the next section, we'll take a closer look at the code that was generated by Odra by default - the famousFlipper contract. ","version":"next","tagName":"h2"},{"title":"Native token","type":0,"sectionRef":"#","url":"/docs/next/basics/native-token","content":"","keywords":"","version":"next"},{"title":"Testing​","type":1,"pageTitle":"Native token","url":"/docs/next/basics/native-token#testing","content":"To be able to test how many tokens a contract (or any address) has, HostEnv comes with a function -balance_of: examples/src/features/native_token.rs #[cfg(test)] mod tests { use super::PublicWallet; use odra::{casper_types::U512, host::{Deployer, HostRef, NoArgs}}; #[test] fn test_modules() { let test_env = odra_test::env(); let mut my_contract = PublicWallet::deploy(&amp;test_env, NoArgs); assert_eq!(test_env.balance_of(&amp;my_contract), U512::zero()); my_contract.with_tokens(U512::from(100)).deposit(); assert_eq!(test_env.balance_of(&amp;my_contract), U512::from(100)); my_contract.withdraw(U512::from(25)); assert_eq!(test_env.balance_of(&amp;my_contract), U512::from(75)); } }  ","version":"next","tagName":"h2"},{"title":"HostEnv​","type":1,"pageTitle":"Native token","url":"/docs/next/basics/native-token#hostenv","content":"In a broader context of the host environment (test, livenet), you can also transfer CSPR tokens between accounts: let env = odra_casper_livenet_env::env(); //let env = odra_test::env(); let (alice, bob) = (env.get_account(0), env.get_account(1)); env.set_caller(alice); let result = env.transfer_tokens(bob, odra::casper_types::U512::from(100));  ","version":"next","tagName":"h2"},{"title":"Testing","type":0,"sectionRef":"#","url":"/docs/next/basics/testing","content":"","keywords":"","version":"next"},{"title":"HostEnv​","type":1,"pageTitle":"Testing","url":"/docs/next/basics/testing#hostenv","content":"Odra gives us some additional functions that we can use to communicate with the host (outside the contract context) and to configure how the contracts are deployed and called. Let's revisit the example from the previous article about host communication and implement the tests that prove it works: examples/src/features/testing.rs #[cfg(test)] mod tests { use crate::features::testing::{TestingContract, TestingContractInitArgs}; use odra::{host::{Deployer, HostEnv}, prelude::*}; #[test] fn env() { let test_env: HostEnv = odra_test::env(); test_env.set_caller(test_env.get_account(0)); let init_args = TestingContractInitArgs { name: &quot;MyContract&quot;.to_string() }; let testing_contract = TestingContract::deploy(&amp;test_env, init_args); let creator = testing_contract.created_by(); test_env.set_caller(test_env.get_account(1)); let init_args = TestingContractInitArgs { name: &quot;MyContract2&quot;.to_string() }; let testing_contract2 = TestingContract::deploy(&amp;test_env, init_args); let creator2 = testing_contract2.created_by(); assert_ne!(creator, creator2); } }  In the code above, at the beginning of the test, we are obtaining a HostEnv instance using odra_test::env(). Next, we are deploying two instances of the same contract, but we're using HostEnv::set_callerto change the caller - so the Address which is deploying the contract. This changes the result of the odra::ContractEnv::caller()the function we are calling inside the contract. HostEnv comes with a set of functions that will let you write better tests: fn set_caller(&amp;self, address: Address) - you've seen it in action just nowfn balance_of&lt;T: Addressable&gt;(&amp;self, addr: &amp;T) -&gt; U512 - returns the balance of the account associated with the given addressfn advance_block_time(&amp;self, time_diff: u64) - increases the current value of block_timefn get_account(&amp;self, n: usize) -&gt; Address - returns an n-th address that was prepared for you by Odra in advance; by default, you start with the 0-th accountfn emitted_event&lt;T: ToBytes + EventInstance, R: Addressable&gt;(&amp;self, contract_address: &amp;R, event: T) -&gt; bool - verifies if the event was emitted by the contract Full list of functions can be found in the HostEnv documentation. ","version":"next","tagName":"h2"},{"title":"What's next​","type":1,"pageTitle":"Testing","url":"/docs/next/basics/testing#whats-next","content":"We take a look at how Odra handles errors! ","version":"next","tagName":"h2"},{"title":"Storage interaction","type":0,"sectionRef":"#","url":"/docs/next/basics/storage-interaction","content":"","keywords":"","version":"next"},{"title":"Var​","type":1,"pageTitle":"Storage interaction","url":"/docs/next/basics/storage-interaction#var","content":"The Var is the simplest storage type available in the Odra framework. It serializes the data and stores it under a single key in the blockchain storage. To use it, just wrap your variable in the Var type. Let's look at a &quot;real world&quot; example of a contract that represents a dog: examples/src/features/storage/variable.rs use odra::prelude::*; #[odra::module] pub struct DogContract { barks: Var&lt;bool&gt;, weight: Var&lt;u32&gt;, name: Var&lt;String&gt;, walks: Var&lt;Vec&lt;u32&gt;&gt;, }  You can see the Var wrapping the data. Even complex types like Vec can be wrapped (with some caveats)! Let's make this contract usable, by providing a constructor and some getter functions: examples/src/features/storage/variable.rs #[odra::module] impl DogContract { pub fn init(&amp;mut self, barks: bool, weight: u32, name: String) { self.barks.set(barks); self.weight.set(weight); self.name.set(name); self.walks.set(Vec::&lt;u32&gt;::default()); } pub fn barks(&amp;self) -&gt; bool { self.barks.get_or_default() } pub fn weight(&amp;self) -&gt; u32 { self.weight.get_or_default() } pub fn name(&amp;self) -&gt; String { self.name.get_or_default() } pub fn walks_amount(&amp;self) -&gt; u32 { let walks = self.walks.get_or_default(); walks.len() as u32 } pub fn walks_total_length(&amp;self) -&gt; u32 { let walks = self.walks.get_or_default(); walks.iter().sum() } }  As you can see, you can access the data, by using get_or_default function: examples/src/features/storage/variable.rs ... self.barks.get_or_default() ...  note Keep in mind that using get() will result in an Option that you'll need to unwrap - the variable doesn't have to be initialized! To modify the data, use the set() function: examples/src/features/storage/variable.rs self.barks.set(barks);  A Var is easy to use and efficient for simple data types. One of its downsides is that it serializes the data as a whole, so when you're using complex types like Vec or HashMap, each time you get or set the whole data is read and written to the blockchain storage. In the example above, if we want to see how many walks our dog had, we would use the function: examples/src/features/storage/variable.rs pub fn walks_amount(&amp;self) -&gt; usize { let walks = self.walks.get_or_default(); walks.len() }  But to do so, we need to extract the whole serialized vector from the storage, which would inefficient, especially for larger sets of data. To tackle this issue following two types were created. ","version":"next","tagName":"h2"},{"title":"Mapping​","type":1,"pageTitle":"Storage interaction","url":"/docs/next/basics/storage-interaction#mapping","content":"The Mapping is used to store and access data as key-value pairs. To define a Mapping, you need to pass two values - the key type and the value type. Let's look at the variation of the Dog contract, that uses Mapping to store information about our dog's friends and how many times they visited: examples/src/features/storage/mapping.rs use odra::prelude::*; #[odra::module] pub struct DogContract2 { name: Var&lt;String&gt;, friends: Mapping&lt;String, u32&gt;, }  In the example above, our key is a String (it is a name of the friend) and we are storing u32 values (amount of visits). To read and write values from and into a Mapping we use a similar approach to the one shown in the Vars section with one difference - we need to pass a key: examples/src/features/storage/mapping.rs pub fn visit(&amp;mut self, friend_name: String) { let visits = self.visits(friend_name.clone()); self.friends.set(&amp;friend_name, visits + 1); } pub fn visits(&amp;self, friend_name: String) -&gt; u32 { self.friends.get_or_default(&amp;friend_name) }  The biggest improvement over a Var is that we can model functionality of a HashMap using Mapping. The amount of data written to and read from the storage is minimal. However, we cannot iterate over Mapping. We could implement such behavior by using a numeric type key and saving the length of the set in a separate variable. Thankfully Odra comes with a prepared solution - the List type. note If you take a look into List implementation in Odra, you'll see that in fact it is just a Mapping with a Var working together: core/src/list.rs use odra::prelude::*; pub struct List&lt;T&gt; { values: Mapping&lt;u32, T&gt;, index: Var&lt;u32&gt; }  ","version":"next","tagName":"h2"},{"title":"List​","type":1,"pageTitle":"Storage interaction","url":"/docs/next/basics/storage-interaction#list","content":"Going back to our DogContract example - let's revisit the walk case. This time, instead of Vec, we'll use the list: examples/src/features/storage/list.rs use odra::prelude::*; #[odra::module] pub struct DogContract3 { name: Var&lt;String&gt;, walks: List&lt;u32&gt;, }  As you can see, the notation is very similar to the Vec. To understand the usage, take a look at the reimplementation of the functions with an additional function that takes our dog for a walk (it writes the data to the storage): examples/src/features/storage/list.rs #[odra::module] impl DogContract3 { pub fn init(&amp;mut self, name: String) { self.name.set(name); } pub fn name(&amp;self) -&gt; String { self.name.get_or_default() } pub fn walks_amount(&amp;self) -&gt; u32 { self.walks.len() } pub fn walks_total_length(&amp;self) -&gt; u32 { self.walks.iter().sum() } pub fn walk_the_dog(&amp;mut self, length: u32) { self.walks.push(length); } }  Now, we can know how many walks our dog had without loading the whole vector from the storage. We need to do this to sum the length of all the walks, but the Odra framework cannot (yet) handle all the cases for you. info All of the above examples, alongside the tests, are available in the Odra repository in the examples/src/features/ folder. ","version":"next","tagName":"h2"},{"title":"Custom Types​","type":1,"pageTitle":"Storage interaction","url":"/docs/next/basics/storage-interaction#custom-types","content":"By default you can store only built-in types like numbers, Options, Results, Strings, Vectors. Implementing custom types is straightforward, your type must add #[odra::odra_type] attribute. Let's see how to implement a Dog type: use odra::prelude::*; #[odra::odra_type] pub struct Dog { pub name: String, pub age: u8, pub owner: Option&lt;Address&gt; }  #[odra_type] is applicable to named field structs and enums. It generates serialization, deserialization and schema code for your type.CLType of a custom type is CLType::Any, except for an unit-only enum, which is CLType::U8. unit_only_enum.rs enum Enum { Foo = 3, Bar = 2, Baz = 1, }  note Each custom typed field of your struct must be marked with the #[odra::odra_type] attribute . ","version":"next","tagName":"h2"},{"title":"What's next​","type":1,"pageTitle":"Storage interaction","url":"/docs/next/basics/storage-interaction#whats-next","content":"In the next article, we'll see how to query the host for information about the world and our contract. ","version":"next","tagName":"h2"},{"title":"odra-examples","type":0,"sectionRef":"#","url":"/docs/next/examples/odra-examples","content":"","keywords":"","version":"next"},{"title":"What's next​","type":1,"pageTitle":"odra-examples","url":"/docs/next/examples/odra-examples#whats-next","content":"Read the next article to learn about reusable Odra components encapsulated in odra-modules. ","version":"next","tagName":"h2"},{"title":"Odra for Solidity developers","type":0,"sectionRef":"#","url":"/docs/2.3.0/tutorials/odra-solidity","content":"","keywords":"","version":"2.3.0"},{"title":"Introduction​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.3.0/tutorials/odra-solidity#introduction","content":"Hi, stranger Solidity developer! If you are looking to expand your horizons into Rust-based smart contract development, you've come to the right place. Odra is a high-level framework designed to simplify the development of smart contracts for the Casper Network. This tutorial will guide you through the basics of transitioning from Solidity to Odra, highlighting key differences and providing practical examples. Before we delve into the details, we have great news for you. From the very beginning, we have been thinking of you. Our main goal was to design the framework in a way that flattens the learning curve, especially for Solidity developers. ","version":"2.3.0","tagName":"h2"},{"title":"Prerequisites​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.3.0/tutorials/odra-solidity#prerequisites","content":"To follow this guide, you should have: Knowledge of Solidity.Familiarity with Ethereum and smart contract concepts.Basic understanding of Rust, as Odra is based on it. ","version":"2.3.0","tagName":"h2"},{"title":"Hello World​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.3.0/tutorials/odra-solidity#hello-world","content":"Let's start with a simple &quot;Hello World&quot; contract in Odra. The following code snippet demonstrates a basic smart contract that stores a greeting message. OdraSolidity use odra::prelude::*; #[odra::module] pub struct HelloWorld { greet: Var&lt;String&gt;, } #[odra::module] impl HelloWorld { pub fn init(&amp;mut self, message: String) { self.greet.set(message); } pub fn get(&amp;self) -&gt; String { self.greet.get_or_default() } }  As you may have noticed, the Odra code is slightly more verbose than the Solidity code. To define a contract in Odra, you need to create a struct and implement a module for it, both annotated with the odra::module attribute. The struct contains the contract's state variables, while the module defines the contract's functions. In this example, the HelloWorld struct has a single state variable greet, which stores the greeting message. The module contains two functions: init to set the greeting message and get to retrieve it. Two key differences are: Odra does not generate getters for public state variables automatically, so you need to define them explicitly.To initialize values, you must do it in the init function, which is the contract constructor. You can't assign defaults outside the constructor. ","version":"2.3.0","tagName":"h2"},{"title":"Variable Storage and State Management​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.3.0/tutorials/odra-solidity#variable-storage-and-state-management","content":"","version":"2.3.0","tagName":"h2"},{"title":"Data Types​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.3.0/tutorials/odra-solidity#data-types","content":"OdraSolidity use core::str::FromStr; use odra::{casper_types::{bytesrepr::Bytes, U256}, prelude::*}; #[odra::module] pub struct Primitives { boo: Var&lt;bool&gt;, u: Var&lt;u8&gt;, // u8 is the smallest unsigned integer type u2: Var&lt;U256&gt;, // U256 is the biggest unsigned integer type i: Var&lt;i32&gt;, // i32 is the smallest signed integer type i2: Var&lt;i64&gt;, // i64 is the biggest signed integer type address: Var&lt;Address&gt;, bytes: Var&lt;Bytes&gt;, default_boo: Var&lt;bool&gt;, default_uint: Var&lt;U256&gt;, default_int: Var&lt;i64&gt;, default_addr: Var&lt;Address&gt;, } #[odra::module] impl Primitives { pub fn init(&amp;mut self) { self.boo.set(true); self.u.set(1); self.u2.set(U256::from(456)); self.i.set(-1); self.i2.set(456); self.address.set( Address::from_str( &quot;hash-d4b8fa492d55ac7a515c0c6043d72ba43c49cd120e7ba7eec8c0a330dedab3fb&quot;, ) .unwrap_or_revert(&amp;self.env()), ); self.bytes.set(Bytes::from(vec![0xb5])); let _min_int = U256::zero(); let _max_int = U256::MAX; } // For the types that have default values, we can use the get_or_default method pub fn get_default_boo(&amp;self) -&gt; bool { self.default_boo.get_or_default() } pub fn get_default_uint(&amp;self) -&gt; U256 { self.default_uint.get_or_default() } pub fn get_default_int(&amp;self) -&gt; i64 { self.default_int.get_or_default() } // Does not compile - Address does not have the default value pub fn get_default_addr(&amp;self) -&gt; Address { self.default_addr.get_or_default() } }  The range of integer types in Odra is slightly different from Solidity. Odra provides a wide range of integer types: u8, u16, u32, u64, U128, and U256 for unsigned integers, and i32 and i64 for signed integers. The Address type in Odra is used to represent account and contract addresses. In Odra, there is no default/zero value for the Address type; the workaround is to use Option&lt;Address&gt;. The Bytes type is used to store byte arrays. Values are stored in units called Named Keys and Dictionaries. Additionally, local variables are available within the entry points and can be used to perform necessary actions or computations within the scope of each entry point. ","version":"2.3.0","tagName":"h3"},{"title":"Constants and Immutability​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.3.0/tutorials/odra-solidity#constants-and-immutability","content":"OdraSolidity use odra::{casper_types::{account::AccountHash, U256}, prelude::*}; #[odra::module] pub struct Constants; #[odra::module] impl Constants { pub const MY_UINT: U256 = U256([123, 0, 0, 0]); pub const MY_ADDRESS: Address = Address::Account( AccountHash([0u8; 32]) ); }  In Odra, you can define constants using the const keyword. Constants are immutable and can be of any type, including custom types. In addition to constants, Solidity also supports the immutable keyword, which is used to set the value of a variable once, in the constructor. Further attempts to alter this value result in a compile error. Odra/Rust does not have an equivalent to Solidity's immutable keyword. ","version":"2.3.0","tagName":"h3"},{"title":"Variables​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.3.0/tutorials/odra-solidity#variables","content":"OdraSolidity use odra::{casper_types::U256, prelude::*}; #[odra::module] pub struct Variables { text: Var&lt;String&gt;, my_uint: Var&lt;U256&gt;, } #[odra::module] impl Variables { pub fn init(&amp;mut self) { self.text.set(&quot;Hello&quot;.to_string()); self.my_uint.set(U256::from(123)); } pub fn do_something(&amp;self) { // Local variables let i = 456; // Env variables let timestamp = self.env().get_block_time(); let sender = self.env().caller(); } }  In Solidity there are three types of variables: state variables, local variables, and global variables. State variables are stored on the blockchain and are accessible by all functions within the contract. Local variables are not stored on the blockchain and are only available within the function in which they are declared. Global variables provide information about the blockchain. Odra uses very similar concepts, but with some differences. In Odra, state variables are a part of a module definition, and local variables are available within the entry points and can be used to perform necessary actions or computations within the scope of each entry point. Global variables are accessed using an instance of ContractEnv retrieved using the env() function. ","version":"2.3.0","tagName":"h3"},{"title":"Arrays and Mappings​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.3.0/tutorials/odra-solidity#arrays-and-mappings","content":"OdraSolidity use odra::{casper_types::U256, prelude::*}; #[odra::module] pub struct MappingContract { my_map: Mapping&lt;Address, Option&lt;U256&gt;&gt; } #[odra::module] impl MappingContract { pub fn get(&amp;self, addr: Address) -&gt; U256 { // self.my_map.get(&amp;addr) would return Option&lt;Option&lt;U256&gt;&gt; // so we use get_or_default instead and unwrap the inner Option self.my_map.get_or_default(&amp;addr).unwrap_or_default() } pub fn set(&amp;mut self, addr: Address, i: U256) { self.my_map.set(&amp;addr, Some(i)); } pub fn remove(&amp;mut self, addr: Address) { self.my_map.set(&amp;addr, None); } } #[odra::module] pub struct NestedMapping { my_map: Mapping&lt;(Address, U256), Option&lt;bool&gt;&gt; } #[odra::module] impl NestedMapping { pub fn get(&amp;self, addr: Address, i: U256) -&gt; bool { self.my_map.get_or_default(&amp;(addr, i)).unwrap_or_default() } pub fn set(&amp;mut self, addr: Address, i: U256, boo: bool) { self.my_map.set(&amp;(addr, i), Some(boo)); } pub fn remove(&amp;mut self, addr: Address, i: U256) { self.my_map.set(&amp;(addr, i), None); } }  OdraSolidity use odra::prelude::*; #[odra::module] pub struct Array { // the size of the array must be known at compile time arr: Var&lt;[u8; 10]&gt;, vec: Var&lt;Vec&lt;u32&gt;&gt;, } #[odra::module] impl Array { pub fn init(&amp;mut self) { self.arr.set([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]); self.vec.set(vec![1, 2, 3, 4, 5]); } pub fn get_arr(&amp;self) -&gt; [u8; 10] { self.arr.get_or_default() } pub fn push_vec(&amp;mut self, value: u32) { let mut vec = self.vec.get_or_default(); vec.push(value); self.vec.set(vec); } pub fn pop_vec(&amp;mut self) { let mut vec = self.vec.get_or_default(); vec.pop(); self.vec.set(vec); } pub fn update_arr(&amp;mut self, index: u8, value: u8) { let mut arr = self.arr.get_or_default(); arr[index as usize] = value; self.arr.set(arr); } }  For storing a collection of data as a single unit, Odra uses the Vec type for dynamic arrays and fixed-size arrays, both wrapped with the Var container. As in Solidity, you must be aware that reading the entire array in one go can be expensive, so it's better to avoid it for large arrays. In many cases, you can use a Mapping or List instead of an array or vector to store data. ","version":"2.3.0","tagName":"h3"},{"title":"Custom types​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.3.0/tutorials/odra-solidity#custom-types","content":"OdraSolidity use odra::prelude::*; #[odra::odra_type] #[derive(Default)] pub enum Status { #[default] Pending, Shipped, Accepted, Rejected, Canceled, } #[odra::module] pub struct Enum { status: Var&lt;Status&gt;, } #[odra::module] impl Enum { pub fn get(&amp;self) -&gt; Status { self.status.get_or_default() } pub fn set(&amp;mut self, status: Status) { self.status.set(status); } pub fn cancel(&amp;mut self) { self.status.set(Status::Canceled); } pub fn reset(&amp;mut self) { self.status.set(Default::default()); } }  In Odra, custom types are defined using the #[odra::odra_type] attribute. The enum can have a default value specified using the #[default] attribute if derived from the Default trait. The enum can be used as a state variable in a contract, and its value can be set and retrieved using the set and get functions. The value cannot be deleted; however, it can be set using the Default::default() function. OdraSolidity use odra::prelude::*; #[odra::odra_type] pub struct Todo { text: String, completed: bool, } #[odra::module] pub struct Enum { // You could also use Var&lt;Vec&lt;Todo&gt;&gt; instead of List&lt;Todo&gt;, // but List is more efficient for large arrays, // it loads items lazily. todos: List&lt;Todo&gt;, } #[odra::module] impl Enum { pub fn create(&amp;mut self, text: String) { self.todos.push(Todo { text, completed: false, }); } pub fn update_text(&amp;mut self, index: u32, text: String) { if let Some(mut todo) = self.todos.get(index) { todo.text = text; self.todos.replace(index, todo); } } pub fn toggle_complete(&amp;mut self, index: u32) { if let Some(mut todo) = self.todos.get(index) { todo.completed = !todo.completed; self.todos.replace(index, todo); } } // Odra does not create getters by default pub fn get(&amp;self, index: u32) -&gt; Option&lt;Todo&gt; { self.todos.get(index) } }  Similarly to enums, custom structs are defined using the #[odra::odra_type] attribute. The struct can be used to define a list of items in a contract. The list can be created using the List type, which is more efficient for large arrays as it loads items lazily. ","version":"2.3.0","tagName":"h3"},{"title":"Data Location​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.3.0/tutorials/odra-solidity#data-location","content":"In Solidity, data location is an important concept that determines where the data is stored and how it can be accessed. The data location can be memory, storage, or calldata. In Odra, data location is not explicitly defined, but whenever interacting with storage primitives (e.g., Var, Mapping, List), the data is stored in the contract's storage. ","version":"2.3.0","tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.3.0/tutorials/odra-solidity#functions","content":"Odra contracts define their entry point and internal functions within the impl block. Here's an example of a transfer function: impl Erc20 { pub fn transfer(&amp;mut self, recipient: &amp;Address, amount: &amp;U256) { self.internal_transfer(&amp;self.env().caller(), recipient, amount); // Transfer logic goes here } fn internal_transfer(&amp;mut self, sender: &amp;Address, recipient: &amp;Address, amount: &amp;U256) { // Internal transfer logic goes here } }  Functions can modify contract state and emit events using the ContractEnv function. ","version":"2.3.0","tagName":"h2"},{"title":"View and Pure​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.3.0/tutorials/odra-solidity#view-and-pure","content":"OdraSolidity use odra::prelude::*; #[odra::module] pub struct ViewAndPure { x: Var&lt;u32&gt; } #[odra::module] impl ViewAndPure { pub fn add_to_x(&amp;self, y: u32) -&gt; u32 { self.x.get_or_default() + y } } pub fn add(i: u32, j: u32) -&gt; u32 { i + j }  In Odra, you don't need to specify view or pure functions explicitly. All functions are considered view functions by default, meaning they can read contract state but not modify it. To modify the state, the first parameter (called the receiver parameter) should be &amp;mut self. If you want to create a pure function that doesn't read or modify state, you can define it as a regular Rust function without any side effects. ","version":"2.3.0","tagName":"h3"},{"title":"Modifiers​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.3.0/tutorials/odra-solidity#modifiers","content":"OdraSolidity use odra::prelude::*; #[odra::module] pub struct FunctionModifier { x: Var&lt;u32&gt;, locked: Var&lt;bool&gt;, } #[odra::module] impl FunctionModifier { pub fn decrement(&amp;mut self, i: u32) { self.lock(); self.x.set(self.x.get_or_default() - i); if i &gt; 1 { self.decrement(i - 1); } self.unlock(); } #[inline] fn lock(&amp;mut self) { if self.locked.get_or_default() { self.env().revert(Error::NoReentrancy); } self.locked.set(true); } #[inline] fn unlock(&amp;mut self) { self.locked.set(false); } } #[odra::odra_error] pub enum Error { NoReentrancy = 1, }  In Odra, there is no direct equivalent to Solidity's function modifiers. Instead, you can define functions that perform certain actions before or after the main function logic. In the example above, the lock and unlock functions are called before and after the decrement function, respectively, but they must be called explicitly. As often as practicable, developers should inline functions by including the body of the function within their code using the #[inline] attribute. In the context of coding for Casper blockchain purposes, this reduces the overhead of executed Wasm and prevents unexpected errors due to exceeding resource tolerances. ","version":"2.3.0","tagName":"h3"},{"title":"Visibility​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.3.0/tutorials/odra-solidity#visibility","content":"Functions and state variables have to declare whether they are accessible by other contracts. Functions can be declared as: OdraSolidity `pub` inside `#[odra::module]` impl block - any contract/submodule and account can call. `pub` inside a regular impl block - any submodule can call. `default/no modifier/private` - only inside the contract that defines the function.  ","version":"2.3.0","tagName":"h3"},{"title":"Payable​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.3.0/tutorials/odra-solidity#payable","content":"OdraSolidity use odra::{casper_types::U512, prelude::*}; #[odra::module] pub struct Payable { owner: Var&lt;Address&gt;, } #[odra::module] impl Payable { pub fn init(&amp;mut self) { self.owner.set(self.env().caller()); } #[odra(payable)] pub fn deposit(&amp;self) { } pub fn not_payable(&amp;self) { } pub fn withdraw(&amp;self) { let amount = self.env().self_balance(); self.env().transfer_tokens(&amp;self.owner.get_or_revert_with(ExecutionError::UnwrapError), &amp;amount); } pub fn transfer(&amp;self, to: Address, amount: U512) { self.env().transfer_tokens(&amp;to, &amp;amount); } }  In Odra, you can define a function with the #[odra(payable)] attribute to indicate that the function can receive CSPRs. In Solidity, the payable keyword is used to define functions that can receive Ether. ","version":"2.3.0","tagName":"h3"},{"title":"Selectors​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.3.0/tutorials/odra-solidity#selectors","content":"In Solidity, when a function is called, the first 4 bytes of calldata specify which function to call. This is called a function selector. contract_addr.call( abi.encodeWithSignature(&quot;transfer(address,uint256)&quot;, address, 1234) )  Odra does not support such a mechanism. You must have access to the contract interface to call a function. ","version":"2.3.0","tagName":"h3"},{"title":"Events and Logging​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.3.0/tutorials/odra-solidity#events-and-logging","content":"OdraSolidity use odra::prelude::*; #[odra::event] pub struct Log { sender: Address, message: String, } #[odra::event] pub struct AnotherLog {} #[odra::module] struct Event; #[odra::module] impl Event { pub fn test(&amp;self) { let env = self.env(); env.emit_event(Log { sender: env.caller(), message: &quot;Hello World!&quot;.to_string(), }); env.emit_event(Log { sender: env.caller(), message: &quot;Hello Casper!&quot;.to_string(), }); env.emit_event(AnotherLog {}); } }  In Odra, events are regular structs defined using the #[odra::event] attribute. The event struct can contain multiple fields, which can be of any type (primitive or custom Odra type). To emit an event, use the env's emit_event() function, passing the event struct as an argument. note Events in Solidity are used to emit logs that off-chain services can capture. However, Casper does not support events natively. Odra mimics this feature. Read more about it in the Basics section. ","version":"2.3.0","tagName":"h2"},{"title":"Error Handling​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.3.0/tutorials/odra-solidity#error-handling","content":"OdraSolidity use odra::{prelude::*, casper_types::{U256, U512}}; #[odra::odra_error] pub enum CustomError { InsufficientBalance = 1, InputLowerThanTen = 2, } #[odra::module] pub struct Error; #[odra::module] impl Error { pub fn test_require(&amp;mut self, i: U256) { if i &lt;= 10.into() { self.env().revert(CustomError::InputLowerThanTen); } } pub fn execute_external_call(&amp;self, withdraw_amount: U512) { let balance = self.env().self_balance(); if balance &lt; withdraw_amount { self.env().revert(CustomError::InsufficientBalance); } } }  In Solidity, there are four ways to handle errors: require, revert, assert, and custom errors. In Odra, there is only one way to revert the execution of a function - by using the env().revert() function. The function takes an error type as an argument and stops the execution of the function. You define an error type using the #[odra::odra_error] attribute. On Casper, an error is only a number, so you can't pass a message with the error. ","version":"2.3.0","tagName":"h2"},{"title":"Composition vs. Inheritance​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.3.0/tutorials/odra-solidity#composition-vs-inheritance","content":"In Solidity, developers often use inheritance to reuse code and establish relationships between contracts. However, Odra and Rust follow a different paradigm known as composition. Instead of inheriting behavior from parent contracts, Odra encourages the composition of contracts by embedding one contract within another. Let's take a look at the difference between inheritance in Solidity and composition in Odra. OdraSolidity use odra::prelude::*; #[odra::module] pub struct A; #[odra::module] impl A { pub fn foo(&amp;self) -&gt; String { &quot;A&quot;.to_string() } } #[odra::module] pub struct B { a: SubModule&lt;A&gt; } #[odra::module] impl B { pub fn foo(&amp;self) -&gt; String { &quot;B&quot;.to_string() } } #[odra::module] pub struct C { a: SubModule&lt;A&gt; } #[odra::module] impl C { pub fn foo(&amp;self) -&gt; String { &quot;C&quot;.to_string() } } #[odra::module] pub struct D { b: SubModule&lt;B&gt;, c: SubModule&lt;C&gt; } #[odra::module] impl D { pub fn foo(&amp;self) -&gt; String { self.c.foo() } } #[odra::module] pub struct E { b: SubModule&lt;B&gt;, c: SubModule&lt;C&gt; } #[odra::module] impl E { pub fn foo(&amp;self) -&gt; String { self.b.foo() } } #[odra::module] pub struct F { a: SubModule&lt;A&gt;, b: SubModule&lt;B&gt;, } #[odra::module] impl F { pub fn foo(&amp;self) -&gt; String { self.a.foo() } }  Solidity supports both single and multiple inheritance. This means a contract can inherit from one or more contracts. Solidity uses a technique called &quot;C3 linearization&quot; to resolve the order in which base contracts are inherited in the case of multiple inheritance. This helps to ensure a consistent method resolution order. However, multiple inheritance can lead to complex code and potential issues, especially for inexperienced developers. In contrast, Rust does not have a direct equivalent to the inheritance model, but it achieves similar goals through composition. Each contract is defined as a struct, and contracts can be composed by embedding one struct within another. This approach provides a more flexible and modular way to reuse code and establish relationships between contracts. ","version":"2.3.0","tagName":"h2"},{"title":"Libraries and Utility​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.3.0/tutorials/odra-solidity#libraries-and-utility","content":"OdraSolidity use odra::{casper_types::U256, prelude::*}; mod math { use odra::casper_types::U256; pub fn sqrt(y: U256) -&gt; U256 { let mut z = y; if y &gt; 3.into() { let mut x = y / 2 + 1; while x &lt; z { z = x; x = (y / x + x) / 2; } } else if y != U256::zero() { z = U256::one(); } z } } #[odra::module] struct TestMath; #[odra::module] impl TestMath { pub fn test_square_root(&amp;self, x: U256) -&gt; U256 { math::sqrt(x) } } #[odra::odra_error] enum Error { EmptyArray = 100, } trait Removable { fn remove(&amp;mut self, index: usize); } impl Removable for Var&lt;Vec&lt;U256&gt;&gt; { fn remove(&amp;mut self, index: usize) { let env = self.env(); let mut vec = self.get_or_default(); if vec.is_empty() { env.revert(Error::EmptyArray); } vec[index] = vec.pop().unwrap_or_revert(&amp;env); self.set(vec); } } #[odra::module] struct TestArray { arr: Var&lt;Vec&lt;U256&gt;&gt;, } #[odra::module] impl TestArray { pub fn test_array_remove(&amp;mut self) { let mut arr = self.arr.get_or_default(); for i in 0..3 { arr.push(i.into()); } self.arr.set(arr); self.arr.remove(1); let arr = self.arr.get_or_default(); assert_eq!(arr.len(), 2); assert_eq!(arr[0], 0.into()); assert_eq!(arr[1], 2.into()); } }  In Solidity, libraries are similar to contracts but can't declare any state variables and can't receive Ether. In the sample code above, the Math library contains a square root function, while the Array library provides a function to remove an element from an array. Both libraries are consumed in different ways: the TestMath contract calls the sqrt function directly, while the TestArray contract uses the using keyword, which extends the type uint256[] by adding the remove function. In Odra, you use language-level features: modules and traits. The mod keyword defines a module, which is similar to a library in Solidity. Modules can contain functions, types, and other items that can be reused across multiple contracts. Traits are similar to interfaces in other programming languages, defining a set of functions that a type must implement. Implementing the Removable trait for the Var&lt;Vec&lt;U256&gt;&gt; type allows the remove function to be called on a variable that stores a vector of U256 values. ","version":"2.3.0","tagName":"h2"},{"title":"Fallback and Receive Functions​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.3.0/tutorials/odra-solidity#fallback-and-receive-functions","content":"In Solidity, a contract receiving Ether must implement a receive() and/or fallback() function. The receive() function is called when Ether is sent to the contract with no data, while the fallback() function is called when the contract receives Ether with data or when a function that does not exist is called. Odra does not have a direct equivalent to the receive() and fallback() functions. Instead, you can define a function with the #[odra(payable)] attribute to indicate that the function can receive CSPRs. ","version":"2.3.0","tagName":"h2"},{"title":"Miscellaneous​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.3.0/tutorials/odra-solidity#miscellaneous","content":"","version":"2.3.0","tagName":"h2"},{"title":"Hashing​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.3.0/tutorials/odra-solidity#hashing","content":"OdraSolidity use odra::{casper_types::{bytesrepr::ToBytes, U256}, prelude::*}; #[odra::module] pub struct HashFunction; #[odra::module] impl HashFunction { pub fn hash(&amp;self, text: String, num: U256, addr: Address) -&gt; [u8; 32] { let env = self.env(); let mut data = Vec::new(); data.extend(text.to_bytes().unwrap_or_revert(&amp;env)); data.extend(num.to_bytes().unwrap_or_revert(&amp;env)); data.extend(addr.to_bytes().unwrap_or_revert(&amp;env)); env.hash(data) } } #[odra::module] pub struct GuessTheMagicWord { answer: Var&lt;[u8; 32]&gt;, } #[odra::module] impl GuessTheMagicWord { /// Initializes the contract with the magic word hash. pub fn init(&amp;mut self) { self.answer.set([ 0x86, 0x67, 0x15, 0xbb, 0x0b, 0x96, 0xf1, 0x06, 0xe0, 0x68, 0x07, 0x89, 0x22, 0x84, 0x42, 0x81, 0x19, 0x6b, 0x1e, 0x61, 0x45, 0x50, 0xa5, 0x70, 0x4a, 0xb0, 0xa7, 0x55, 0xbe, 0xd7, 0x56, 0x08, ]); } /// Checks if the `word` is the magic word. pub fn guess(&amp;self, word: String) -&gt; bool { let env = self.env(); let hash = env.hash(word.to_bytes().unwrap_or_revert(&amp;env)); hash == self.answer.get_or_default() } }  The key difference between the two is that in Solidity, the keccak256 function is used to hash data, while in Odra, the env.hash() function is used, which implements the blake2b algorithm. Both functions take a byte array as input and return a 32-byte hash. ","version":"2.3.0","tagName":"h3"},{"title":"Try-catch​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.3.0/tutorials/odra-solidity#try-catch","content":"OdraSolidity use odra::prelude::*; #[odra::module] pub struct Example { other_contract: External&lt;OtherContractContractRef&gt;, } #[odra::module] impl Example { pub fn init(&amp;mut self, other_contract: Address) { self.other_contract.set(other_contract); } pub fn execute_external_call(&amp;self) { let result = self.other_contract.some_function(); match result { Ok(success) =&gt; { // Code to execute if the external call was successful } Err(reason) =&gt; { // Code to execute if the external call failed } } } } #[odra::module] pub struct OtherContract; #[odra::module] impl OtherContract { pub fn some_function(&amp;self) -&gt; Result&lt;bool, ()&gt; { Ok(true) } }  In Solidity, try/catch is a feature that allows developers to handle exceptions and errors more gracefully. The try/catch statement allows developers to catch and handle exceptions that occur during external function calls and contract creation. In Odra, there is no direct equivalent to the try/catch statement in Solidity. However, you can use the Result type to handle errors in a similar way. The Result type is an enum that represents either success (Ok) or failure (Err). You can use the match statement to handle the Result type and execute different code based on the result. However, if an unexpected error occurs on the way, the whole transaction reverts. ","version":"2.3.0","tagName":"h3"},{"title":"Conclusion​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/2.3.0/tutorials/odra-solidity#conclusion","content":"Congratulations! You've now learned the main differences in writing smart contracts with the Odra Framework. By understanding the structure, initialization, error handling, and the composition pattern in Odra, you can effectively transition from Solidity to Odra for Casper blockchain development. Experiment with the provided code samples, explore more advanced features, and unleash the full potential of the Odra Framework. Read more about the Odra Framework in the Basics and Advanced sections. Learn by example with our Tutorial series, you will find there a contract you likely familiar with - the Erc20 standard implementation. If you have any further questions or need clarification on specific topics, feel free to join our Discord! ","version":"2.3.0","tagName":"h2"},{"title":"Using odra-modules","type":0,"sectionRef":"#","url":"/docs/next/examples/using-odra-modules","content":"","keywords":"","version":"next"},{"title":"Available modules​","type":1,"pageTitle":"Using odra-modules","url":"/docs/next/examples/using-odra-modules#available-modules","content":"Odra modules comes with couple of ready-to-use modules and reusable extensions. ","version":"next","tagName":"h2"},{"title":"Tokens​","type":1,"pageTitle":"Using odra-modules","url":"/docs/next/examples/using-odra-modules#tokens","content":"CEP-18​ Casper Ecosystem Proposal 18 (CEP-18) is a standard interface for the CSPR and the custom made tokens. Inspired by the ERC20 standard. Read more about the CEP-18 here. CEP-95​ Casper Ecosystem Proposal 95 (CEP-95) is a Casper NFT Standard. It aims to replace CEP-47 and CEP-78, which have flaws that complicate their support in the ecosystem. This standard is aligned with Ethereum's ERC-721, but makes adjustments relevant for the Casper Ecosystem. Similarly to ERC-721, this standard can be used to represent a various range of tokenized assets Read more about the CEP-95 here. Erc20​ The Erc20 module implements the ERC20 standard. Erc721​ The Erc721Base module implements the ERC721 standard, adjusted for the Odra framework. The Erc721Token module implements the ERC721Base and additionally uses the Erc721Metadata and Ownable extensions. The Erc721Receiver trait lets you implement your own logic for receiving NFTs. The OwnedErc721WithMetadata trait is a combination of Erc721Token, Erc721Metadata and Ownable modules. Erc1155​ The Erc1155Base module implements the ERC1155 standard, adjusted for the Odra framework. The Erc1155Token module implements the ERC1155Base and additionally uses the Ownable extension. The OwnedErc1155 trait is a combination of Erc1155Token and Ownable modules. Wrapped native token​ The WrappedNativeToken module implements the Wrapper for the native token, it was inspired by the WETH. ","version":"next","tagName":"h3"},{"title":"Access​","type":1,"pageTitle":"Using odra-modules","url":"/docs/next/examples/using-odra-modules#access","content":"AccessControl​ This module enables the implementation of role-based access control mechanisms for children modules. Roles are identified by their 32-bytes identifier, which should be unique and exposed in the external API. Ownable​ This module provides a straightforward access control feature that enables exclusive access to particular functions by an account, known as the owner. The account that initiates the module is automatically assigned as the owner. However, ownership can be transferred later by using thetransfer_ownership() function. Ownable2Step​ An extension of the Ownable module. Ownership can be transferred in a two-step process by using transfer_ownership() and accept_ownership() functions. ","version":"next","tagName":"h3"},{"title":"Security​","type":1,"pageTitle":"Using odra-modules","url":"/docs/next/examples/using-odra-modules#security","content":"Pausable​ A module allowing to implement an emergency stop mechanism that can be triggered by any account. ","version":"next","tagName":"h3"},{"title":"Installation","type":0,"sectionRef":"#","url":"/docs/next/getting-started/installation","content":"","keywords":"","version":"next"},{"title":"Prerequisites​","type":1,"pageTitle":"Installation","url":"/docs/next/getting-started/installation#prerequisites","content":"To start working with Odra, you need to have the following installed on your machine: Rust toolchain installed (see rustup.rs)wasmstrip tool installed (see wabt)wasm-opt tool installed (see binaryen) We do not provide exact commands for installing these tools, as they are different for different operating systems. Please refer to the documentation of the tools themselves. With Rust toolchain ready, you can add a new target: rustup target add wasm32-unknown-unknown  note wasm32-unknown-unknown is a target that will be used by Odra to compile your smart contracts to WASM files. ","version":"next","tagName":"h2"},{"title":"Installing Cargo Odra​","type":1,"pageTitle":"Installation","url":"/docs/next/getting-started/installation#installing-cargo-odra","content":"Cargo Odra is a helpful tool that will help you to build and test your smart contracts. It is not required to use Odra, but the documentation will assume that you have it installed. To install it, simply execute the following command: cargo install cargo-odra --locked  To check if it was installed correctly and see available commands, type: cargo odra --help  If everything went fine, we can proceed to the next step. ","version":"next","tagName":"h2"},{"title":"Creating a new Odra project​","type":1,"pageTitle":"Installation","url":"/docs/next/getting-started/installation#creating-a-new-odra-project","content":"To create a new project, simply execute: cargo odra new --name my-project &amp;&amp; cd my_project  This will create a new folder called my_project and initialize Odra there. Cargo Odra will create a sample contract for you in src directory. You can run the tests of this contract by executing: cargo odra test  This will run tests using Odra's internal OdraVM. You can run those tests against a real backend, let's use CasperVM: cargo odra test -b casper  Congratulations! Now you are ready to create contracts using Odra framework! If you had any problems during the installation process, feel free to ask for help on our Discord. ","version":"next","tagName":"h2"},{"title":"What's next?​","type":1,"pageTitle":"Installation","url":"/docs/next/getting-started/installation#whats-next","content":"If you want to see the code that you just tested, continue to the description of Flipper example. ","version":"next","tagName":"h2"},{"title":"Flipper example","type":0,"sectionRef":"#","url":"/docs/next/getting-started/flipper","content":"","keywords":"","version":"next"},{"title":"Let's flip​","type":1,"pageTitle":"Flipper example","url":"/docs/next/getting-started/flipper#lets-flip","content":"flipper.rs use odra::prelude::*; /// A module definition. Each module struct consists Vars and Mappings /// or/and another modules. #[odra::module] pub struct Flipper { /// The module itself does not store the value, /// it's a proxy that writes/reads value to/from the host. value: Var&lt;bool&gt;, } /// Module implementation. /// /// To generate entrypoints, /// an implementation block must be marked as #[odra::module]. #[odra::module] impl Flipper { /// Odra constructor. /// /// Initializes the contract. pub fn init(&amp;mut self) { self.value.set(false); } /// Replaces the current value with the passed argument. pub fn set(&amp;mut self, value: bool) { self.value.set(value); } /// Replaces the current value with the opposite value. pub fn flip(&amp;mut self) { self.value.set(!self.get()); } /// Retrieves value from the storage. /// If the value has never been set, the default value is returned. pub fn get(&amp;self) -&gt; bool { self.value.get_or_default() } } #[cfg(test)] mod tests { use crate::flipper::Flipper; use odra::host::{Deployer, NoArgs}; #[test] fn flipping() { let env = odra_test::env(); // To test a module we need to deploy it. `Flipper` implements `Deployer` trait, // so we can use it to deploy the module. let mut contract = Flipper::deploy(&amp;env, NoArgs); assert!(!contract.get()); contract.flip(); assert!(contract.get()); } }  ","version":"next","tagName":"h2"},{"title":"Testing​","type":1,"pageTitle":"Flipper example","url":"/docs/next/getting-started/flipper#testing","content":"To run the tests, execute the following command: cargo odra test # or add the `-b casper` flag to run tests on the CasperVM  ","version":"next","tagName":"h2"},{"title":"What's next​","type":1,"pageTitle":"Flipper example","url":"/docs/next/getting-started/flipper#whats-next","content":"In the next category of articles, we will go through basic concepts of Odra. ","version":"next","tagName":"h2"},{"title":"Migration guide to v2.0.0 from 1.*","type":0,"sectionRef":"#","url":"/docs/next/migrations/to-2.0.0","content":"","keywords":"","version":"next"},{"title":"Updating rustc version​","type":1,"pageTitle":"Migration guide to v2.0.0 from 1.*","url":"/docs/next/migrations/to-2.0.0#updating-rustc-version","content":"Update rust-toolchain file in your project: nightly-2024-07-31  ","version":"next","tagName":"h2"},{"title":"Migration guide to v1.3.0","type":0,"sectionRef":"#","url":"/docs/next/migrations/to-1.3.0","content":"","keywords":"","version":"next"},{"title":"Migrating to Odra v1.3.0​","type":1,"pageTitle":"Migration guide to v1.3.0","url":"/docs/next/migrations/to-1.3.0#migrating-to-odra-v130","content":"To migrate your smart contracts to Odra v1.3.0, remove the use the deploy method from the module instead of the {{ModuleName}}HostRef struct: before.rs let token = TokenHostRef::deploy(env, init_args); let another_token = AnotherTokenHostRef::load(env, address);  after.rs let token = Token::deploy(env, init_args); let another_token = AnotherToken::load(env, address);  ","version":"next","tagName":"h2"},{"title":"Migration guide to v2.1.0 from 2.0.*","type":0,"sectionRef":"#","url":"/docs/next/migrations/to-2.1.0","content":"","keywords":"","version":"next"},{"title":"Updating the test code​","type":1,"pageTitle":"Migration guide to v2.1.0 from 2.0.*","url":"/docs/next/migrations/to-2.1.0#updating-the-test-code","content":"Function that required an event reference as an argument has been changed to accept an event type instead. before.rs assert!(test_env.emitted_event( &amp;party_contract, &amp;PartyStarted { caller: test_env.get_account(0), block_time: 0 } ));  after.rs assert!(test_env.emitted_event( &amp;party_contract, PartyStarted { caller: test_env.get_account(0), block_time: 0 } ));  In the previous version, the HostRef and Addressable traits both included a function called address, which may have caused confusion and led to exporting the address function from the wrong trait. In the updated version, address is now defined only in the Addressable trait, while the HostRef trait provides a separate function called contract_address instead. ","version":"next","tagName":"h2"},{"title":"Access Control","type":0,"sectionRef":"#","url":"/docs/next/tutorials/access-control","content":"","keywords":"","version":"next"},{"title":"Code​","type":1,"pageTitle":"Access Control","url":"/docs/next/tutorials/access-control#code","content":"Before we start writing code, we list the functionalities of our access control layer. A Role type is used across the module.A Role can be assigned to many Addresses.Each Role may have a corresponding admin role.Only an admin can grant/revoke a Role.A Role can be renounced.A Role cannot be renounced on someone's behalf.Each action triggers an event.Unauthorized access stops contract execution. ","version":"next","tagName":"h2"},{"title":"Project Structure​","type":1,"pageTitle":"Access Control","url":"/docs/next/tutorials/access-control#project-structure","content":"access-control ├── src │ ├── access │ │ ├── access_control.rs │ │ ├── events.rs │ │ └── errors.rs │ └── lib.rs |── build.rs |── Cargo.toml └── Odra.toml  ","version":"next","tagName":"h3"},{"title":"Events and Errors​","type":1,"pageTitle":"Access Control","url":"/docs/next/tutorials/access-control#events-and-errors","content":"There are three actions that can be performed concerning a Role: granting, revoking, and altering the admin role. Let us establish standard Odra events for each of these actions. events.rs use odra::prelude::*; use super::access_control::Role; #[odra::event] pub struct RoleGranted { pub role: Role, pub address: Address, pub sender: Address } #[odra::event] pub struct RoleRevoked { pub role: Role, pub address: Address, pub sender: Address } #[odra::event] pub struct RoleAdminChanged { pub role: Role, pub previous_admin_role: Role, pub new_admin_role: Role }  L4-L16 - to describe the grant or revoke actions, our events specify the Role, and Addresses indicating who receives or loses access and who provides or withdraws it.L18-L23 - the event describing the admin role change, requires the subject Role, the previous and the current admin Role. errors.rs #[odra::odra_error] pub enum Error { MissingRole = 20_000, RoleRenounceForAnotherAddress = 20_001, }  Errors definition is straightforward - there are only two invalid states: An action is triggered by an unauthorized actor.The caller is attempting to resign the Role on someone's behalf.  ","version":"next","tagName":"h3"},{"title":"Module​","type":1,"pageTitle":"Access Control","url":"/docs/next/tutorials/access-control#module","content":"Now, we are stepping into the most interesting part: the module definition and implementation. access_control.rs use super::events::*; use super::errors::Error; use odra::prelude::*; pub type Role = [u8; 32]; pub const DEFAULT_ADMIN_ROLE: Role = [0u8; 32]; #[odra::module(events = [RoleAdminChanged, RoleGranted, RoleRevoked], errors = Error)] pub struct AccessControl { roles: Mapping&lt;(Role, Address), bool&gt;, role_admin: Mapping&lt;Role, Role&gt; } #[odra::module] impl AccessControl { pub fn has_role(&amp;self, role: &amp;Role, address: &amp;Address) -&gt; bool { self.roles.get_or_default(&amp;(*role, *address)) } pub fn get_role_admin(&amp;self, role: &amp;Role) -&gt; Role { let admin_role = self.role_admin.get(role); if let Some(admin) = admin_role { admin } else { DEFAULT_ADMIN_ROLE } } pub fn grant_role(&amp;mut self, role: &amp;Role, address: &amp;Address) { self.check_role(&amp;self.get_role_admin(role), &amp;self.env().caller()); self.unchecked_grant_role(role, address); } pub fn revoke_role(&amp;mut self, role: &amp;Role, address: &amp;Address) { self.check_role(&amp;self.get_role_admin(role), &amp;self.env().caller()); self.unchecked_revoke_role(role, address); } pub fn renounce_role(&amp;mut self, role: &amp;Role, address: &amp;Address) { if address != &amp;self.env().caller() { self.env().revert(Error::RoleRenounceForAnotherAddress); } self.unchecked_revoke_role(role, address); } } impl AccessControl { pub fn check_role(&amp;self, role: &amp;Role, address: &amp;Address) { if !self.has_role(role, address) { self.env().revert(Error::MissingRole); } } pub fn set_admin_role(&amp;mut self, role: &amp;Role, admin_role: &amp;Role) { let previous_admin_role = self.get_role_admin(role); self.role_admin.set(role, *admin_role); self.env().emit_event(RoleAdminChanged { role: *role, previous_admin_role, new_admin_role: *admin_role }); } pub fn unchecked_grant_role(&amp;mut self, role: &amp;Role, address: &amp;Address) { if !self.has_role(role, address) { self.roles.set(&amp;(*role, *address), true); self.env().emit_event(RoleGranted { role: *role, address: *address, sender: self.env().caller() }); } } pub fn unchecked_revoke_role(&amp;mut self, role: &amp;Role, address: &amp;Address) { if self.has_role(role, address) { self.roles.set(&amp;(*role, *address), false); self.env().emit_event(RoleRevoked { role: *role, address: *address, sender: self.env().caller() }); } } }  L5 - Firstly, we need the Role type. It is simply an alias for a 32-byte array.L7 - The default role is an array filled with zeros.L10-L13 - The storage consists of two mappings: roles - a nested mapping that stores information about whether a certain Role is granted to a given Address.role_admin - each Role can have a single admin Role. L17-L19 - This is a simple check to determine if a Role has been granted to a given Address. It is an exposed entry point and an important building block widely used throughout the entire module.L48 - This is a non-exported block containing helper functions.L49-L53 - The check_role() function serves as a guard function. Before a Role is granted or revoked, we must ensure that the caller is allowed to do so. For this purpose, the function reads the roles mapping. If the role has not been granted to the address, the contract reverts with Error::MissingRole.L55-L63 - The set_admin_role() function simply updates the role_admin mapping and emits the RoleAdminChanged event.L65-L85 - The unchecked_grant_role() and unchecked_revoke_role() functions are mirror functions that update the roles mapping and post RoleGranted or RoleRevoked events. If the role is already granted, unchecked_grant_role() has no effect (the opposite check is made in the case of revoking a role).L21-L28 - The get_role_admin() entry point reads the role_admin. If there is no admin role for a given role, it returns the default role.L30-L45 - This is a combination of check_role() and unchecked_*_role(). Entry points fail on unauthorized access. ","version":"next","tagName":"h3"},{"title":"Migration guide to v0.9.0","type":0,"sectionRef":"#","url":"/docs/next/migrations/to-0.9.0","content":"","keywords":"","version":"next"},{"title":"1. Prerequisites​","type":1,"pageTitle":"Migration guide to v0.9.0","url":"/docs/next/migrations/to-0.9.0#1-prerequisites","content":"","version":"next","tagName":"h2"},{"title":"1.1. Update cargo-odra​","type":1,"pageTitle":"Migration guide to v0.9.0","url":"/docs/next/migrations/to-0.9.0#11-update-cargo-odra","content":"Before you begin the migration process, make sure you installed the latest version of the Cargo Odra toolchain. You can install it by running the following command: cargo install cargo-odra --force --locked  ","version":"next","tagName":"h3"},{"title":"1.2. Review the Changelog​","type":1,"pageTitle":"Migration guide to v0.9.0","url":"/docs/next/migrations/to-0.9.0#12-review-the-changelog","content":"Before you move to changing your code, start by reviewing the Changelog to understand the changes introduced in v0.9.0. ","version":"next","tagName":"h3"},{"title":"2. Migration Steps​","type":1,"pageTitle":"Migration guide to v0.9.0","url":"/docs/next/migrations/to-0.9.0#2-migration-steps","content":"","version":"next","tagName":"h2"},{"title":"2.1 Update build_schema.rs bin​","type":1,"pageTitle":"Migration guide to v0.9.0","url":"/docs/next/migrations/to-0.9.0#21-update-build_schemars-bin","content":"Odra 0.9.0 adds a new standardized way of generating contract schema - Casper Contract Schema. You can find the updated build_schema.rs file in templates directory in the Odra main repository. You can choose whatever template you want to use and copy the files to your project. In both files, you should replace {{project-name}} with the name of your project. ","version":"next","tagName":"h3"},{"title":"2.2 Update smart contract code​","type":1,"pageTitle":"Migration guide to v0.9.0","url":"/docs/next/migrations/to-0.9.0#22-update-smart-contract-code","content":"The main changes in the smart contract code are related to the way of defining custom types, events and errors. The following sections will guide you through the necessary changes. 2.2.1. Update custom types definitions.​ #[derive(OdraType)] attribute has been replace with #[odra::odra_type] attribute. 0.9.00.8.0 use odra::Address; #[odra::odra_type] pub struct Dog { pub name: String, pub age: u8, pub owner: Option&lt;Address&gt; }  2.2.2. Update errors definitions.​ #[derive(OdraError)] attribute has been replace with #[odra::odra_error] attribute. Error enum should be passed as a parameter to the #[odra::module] attribute. 0.9.00.8.0 #[odra::module(events = [/* events go here */], errors = Error)] pub struct Erc20 { // fields } #[odra::odra_error] pub enum Error { InsufficientBalance = 30_000, InsufficientAllowance = 30_001, NameNotSet = 30_002, SymbolNotSet = 30_003, DecimalsNotSet = 30_004 }  2.2.3. Update events definitions.​ #[derive(Event)] attribute has been replace with #[odra::event] attribute. 0.9.00.8.0 use odra::prelude::*; use odra::{Address, casper_types::U256}; #[odra::event] pub struct Transfer { pub from: Option&lt;Address&gt;, pub to: Option&lt;Address&gt;, pub amount: U256 }  ","version":"next","tagName":"h3"},{"title":"3. Code Examples​","type":1,"pageTitle":"Migration guide to v0.9.0","url":"/docs/next/migrations/to-0.9.0#3-code-examples","content":"Here is a complete example of a smart contract after and before the migration to v0.9.0. 0.9.0Prev src/erc20.rs use crate::erc20::errors::Error; use crate::erc20::events::*; use odra::prelude::*; use odra::{casper_types::U256, Address, Mapping, Var}; #[odra::module(events = [Approval, Transfer], errors = Error)] pub struct Erc20 { decimals: Var&lt;u8&gt;, symbol: Var&lt;String&gt;, name: Var&lt;String&gt;, total_supply: Var&lt;U256&gt;, balances: Mapping&lt;Address, U256&gt;, allowances: Mapping&lt;(Address, Address), U256&gt; } #[odra::module] impl Erc20 { pub fn init( &amp;mut self, symbol: String, name: String, decimals: u8, initial_supply: Option&lt;U256&gt; ) { let caller = self.env().caller(); self.symbol.set(symbol); self.name.set(name); self.decimals.set(decimals); if let Some(initial_supply) = initial_supply { self.total_supply.set(initial_supply); self.balances.set(&amp;caller, initial_supply); if !initial_supply.is_zero() { self.env().emit_event(Transfer { from: None, to: Some(caller), amount: initial_supply }); } } } pub fn transfer(&amp;mut self, recipient: &amp;Address, amount: &amp;U256) { let caller = self.env().caller(); self.raw_transfer(&amp;caller, recipient, amount); } pub fn transfer_from(&amp;mut self, owner: &amp;Address, recipient: &amp;Address, amount: &amp;U256) { let spender = self.env().caller(); self.spend_allowance(owner, &amp;spender, amount); self.raw_transfer(owner, recipient, amount); } pub fn approve(&amp;mut self, spender: &amp;Address, amount: &amp;U256) { let owner = self.env().caller(); self.allowances.set(&amp;(owner, *spender), *amount); self.env().emit_event(Approval { owner, spender: *spender, value: *amount }); } pub fn name(&amp;self) -&gt; String { self.name.get_or_revert_with(Error::NameNotSet) } // Other getter functions... pub fn allowance(&amp;self, owner: &amp;Address, spender: &amp;Address) -&gt; U256 { self.allowances.get_or_default(&amp;(*owner, *spender)) } pub fn mint(&amp;mut self, address: &amp;Address, amount: &amp;U256) { self.total_supply.add(*amount); self.balances.add(address, *amount); self.env().emit_event(Transfer { from: None, to: Some(*address), amount: *amount }); } pub fn burn(&amp;mut self, address: &amp;Address, amount: &amp;U256) { if self.balance_of(address) &lt; *amount { self.env().revert(Error::InsufficientBalance); } self.total_supply.subtract(*amount); self.balances.subtract(address, *amount); self.env().emit_event(Transfer { from: Some(*address), to: None, amount: *amount }); } } impl Erc20 { fn raw_transfer(&amp;mut self, owner: &amp;Address, recipient: &amp;Address, amount: &amp;U256) { if *amount &gt; self.balances.get_or_default(owner) { self.env().revert(Error::InsufficientBalance) } self.balances.subtract(owner, *amount); self.balances.add(recipient, *amount); self.env().emit_event(Transfer { from: Some(*owner), to: Some(*recipient), amount: *amount }); } fn spend_allowance(&amp;mut self, owner: &amp;Address, spender: &amp;Address, amount: &amp;U256) { let allowance = self.allowances.get_or_default(&amp;(*owner, *spender)); if allowance &lt; *amount { self.env().revert(Error::InsufficientAllowance) } self.allowances.subtract(&amp;(*owner, *spender), *amount); self.env().emit_event(Approval { owner: *owner, spender: *spender, value: allowance - *amount }); } } pub mod events { use odra::prelude::*; use odra::{casper_types::U256, Address}; #[odra::event] pub struct Transfer { pub from: Option&lt;Address&gt;, pub to: Option&lt;Address&gt;, pub amount: U256 } #[odra::event] pub struct Approval { pub owner: Address, pub spender: Address, pub value: U256 } } pub mod errors { #[odra::odra_error] pub enum Error { InsufficientBalance = 30_000, InsufficientAllowance = 30_001, NameNotSet = 30_002, SymbolNotSet = 30_003, DecimalsNotSet = 30_004 } } #[cfg(test)] mod tests { // nothing changed in the tests }  ","version":"next","tagName":"h2"},{"title":"4. Troubleshooting​","type":1,"pageTitle":"Migration guide to v0.9.0","url":"/docs/next/migrations/to-0.9.0#4-troubleshooting","content":"If you encounter any further issues after completing the migration steps, please don't hesitate to reach out to us on Discord or explore the other sections this documentation. You can also refer to the technical documentation for more detailed information. Additionally, our examples repository offers a wide range of examples to assist you in understanding the new features and APIs. Be sure to carefully review any compilation errors and warnings, as they may provide valuable insights into the necessary adjustments. ","version":"next","tagName":"h2"},{"title":"5. References​","type":1,"pageTitle":"Migration guide to v0.9.0","url":"/docs/next/migrations/to-0.9.0#5-references","content":"ChangelogOdra DocumentationDocs.rsExamples ","version":"next","tagName":"h2"},{"title":"Build, Deploy and Read the State of a Contract","type":0,"sectionRef":"#","url":"/docs/next/tutorials/build-deploy-read","content":"","keywords":"","version":"next"},{"title":"Contract​","type":1,"pageTitle":"Build, Deploy and Read the State of a Contract","url":"/docs/next/tutorials/build-deploy-read#contract","content":"Let's write a contract with complex storage layout. The contract stores a plain numeric value, a custom nested type and a submodule with another submodule with stores a Mapping. We will expose two methods: The constructor init which sets the metadata and the version of the contract.The method set_data which sets the value of the numeric field and the values of the mapping. custom_item.rs use odra::{casper_types::U256, prelude::*}; // A custom type with a vector of another custom type #[odra::odra_type] pub struct Metadata { name: String, description: String, prices: Vec&lt;Price&gt;, } #[odra::odra_type] pub struct Price { value: U256, } // The main contract with a version, metadata and a submodule #[odra::module] pub struct CustomItem { version: Var&lt;u32&gt;, meta: Var&lt;Metadata&gt;, data: SubModule&lt;Data&gt; } #[odra::module] impl CustomItem { pub fn init(&amp;mut self, name: String, description: String, price_1: U256, price_2: U256) { let meta = Metadata { name, description, prices: vec![ Price { value: price_1 }, Price { value: price_2 } ] }; self.meta.set(meta); self.version.set(self.version.get_or_default() + 1); } pub fn set_data(&amp;mut self, value: u32, name: String, name2: String) { self.data.value.set(value); self.data.inner.named_values.set(&amp;name, 10); self.data.inner.named_values.set(&amp;name2, 20); } } // A submodule with a numeric value and another submodule #[odra::module] struct Data { value: Var&lt;u32&gt;, inner: SubModule&lt;InnerData&gt;, } // A submodule with a mapping #[odra::module] struct InnerData { named_values: Mapping&lt;String, u32&gt;, }  ","version":"next","tagName":"h3"},{"title":"Deploying the contract​","type":1,"pageTitle":"Build, Deploy and Read the State of a Contract","url":"/docs/next/tutorials/build-deploy-read#deploying-the-contract","content":"First, we need to setup the chain. We will use the NCTL docker image to run a local network. docker run --rm -it --name mynctl -d -p 11101:11101 -p 14101:14101 -p 18101:18101 makesoftware/casper-nctl  Next, we need to compile the contract to a Wasm file. cargo odra build -c custom_item  Then, we can deploy the contract using the casper-client tool. casper-client put-transaction session \\ --node-address http://localhost:11101 \\ --chain-name casper-net-1 \\ --secret-key path/to/your/secret_key.pem \\ --wasm-path ./wasm/Erc20.wasm \\ --payment-amount 450000000000 \\ --gas-price-tolerance 1 \\ --standard-payment true \\ --session-arg &quot;odra_cfg_package_hash_key_name:string:'test_contract_package_hash'&quot; \\ --session-arg &quot;odra_cfg_allow_key_override:bool:'true'&quot; \\ --session-arg &quot;odra_cfg_is_upgradable:bool:'true'&quot; \\ --session-arg &quot;odra_cfg_is_upgrade:bool:'false'&quot; \\ --session-arg &quot;name:string='My Name'&quot; \\ --session-arg &quot;description:string='My Description'&quot; \\ --session-arg &quot;price_1:u256='101'&quot; \\ --session-arg &quot;price_2:u256='202'&quot;  Finally, we can call the set_data method to set the values of the contract. casper-client put-transaction package \\ --node-address http://localhost:11101 \\ --chain-name casper-net-1 \\ --secret-key path/to/your/secret_key.pem \\ --gas-price-tolerance 1 \\ --contract-package-hash &quot;hash-...&quot; \\ --payment-amount 2500000000 \\ --standard-payment &quot;true&quot; \\ --session-entry-point &quot;set_data&quot; \\ --session-arg &quot;value:u32:'666'&quot; \\ --session-arg &quot;name:string='alice'&quot; \\ --session-arg &quot;name2:string='bob'&quot;  ","version":"next","tagName":"h3"},{"title":"Storage Layout​","type":1,"pageTitle":"Build, Deploy and Read the State of a Contract","url":"/docs/next/tutorials/build-deploy-read#storage-layout","content":"To read the state of the contract, we need to understand the storage layout. The first step is to calculate the index of the keys. Storage Layout CustomItem: prefix: 0x0..._0000_0000_0000 0 version: u32, 0x0..._0000_0000_0001 1 meta: Metadata, 0x0..._0000_0000_0010 2 data: Data: prefix: 0x0..._0000_0000_0011 3 value: u32, 0x0..._0000_0011_0001 (3 &lt;&lt; 4) + 1 inner: InnerData: prefix: 0x0..._0000_0011_0010 (3 &lt;&lt; 4) + 2 named_values: Mapping 0x0..._0011_0010_0001 ((3 &lt;&lt; 4) + 2) &lt;&lt; 4 + 1  The actual key is obtained as follows: Convert the index to a big-endian byte array.Concatenate the index with the mapping data.Hash the concatenated bytes using blake2b.Return the hex representation of the hash (the stored key must be utf-8 encoded). In more detail, the storage layout is described in the Storage Layout article. ","version":"next","tagName":"h3"},{"title":"Reading the state​","type":1,"pageTitle":"Build, Deploy and Read the State of a Contract","url":"/docs/next/tutorials/build-deploy-read#reading-the-state","content":"RustTypeScript main.rs use casper_client::{rpcs::DictionaryItemIdentifier, types::StoredValue, Verbosity}; use casper_types::{ bytesrepr::{FromBytes, ToBytes}, U256, }; // replace with your contract hash const CONTRACT_HASH: &amp;str = &quot;hash-...&quot;; const NODE_ADDRESS: &amp;str = &quot;http://localhost:11101/rpc&quot;; const RPC_ID: &amp;str = &quot;casper-net-1&quot;; const DICTIONARY_NAME: &amp;str = &quot;state&quot;; #[derive(Debug, PartialEq, Eq, Hash)] pub struct Metadata { name: String, description: String, prices: Vec&lt;Price&gt;, } #[derive(Debug, PartialEq, Eq, Hash)] pub struct Price { value: U256, } async fn read_state_key(key: String) -&gt; Vec&lt;u8&gt; { let state_root_hash = casper_client::get_state_root_hash( RPC_ID.to_string().into(), NODE_ADDRESS, Verbosity::Low, None, ) .await .unwrap() .result .state_root_hash .unwrap(); // Read the value from the `state` dictionary. let result = casper_client::get_dictionary_item( RPC_ID.to_string().into(), NODE_ADDRESS, Verbosity::Low, state_root_hash, DictionaryItemIdentifier::ContractNamedKey { key: CONTRACT_HASH.to_string(), dictionary_name: DICTIONARY_NAME.to_string(), dictionary_item_key: key, }, ) .await .unwrap() .result .stored_value; // We expect the value to be a CLValue if let StoredValue::CLValue(cl_value) = result { // Ignore the first 4 bytes, which are the length of the CLType. cl_value.inner_bytes()[4..].to_vec() } else { vec![] } } async fn metadata() -&gt; Metadata { // The key for the metadata is 2, and it has no mapping data let key = key(2, &amp;[]); let bytes = read_state_key(key).await; // Read the name and store the remaining bytes let (name, bytes) = String::from_bytes(&amp;bytes).unwrap(); // Read the description and store the remaining bytes let (description, bytes) = String::from_bytes(&amp;bytes).unwrap(); // A vector is stored as a u32 size followed by the elements // Read the size of the vector and store the remaining bytes let (size, mut bytes) = u32::from_bytes(&amp;bytes).unwrap(); let mut prices = vec![]; // As we know the size of the vector, we can loop over it for _ in 0..size { // Read the value and store the remaining bytes let (value, rem) = U256::from_bytes(&amp;bytes).unwrap(); bytes = rem; prices.push(Price { value }); } // Anytime you finish parsing a value, you should check if there are any remaining bytes // if there are, it means you have a bug in your parsing logic. // For simplicity, we will ignore the remaining bytes here. Metadata { name, description, prices } } async fn value() -&gt; u32 { // The key for the value is (3 &lt;&lt; 4) + 1, and it has no mapping data let key = key((3 &lt;&lt; 4) + 1, &amp;[]); let bytes = read_state_key(key).await; // Read the value and ignore the remaining bytes for simplicity u32::from_bytes(&amp;bytes).unwrap().0 } async fn named_value(name: &amp;str) -&gt; u32 { // The key for the named value is (((3 &lt;&lt; 4) + 2) &lt;&lt; 4) + 1, and the mapping data is the name as bytes let mapping_data = name.to_bytes().unwrap(); let key = key((((3 &lt;&lt; 4) + 2) &lt;&lt; 4) + 1, &amp;mapping_data); let bytes = read_state_key(key).await; // Read the value and ignore the remaining bytes for simplicity u32::from_bytes(&amp;bytes).unwrap().0 } fn main() { let runtime = tokio::runtime::Runtime::new().unwrap(); dbg!(runtime.block_on(metadata())); dbg!(runtime.block_on(value())); dbg!(runtime.block_on(named_value(&quot;alice&quot;))); dbg!(runtime.block_on(named_value(&quot;bob&quot;))); } // The key is a combination of the index and the mapping data // The algorithm is as follows: // 1. Convert the index to a big-endian byte array // 2. Concatenate the index with the mapping data // 3. Hash the concatenated bytes using blake2b // 4. Return the hex representation of the hash (the stored key must be utf-8 encoded) fn key(idx: u32, mapping_data: &amp;[u8]) -&gt; String { let mut key = Vec::new(); key.extend_from_slice(idx.to_be_bytes().as_ref()); key.extend_from_slice(mapping_data); let hashed_key = blake2b(&amp;key); hex::encode(&amp;hashed_key) } fn blake2b(bytes: &amp;[u8]) -&gt; [u8; 32] { let mut result = [0u8; 32]; let mut hasher = &lt;blake2::Blake2bVar as blake2::digest::VariableOutput&gt;::new(32) .expect(&quot;should create hasher&quot;); let _ = std::io::Write::write(&amp;mut hasher, bytes); blake2::digest::VariableOutput::finalize_variable(hasher, &amp;mut result) .expect(&quot;should copy hash to the result array&quot;); result } cargo run [src/main.rs:116:5] runtime.block_on(metadata()) = Metadata { name: &quot;My Contract&quot;, description: &quot;My Description&quot;, prices: [ Price { value: 123, }, Price { value: 321, }, ], } [src/main.rs:117:5] runtime.block_on(value()) = 666 [src/main.rs:118:5] runtime.block_on(named_value(&quot;alice&quot;)) = 20 [src/main.rs:119:5] runtime.block_on(named_value(&quot;bob&quot;)) = 10  ","version":"next","tagName":"h3"},{"title":"Deploying a Token on Casper Livenet","type":0,"sectionRef":"#","url":"/docs/next/tutorials/deploying-on-casper","content":"","keywords":"","version":"next"},{"title":"Casper Wallet​","type":1,"pageTitle":"Deploying a Token on Casper Livenet","url":"/docs/next/tutorials/deploying-on-casper#casper-wallet","content":"We will be using Casper Wallet to do some tasks in this tutorial. To install it, please follow the instructions on the official website. After setting up the wallet, extract the private key of the account you want to use for our testing. You can do this by clicking on the Menu &gt; Download account keys. danger You are solely responsible for the security of your private keys. We recommend creating a new account for the testing purposes. Why do we need the private key? We will use it in Odra to deploy our contract to the Casper network using Livenet backend. ","version":"next","tagName":"h2"},{"title":"Getting tokens​","type":1,"pageTitle":"Deploying a Token on Casper Livenet","url":"/docs/next/tutorials/deploying-on-casper#getting-tokens","content":"To deploy the contract on the Livenet, we need to have some CSPR. The easiest way to get them is to use the faucet, which will send us 1000 CSPR for free. Unfortunately, only on the Testnet. To use the faucet, go to the Casper Testnet Faucet. Log in using your Casper Wallet account and click on the &quot;Request Tokens&quot; button. note One account can request tokens only once. If you run out of tokens, you can either ask someone in the Casper community to send you some, or simply create a new account in the wallet. Now, when we have the tokens, we can deploy the contract. Let's do it using Odra! ","version":"next","tagName":"h2"},{"title":"Odra Livenet​","type":1,"pageTitle":"Deploying a Token on Casper Livenet","url":"/docs/next/tutorials/deploying-on-casper#odra-livenet","content":"Odra Livenet is described in detail in thebackends section of this documentation. We will then briefly describe how to use set it up in this tutorial. In your contract code, create a new file in the bin folder: bin/our_token_livenet.rs //! Deploys a new OurToken contract on the Casper livenet and mints some tokens for the tutorial //! creator. use std::str::FromStr; use odra::casper_types::U256; use odra::host::{Deployer, HostEnv, HostRef, HostRefLoader}; use odra::prelude::Address; use ourcoin::token::{OurToken, OurToken, OurTokenInitArgs}; fn main() { // Load the Casper livenet environment. let env = odra_casper_livenet_env::env(); // Caller is the deployer and the owner of the private key. let owner = env.caller(); // Just some random address... let recipient = &quot;hash-48bd92253a1370d1d913c56800296145547a243d13ff4f059ba4b985b1e94c26&quot;; let recipient = Address::from_str(recipient).unwrap(); // Deploy new contract. let mut token = deploy_our_token(&amp;env); println!(&quot;Token address: {}&quot;, token.address().to_string()); env.set_gas(2_500_000_000u64); // Propose minting new tokens. token.propose_new_mint(recipient, U256::from(1_000)); // Vote, we are the only voter. token.vote(true, U256::from(1_000)); // Let's advance the block time by 11 minutes, as // we set the voting time to 10 minutes. // OH NO! It is the Livenet, so we need to wait real time... // Hopefully you are not in a hurry. env.advance_block_time(11 * 60 * 1000); // Tally the votes. token.tally(); // Check the balances. println!(&quot;Owner's balance: {:?}&quot;, token.balance_of(&amp;owner)); println!( &quot;Tutorial creator's balance: {:?}&quot;, token.balance_of(&amp;recipient) ); } /// Deploys a contract. pub fn deploy_our_token(env: &amp;HostEnv) -&gt; OurTokenHostRef { let name = String::from(&quot;OurToken&quot;); let symbol = String::from(&quot;OT&quot;); let decimals = 0; let initial_supply = U256::from(1_000); let init_args = OurTokenInitArgs { name, symbol, decimals, initial_supply, }; env.set_gas(400_000_000_000u64); OurToken::deploy(env, init_args) // OurToken::deploy_with_cfg(env, init_args, odra::host::InstallConfig { // package_named_key: String::from(&quot;OurToken&quot;), // is_upgradable: true, // allow_key_override: true, // }) } /// Loads a contract. Just in case you need to load an existing contract later... fn _load_our_token(env: &amp;HostEnv) -&gt; OurTokenHostRef { let address = &quot;hash-XXXXX&quot;; let address = Address::from_str(address).unwrap(); OurToken::load(env, address) }  You can deploy a contract with the default configuration or with a custom configuration calling deploy_with_cfg. Read more about InstallConfig in the Odra documentation. In your Cargo.toml file, we need to add a new dependency, a feature and register the new binary. In the end, it should look like this: Cargo.toml [package] name = &quot;ourcoin&quot; version = &quot;0.1.0&quot; edition = &quot;2021&quot; [dependencies] odra = { version = &quot;2.2.0&quot;, features = [], default-features = false } odra-modules = { version = &quot;2.2.0&quot;, features = [], default-features = false } odra-casper-livenet-env = { version = &quot;2.2.0&quot;, optional = true } [dev-dependencies] odra-test = { version = &quot;2.2.0&quot;, features = [], default-features = false } [build-dependencies] odra-build = { version = &quot;2.2.0&quot;, features = [], default-features = false } [features] default = [] livenet = [&quot;odra-casper-livenet-env&quot;] [[bin]] name = &quot;ourcoin_build_contract&quot; path = &quot;bin/build_contract.rs&quot; test = false [[bin]] name = &quot;ourcoin_build_schema&quot; path = &quot;bin/build_schema.rs&quot; test = false [[bin]] name = &quot;our_token_livenet&quot; path = &quot;bin/our_token_livenet.rs&quot; required-features = [&quot;livenet&quot;] [profile.release] codegen-units = 1 lto = true [profile.dev.package.&quot;*&quot;] opt-level = 3  Finally, add the .env file with the following content: .env # Path to the secret key of the account that will be used to deploy the contracts. ODRA_CASPER_LIVENET_SECRET_KEY_PATH=folder_with_your_secret_key/secret_key.pem # RPC address of the node that will be used to deploy the contracts. # For CSPR.cloud, you can use the following addresses: # - https://node.cspr.cloud # - https://node.testnet.cspr.cloud # For nctl, default is: # - http://localhost:11101 ODRA_CASPER_LIVENET_NODE_ADDRESS=&lt;node_address&gt; # Chain name of the network. The mainnet is &quot;casper&quot; and test net is &quot;casper-test&quot;. # The integration network uses the &quot;integration-test&quot; chain name. # For nctl default is &quot;casper-net-1&quot; ODRA_CASPER_LIVENET_CHAIN_NAME=&lt;chain_name&gt; # Events url # For CSPR.cloud, you can use the following addresses: # - https://node.cspr.cloud/events # For nctl, default is: # - http://localhost:18101/events ODRA_CASPER_LIVENET_EVENTS_URL=&lt;events url&gt;  Of course, you need to replace the secret key's path with the path to the secret key file you downloaded from the Casper Wallet. note One of the problems you may encounter is that the node you are using will be down or will not accept your calls. In this case, you will have to find and use another node IP address. Now, we will run our code: cargo run --bin our_token_livenet --features livenet  If everything is set up correctly, you should see the output similar to this: cargo run --bin our_token_livenet --features livenet Compiling ourcoin v0.1.0 (/Users/kpob/workspace/odra/examples/ourcoin) Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.33s Running `../../target/debug/our_token_livenet` 💁 INFO : Found wasm under &quot;/Users/kpob/workspace/odra/examples/ourcoin/wasm/OurToken.wasm&quot;. 💁 INFO : Deploying &quot;OurToken&quot;. 🙄 WAIT : Waiting 10 for V1(TransactionV1Hash(c856983e995c79d8459540bd9d29d196535f63ceb8bac0f73ea747c5c9c74d76)). 💁 INFO : Transaction &quot;c856983e995c79d8459540bd9d29d196535f63ceb8bac0f73ea747c5c9c74d76&quot; successfully executed. 🔗 LINK : https://testnet.cspr.live/transaction/c856983e995c79d8459540bd9d29d196535f63ceb8bac0f73ea747c5c9c74d76 💁 INFO : Contract &quot;contract-package-e39aa2f8e4d509c0253dcd1709a9f08449477eef0f22f0ad5912fff327f509c8&quot; deployed. Token address: hash-e39aa2f8e4d509c0253dcd1709a9f08449477eef0f22f0ad5912fff327f509c8 💁 INFO : Calling &quot;contract-package-e39aa2f8e4d509c0253dcd1709a9f08449477eef0f22f0ad5912fff327f509c8&quot; directly with entrypoint &quot;propose_new_mint&quot;. 🙄 WAIT : Waiting 10 for V1(TransactionV1Hash(2d1aafe8f06748c7cfaf7972caee6b701de7a817430b52a73215f5ad9a175e77)). 💁 INFO : Transaction &quot;2d1aafe8f06748c7cfaf7972caee6b701de7a817430b52a73215f5ad9a175e77&quot; successfully executed. 🔗 LINK : https://testnet.cspr.live/transaction/2d1aafe8f06748c7cfaf7972caee6b701de7a817430b52a73215f5ad9a175e77 💁 INFO : Calling &quot;contract-package-e39aa2f8e4d509c0253dcd1709a9f08449477eef0f22f0ad5912fff327f509c8&quot; directly with entrypoint &quot;vote&quot;. 🙄 WAIT : Waiting 10 for V1(TransactionV1Hash(b565acd01c2ebbab78fa91a3f0091b849a037f1984ca4c996788b92fcd9521db)). 🙄 WAIT : Waiting 10 for V1(TransactionV1Hash(b565acd01c2ebbab78fa91a3f0091b849a037f1984ca4c996788b92fcd9521db)). 💁 INFO : Transaction &quot;b565acd01c2ebbab78fa91a3f0091b849a037f1984ca4c996788b92fcd9521db&quot; successfully executed. 🔗 LINK : https://testnet.cspr.live/transaction/b565acd01c2ebbab78fa91a3f0091b849a037f1984ca4c996788b92fcd9521db 💁 INFO : advance_block_time called - Waiting for 660000 ms 💁 INFO : Calling &quot;contract-package-e39aa2f8e4d509c0253dcd1709a9f08449477eef0f22f0ad5912fff327f509c8&quot; directly with entrypoint &quot;tally&quot;. 🙄 WAIT : Waiting 10 for V1(TransactionV1Hash(8d24de09298522b028073be5ba05542bf4efd0f03d0e8771d5c5a727832eba94)). 🙄 WAIT : Waiting 10 for V1(TransactionV1Hash(8d24de09298522b028073be5ba05542bf4efd0f03d0e8771d5c5a727832eba94)). 💁 INFO : Transaction &quot;8d24de09298522b028073be5ba05542bf4efd0f03d0e8771d5c5a727832eba94&quot; successfully executed. 🔗 LINK : https://testnet.cspr.live/transaction/8d24de09298522b028073be5ba05542bf4efd0f03d0e8771d5c5a727832eba94 Owner's balance: 1000 Tutorial creator's balance: 1000  Congratulations, your contract is now deployed on the Casper network! Before we move on, note the address of the token! We will use it in the next section to interact with the token. In our case it ishash-e39aa2f8e4d509c0253dcd1709a9f08449477eef0f22f0ad5912fff327f509c8. ","version":"next","tagName":"h2"},{"title":"Cspr.live​","type":1,"pageTitle":"Deploying a Token on Casper Livenet","url":"/docs/next/tutorials/deploying-on-casper#csprlive","content":"The first thing we will do is to explore Casper's network block explorer,cspr.live. We can put the address of our token in the search bar to find it. note If you deployed your contract on the Testnet, remember to make sure that the Testnet network is selected in the dropdown menu in the top right corner. If everything is set up correctly, you should see the contract package's details. Besides the owner, keys etc., you can also see the contract's metdata, if it was developed using a standard that cspr.live supports. Indeed, we can see that it detected that our contract is a CEP-18 token! We see the name, symbol and total supply. All the mentions of the contract on the website will use the token name instead of the contract address.  Additionally, on the Token Txs tab, we can see the transactions that happened with the token. We can see the minting transaction we did in the previous section and transfers done during the voting process.  If we click on one of the accounts that recieved the tokens, we will go to the account page. Here, on the Tokens tab, we can see all the tokens that the account has - and OurToken is one of them! If you wish, you can check the status of the contract deployed during the development of this tutorial here. ","version":"next","tagName":"h2"},{"title":"Transferring Tokens using Casper Wallet​","type":1,"pageTitle":"Deploying a Token on Casper Livenet","url":"/docs/next/tutorials/deploying-on-casper#transferring-tokens-using-casper-wallet","content":"Casper wallet can do much more than just logging in to the faucet, exporting the private keys and transferring CSPR. It can also interact with the contracts deployed on the network. If you deployed the contract and left some OT tokens to yourself, you should see them in the Casper Wallet window. You should also be able to transfer them to another account!  ","version":"next","tagName":"h2"},{"title":"Conclusion​","type":1,"pageTitle":"Deploying a Token on Casper Livenet","url":"/docs/next/tutorials/deploying-on-casper#conclusion","content":"We've successfully deployed a token on the Casper network and interacted with it using the Odra backend and Casper Wallet. We've also learned how to use the cspr.live block explorer to check the status of your contract. Odra, Cspr.live and Casper Wallet are just a few of the tools that the Casper ecosystem provides. Feel free to explore them on casperecosystem.io. ","version":"next","tagName":"h2"},{"title":"Migration guide to v0.8.0","type":0,"sectionRef":"#","url":"/docs/next/migrations/to-0.8.0","content":"","keywords":"","version":"next"},{"title":"1. Prerequisites​","type":1,"pageTitle":"Migration guide to v0.8.0","url":"/docs/next/migrations/to-0.8.0#1-prerequisites","content":"","version":"next","tagName":"h2"},{"title":"1.1. Update cargo-odra​","type":1,"pageTitle":"Migration guide to v0.8.0","url":"/docs/next/migrations/to-0.8.0#11-update-cargo-odra","content":"Before you begin the migration process, make sure you installed the latest version of the Cargo Odra toolchain. You can install it by running the following command: cargo install cargo-odra --force --locked  ","version":"next","tagName":"h3"},{"title":"1.2. Review the Changelog​","type":1,"pageTitle":"Migration guide to v0.8.0","url":"/docs/next/migrations/to-0.8.0#12-review-the-changelog","content":"Before you move to changing your code, start by reviewing the Changelog to understand the changes introduced in v0.8.0. ","version":"next","tagName":"h3"},{"title":"2. Migration Steps​","type":1,"pageTitle":"Migration guide to v0.8.0","url":"/docs/next/migrations/to-0.8.0#2-migration-steps","content":"","version":"next","tagName":"h2"},{"title":"2.1 Add bin directory​","type":1,"pageTitle":"Migration guide to v0.8.0","url":"/docs/next/migrations/to-0.8.0#21-add-bin-directory","content":"Odra 0.8.0 introduces a new way to build smart contracts. The .builder_casper directory is no longer used. Instead, you should create a new directory called bin in the root of your project and add the build_contract.rs and build_schema.rs files to the bin directory. You can find the build_contract.rs and build_schema.rs files in templates directory in the Odra main repository. You can choose whatever template you want to use and copy the files to your project. In both files, you should replace {{project-name}} with the name of your project. ","version":"next","tagName":"h3"},{"title":"2.2. Update Cargo.toml​","type":1,"pageTitle":"Migration guide to v0.8.0","url":"/docs/next/migrations/to-0.8.0#22-update-cargotoml","content":"There a bunch of changes in the Cargo.toml file. You don't have to specify the features anymore - remove the features section and default-features flag from the odra dependency.Register bins you added in the previous step.Add dev-dependencies section with odra-test crate.Add recommended profiles for release and dev to optimize the build process. Below you can compare the Cargo.toml file after and before the migration to v0.8.0: 0.8.0Prev [package] name = &quot;my_project&quot; version = &quot;0.1.0&quot; edition = &quot;2021&quot; [dependencies] odra = &quot;0.8.0&quot; [dev-dependencies] odra-test = &quot;0.8.0&quot; [[bin]] name = &quot;my_project_build_contract&quot; path = &quot;bin/build_contract.rs&quot; test = false [[bin]] name = &quot;my_project_build_schema&quot; path = &quot;bin/build_schema.rs&quot; test = false [profile.release] codegen-units = 1 lto = true [profile.dev.package.&quot;*&quot;] opt-level = 3  ","version":"next","tagName":"h3"},{"title":"2.2. Update Odra.toml​","type":1,"pageTitle":"Migration guide to v0.8.0","url":"/docs/next/migrations/to-0.8.0#22-update-odratoml","content":"Due to the changes in cargo-odra, the Odra.toml file has been simplified. The name property is no longer required. 0.8.0Prev [[contracts]] fqn = &quot;my_project::Flipper&quot;  ","version":"next","tagName":"h3"},{"title":"2.3. Update Smart Contracts​","type":1,"pageTitle":"Migration guide to v0.8.0","url":"/docs/next/migrations/to-0.8.0#23-update-smart-contracts","content":"The smart contracts themselves will need to be updated to work with the new version of the framework. The changes will depend on the specific features and APIs used in the contracts. Here are some common changes you might need to make: 2.3.1. Update the use statements to reflect the new module structure.​ Big integer types are now located in the odra::casper_types module.odra::types::Address is now odra::Address.Variable is now Var.Remove odra::contract_env.Remove odra::types::event::OdraEvent.Remove odra::types::OdraType as it is no longer required.Change odra::types::casper_types::*; to odra::casper_types::*;. 2.3.2. Some type aliases are no longer in use.​ Balance - use odra::casper_types::U512.BlockTime - use u64.EventData - use odra::casper_types::bytesrepr::Bytes. 2.3.3. Consider import odra::prelude::* in your module files.​ 2.3.4. Flatten nested Mappings.​ // Before #[odra::module(events = [Approval, Transfer])] pub struct Erc20 { ... allowances: Mapping&lt;Address, Mapping&lt;Address, U256&gt;&gt; } // After #[odra::module(events = [Approval, Transfer])] pub struct Erc20 { ... allowances: Mapping&lt;(Address, Address), U256&gt; }  2.3.5. Update errors definitions.​ execution_error! macro has been replace with OdraError derive macro. 0.8.0Prev use odra::OdraError; #[derive(OdraError)] pub enum Error { InsufficientBalance = 30_000, InsufficientAllowance = 30_001, NameNotSet = 30_002, SymbolNotSet = 30_003, DecimalsNotSet = 30_004 }  2.3.6. Update events definitions.​ 0.8.0Prev use odra::prelude::*; use odra::Event; #[derive(Event, Eq, PartialEq, Debug)] pub struct Transfer { pub from: Option&lt;Address&gt;, pub to: Option&lt;Address&gt;, pub amount: U256 } // Emitting the event self.env().emit_event(Transfer { from: None, to: Some(*address), amount: *amount });  2.3.7. Replace contract_env with self.env() in your modules.​ self.env() is a new way to access the contract environment, returns a reference to ContractEnv. The API is similar to the previous contract_env but with some changes. fn get_var&lt;T: FromBytes&gt;(key: &amp;[u8]) -&gt; Option&lt;T&gt; is now fn get_value&lt;T: FromBytes&gt;(&amp;self, key: &amp;[u8]) -&gt; Option&lt;T&gt;.fn set_var&lt;T: CLTyped + ToBytes&gt;(key: &amp;[u8], value: T) is now fn set_value&lt;T: ToBytes + CLTyped&gt;(&amp;self, key: &amp;[u8], value: T).set_dict_value() and get_dict_value() has been removed. All the dictionary operations should be performed using Mapping type, internally using set_var() and get_var() functions. fn hash&lt;T: AsRef&lt;[u8]&gt;&gt;(input: T) -&gt; Vec&lt;u8&gt; is now fn hash&lt;T: ToBytes&gt;(&amp;self, value: T) -&gt; [u8; 32].fn revert&lt;E: Into&lt;ExecutionError&gt;&gt;(error: E) -&gt; ! is now fn revert&lt;E: Into&lt;OdraError&gt;&gt;(&amp;self, error: E) -&gt; !.fn emit_event&lt;T: ToBytes + OdraEvent&gt;(event: T) is now fn emit_event&lt;T: ToBytes&gt;(&amp;self, event: T).fn call_contract&lt;T: CLTyped + FromBytes&gt;(address: Address, entrypoint: &amp;str, args: &amp;RuntimeArgs, amount: Option&lt;U512&gt;) -&gt; T is now fn call_contract&lt;T: FromBytes&gt;(&amp;self, address: Address, call: CallDef) -&gt; T.functions native_token_metadata() and one_token() have been removed. 2.3.8. Wrap submodules of your module with odra::SubModule&lt;T&gt;.​ 0.8.0Prev #[odra::module(events = [Transfer])] pub struct Erc721Token { core: SubModule&lt;Erc721Base&gt;, metadata: SubModule&lt;Erc721MetadataExtension&gt;, ownable: SubModule&lt;Ownable&gt; }  2.3.9. Update external contract calls.​ However the definition of an external contract remains the same, the way you call it has changed. A reference to an external contract is named {{ModuleName}}ContractRef (former {{ModuleName}}Ref) and you can call it using {{ModuleName}}ContractRef::new(env, address) (former {{ModuleName}}Ref::at()). 0.8.0Prev #[odra::external_contract] pub trait Token { fn balance_of(&amp;self, owner: &amp;Address) -&gt; U256; } // Usage TokenContractRef::new(env, token).balance_of(account)  2.3.10. Update constructors.​ Remove the #[odra::init] attribute from the constructor and ensure that the constructor function is named init. 2.3.11. Update UnwrapOrRevert calls.​ The functions unwrap_or_revert and unwrap_or_revert_with now require &amp;HostEnv as the first parameter. 2.3.12. Remove #[odra(using)] attribute from your module definition.​ Sharing the same instance of a module is no longer supported. A redesign of the module structure might be required. ","version":"next","tagName":"h3"},{"title":"2.4. Update Tests​","type":1,"pageTitle":"Migration guide to v0.8.0","url":"/docs/next/migrations/to-0.8.0#24-update-tests","content":"Once you've updated your smart contracts, you'll need to update your tests to reflect the changes. The changes will depend on the specific features and APIs used in the tests. Here are some common changes you might need to make: 2.4.1. Contract deployment.​ The way you deploy a contract has changed: You should use {{ModuleName}}HostRef::deploy(&amp;env, args) instead of {{ModuleName}}Deployer::init(). The {{ModuleName}}HostRef implements odra::host::Deployer.Instantiate the HostEnv using odra_test::env(), required by the odra::host::Deployer::deploy() function.If the contract doesn't have init args, you should use odra::host::NoArgs as the second argument of the deploy function.If the contract has init args, you should pass the autogenerated {{ModuleName}}InitArgs as the second argument of the deploy function. 0.8.0Prev // A contract without init args use super::OwnableHostRef; use odra::host::{Deployer, HostEnv, HostRef, NoArgs}; let env: HostEnv = odra_test::env(); let ownable = OwnableHostRef::deploy(&amp;env, NoArgs) // A contract with init args use super::{Erc20HostRef, Erc20InitArgs}; use odra::host::{Deployer, HostEnv}; let env: HostEnv = odra_test::env(); let init_args = Erc20InitArgs { symbol: SYMBOL.to_string(), name: NAME.to_string(), decimals: DECIMALS, initial_supply: Some(INITIAL_SUPPLY.into()) }; let erc20 = Erc20HostRef::deploy(&amp;env, init_args);  2.4.2. Host interactions.​ Replace odra::test_env with odra_test::env().The API of odra::test_env and odra_test::env() are similar, but there are some differences: test_env::advance_block_time_by(BlockTime) is now env.advance_block_time(u64).test_env::token_balance(Address) is now env.balance_of(&amp;Address).functions test_env::last_call_contract_gas_cost(), test_env::last_call_contract_gas_used(), test_env::total_gas_used(Address), test_env::gas_report() have been removed. You should use HostRef::last_call() and extract the data from a odra::ContractCallResult instance. HostRef is a trait implemented by {{ModuleName}}HostRef. 2.4.3. Testing failing scenarios.​ test_env::assert_exception() has been removed. You should use the try_ prefix to call the function and then assert the result.try_ prefix is a new way to call a function that might fail. It returns a OdraResult type, which you can then assert using the standard Rust assert_eq! macro. 0.8.0Prev #[test] fn transfer_from_error() { let (env, mut erc20) = setup(); let (owner, spender, recipient) = (env.get_account(0), env.get_account(1), env.get_account(2)); let amount = 1_000.into(); env.set_caller(spender); assert_eq!( erc20.try_transfer_from(owner, recipient, amount), Err(Error::InsufficientAllowance.into()) ); }  2.4.4. Testing events.​ assert_events! macro has been removed. You should use HostEnv::emitted_event() to assert the emitted events. The new API doesn't allow to assert multiple events at once, but adds alternative ways to assert the emitted events. Check the HostEnv documentation to explore the available options. 0.8.0Prev let env: HostEnv = odra_test::env(); let erc20 = Erc20HostRef::deploy(&amp;env, init_args); ... assert!(env.emitted_event( erc20.address(), &amp;Approval { owner, spender, value: approved_amount - transfer_amount } )); assert!(env.emitted_event( erc20.address(), &amp;Transfer { from: Some(owner), to: Some(recipient), amount: transfer_amount } ));  ","version":"next","tagName":"h3"},{"title":"3. Code Examples​","type":1,"pageTitle":"Migration guide to v0.8.0","url":"/docs/next/migrations/to-0.8.0#3-code-examples","content":"Here is a complete example of a smart contract after and before the migration to v0.8.0. 0.8.0Prev src/erc20.rs use crate::erc20::errors::Error::*; use crate::erc20::events::*; use odra::prelude::*; use odra::{casper_types::U256, Address, Mapping, Var}; #[odra::module(events = [Approval, Transfer])] pub struct Erc20 { decimals: Var&lt;u8&gt;, symbol: Var&lt;String&gt;, name: Var&lt;String&gt;, total_supply: Var&lt;U256&gt;, balances: Mapping&lt;Address, U256&gt;, allowances: Mapping&lt;(Address, Address), U256&gt; } #[odra::module] impl Erc20 { pub fn init( &amp;mut self, symbol: String, name: String, decimals: u8, initial_supply: Option&lt;U256&gt; ) { let caller = self.env().caller(); self.symbol.set(symbol); self.name.set(name); self.decimals.set(decimals); if let Some(initial_supply) = initial_supply { self.total_supply.set(initial_supply); self.balances.set(&amp;caller, initial_supply); if !initial_supply.is_zero() { self.env().emit_event(Transfer { from: None, to: Some(caller), amount: initial_supply }); } } } pub fn transfer(&amp;mut self, recipient: &amp;Address, amount: &amp;U256) { let caller = self.env().caller(); self.raw_transfer(&amp;caller, recipient, amount); } pub fn transfer_from(&amp;mut self, owner: &amp;Address, recipient: &amp;Address, amount: &amp;U256) { let spender = self.env().caller(); self.spend_allowance(owner, &amp;spender, amount); self.raw_transfer(owner, recipient, amount); } pub fn approve(&amp;mut self, spender: &amp;Address, amount: &amp;U256) { let owner = self.env().caller(); self.allowances.set(&amp;(owner, *spender), *amount); self.env().emit_event(Approval { owner, spender: *spender, value: *amount }); } pub fn name(&amp;self) -&gt; String { self.name.get_or_revert_with(NameNotSet) } // Other getter functions... pub fn allowance(&amp;self, owner: &amp;Address, spender: &amp;Address) -&gt; U256 { self.allowances.get_or_default(&amp;(*owner, *spender)) } pub fn mint(&amp;mut self, address: &amp;Address, amount: &amp;U256) { self.total_supply.add(*amount); self.balances.add(address, *amount); self.env().emit_event(Transfer { from: None, to: Some(*address), amount: *amount }); } pub fn burn(&amp;mut self, address: &amp;Address, amount: &amp;U256) { if self.balance_of(address) &lt; *amount { self.env().revert(InsufficientBalance); } self.total_supply.subtract(*amount); self.balances.subtract(address, *amount); self.env().emit_event(Transfer { from: Some(*address), to: None, amount: *amount }); } } impl Erc20 { fn raw_transfer(&amp;mut self, owner: &amp;Address, recipient: &amp;Address, amount: &amp;U256) { if *amount &gt; self.balances.get_or_default(owner) { self.env().revert(InsufficientBalance) } self.balances.subtract(owner, *amount); self.balances.add(recipient, *amount); self.env().emit_event(Transfer { from: Some(*owner), to: Some(*recipient), amount: *amount }); } fn spend_allowance(&amp;mut self, owner: &amp;Address, spender: &amp;Address, amount: &amp;U256) { let allowance = self.allowances.get_or_default(&amp;(*owner, *spender)); if allowance &lt; *amount { self.env().revert(InsufficientAllowance) } self.allowances.subtract(&amp;(*owner, *spender), *amount); self.env().emit_event(Approval { owner: *owner, spender: *spender, value: allowance - *amount }); } } pub mod events { use odra::prelude::*; use odra::{casper_types::U256, Address, Event}; #[derive(Event, Eq, PartialEq, Debug)] pub struct Transfer { pub from: Option&lt;Address&gt;, pub to: Option&lt;Address&gt;, pub amount: U256 } #[derive(Event, Eq, PartialEq, Debug)] pub struct Approval { pub owner: Address, pub spender: Address, pub value: U256 } } pub mod errors { use odra::OdraError; #[derive(OdraError)] pub enum Error { InsufficientBalance = 30_000, InsufficientAllowance = 30_001, NameNotSet = 30_002, SymbolNotSet = 30_003, DecimalsNotSet = 30_004 } } #[cfg(test)] mod tests { use super::{ errors::Error, events::{Approval, Transfer}, Erc20HostRef, Erc20InitArgs }; use odra::{ casper_types::U256, host::{Deployer, HostEnv, HostRef}, prelude::* }; const NAME: &amp;str = &quot;Plascoin&quot;; const SYMBOL: &amp;str = &quot;PLS&quot;; const DECIMALS: u8 = 10; const INITIAL_SUPPLY: u32 = 10_000; fn setup() -&gt; (HostEnv, Erc20HostRef) { let env = odra_test::env(); ( env.clone(), Erc20HostRef::deploy( &amp;env, Erc20InitArgs { symbol: SYMBOL.to_string(), name: NAME.to_string(), decimals: DECIMALS, initial_supply: Some(INITIAL_SUPPLY.into()) } ) ) } #[test] fn initialization() { // When deploy a contract with the initial supply. let (env, erc20) = setup(); // Then the contract has the metadata set. assert_eq!(erc20.symbol(), SYMBOL.to_string()); assert_eq!(erc20.name(), NAME.to_string()); assert_eq!(erc20.decimals(), DECIMALS); // Then the total supply is updated. assert_eq!(erc20.total_supply(), INITIAL_SUPPLY.into()); // Then a Transfer event was emitted. assert!(env.emitted_event( erc20.address(), &amp;Transfer { from: None, to: Some(env.get_account(0)), amount: INITIAL_SUPPLY.into() } )); } #[test] fn transfer_works() { // Given a new contract. let (env, mut erc20) = setup(); // When transfer tokens to a recipient. let sender = env.get_account(0); let recipient = env.get_account(1); let amount = 1_000.into(); erc20.transfer(&amp;recipient, &amp;amount); // Then the sender balance is deducted. assert_eq!( erc20.balance_of(&amp;sender), U256::from(INITIAL_SUPPLY) - amount ); // Then the recipient balance is updated. assert_eq!(erc20.balance_of(&amp;recipient), amount); // Then Transfer event was emitted. assert!(env.emitted_event( erc20.address(), &amp;Transfer { from: Some(sender), to: Some(recipient), amount } )); } #[test] fn transfer_error() { // Given a new contract. let (env, mut erc20) = setup(); // When the transfer amount exceeds the sender balance. let recipient = env.get_account(1); let amount = U256::from(INITIAL_SUPPLY) + U256::one(); // Then an error occurs. assert!(erc20.try_transfer(&amp;recipient, &amp;amount).is_err()); } // Other tests... }  ","version":"next","tagName":"h2"},{"title":"4. Troubleshooting​","type":1,"pageTitle":"Migration guide to v0.8.0","url":"/docs/next/migrations/to-0.8.0#4-troubleshooting","content":"If you encounter any further issues after completing the migration steps, please don't hesitate to reach out to us on Discord or explore the other sections this documentation. You can also refer to the technical documentation for more detailed information. Additionally, our examples repository offers a wide range of examples to assist you in understanding the new features and APIs. Be sure to carefully review any compilation errors and warnings, as they may provide valuable insights into the necessary adjustments. ","version":"next","tagName":"h2"},{"title":"5. References​","type":1,"pageTitle":"Migration guide to v0.8.0","url":"/docs/next/migrations/to-0.8.0#5-references","content":"ChangelogOdra DocumentationDocs.rsExamples ","version":"next","tagName":"h2"},{"title":"CEP-18","type":0,"sectionRef":"#","url":"/docs/next/tutorials/cep18","content":"","keywords":"","version":"next"},{"title":"Self-governing token​","type":1,"pageTitle":"CEP-18","url":"/docs/next/tutorials/cep18#self-governing-token","content":"There are many ways to implement a governance mechanism for a token, each more complex than the other. In our example, we will use a simple one, where the community of token holders can vote to mint new tokens. ","version":"next","tagName":"h2"},{"title":"Token implementation​","type":1,"pageTitle":"CEP-18","url":"/docs/next/tutorials/cep18#token-implementation","content":"Let's start by creating a new project, choosing a clever name and using cep18 as our starting template: cargo odra new --name ourcoin --template cep18  Let's glance at our token code: src/token.rs #[odra::module] pub struct MyToken { token: SubModule&lt;Cep18&gt;, } impl MyToken { // Delegate all Cep18 functions to the token sub-module. delegate! { to self.token { ... fn name(&amp;self) -&gt; String; fn symbol(&amp;self) -&gt; String; ...  As we can see, it indeed uses the Cep18 module and delegates all the methods to it. The only thing to do is to change the name of the struct to more appropriate OurToken, run the provided tests using cargo odra test, and continue with the implementation of the governance. note Remember to change the name of the struct and its usages as well as the struct name in the Odra.toml file! ","version":"next","tagName":"h2"},{"title":"Governance implementation​","type":1,"pageTitle":"CEP-18","url":"/docs/next/tutorials/cep18#governance-implementation","content":"Let's go through the process of implementing the governance mechanism. If we don't want to, we don't have to hide entrypoints from the public responsible for minting new tokens. By default, minting Modalityis turned off, so any attempt of direct minting will result in an error. We will however implement a voting mechanism, where the token holders can vote to mint new tokens. ","version":"next","tagName":"h2"},{"title":"Voting mechanism​","type":1,"pageTitle":"CEP-18","url":"/docs/next/tutorials/cep18#voting-mechanism","content":"Our voting system will be straightforward: Anyone with the tokens can propose a new mint.Anyone with the tokens can vote for the new mint by staking their tokens.If the majority of the token holders vote for the mint, it is executed. Storage​ We will need to store some additional information about the votes, so let's add some fields to our token struct: src/token.rs #[odra::module] pub struct OurToken { /// A sub-module that implements the CEP-18 token standard. token: SubModule&lt;Cep18&gt;, /// The proposed mint. proposed_mint: Var&lt;(Address, U256)&gt;, /// The list of votes cast in the current vote. votes: List&lt;Ballot&gt;, /// Whether a vote is open. is_vote_open: Var&lt;bool&gt;, /// The time when the vote ends. vote_end_time: Var&lt;u64&gt;, } /// A ballot cast by a voter. #[odra::odra_type] struct Ballot { voter: Address, choice: bool, amount: U256, }  Notice that proposed_mint contains a tuple containing the address of the proposer and the amount of tokens to mint. Moreover, we need to keep track if the vote time has ended, but also if it was already tallied, that's why we need both is_vote_open and vote_end_time. We will also use the power of the Listtype to store the Ballots. Proposing a new mint​ To implement the endpoint that allows token holders to propose a new mint, we need to add a new function to our token module: src/token.rs /// Proposes a new mint for the contract. pub fn propose_new_mint(&amp;mut self, account: Address, amount: U256) { // Only allow proposing a new mint if there is no vote in progress. if self.is_vote_open().get_or_default() { self.env().revert(GovernanceError::VoteAlreadyOpen); } // Only the token holders can propose a new mint. if self.balance_of(&amp;self.env().caller()) == U256::zero() { self.env().revert(GovernanceError::OnlyTokenHoldersCanPropose); } // Set the proposed mint. self.proposed_mint.set((account, amount)); // Open a vote. self.is_vote_open.set(true); // Set the vote end time to 10 minutes from now. self.vote_end_time .set(self.env().get_block_time() + 60 * 10 * 1000); }  As a parameters to the function, we pass the address of the account that should be the receiver of the minted tokens, and the amount. After some validation, we open the vote by setting the is_vote_open to true, and setting the vote_end_time to 10 minutes. In real-world scenarios, the time could be configurable, but for the sake of simplicity, we hardcoded it. Also, it should be quite longer than 10 minutes, but it will come in handy when we test it on Livenet. Voting for the mint​ Next, we need an endpoint that will allow us to cast a ballot: src/token.rs /// Votes on the proposed mint. pub fn vote(&amp;mut self, choice: bool, amount: U256) { // Only allow voting if there is a vote in progress. self.assert_vote_in_progress(); let voter = self.env().caller(); let contract = self.env().self_address(); // Transfer the voting tokens from the voter to the contract. self.token .transfer(&amp;contract, &amp;amount); // Add the vote to the list. self.votes.push(Ballot { voter, choice, amount, }); }  The most interesting thing here is that we are using a mechanism of staking, where we transfer our tokens to the contract, to show that we really mean it. The tokens will be locked until the vote is over, and tallied. Speaking of tallying... Tallying the votes​ The last step is to tally the votes and mint the tokens if the majority of voters agreed to do so: src/token.rs /// Count the votes and perform the action pub fn tally(&amp;mut self) { // Only allow tallying the votes once. if !self.is_vote_open.get_or_default() { self.env().revert(GovernanceError::NoVoteInProgress); } // Only allow tallying the votes after the vote has ended. let finish_time = self .vote_end_time .get_or_revert_with(GovernanceError::NoVoteInProgress); if self.env().get_block_time() &lt; finish_time { self.env().revert(GovernanceError::VoteNotYetEnded); } // Count the votes let mut yes_votes = U256::zero(); let mut no_votes = U256::zero(); let contract = self.env().self_address(); while let Some(vote) = self.votes.pop() { if vote.choice { yes_votes += vote.amount; } else { no_votes += vote.amount; } // Transfer back the voting tokens to the voter. self.token.raw_transfer(&amp;contract, &amp;vote.voter, &amp;vote.amount); } // Perform the action if the vote has passed. if yes_votes &gt; no_votes { let (account, amount) = self .proposed_mint .get_or_revert_with(GovernanceError::NoVoteInProgress); self.token.raw_mint(&amp;account, &amp;amount); } // Close the vote. self.is_vote_open.set(false); }  Notice how we used raw_transfer from the Cep18 module. We used it to set the sender, so the contract's balance will be used, instead of the caller's. Additonally, we used raw_mint to mint the tokens, skipping the security checks. We have no modality for minting, but even if we had, we don't have anyone with permissions! The Contract needs to mint the tokens itself. ","version":"next","tagName":"h3"},{"title":"Testing​","type":1,"pageTitle":"CEP-18","url":"/docs/next/tutorials/cep18#testing","content":"Now, we will put our implementation to the test. One unit test, that we can run both on OdraVM and on the CasperVM. src/token.rs #[test] fn it_works() { let env = odra_test::env(); let init_args = OurTokenInitArgs { name: &quot;OurToken&quot;.to_string(), symbol: &quot;OT&quot;.to_string(), decimals: 0, initial_supply: U256::from(1_000u64), }; let mut token = OurToken::deploy(&amp;env, init_args); // The deployer, as the only token holder, // starts a new voting to mint 1000 tokens to account 1. // There is only 1 token holder, so there is one Ballot cast. token.propose_new_mint(env.get_account(1), U256::from(2000)); token.vote(true, U256::from(1000)); // The tokens should now be staked. assert_eq!(token.balance_of(&amp;env.get_account(0)), U256::zero()); // Wait for the vote to end. env.advance_block_time(60 * 11 * 1000); // Finish the vote. token.tally(); // The tokens should now be minted. assert_eq!(token.balance_of(&amp;env.get_account(1)), U256::from(2000)); assert_eq!(token.total_supply(), 3000.into()); // The stake should be returned. assert_eq!(token.balance_of(&amp;env.get_account(0)), U256::from(1000)); // Now account 1 can mint new tokens with their voting power... env.set_caller(env.get_account(1)); token.propose_new_mint(env.get_account(1), U256::from(2000)); token.vote(true, U256::from(2000)); // ...Even if the deployer votes against it. env.set_caller(env.get_account(0)); token.vote(false, U256::from(1000)); env.advance_block_time(60 * 11 * 1000); token.tally(); // The power of community governance! assert_eq!(token.balance_of(&amp;env.get_account(1)), U256::from(4000)); }  We can run the test using both methods: cargo odra test cargo odra test -b casper  It is all nice and green, but it would be really nice to see it in action. How about deploying it on the Casper network? ","version":"next","tagName":"h3"},{"title":"What's next​","type":1,"pageTitle":"CEP-18","url":"/docs/next/tutorials/cep18#whats-next","content":"We will se our token in action, by deploying it on the Casper network, and using tools from the Casper Ecosystem to interact with it. ","version":"next","tagName":"h2"},{"title":"Complete code​","type":1,"pageTitle":"CEP-18","url":"/docs/next/tutorials/cep18#complete-code","content":"Here is the complete code of the OurToken module: src/token.rs use odra::{casper_types::U256, prelude::*}; use odra_modules::cep18_token::Cep18; /// A ballot cast by a voter. #[odra::odra_type] struct Ballot { voter: Address, choice: bool, amount: U256, } /// Errors for the governed token. #[odra::odra_error] pub enum GovernanceError { /// The vote is already in progress. VoteAlreadyOpen = 0, /// No vote is in progress. NoVoteInProgress = 1, /// Cannot tally votes yet. VoteNotYetEnded = 2, /// Vote ended VoteEnded = 3, /// Only the token holders can propose a new mint. OnlyTokenHoldersCanPropose = 4, } /// A module definition. Each module struct consists of Vars and Mappings /// or/and other modules. #[odra::module(errors = GovernanceError)] pub struct OurToken { /// A submodule that implements the CEP-18 token standard. token: SubModule&lt;Cep18&gt;, /// The proposed mint. proposed_mint: Var&lt;(Address, U256)&gt;, /// The list of votes cast in the current vote. votes: List&lt;Ballot&gt;, /// Whether a vote is open. is_vote_open: Var&lt;bool&gt;, /// The time when the vote ends. vote_end_time: Var&lt;u64&gt;, } /// Module implementation. /// /// To generate entrypoints, /// an implementation block must be marked as #[odra::module]. #[odra::module] impl OurToken { /// Initializes the contract with the given metadata and initial supply. pub fn init(&amp;mut self, name: String, symbol: String, decimals: u8, initial_supply: U256) { // We put the token address as an admin, so it can govern itself. Self-governing token! self.token.init(symbol, name, decimals, initial_supply); } // Delegate all Cep18 functions to the token submodule. delegate! { to self.token { /// Returns the name of the token. fn name(&amp;self) -&gt; String; /// Returns the symbol of the token. fn symbol(&amp;self) -&gt; String; /// Returns the number of decimals the token uses. fn decimals(&amp;self) -&gt; u8; /// Returns the total supply of the token. fn total_supply(&amp;self) -&gt; U256; /// Returns the balance of the given address. fn balance_of(&amp;self, address: &amp;Address) -&gt; U256; /// Returns the amount of tokens the owner has allowed the spender to spend. fn allowance(&amp;self, owner: &amp;Address, spender: &amp;Address) -&gt; U256; /// Approves the spender to spend the given amount of tokens on behalf of the caller. fn approve(&amp;mut self, spender: &amp;Address, amount: &amp;U256); /// Decreases the allowance of the spender by the given amount. fn decrease_allowance(&amp;mut self, spender: &amp;Address, decr_by: &amp;U256); /// Increases the allowance of the spender by the given amount. fn increase_allowance(&amp;mut self, spender: &amp;Address, inc_by: &amp;U256); /// Transfers tokens from the caller to the recipient. fn transfer(&amp;mut self, recipient: &amp;Address, amount: &amp;U256); /// Transfers tokens from the owner to the recipient using the spender's allowance. fn transfer_from(&amp;mut self, owner: &amp;Address, recipient: &amp;Address, amount: &amp;U256); } } /// Burns the given amount of tokens from the given address. pub fn burn(&amp;mut self, owner: &amp;Address, amount: &amp;U256) { self.token.assert_caller(owner); // Burn the tokens. self.token.raw_burn(owner, amount); } /// Proposes a new mint for the contract. pub fn propose_new_mint(&amp;mut self, account: Address, amount: U256) { // Only allow proposing a new mint if there is no vote in progress. if self.is_vote_open.get_or_default() { self.env().revert(GovernanceError::VoteAlreadyOpen); } // Only the token holders can propose a new mint. if self.balance_of(&amp;self.env().caller()) == U256::zero() { self.env() .revert(GovernanceError::OnlyTokenHoldersCanPropose); } // Set the proposed mint. self.proposed_mint.set((account, amount)); // Open a vote. self.is_vote_open.set(true); // Set the vote end time to 10 minutes from now. self.vote_end_time .set(self.env().get_block_time() + 10 * 60 * 1000); } /// Votes on the proposed mint. pub fn vote(&amp;mut self, choice: bool, amount: U256) { // Only allow voting if there is a vote in progress. self.assert_vote_in_progress(); let voter = self.env().caller(); let contract = self.env().self_address(); // Transfer the voting tokens from the voter to the contract. self.token.transfer(&amp;contract, &amp;amount); // Add the vote to the list. self.votes.push(Ballot { voter, choice, amount, }); } /// Count the votes and perform the action pub fn tally(&amp;mut self) { // Only allow tallying the votes once. if !self.is_vote_open.get_or_default() { self.env().revert(GovernanceError::NoVoteInProgress); } // Only allow tallying the votes after the vote has ended. let finish_time = self .vote_end_time .get_or_revert_with(GovernanceError::NoVoteInProgress); if self.env().get_block_time() &lt; finish_time { self.env().revert(GovernanceError::VoteNotYetEnded); } // Count the votes let mut yes_votes = U256::zero(); let mut no_votes = U256::zero(); let contract = self.env().self_address(); while let Some(vote) = self.votes.pop() { if vote.choice { yes_votes += vote.amount; } else { no_votes += vote.amount; } // Transfer back the voting tokens to the voter. self.token .raw_transfer(&amp;contract, &amp;vote.voter, &amp;vote.amount); } // Perform the action if the vote has passed. if yes_votes &gt; no_votes { let (account, amount) = self .proposed_mint .get_or_revert_with(GovernanceError::NoVoteInProgress); self.token.raw_mint(&amp;account, &amp;amount); } // Close the vote. self.is_vote_open.set(false); } fn assert_vote_in_progress(&amp;self) { if !self.is_vote_open.get_or_default() { self.env().revert(GovernanceError::NoVoteInProgress); } let finish_time = self .vote_end_time .get_or_revert_with(GovernanceError::NoVoteInProgress); if self.env().get_block_time() &gt; finish_time { self.env().revert(GovernanceError::VoteEnded); } } } #[cfg(test)] mod tests { use super::*; use odra::host::Deployer; #[test] fn it_works() { let env = odra_test::env(); let init_args = OurTokenInitArgs { name: &quot;OurToken&quot;.to_string(), symbol: &quot;OT&quot;.to_string(), decimals: 0, initial_supply: U256::from(1_000u64), }; let mut token = OurToken::deploy(&amp;env, init_args); // The deployer, as the only token holder, // starts a new voting to mint 1000 tokens to account 1. // There is only 1 token holder, so there is one Ballot cast. token.propose_new_mint(env.get_account(1), U256::from(2000)); token.vote(true, U256::from(1000)); // The tokens should now be staked. assert_eq!(token.balance_of(&amp;env.get_account(0)), U256::zero()); // Wait for the vote to end. env.advance_block_time(60 * 11 * 1000); // Finish the vote. token.tally(); // The tokens should now be minted. assert_eq!(token.balance_of(&amp;env.get_account(1)), U256::from(2000)); assert_eq!(token.total_supply(), 3000.into()); // The stake should be returned. assert_eq!(token.balance_of(&amp;env.get_account(0)), U256::from(1000)); // Now account 1 can mint new tokens with their voting power... env.set_caller(env.get_account(1)); token.propose_new_mint(env.get_account(1), U256::from(2000)); token.vote(true, U256::from(2000)); // ...Even if the deployer votes against it. env.set_caller(env.get_account(0)); token.vote(false, U256::from(1000)); env.advance_block_time(60 * 11 * 1000); token.tally(); // The power of community governance! assert_eq!(token.balance_of(&amp;env.get_account(1)), U256::from(4000)); } }  ","version":"next","tagName":"h2"},{"title":"ERC-20","type":0,"sectionRef":"#","url":"/docs/next/tutorials/erc20","content":"","keywords":"","version":"next"},{"title":"Framework features​","type":1,"pageTitle":"ERC-20","url":"/docs/next/tutorials/erc20#framework-features","content":"A module we will write in a minute, will help you master a few Odra features: Advanced storage using key-value pairs,Odra types such as Address,Advanced event assertion. ","version":"next","tagName":"h2"},{"title":"Code​","type":1,"pageTitle":"ERC-20","url":"/docs/next/tutorials/erc20#code","content":"Our module features a considerably more complex storage layout compared to the previous example. It is designed to store the following data: Immutable metadata - name, symbol, and decimals.Total supply.Balances of individual users.Allowances, essentially indicating who is permitted to spend tokens on behalf of another user. ","version":"next","tagName":"h2"},{"title":"Module definition​","type":1,"pageTitle":"ERC-20","url":"/docs/next/tutorials/erc20#module-definition","content":"erc20.rs use odra::prelude::*; use odra::casper_types::U256; #[odra::module(events = [Transfer, Approval], errors = Error)] pub struct Erc20 { decimals: Var&lt;u8&gt;, symbol: Var&lt;String&gt;, name: Var&lt;String&gt;, total_supply: Var&lt;U256&gt;, balances: Mapping&lt;Address, U256&gt;, allowances: Mapping&lt;(Address, Address), U256&gt; }  L10 - For the first time, we need to store key-value pairs. In order to do that, we use Mapping. The name is taken after Solidity's native type mapping.L11 - Odra does not allows nested Mappings as Solidity does. Instead, you can create a compound key using a tuple of keys. ","version":"next","tagName":"h2"},{"title":"Metadata​","type":1,"pageTitle":"ERC-20","url":"/docs/next/tutorials/erc20#metadata","content":"erc20.rs #[odra::module] impl Erc20 { pub fn init(&amp;mut self, name: String, symbol: String, decimals: u8, initial_supply: U256) { let caller = self.env().caller(); self.name.set(name); self.symbol.set(symbol); self.decimals.set(decimals); self.mint(&amp;caller, &amp;initial_supply); } pub fn name(&amp;self) -&gt; String { self.name.get_or_default() } pub fn symbol(&amp;self) -&gt; String { self.symbol.get_or_default() } pub fn decimals(&amp;self) -&gt; u8 { self.decimals.get_or_default() } pub fn total_supply(&amp;self) -&gt; U256 { self.total_supply.get_or_default() } } impl Erc20 { pub fn mint(&amp;mut self, address: &amp;Address, amount: &amp;U256) { self.balances.add(address, *amount); self.total_supply.add(*amount); self.env().emit_event(Transfer { from: None, to: Some(*address), amount: *amount }); } } #[odra::event] pub struct Transfer { pub from: Option&lt;Address&gt;, pub to: Option&lt;Address&gt;, pub amount: U256 }  L1 - The first impl block, marked as a module, contains functions defined in the ERC-20 standard.L3-L9 - A constructor sets the token metadata and mints the initial supply.L28 - The second impl is not an Odra module; in other words, these functions will not be part of the contract's public interface.L29-L38 - The mint function is public, so, like in regular Rust code, it will be accessible from the outside. mint() uses the notation self.balances.add(address, *amount);, which is syntactic sugar for: let current_balance = self.balances.get(address).unwrap_or_default(); let new_balance = &lt;U256 as OverflowingAdd&gt;::overflowing_add(current_balance, current_balance).unwrap_or_revert(&amp;self.env()); self.balances.set(address, new_balance);  ","version":"next","tagName":"h3"},{"title":"Core​","type":1,"pageTitle":"ERC-20","url":"/docs/next/tutorials/erc20#core","content":"To ensure comprehensive functionality, let's implement the remaining features such as transfer, transfer_from, and approve. Since they do not introduce any new concepts, we will present them without additional remarks. erc20.rs #[odra::module] impl Erc20 { ... pub fn transfer(&amp;mut self, recipient: &amp;Address, amount: &amp;U256) { let caller = self.env().caller(); self.raw_transfer(&amp;caller, recipient, amount); } pub fn transfer_from(&amp;mut self, owner: &amp;Address, recipient: &amp;Address, amount: &amp;U256) { let spender = self.env().caller(); self.spend_allowance(owner, &amp;spender, amount); self.raw_transfer(owner, recipient, amount); } pub fn approve(&amp;mut self, spender: &amp;Address, amount: &amp;U256) { let owner = self.env().caller(); self.allowances.set(&amp;(owner, *spender), *amount); self.env().emit_event(Approval { owner, spender: *spender, value: *amount }); } pub fn balance_of(&amp;self, address: &amp;Address) -&gt; U256 { self.balances.get_or_default(&amp;address) } pub fn allowance(&amp;self, owner: &amp;Address, spender: &amp;Address) -&gt; U256 { self.allowances.get_or_default(&amp;(*owner, *spender)) } } impl Erc20 { ... fn raw_transfer(&amp;mut self, owner: &amp;Address, recipient: &amp;Address, amount: &amp;U256) { let owner_balance = self.balances.get_or_default(&amp;owner); if *amount &gt; owner_balance { self.env().revert(Error::InsufficientBalance) } self.balances.set(owner, owner_balance - *amount); self.balances.add(recipient, *amount); self.env().emit_event(Transfer { from: Some(*owner), to: Some(*recipient), amount: *amount }); } fn spend_allowance(&amp;mut self, owner: &amp;Address, spender: &amp;Address, amount: &amp;U256) { let allowance = self.allowance(owner, spender); if allowance &lt; *amount { self.env().revert(Error::InsufficientAllowance) } let new_allowance = allowance - *amount; self.allowances .set(&amp;(*owner, *spender), new_allowance); self.env().emit_event(Approval { owner: *owner, spender: *spender, value: allowance - *amount }); } } #[odra::event] pub struct Approval { pub owner: Address, pub spender: Address, pub value: U256 } #[odra::odra_error] pub enum Error { InsufficientBalance = 1, InsufficientAllowance = 2, }  Now, compare the code we have written, with Open Zeppelin code. Out of 10, how Solidity-ish is our implementation? ","version":"next","tagName":"h3"},{"title":"Test​","type":1,"pageTitle":"ERC-20","url":"/docs/next/tutorials/erc20#test","content":"erc20.rs #[cfg(test)] pub mod tests { use super::*; use odra::{ casper_types::U256, host::{Deployer, HostEnv}, prelude::* }; const NAME: &amp;str = &quot;Plascoin&quot;; const SYMBOL: &amp;str = &quot;PLS&quot;; const DECIMALS: u8 = 10; const INITIAL_SUPPLY: u32 = 10_000; fn setup() -&gt; (HostEnv, Erc20HostRef) { let env = odra_test::env(); ( env.clone(), Erc20::deploy( &amp;env, Erc20InitArgs { symbol: SYMBOL.to_string(), name: NAME.to_string(), decimals: DECIMALS, initial_supply: INITIAL_SUPPLY.into() } ) ) } #[test] fn initialization() { // When deploy a contract with the initial supply. let (env, erc20) = setup(); // Then the contract has the metadata set. assert_eq!(erc20.symbol(), SYMBOL.to_string()); assert_eq!(erc20.name(), NAME.to_string()); assert_eq!(erc20.decimals(), DECIMALS); // Then the total supply is updated. assert_eq!(erc20.total_supply(), INITIAL_SUPPLY.into()); // Then a Transfer event was emitted. assert!(env.emitted_event( &amp;erc20, &amp;Transfer { from: None, to: Some(env.get_account(0)), amount: INITIAL_SUPPLY.into() } )); } #[test] fn transfer_works() { // Given a new contract. let (env, mut erc20) = setup(); // When transfer tokens to a recipient. let sender = env.get_account(0); let recipient = env.get_account(1); let amount = 1_000.into(); erc20.transfer(&amp;recipient, &amp;amount); // Then the sender balance is deducted. assert_eq!( erc20.balance_of(&amp;sender), U256::from(INITIAL_SUPPLY) - amount ); // Then the recipient balance is updated. assert_eq!(erc20.balance_of(&amp;recipient), amount); // Then Transfer event was emitted. assert!(env.emitted_event( &amp;erc20, &amp;Transfer { from: Some(sender), to: Some(recipient), amount } )); } #[test] fn transfer_error() { // Given a new contract. let (env, mut erc20) = setup(); // When the transfer amount exceeds the sender balance. let recipient = env.get_account(1); let amount = U256::from(INITIAL_SUPPLY) + U256::one(); // Then an error occurs. assert!(erc20.try_transfer(&amp;recipient, &amp;amount).is_err()); } #[test] fn transfer_from_and_approval_work() { let (env, mut erc20) = setup(); let (owner, recipient, spender) = (env.get_account(0), env.get_account(1), env.get_account(2)); let approved_amount = 3_000.into(); let transfer_amount = 1_000.into(); assert_eq!(erc20.balance_of(&amp;owner), U256::from(INITIAL_SUPPLY)); // Owner approves Spender. erc20.approve(&amp;spender, &amp;approved_amount); // Allowance was recorded. assert_eq!(erc20.allowance(&amp;owner, &amp;spender), approved_amount); assert!(env.emitted_event( &amp;erc20, Approval { owner, spender, value: approved_amount } )); // Spender transfers tokens from Owner to Recipient. env.set_caller(spender); erc20.transfer_from(&amp;owner, &amp;recipient, &amp;transfer_amount); // Tokens are transferred and allowance decremented. assert_eq!( erc20.balance_of(&amp;owner), U256::from(INITIAL_SUPPLY) - transfer_amount ); assert_eq!(erc20.balance_of(&amp;recipient), transfer_amount); assert!(env.emitted_event( &amp;erc20, Approval { owner, spender, value: approved_amount - transfer_amount } )); assert!(env.emitted_event( &amp;erc20, Transfer { from: Some(owner), to: Some(recipient), amount: transfer_amount } )); // assert!(env.emitted(&amp;erc20, &quot;Transfer&quot;)); } #[test] fn transfer_from_error() { // Given a new instance. let (env, mut erc20) = setup(); // When the spender's allowance is zero. let (owner, spender, recipient) = (env.get_account(0), env.get_account(1), env.get_account(2)); let amount = 1_000.into(); env.set_caller(spender); // Then transfer fails. assert_eq!( erc20.try_transfer_from(&amp;owner, &amp;recipient, &amp;amount), Err(Error::InsufficientAllowance.into()) ); } }  L146 - Alternatively, if you don't want to check the entire event, you may assert only its type. ","version":"next","tagName":"h3"},{"title":"What's next​","type":1,"pageTitle":"ERC-20","url":"/docs/next/tutorials/erc20#whats-next","content":"Having two modules: Ownable and Erc20, let's combine them, and create an ERC-20 on steroids. ","version":"next","tagName":"h2"},{"title":"Odra CLI","type":0,"sectionRef":"#","url":"/docs/next/tutorials/odra-cli","content":"","keywords":"","version":"next"},{"title":"Example​","type":1,"pageTitle":"Odra CLI","url":"/docs/next/tutorials/odra-cli#example","content":"Let's go through an example available in the odra repository to see how to use the Odra CLI library. It creates a CLI tool for a useful DogContract. ","version":"next","tagName":"h2"},{"title":"Cargo.toml​","type":1,"pageTitle":"Odra CLI","url":"/docs/next/tutorials/odra-cli#cargotoml","content":"To use the Odra CLI library in your project, you need to add odra-cli to your Cargo.toml file, alongside a new binary: [dependencies] ... odra-cli = &quot;2&quot; ... [[bin]] name = &quot;odra-cli&quot; path = &quot;bin/odra-cli.rs&quot;  Then, create an empty file in the bin directory named odra-cli.rs. ","version":"next","tagName":"h3"},{"title":"Deploy script​","type":1,"pageTitle":"Odra CLI","url":"/docs/next/tutorials/odra-cli#deploy-script","content":"The first type of script we can create is a deploy script. It is used to deploy the contract to the network and store the address of the deployed contract in a container for later use. Only one deploy script can be used in a single CLI tool, and it is executed when the user runs the deploy command. bin/odra-cli.rs use odra::host::HostEnv; use odra_cli::{ deploy::DeployScript, DeployerExt, DeployedContractsContainer, }; use odra_examples::features::storage::variable::{DogContract, DogContractInitArgs}; /// Deploys the `DogContract` and adds it to the container. pub struct DeployDogScript; impl DeployScript for DeployDogScript { fn deploy( &amp;self, env: &amp;HostEnv, container: &amp;mut DeployedContractsContainer ) -&gt; Result&lt;(), odra_cli::deploy::Error&gt; { env.set_gas(350_000_000_000); let dog_contract = DogContract::try_deploy( env, DogContractInitArgs { barks: true, weight: 10, name: &quot;Mantus&quot;.to_string() } )?; container.add_contract(&amp;dog_contract)?; // By default, a contract is non-upgradeable, you can change it by passing `InstallConfig` _ = DogContract::try_deploy_with_cfg( env, DogContractInitArgs { barks: true, weight: 10, name: &quot;Mantus&quot;.to_string() }, InstallConfig::upgradable::&lt;DogContract&gt;(), )?; // Alternatively, you can use the `DeployerExt` trait to deploy the contract: _ = DogContract::load_or_deploy( env, DogContractInitArgs { barks: true, weight: 10, name: &quot;Mantus&quot;.to_string() }, container, 350_000_000_000 )?; // You can use `load_or_deploy_with_cfg` to deploy the contract with a custom configuration _ = DogContract::load_or_deploy_with_cfg( env, DogContractInitArgs { barks: true, weight: 10, name: &quot;Mantus&quot;.to_string() }, InstallConfig::upgradable::&lt;DogContract&gt;(), container, 350_000_000_000 )?; Ok(()) } }  In the example above, we see a few alternative implementations of a simple DeployScript for our DogContract. All of them set the gas limit, deploy the contract and adds it to a container. DogContract::try_deploy method, which deploys the contract every time the script is run. DogContract::try_deploy_with_cfg also deploys a contract everytime, but passes InstallConfig instance to configure the deployment using a factory method InstallConfig::upgradable.Utilizes the DeployerExt trait, which checks if the contract is already deployed and returns the existing instance if it is, or deploys it if it is not. It is a convenient way to ensure that the contract is deployed only once. It is useful when you want to add more contracts to the script in the future and avoid redeploying previously deployed contracts. The last option is to use DeployerExt::load_or_deploy_with_cfg that works like the previous one, but accepts a custom configuration. The address of the deployed contract is stored in a TOML file in the resources directory, which is created automatically by the Odra CLI library. ","version":"next","tagName":"h3"},{"title":"Scenarios​","type":1,"pageTitle":"Odra CLI","url":"/docs/next/tutorials/odra-cli#scenarios","content":"Scenarios are a way to run multiple calls one after another, and can be used to test the contract or perform complex operations like setting up the dependencies between contracts. To create a scenario, you need to implement the Scenario trait and add it to the OdraCli instance in the main function. A scenario also implements the ScenarioMetadata trait, which provides metadata about the scenario, such as its name and description. You can use this metadata to display the scenario in the CLI tool and provide a description of what it does. bin/odra-cli.rs use odra_cli::{ scenario::{Args, Error, Scenario, ScenarioMetadata}, CommandArg, ContractProvider, DeployedContractsContainer, }; use std::vec; pub struct DogCheckScenario; impl Scenario for DogCheckScenario { fn args(&amp;self) -&gt; Vec&lt;CommandArg&gt; { vec![CommandArg::new( &quot;name&quot;, &quot;The name of the dog&quot;, NamedCLType::String, ).required()] } fn run( &amp;self, env: &amp;HostEnv, container: &amp;DeployedContractsContainer, args: Args ) -&gt; Result&lt;(), Error&gt; { let dog_contract = container.contract_ref::&lt;DogContract&gt;(env)?; let test_name = args.get_single::&lt;String&gt;(&quot;name&quot;)?; env.set_gas(50_000_000); let actual_name = dog_contract.try_name()?; assert_eq!(test_name, actual_name, &quot;Dog name mismatch&quot;); Ok(()) } } impl ScenarioMetadata for DogCheckScenario { const NAME: &amp;'static str = &quot;check&quot;; const DESCRIPTION: &amp;'static str = &quot;Checks if the name of the deployed dog matches the provided name&quot;; }  A scenario must implement the Scenario trait, which requires defining the args and run methods. The args method returns a vector of CommandArg that defines the arguments that the scenario accepts. In this case, we define a single argument name of type String, which is required - the program will fail at parse time if the argument is not provided. The run method is where the scenario logic is implemented. It receives the HostEnv, a container with deployed contracts, and the arguments passed to the scenario. To load the contract, we use the ContractProvider trait, which allows us to get a reference to the contract by its type. The trait is implemented for the DeployedContractsContainer, which is passed to the run method. To read the arguments, we use the Args type, which provides two methods: get_single and get_many. In this case, we use get_single to get the value of the name argument. If we want to get multiple values for an argument, we must define the argument as CommandArg::new(&quot;name&quot;, &quot;The name of the dog&quot;, NamedCLType::String).list(), where list() indicates that the argument can be provided multiple times. The example above performs a simple check on the return value of one of the methods. Of course, there is no limit to how complex a scenario can be. ","version":"next","tagName":"h3"},{"title":"Contract methods​","type":1,"pageTitle":"Odra CLI","url":"/docs/next/tutorials/odra-cli#contract-methods","content":"To interact with the contract methods, we can use the contract command. The Odra CLI automatically generates commands for each contract method, allowing us to call them directly by name. But first, we need to register the contract in the OdraCli instance. ","version":"next","tagName":"h3"},{"title":"Builder​","type":1,"pageTitle":"Odra CLI","url":"/docs/next/tutorials/odra-cli#builder","content":"Now, let's put everything together in the main function. We will use the OdraCli builder to create a CLI tool that can deploy the contract, call its methods, and run scenarios. bin/odra-cli.rs use odra_cli::OdraCli; /// Main function to run the CLI tool. pub fn main() { OdraCli::new() .about(&quot;Dog contract cli tool&quot;) .deploy(DeployDogScript) .contract::&lt;DogContract&gt;() .scenario(DogCheckScenario) .build() .run(); }  This code creates a new OdraCli instance, sets the description of the tool, adds the deploy script, registers the DogContract, and adds the scenario. Finally, it builds the CLI tool and runs it. ","version":"next","tagName":"h3"},{"title":"How to use it​","type":1,"pageTitle":"Odra CLI","url":"/docs/next/tutorials/odra-cli#how-to-use-it","content":"Assuming the correct livenet environment is set up, you can run the CLI tool using the following command: cargo run --bin odra-cli  This will display all of our options: Dog contract cli tool Usage: odra_cli [OPTIONS] &lt;COMMAND&gt; Commands: deploy Runs the deploy script contract Commands for interacting with contracts scenario Commands for interacting with scenarios print-events Prints the most recent events emitted by a contract help Print this message or the help of the given subcommand(s) Options: -c, --contracts-toml &lt;PathBuf&gt; The path to the file with the deployed contracts. Relative to the project root. -h, --help Print help  By default, contracts are written/read to/from the contracts.toml file, which is located in the resources directory, but you can specify a different path using the -c or --contracts-toml option. ","version":"next","tagName":"h2"},{"title":"Deploy command​","type":1,"pageTitle":"Odra CLI","url":"/docs/next/tutorials/odra-cli#deploy-command","content":"First, we need to deploy the contract: cargo run --bin odra_cli deploy  This gives us the following output: cargo run --bin odra_cli -- deploy Compiling odra-examples v2.1.0 (/home/kuba/Projekty/odra/odra/examples) Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.65s Running `../target/debug/odra_cli deploy` 💁 INFO : Found wasm under &quot;wasm/DogContract.wasm&quot;. 💁 INFO : Deploying &quot;DogContract&quot;. 🙄 WAIT : Waiting 10 for V1(TransactionV1Hash(4230d5ca3113d87190e4136cefe097bd08fea03c841ce5e4df73a049e10208f1)). 💁 INFO : Transaction &quot;4230d5ca3113d87190e4136cefe097bd08fea03c841ce5e4df73a049e10208f1&quot; successfully executed. 🔗 LINK : 💁 INFO : Contract &quot;contract-package-53b3486180b2a9506fbb0523ed159b1908cec628d091b19cbe74e057e7ebbc8b&quot; deployed. 💁 INFO : Command executed successfully  This will run the deploy script and create a new file in the resources directory named contracts.toml: last_updated = &quot;2025-07-03T10:33:55Z&quot; [[contracts]] name = &quot;DogContract&quot; package_hash = &quot;hash-53b3486180b2a9506fbb0523ed159b1908cec628d091b19cbe74e057e7ebbc8b&quot;  All the calls to the contract will be made using this package hash, unless you specify a different one using the -c or --contracts-toml option. ","version":"next","tagName":"h3"},{"title":"Contract command​","type":1,"pageTitle":"Odra CLI","url":"/docs/next/tutorials/odra-cli#contract-command","content":"To call a contract method, we need to use the contract command. The command itself will display all the available contracts: cargo run --bin odra_cli -- contract  This outputs: Commands for interacting with contracts Usage: odra_cli contract &lt;COMMAND&gt; Commands: DogContract Commands for interacting with the DogContract contract help Print this message or the help of the given subcommand(s)  And when a contract is selected, it will show us the available methods: cargo run --bin odra_cli -- contract DogContract  Commands for interacting with the DogContract contract Usage: odra_cli contract DogContract &lt;COMMAND&gt; Commands: barks Returns true if the dog barks. weight Returns the dog's weight. name Returns the dog's name. walks_amount Adds a walk to the dog's walks. walks_total_length Returns the total length of the dog's walks. help Print this message or the help of the given subcommand(s)  To run a command, compose a command like this: cargo run --bin odra_cli -- contract DogContract barks  This will result in: 💁 INFO : Call result: true 💁 INFO : Command executed successfully  If you run a command that requires arguments, it will display an error message: cargo run --bin odra_cli -- contract DogContract rename error: the following required arguments were not provided: --new_name &lt;String&gt; --gas &lt;U64&gt; Usage: odra_cli contract DogContract rename --new_name &lt;String&gt; --gas &lt;U64&gt; For more information, try '--help'.  The error message above indicates that the rename method requires two arguments: new_name and gas. In the code, the rename method is mutable and takes a single argument new_name of type String. As the entry point is mutable and requires a real transaction, the gas argument is also required to specify how much gas to use for the call. The gas amount is denominated in motes. Let's run the command with the required arguments: cargo run --bin odra_cli -- contract DogContract rename --new_name &quot;Doggy&quot; --gas 200000000 error: invalid value '200000000' for '--gas &lt;U64&gt;': 200000000 is not in 2500000000..18446744073709551615  As the minimum gas amount for a transaction is 2.5 CSPRs, we need to increase the gas amount to at least that value: cargo run --bin odra_cli -- contract DogContract rename --new_name &quot;Doggy&quot; --gas 2500000000 💁 INFO : Calling &quot;contract-package-0eda9544d667775d8e5503543dd8ba0996d439fd9ded79cfe28454d07f42df3a&quot; directly with entrypoint &quot;rename&quot;. 🙄 WAIT : Waiting 10 for V1(TransactionV1Hash(e9d2e7f9d7d832cbf64e6e9eb09404423757e354a1ed7420c0398d851fea3a40)). 💁 INFO : Transaction &quot;e9d2e7f9d7d832cbf64e6e9eb09404423757e354a1ed7420c0398d851fea3a40&quot; successfully executed. 🔗 LINK : 💁 INFO : Call executed successfully, but no result was returned. 💁 INFO : Command executed successfully # Verifying the name change cargo run --bin odra_cli -- contract DogContract name 💁 INFO : Call result: Doggy 💁 INFO : Command executed successfully  There are more options available for the contract command that we can discover by running the help command: cargo run --bin odra_cli -- contract DogContract rename --help It is uncommon but you can change the dog's name. Usage: odra_cli contract DogContract rename [OPTIONS] --new_name &lt;String&gt; --gas &lt;U64&gt; Options: --new_name &lt;String&gt; --attached_value &lt;U512&gt; The amount of CSPRs attached to the call --gas &lt;U64&gt; The amount of gas to attach to the call -p, --print-events Print events emitted by the contract -h, --help  If you want to print the events emitted by the contract, you can use the --print-events option. This will print all the events emitted by the contract during the call. cargo run --bin odra_cli -- contract DogContract rename --new_name &quot;Doggy&quot; --gas 2500000000 --print-events 💁 INFO : Syncing events for the call... 💁 INFO : Calling &quot;contract-package-0eda9544d667775d8e5503543dd8ba0996d439fd9ded79cfe28454d07f42df3a&quot; directly with entrypoint &quot;rename&quot;. 🙄 WAIT : Waiting 10 for V1(TransactionV1Hash(f2f473d46b59c136052f687539ab76e5fbb3af958c483e3a382b5a0e498227c4)). 💁 INFO : Transaction &quot;f2f473d46b59c136052f687539ab76e5fbb3af958c483e3a382b5a0e498227c4&quot; successfully executed. 🔗 LINK : 💁 INFO : Captured 1 events for contract 'DogContract' 💁 INFO : Event 1: 'NamedChanged': 'old_name': Mantus 'new_name': Doggy 💁 INFO : Call executed successfully, but no result was returned. 💁 INFO : Command executed successfully  For a payable method, you can use the --attached_value option to specify the amount of CSPRs to attach to the call. The value is denominated in motes. ","version":"next","tagName":"h3"},{"title":"Print-events command​","type":1,"pageTitle":"Odra CLI","url":"/docs/next/tutorials/odra-cli#print-events-command","content":"The print-events command allows you to print the most recent events emitted by a contract. It is useful for debugging and understanding what is happening in the contract. You can run it like this: cargo run --bin odra_cli -- print-events DogContract --help Print events of the DogContract contract Usage: odra_cli print-events DogContract [OPTIONS] Options: -n, --number &lt;N&gt; Number of events to print [default: 10] -h, --help Print help cargo run --bin odra_cli -- print-events DogContract -n 2 💁 INFO : Printing 4 the most recent events for contract 'DogContract' 💁 INFO : Event 1: 'NamedChanged': 'old_name': Mantus 'new_name': Doggy 💁 INFO : Event 2: 'NamedChanged': 'old_name': Rex 'new_name': Mantus 💁 INFO : Command executed successfully  By default, it prints the last 10 events, but you can specify a different number using the -n or --number option. ","version":"next","tagName":"h3"},{"title":"Scenario command​","type":1,"pageTitle":"Odra CLI","url":"/docs/next/tutorials/odra-cli#scenario-command","content":"Scenarios registered in the OdraCli instance can be run using the scenario command. It displays all the available scenarios: cargo run --bin odra_cli -- scenario  This will output: Commands for running user-defined scenarios Usage: odra_cli scenario &lt;COMMAND&gt; Commands: check Checks if the name of the deployed dog matches the provided name help Print this message or the help of the given subcommand(s)  It can be run like this: cargo run --bin odra_cli -- scenario check --name Doggy  This will output: thread 'main' panicked at examples/bin/odra_cli.rs:59:9: assertion `left == right` failed: Dog name mismatch left: &quot;Doggy&quot; right: &quot;Mantus&quot; ## Conclusion The Odra CLI library provides a powerful and convenient way to create command-line tools for your Odra contracts. It simplifies the process of deploying, interacting with, and testing your contracts, allowing you to focus on the business logic of your application. By following the examples in this tutorial, you can create your own CLI tools and streamline your development workflow.  ","version":"next","tagName":"h3"},{"title":"Ownable","type":0,"sectionRef":"#","url":"/docs/next/tutorials/ownable","content":"","keywords":"","version":"next"},{"title":"Framework features​","type":1,"pageTitle":"Ownable","url":"/docs/next/tutorials/ownable#framework-features","content":"A module we will write in a minute, will help you master a few Odra features: storing a single value,defining a constructor,error handling,defining and emitting events.registering a contact in a test environment,interactions with the test environment,assertions (value, events, errors assertions). ","version":"next","tagName":"h2"},{"title":"Code​","type":1,"pageTitle":"Ownable","url":"/docs/next/tutorials/ownable#code","content":"Before we write any code, we define functionalities we would like to implement. Module has an initializer that should be called once. Only the current owner can set a new owner.Read the current owner.A function that fails if called by a non-owner account. ","version":"next","tagName":"h2"},{"title":"Define a module​","type":1,"pageTitle":"Ownable","url":"/docs/next/tutorials/ownable#define-a-module","content":"ownable.rs use odra::prelude::*; #[odra::module(events = [OwnershipChanged])] pub struct Ownable { owner: Var&lt;Option&lt;Address&gt;&gt; }  That was easy, but it is crucial to understand the basics before we move on. L3 - Firstly, we need to create a struct called Ownable and apply #[odra::module(events = [OwnershipChanged])] attribute to it. The events attribute is optional but informs the Odra toolchain about the events that will be emitted by the module and includes them in the contract's metadata. OwnershipChanged is a type that will be defined later.L5 - Then we can define the layout of our module. It is extremely simple - just a single state value. What is most important is that you can never leave a raw type; you must always wrap it with Var. ","version":"next","tagName":"h3"},{"title":"Init the module​","type":1,"pageTitle":"Ownable","url":"/docs/next/tutorials/ownable#init-the-module","content":"ownable.rs #[odra::module] impl Ownable { pub fn init(&amp;mut self, owner: Address) { if self.owner.get_or_default().is_some() { self.env().revert(Error::OwnerIsAlreadyInitialized) } self.owner.set(Some(owner)); self.env().emit_event(OwnershipChanged { prev_owner: None, new_owner: owner }); } } #[odra::odra_error] pub enum Error { OwnerIsAlreadyInitialized = 1, } #[odra::event] pub struct OwnershipChanged { pub prev_owner: Option&lt;Address&gt;, pub new_owner: Address }  Ok, we have done a couple of things, let's analyze them one by one: L1 - The impl should be an Odra module, so add #[odra::module].L3 - The init function is a constructor. This matters if we would like to deploy the Ownable module as a standalone contract.L17-L20 - Before we set a new owner, we must assert there was no owner before and raise an error otherwise. For that purpose, we defined an Error enum. Notice that the #[odra::odra_error] attribute is applied to the enum. It generates, among others, the required Into&lt;odra::OdraError&gt; binding.L4-L6 - If the owner has been set already, we call ContractEnv::revert() function with an Error::OwnerIsAlreadyInitialized argument. L8 - Then we write the owner passed as an argument to the storage. To do so, we call the set() on Var.L22-L26 - Once the owner is set, we would like to inform the outside world. The first step is to define an event struct. The struct annotated with #[odra::event] attribute.L10 - Finally, call ContractEnv::emit_event() passing the OwnershipChanged instance to the function. Hence, we set the first owner, we set the prev_owner value to None.  ","version":"next","tagName":"h3"},{"title":"Features implementation​","type":1,"pageTitle":"Ownable","url":"/docs/next/tutorials/ownable#features-implementation","content":"ownable.rs #[odra::module] impl Ownable { ... pub fn ensure_ownership(&amp;self, address: &amp;Address) { if Some(address) != self.owner.get_or_default().as_ref() { self.env().revert(Error::NotOwner) } } pub fn change_ownership(&amp;mut self, new_owner: &amp;Address) { self.ensure_ownership(&amp;self.env().caller()); let current_owner = self.get_owner(); self.owner.set(Some(*new_owner)); self.env().emit_event(OwnershipChanged { prev_owner: Some(current_owner), new_owner: *new_owner }); } pub fn get_owner(&amp;self) -&gt; Address { match self.owner.get_or_default() { Some(owner) =&gt; owner, None =&gt; self.env().revert(Error::OwnerIsNotInitialized) } } } #[odra::odra_error] pub enum Error { NotOwner = 1, OwnerIsAlreadyInitialized = 2, OwnerIsNotInitialized = 3, }  The above implementation relies on the concepts we have already used in this tutorial, so it should be easy for you to get along. L7,L31 - ensure_ownership() reads the current owner and reverts if it does not match the input Address. Also, we need to update our Error enum by adding a new variant NotOwner.L11 - The function defined above can be reused in the change_ownership() implementation. We pass to it the current caller, using the ContractEnv::caller() function. Then we update the state and emit OwnershipChanged.L21,L33 - Lastly, a getter function. Read the owner from storage, if the getter is called on an uninitialized module, it should revert with a new Error variant OwnerIsNotInitialized. There is one worth-mentioning subtlety: Var::get() function returns Option&lt;T&gt;. If the type implements the Default trait, you can call the get_or_default() function, and the contract does not fail even if the value is not initialized. As the owner is of type Option&lt;Address&gt; the Var::get() would return Option&lt;Option&lt;Address&gt;&gt;, we use Var::get_or_default() instead. ","version":"next","tagName":"h3"},{"title":"Test​","type":1,"pageTitle":"Ownable","url":"/docs/next/tutorials/ownable#test","content":"ownable.rs #[cfg(test)] mod tests { use super::*; use odra::host::{Deployer, HostEnv}; fn setup() -&gt; (OwnableHostRef, HostEnv, Address) { let env: HostEnv = odra_test::env(); let init_args = OwnableInitArgs { owner: env.get_account(0) }; (Ownable::deploy(&amp;env, init_args), env.clone(), env.get_account(0)) } #[test] fn initialization_works() { let (ownable, env, owner) = setup(); assert_eq!(ownable.get_owner(), owner); env.emitted_event( &amp;ownable, OwnershipChanged { prev_owner: None, new_owner: owner } ); } #[test] fn owner_can_change_ownership() { let (mut ownable, env, owner) = setup(); let new_owner = env.get_account(1); env.set_caller(owner); ownable.change_ownership(&amp;new_owner); assert_eq!(ownable.get_owner(), new_owner); env.emitted_event( &amp;ownable, OwnershipChanged { prev_owner: Some(owner), new_owner } ); } #[test] fn non_owner_cannot_change_ownership() { let (mut ownable, env, _) = setup(); let new_owner = env.get_account(1); ownable.change_ownership(&amp;new_owner); assert_eq!( ownable.try_change_ownership(&amp;new_owner), Err(Error::NotOwner.into()) ); } }  L6 - Each test case starts with the same initialization process, so for convenience, we have defined the setup() function, which we call in the first statement of each test. Take a look at the signature: fn setup() -&gt; (OwnableHostRef, HostEnv, Address). OwnableHostRef is a contract reference generated by Odra. This reference allows us to call all the defined entrypoints, namely: ensure_ownership(), change_ownership(), get_owner(), but not init(), which is a constructor.L7-L11 - The starting point of every test is getting an instance of HostEnv by calling odra_test::env(). Our function returns a triple: a contract ref, an env, and an address (the initial owner). Odra's #[odra::module] attribute implements a odra::host::Deployer for Ownable, and OwnableInitArgs that we pass as the second argument of the odra::host::Deployer::deploy() function. Lastly, the module needs an owner. The easiest way is to take one from the HostEnv. We choose the address of first account (which is the default one). L14 - It is time to define the first test. As you see, it is a regular Rust test.L16-17 - Using the setup() function, we get the owner and a reference (in this test, we don't use the env, so we ignore it). We make a standard assertion, comparing the owner we know with the value returned from the contract. note You may have noticed, we use here the term module interchangeably with contract. The reason is once we deploy our module onto a virtual blockchain it may be considered a contract. L19-25 - On the contract, only the init() function has been called, so we expect one event to have been emitted. To assert that, let's use HostEnv. To get the env, we call env() on the contract, then call HostEnv::emitted_event. As the first argument, pass the contract you want to read events from, followed by an event as you expect it to have occurred.L31 - Because we know the initial owner is the 0th account, we must select a different account. It could be any index from 1 to 19 - the HostEnv predefines 20 accounts.L33 - As mentioned, the default is the 0th account, if you want to change the executor, call the HostEnv::set_caller() function. note The caller switch applies only the next contract interaction, the second call will be done as the default account. L46-55 - If a non-owner account tries to change ownership, we expect it to fail. To capture the error, call HostEnv::try_change_ownership() instead of HostEnv::change_ownership(). HostEnv provides try_ functions for each contract's entrypoint. The try functions return OdraResult (an alias for Result&lt;T, OdraError&gt;) instead of panicking and halting the execution. In our case, we expect the contract to revert with the Error::NotOwner error. To compare the error, we use the Error::into() function, which converts the error into the OdraError type. ","version":"next","tagName":"h3"},{"title":"Summary​","type":1,"pageTitle":"Ownable","url":"/docs/next/tutorials/ownable#summary","content":"The Ownable module is ready, and we can test it against any defined backend. Theoretically it can be deployed as a standalone contract, but in upcoming tutorials you will see how to use it to compose a more complex contract. ","version":"next","tagName":"h2"},{"title":"What's next​","type":1,"pageTitle":"Ownable","url":"/docs/next/tutorials/ownable#whats-next","content":"In the next tutorial we will implement a ERC20 standard. ","version":"next","tagName":"h2"},{"title":"OwnedToken","type":0,"sectionRef":"#","url":"/docs/next/tutorials/owned-token","content":"","keywords":"","version":"next"},{"title":"Code​","type":1,"pageTitle":"OwnedToken","url":"/docs/next/tutorials/owned-token#code","content":"What should our module be capable of? Conform the Erc20 interface.Allow only the module owner to mint tokens.Enable the current owner to designate a new owner. ","version":"next","tagName":"h2"},{"title":"Module definition​","type":1,"pageTitle":"OwnedToken","url":"/docs/next/tutorials/owned-token#module-definition","content":"Let's define a module called OwnedToken that is a composition of Ownable and Erc20 modules. owned_token.rs use crate::{erc20::Erc20, ownable::Ownable}; use odra::prelude::*; #[odra::module] pub struct OwnedToken { ownable: SubModule&lt;Ownable&gt;, erc20: SubModule&lt;Erc20&gt; }  As you can see, we do not need any storage definition - we just take advantage of the already-defined modules! ","version":"next","tagName":"h3"},{"title":"Delegation​","type":1,"pageTitle":"OwnedToken","url":"/docs/next/tutorials/owned-token#delegation","content":"owned_token.rs ... use odra::casper_types::U256; ... #[odra::module] impl OwnedToken { pub fn init(&amp;mut self, name: String, symbol: String, decimals: u8, initial_supply: U256) { let deployer = self.env().caller(); self.ownable.init(deployer); self.erc20.init(name, symbol, decimals, initial_supply); } pub fn name(&amp;self) -&gt; String { self.erc20.name() } pub fn symbol(&amp;self) -&gt; String { self.erc20.symbol() } pub fn decimals(&amp;self) -&gt; u8 { self.erc20.decimals() } pub fn total_supply(&amp;self) -&gt; U256 { self.erc20.total_supply() } pub fn balance_of(&amp;self, address: &amp;Address) -&gt; U256 { self.erc20.balance_of(address) } pub fn allowance(&amp;self, owner: &amp;Address, spender: &amp;Address) -&gt; U256 { self.erc20.allowance(owner, spender) } pub fn transfer(&amp;mut self, recipient: &amp;Address, amount: &amp;U256) { self.erc20.transfer(recipient, amount); } pub fn transfer_from(&amp;mut self, owner: &amp;Address, recipient: &amp;Address, amount: &amp;U256) { self.erc20.transfer_from(owner, recipient, amount); } pub fn approve(&amp;mut self, spender: &amp;Address, amount: &amp;U256) { self.erc20.approve(spender, amount); } pub fn get_owner(&amp;self) -&gt; Address { self.ownable.get_owner() } pub fn change_ownership(&amp;mut self, new_owner: &amp;Address) { self.ownable.change_ownership(new_owner); } pub fn mint(&amp;mut self, address: &amp;Address, amount: &amp;U256) { self.ownable.ensure_ownership(&amp;self.env().caller()); self.erc20.mint(address, amount); } }  Easy. However, there are a few worth mentioning subtleness: L9-L10 - A constructor is an excellent place to initialize both modules at once.L13-L15 - Most of the entrypoints do not need any modification, so we simply delegate them to the erc20 module.L49-L51 - The same is done with the ownable module.L57-L60 - Minting should not be unconditional, we need some control over it. First, using ownable we make sure the caller really is indeed the owner. ","version":"next","tagName":"h3"},{"title":"Summary​","type":1,"pageTitle":"OwnedToken","url":"/docs/next/tutorials/owned-token#summary","content":"The Odra Framework encourages a modularized design of your smart contracts. You can encapsulate features in smaller units and test them in isolation, ensuring your project is easy to maintain. Finally, unleash their full potential by combining modules. You do not need any magic bindings for that. ","version":"next","tagName":"h2"},{"title":"Ticketing System","type":0,"sectionRef":"#","url":"/docs/next/tutorials/nft","content":"","keywords":"","version":"next"},{"title":"Ticket Office Contract​","type":1,"pageTitle":"Ticketing System","url":"/docs/next/tutorials/nft#ticket-office-contract","content":"Our TicketOffice contract will include the following features: Compliance with the CEP-78 standard.Ownership functionality.Only the owner can issue new event tickets.Users can purchase tickets for events.Tickets are limited to a one-time sale.Public access to view the total income of the TicketOffice. ","version":"next","tagName":"h2"},{"title":"Setup the project​","type":1,"pageTitle":"Ticketing System","url":"/docs/next/tutorials/nft#setup-the-project","content":"Creating a new NFT token with Odra is straightforward. Use the cargo odra new command to create a new project with the CEP-95 template: cargo odra new --name ticket-office --template cep95  ","version":"next","tagName":"h2"},{"title":"Contract implementation​","type":1,"pageTitle":"Ticketing System","url":"/docs/next/tutorials/nft#contract-implementation","content":"Let's start implementing the TicketOffice contract by modify the code generated from the template. src/token.rs use odra::{casper_types::{U256, U512}, prelude::*}; use odra_modules::access::Ownable; use odra_modules::cep95::{CEP95Interface, Cep95}; pub type TicketId = U256; #[odra::odra_type] pub enum TicketStatus { Available, Sold, } #[odra::odra_type] pub struct TicketInfo { event_name: String, price: U512, status: TicketStatus, } #[odra::event] pub struct OnTicketIssue { ticket_id: TicketId, event_name: String, price: U512, } #[odra::event] pub struct OnTicketSell { ticket_id: TicketId, buyer: Address, } #[odra::odra_error] pub enum Error { TicketNotAvailableForSale = 200, InsufficientFunds = 201, InvalidTicketId = 202, TicketDoesNotExist = 203, } #[odra::module( events = [OnTicketIssue, OnTicketSell], errors = Error )] pub struct TicketOffice { token: SubModule&lt;Cep95&gt;, ownable: SubModule&lt;Ownable&gt;, tickets: Mapping&lt;TicketId, TicketInfo&gt;, token_id_counter: Var&lt;TicketId&gt;, total_supply: Var&lt;u64&gt;, } #[odra::module] impl TicketOffice { pub fn init(&amp;mut self, collection_name: String, collection_symbol: String, total_supply: u64) { let caller = self.env().caller(); self.ownable.init(caller); self.token.init(collection_name, collection_symbol); } pub fn issue_ticket(&amp;mut self, event_name: String, price: U512) { let env = self.env(); let caller = env.caller(); self.ownable.assert_owner(&amp;caller); // mint a new token let ticket_id = self.token_id_counter.get_or_default(); self.token.mint(caller, ticket_id, Default::default()); // store ticket info self.tickets.set( &amp;ticket_id, TicketInfo { event_name: event_name.clone(), price, status: TicketStatus::Available, }, ); self.token_id_counter.set(ticket_id + 1); // emit an event env.emit_event(OnTicketIssue { ticket_id, event_name, price, }); } #[odra(payable)] pub fn buy_ticket(&amp;mut self, ticket_id: TicketId) { let env = self.env(); let owner = self.ownable.get_owner(); let buyer = env.caller(); let value = env.attached_value(); // only tokens owned by the owner can be sold if self.token.owner_of(ticket_id) != Some(owner) { env.revert(Error::TicketNotAvailableForSale); } let mut ticket = self .tickets .get(&amp;ticket_id) .unwrap_or_revert_with(&amp;env, Error::TicketDoesNotExist); // only available tickets can be sold if ticket.status != TicketStatus::Available { env.revert(Error::TicketNotAvailableForSale); } // check if the buyer sends enough funds if value &lt; ticket.price { env.revert(Error::InsufficientFunds); } // transfer csprs to the owner env.transfer_tokens(&amp;owner, &amp;value); // transfer the ticket to the buyer self.token.transfer_from(owner, buyer, ticket_id); ticket.status = TicketStatus::Sold; self.tickets.set(&amp;ticket_id, ticket); env.emit_event(OnTicketSell { ticket_id, buyer }); } pub fn balance_of(&amp;self) -&gt; U512 { self.env().self_balance() } }  L7-L39 - We define structures and enums that will be used in our contract. TicketStatus enum represents the status of a ticket, TicketInfo struct contains information about a ticket that is written to the storage, TicketId is a type alias for u64. OnTicketIssue and OnTicketSell are events that will be emitted when a ticket is issued or sold.L41-L44 - Register errors and events that will be used in our contract, required to produce a complete contract schema.L45-L51 - TicketOffice module definition. The module contains a Cep95 token, an Ownable module, a Mapping that stores information about tickets and Vars token_id_counter and total_supply to keep track of the total number of tickets issued.L55-L59 - The init function has been generated from the template and there is no need to modify it, except the Ownable module initialization.L61-L84 - The issue_ticket function allows the owner to issue a new ticket. The function mints a new token, stores information about the ticket, and emits an OnTicketIssue event.L86 - The payable attribute indicates that the buy_ticket function can receive funds.L87-L116 - The buy_ticket function checks if the ticket is available for sale, if the buyer sends enough funds, and transfers the ticket to the buyer. Finally, the function updates the ticket status and emits an OnTicketSell event. Lets test the contract. The test scenario will be as follows: Deploy the contract.Issue two tickets.Try to buy a ticket with insufficient funds.Buy tickets.Try to buy the same ticket again.Check the balance of the contract. src/tests.rs use odra::{ casper_types::U512, host::{Deployer, HostRef}, }; use crate::token::{Error, TicketOfficeHostRef, TicketOfficeInitArgs}; #[test] fn it_works() { let env = odra_test::env(); let init_args = TicketOfficeInitArgs { collection_name: &quot;Ticket&quot;.to_string(), collection_symbol: &quot;T&quot;.to_string(), total_supply: 100, }; let mut contract = TicketOffice::deploy(&amp;env, init_args); contract.issue_ticket(&quot;Ev&quot;.to_string(), U512::from(100)); contract.issue_ticket(&quot;Ev&quot;.to_string(), U512::from(50)); let buyer = env.get_account(1); env.set_caller(buyer); assert_eq!( contract .with_tokens(U512::from(50)) .try_buy_ticket(0.into()), Err(Error::InsufficientFunds.into()) ); assert_eq!( contract .with_tokens(U512::from(100)) .try_buy_ticket(0.into()), Ok(()) ); assert_eq!( contract .with_tokens(U512::from(50)) .try_buy_ticket(1.into()), Ok(()) ); assert_eq!( contract .with_tokens(U512::from(100)) .try_buy_ticket(0.into()), Err(Error::TicketNotAvailableForSale.into()) ); }  Unfortunately, the test failed. The first assertion succeeds because the buyer sends insufficient funds to buy the ticket. However, the second assertion fails even though the buyer sends enough funds to purchase the ticket. The buy_ticket function reverts with CEP-95 Error::NotAnOwnerOrApproved because the buyer attempts to transfer a token that they do not own, are not approved for, or are not an operator of. odra/modules/src/cep95.rs fn transfer_from(&amp;mut self, from: Address, to: Address, token_id: U256) { self.assert_exists(&amp;token_id); let caller = self.env().caller(); let owner = self .owner_of(token_id) .unwrap_or_revert_with(self, Error::ValueNotSet); // Only the owner or an approved spender can transfer the token. if (owner != from || owner != caller) &amp;&amp; !self.is_approved_for_all(from, caller) { if let Some(approved) = self.approved_for(token_id) { if approved != caller { self.env().revert(Error::NotAnOwnerOrApproved); } } else { self.env().revert(Error::NotAnOwnerOrApproved); } } ... }  Let's fix it by redesigning our little system. ","version":"next","tagName":"h2"},{"title":"Redesign​","type":1,"pageTitle":"Ticketing System","url":"/docs/next/tutorials/nft#redesign","content":"Since a buyer cannot purchase a ticket directly, we need to introduce an intermediary — an operator who will be responsible for buying tickets on behalf of the buyer. The operator will be approved by the ticket office to transfer tickets. The sequence diagram below illustrates the new flow: ","version":"next","tagName":"h2"},{"title":"Ticket Operator Contract​","type":1,"pageTitle":"Ticketing System","url":"/docs/next/tutorials/nft#ticket-operator-contract","content":"As shown in the sequence diagram, a new contract will act as an operator for the ticket office. To create this new contract, use the cargo odra generate command. cargo odra generate -c ticket_operator  src/ticket_operator.rs use crate::token::{TicketId, TicketOfficeContractRef}; use odra::{casper_types::{U256, U512}, ContractRef, prelude::*}; #[odra::odra_error] pub enum Error { UnknownTicketOffice = 300, } #[odra::module(errors = Error)] pub struct TicketOperator { ticket_office_address: Var&lt;Address&gt;, } #[odra::module] impl TicketOperator { pub fn register(&amp;mut self, ticket_office_address: Address) { self.ticket_office_address.set(ticket_office_address); } // now the operator's `buy_ticket` receives funds. #[odra(payable)] pub fn buy_ticket(&amp;mut self, ticket_id: TicketId) { let env = self.env(); let buyer = env.caller(); let value = env.attached_value(); let center = self .ticket_office_address .get() .unwrap_or_revert_with(&amp;env, Error::UnknownTicketOffice); let mut ticket_contract = TicketOfficeContractRef::new(env, center); // now and approved entity - the operator - buys the ticket on behalf of the buyer ticket_contract.buy_ticket(ticket_id, buyer, value); } pub fn balance_of(&amp;self) -&gt; U512 { self.env().self_balance() } }  L4-L7 - Define errors that will be used in the contract.L9-L13 - Define the TicketOperator module that stores the address of the ticketing office.L16-L18 - The register function sets the address of the ticketing office.L20-L32 - The buy_ticket function buys a ticket on behalf of the buyer using the ticket office address. The function forwards the call to the ticketing office contract. We simply create a TicketOfficeContractRef to interact we the TicketOffice contract. Note that, the operator's buy_ticket now receives funds. Now we need to adjust the TicketOffice contract to use the TicketOperator contract to buy tickets. src/token.rs #[odra::odra_error] pub enum Error { ... MissingOperator = 204, Unauthorized = 205, } #[odra::module] pub struct TicketOffice { ... operator: Var&lt;Address&gt;, } #[odra::module] impl TicketOffice { ... pub fn register_operator(&amp;mut self, operator: Address) { // only the owner can register an operator let caller = self.env().caller(); self.ownable.assert_owner(&amp;caller); // store the ticketing center address in the operator contract TicketOperatorContractRef::new(self.env(), operator).register(self.env().self_address()); self.operator.set(operator); } pub fn issue_ticket(&amp;mut self, event_name: String, price: U512) { // minting logic remains the same... ... // approve the operator to transfer the ticket let operator = self.operator(); self.token.approve(operator, ticket_id); // emit an event ... } pub fn buy_ticket(&amp;mut self, ticket_id: TicketId, buyer: Address, value: U512) { let env = self.env(); let owner = self.ownable.get_owner(); let caller = env.caller(); // make sure the caller is the operator if !self.is_operator(caller) { env.revert(Error::Unauthorized); } ... // the logic remains the same, except for the csprs transfer // it is now handled by the operator contract. // env.transfer_tokens(&amp;owner, &amp;value); } #[inline] fn is_operator(&amp;self, caller: Address) -&gt; bool { Some(caller) == self.operator.get() } #[inline] fn operator(&amp;self) -&gt; Address { self.operator .get() .unwrap_or_revert_with(&amp;self.env(), Error::MissingOperator) } }  L11 - the contract stores the operator address.L18-L25 - a new function register_operator allows the owner to register an operator. Also calls the register entry point on the operator contract.L32-36 - modify the issue_ticket function: once a new token is minted, approves the operator to transfer the ticket later.L40-L53 - modify the buy_ticket function: check if the caller is the operator, do not transfer cspr to the contract - now the operator collect funds.We also added two helper functions: is_operator and operator to check if the caller is the operator and get the operator address. Two new errors were added: MissingOperator and Unauthorized. Now we need to update our tests to create a scenario we presented in the sequence diagram. src/tests.rs use odra::{ casper_types::U512, host::{Deployer, HostRef, NoArgs}, prelude::* }; use crate::{ ticket_operator::TicketOperatorHostRef, token::{Error, TicketId, TicketOfficeContractRef, TicketOfficeInitArgs}, }; #[test] fn it_works() { let env = odra_test::env(); let init_args = TicketOfficeInitArgs { collection_name: &quot;Ticket&quot;.to_string(), collection_symbol: &quot;T&quot;.to_string(), total_supply: 100, }; let operator = TicketOperator::deploy(&amp;env, NoArgs); let mut ticket_office = TicketOfficeContractRef::deploy(&amp;env, init_args); ticket_office.register_operator(operator.address().clone()); ticket_office.issue_ticket(&quot;Ev&quot;.to_string(), U512::from(100)); ticket_office.issue_ticket(&quot;Ev&quot;.to_string(), U512::from(50)); let buyer = env.get_account(1); env.set_caller(buyer); assert_eq!( buy_ticket(&amp;operator, 0.into(), 50), Err(Error::InsufficientFunds.into()) ); assert_eq!(buy_ticket(&amp;operator, 0.into(), 100), Ok(())); assert_eq!(buy_ticket(&amp;operator, 1.into(), 50), Ok(())); assert_eq!( buy_ticket(&amp;operator, 0.into(), 100), Err(Error::TicketNotAvailableForSale.into()) ); assert_eq!(operator.balance_of(), U512::from(150)); } fn buy_ticket(operator: &amp;TicketOperatorHostRef, id: TicketId, price: u64) -&gt; OdraResult&lt;()&gt; { operator.with_tokens(U512::from(price)).try_buy_ticket(id) }  ","version":"next","tagName":"h3"},{"title":"Conclusion​","type":1,"pageTitle":"Ticketing System","url":"/docs/next/tutorials/nft#conclusion","content":"In this tutorial, we created a simple ticketing system using the CEP-95 standard. This guide demonstrates how to combine various Odra features, including modules, events, errors, payable functions, and cross-contract calls. ","version":"next","tagName":"h2"},{"title":"Pausable","type":0,"sectionRef":"#","url":"/docs/next/tutorials/pauseable","content":"","keywords":"","version":"next"},{"title":"Code​","type":1,"pageTitle":"Pausable","url":"/docs/next/tutorials/pauseable#code","content":"As always, we will start with defining functionalities of our module. Check the state - is it paused or not.State guards - a contract should stop execution if is in a state we don't expect.Switch the state. ","version":"next","tagName":"h2"},{"title":"Events and Error​","type":1,"pageTitle":"Pausable","url":"/docs/next/tutorials/pauseable#events-and-error","content":"There just two errors that may occur: PausedRequired, UnpausedRequired. We define them in a standard Odra way. Events definition is highly uncomplicated: Paused and Unpaused events holds only the address of the pauser. pauseable.rs use odra::prelude::*; #[odra::odra_error] pub enum Error { PausedRequired = 1_000, UnpausedRequired = 1_001, } #[odra::event] pub struct Paused { pub account: Address } #[odra::event] pub struct Unpaused { pub account: Address }  ","version":"next","tagName":"h3"},{"title":"Module definition​","type":1,"pageTitle":"Pausable","url":"/docs/next/tutorials/pauseable#module-definition","content":"The module storage is extremely simple - has a single Var of type bool, that indicates if a contract is paused. pauseable.rs #[odra::module(events = [Paused, Unpaused], errors = Error)] pub struct Pausable { is_paused: Var&lt;bool&gt; }  ","version":"next","tagName":"h3"},{"title":"Checks and guards​","type":1,"pageTitle":"Pausable","url":"/docs/next/tutorials/pauseable#checks-and-guards","content":"Now, let's move to state checks and guards. pauseable.rs impl Pausable { pub fn is_paused(&amp;self) -&gt; bool { self.is_paused.get_or_default() } pub fn require_not_paused(&amp;self) { if self.is_paused() { self.env().revert(Error::UnpausedRequired); } } pub fn require_paused(&amp;self) { if !self.is_paused() { self.env().revert(Error::PausedRequired); } } }  L1 - as mentioned in the intro, the module is not intended to be a standalone contract, so the only impl block is not annotated with odra::module and hence does not expose any entrypoint.L2 - is_paused() checks the contract state, if the Var is_paused has not been initialized, the default value (false) is returned.L6 - to guarantee the code is executed when the contract is not paused, require_not_paused() function reads the state and reverts if the contract is paused. L12 - require_paused() is a mirror function - stops the contract execution if the contract is not paused. ","version":"next","tagName":"h3"},{"title":"Actions​","type":1,"pageTitle":"Pausable","url":"/docs/next/tutorials/pauseable#actions","content":"Finally, we will add the ability to switch the module state. pauseable.rs impl Pausable { pub fn pause(&amp;mut self) { self.require_not_paused(); self.is_paused.set(true); self.env().emit_event(Paused { account: self.env().caller() }); } pub fn unpause(&amp;mut self) { self.require_paused(); self.is_paused.set(false); self.env().emit_event(Unpaused { account: self.env().caller() }); } }  pause() and unpause() functions do three things: ensure the contract is the right state (unpaused for pause(), not paused for unpause()), updates the state, and finally emits events (Paused/Unpaused). ","version":"next","tagName":"h3"},{"title":"Pausable counter​","type":1,"pageTitle":"Pausable","url":"/docs/next/tutorials/pauseable#pausable-counter","content":"In the end, let's use the module in a contract. For this purpose, we will implement a mock contract called PausableCounter. The contract consists of a Var value and a Pausable module. The counter can only be incremented if the contract is in a normal state (is not paused). pauseable.rs ... #[odra::module] pub struct PausableCounter { value: Var&lt;u32&gt;, pauseable: SubModule&lt;Pausable&gt; } #[odra::module] impl PausableCounter { pub fn increment(&amp;mut self) { self.pauseable.require_not_paused(); let new_value = self.value.get_or_default() + 1; self.value.set(new_value); } pub fn pause(&amp;mut self) { self.pauseable.pause(); } pub fn unpause(&amp;mut self) { self.pauseable.unpause(); } pub fn get_value(&amp;self) -&gt; u32 { self.value.get_or_default() } } #[cfg(test)] mod test { use super::*; use odra::host::{Deployer, NoArgs}; #[test] fn increment_only_if_unpaused() { let test_env = odra_test::env(); let mut contract = PausableCounter::deploy(&amp;test_env, NoArgs); contract.increment(); contract.pause(); assert_eq!( contract.try_increment().unwrap_err(), Error::UnpausedRequired.into() ); assert_eq!(contract.get_value(), 1); } }  As we see in the test, in a simple way, using a single function call we can turn off the counter for a while and freeze the counter. Any time we want we can turn it back on. Easy! ","version":"next","tagName":"h2"},{"title":"Odra framework","type":0,"sectionRef":"#","url":"/docs/","content":"","keywords":"","version":"2.3.1"},{"title":"What's next​","type":1,"pageTitle":"Odra framework","url":"/docs/#whats-next","content":"See the Installation and our Flipper example to find out how to start your new project with Odra. ","version":"2.3.1","tagName":"h2"},{"title":"Upgrading Contracts","type":0,"sectionRef":"#","url":"/docs/next/tutorials/upgrades","content":"","keywords":"","version":"next"},{"title":"Livenet Example​","type":1,"pageTitle":"Upgrading Contracts","url":"/docs/next/tutorials/upgrades#livenet-example","content":"In this example, we will deploy a simple counter contract and then upgrade it to a new version with additional features. We will skip the details of the contract implementation and focus on the deployment and upgrade process. Our example deploys a simple counter contract making it upgradable and then upgrades it twice: first to CounterV2, and then back to CounterV1. examples/bin/upgrades_on_livenet.rs //! This example demonstrates how to deploy and upgrade a contract on the Livenet environment. use odra::casper_types::U256; use odra::host::{Deployer, HostRef, InstallConfig, NoArgs}; use odra_examples::features::upgrade::{CounterV1, CounterV2, CounterV2UpgradeArgs}; fn main() { let env = odra_casper_livenet_env::env(); env.set_gas(500_000_000_000u64); // Contracts can be upgraded let mut counter = CounterV1::deploy_with_cfg(&amp;env, NoArgs, InstallConfig::upgradable::&lt;CounterV1&gt;()); env.set_gas(50_000_000_000u64); counter.increment(); assert_eq!(counter.get(), 1); env.set_gas(500_000_000_000u64); let mut counter2 = CounterV2::try_upgrade( &amp;env, counter.contract_address(), CounterV2UpgradeArgs { new_start: None } ) .unwrap(); env.set_gas(50_000_000_000u64); counter2.increment(); assert_eq!(counter2.get(), U256::from(2)); env.set_gas(500_000_000_000u64); let mut counter3 = CounterV1::try_upgrade(&amp;env, counter.contract_address(), NoArgs).unwrap(); env.set_gas(50_000_000_000u64); counter3.increment(); assert_eq!(counter3.get(), 2); }  The Deployer trait has two functions that allow upgrading contracts: try_upgrade: upgrades a contract to a new version. It takes the environment, the address of the contract to be upgraded, and the arguments for the new version of the contract. The function try_upgrade_with_cfg: same as try_upgrade, but allows specifying a custom upgrade configuration. Let's take a quick look at the CounterV2 implementation: #[odra::module] impl CounterV2 { pub fn init(&amp;mut self, start_from: Option&lt;U256&gt;) { if let Some(start) = start_from { self.new_counter.set(start); } else { self.new_counter.set(U256::from(0)); } } pub fn upgrade(&amp;mut self, new_start: Option&lt;U256&gt;) { if let Some(start) = new_start { self.new_counter.set(start); } else { // If no new value is provided, we keep the current value self.new_counter.set(self.counter.get_or_default().into()); } } ... }  The contract implements the upgrade function, which allows executing the upgrade logic for the contract. When upgrading to a new version, the upgrade function is called with the new initialization parameters. We call the try_upgrade function with CounterV2UpgradeArgs - a struct automatically generated by the Odra framework. It is a mirror feature of the contract's initialization parameters. ","version":"next","tagName":"h2"},{"title":"Run the example​","type":1,"pageTitle":"Upgrading Contracts","url":"/docs/next/tutorials/upgrades#run-the-example","content":"Now, let's see the code in action! cargo run --bin our_token_livenet --features livenet  A sample output of the program might look like this:  Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.11s Running `../target/debug/upgrade_on_livenet` 💁 INFO : Found wasm under &quot;/Users/kpob/workspace/odra/examples/wasm/CounterV1.wasm&quot;. 💁 INFO : Deploying &quot;CounterV1&quot;. 🙄 WAIT : Waiting 10 for V1(TransactionV1Hash(301469239d731d7b7ca9aef7a42dcb1473a1388d59e1bac619a008e7b555aa0d)). 💁 INFO : Transaction &quot;301469239d731d7b7ca9aef7a42dcb1473a1388d59e1bac619a008e7b555aa0d&quot; successfully executed. 🔗 LINK : https://testnet.cspr.live/transaction/301469239d731d7b7ca9aef7a42dcb1473a1388d59e1bac619a008e7b555aa0d 💁 INFO : Contract &quot;contract-package-b8b5003fe3ba05b4cae2e8acaeb777520e025958e12bd15394bf42e96f3f7b12&quot; deployed. 💁 INFO : Calling &quot;contract-package-b8b5003fe3ba05b4cae2e8acaeb777520e025958e12bd15394bf42e96f3f7b12&quot; directly with entrypoint &quot;increment&quot;. 🙄 WAIT : Waiting 10 for V1(TransactionV1Hash(a0fb180018063702094cdd66bdda1a3eda6f90c2e726334f202d77cddd88e649)). 🙄 WAIT : Waiting 10 for V1(TransactionV1Hash(a0fb180018063702094cdd66bdda1a3eda6f90c2e726334f202d77cddd88e649)). 💁 INFO : Transaction &quot;a0fb180018063702094cdd66bdda1a3eda6f90c2e726334f202d77cddd88e649&quot; successfully executed. 🔗 LINK : https://testnet.cspr.live/transaction/a0fb180018063702094cdd66bdda1a3eda6f90c2e726334f202d77cddd88e649 💁 INFO : Found wasm under &quot;/Users/kpob/workspace/odra/examples/wasm/CounterV2.wasm&quot;. 💁 INFO : Deploying &quot;CounterV2&quot;. 🙄 WAIT : Waiting 10 for V1(TransactionV1Hash(ec4518f51a2b3ed19886d6cd2d67e138aeb24834362d8fad8adb4af45fa36f21)). 💁 INFO : Transaction &quot;ec4518f51a2b3ed19886d6cd2d67e138aeb24834362d8fad8adb4af45fa36f21&quot; successfully executed. 🔗 LINK : https://testnet.cspr.live/transaction/ec4518f51a2b3ed19886d6cd2d67e138aeb24834362d8fad8adb4af45fa36f21 💁 INFO : Contract &quot;contract-package-b8b5003fe3ba05b4cae2e8acaeb777520e025958e12bd15394bf42e96f3f7b12&quot; deployed. 💁 INFO : Calling &quot;contract-package-b8b5003fe3ba05b4cae2e8acaeb777520e025958e12bd15394bf42e96f3f7b12&quot; directly with entrypoint &quot;increment&quot;. 🙄 WAIT : Waiting 10 for V1(TransactionV1Hash(cc694727bf166c55e2080578fcf6dc944e2d9b931b8301fe5208c8e29e8c599a)). 🙄 WAIT : Waiting 10 for V1(TransactionV1Hash(cc694727bf166c55e2080578fcf6dc944e2d9b931b8301fe5208c8e29e8c599a)). 💁 INFO : Transaction &quot;cc694727bf166c55e2080578fcf6dc944e2d9b931b8301fe5208c8e29e8c599a&quot; successfully executed. 🔗 LINK : https://testnet.cspr.live/transaction/cc694727bf166c55e2080578fcf6dc944e2d9b931b8301fe5208c8e29e8c599a 💁 INFO : Found wasm under &quot;/Users/kpob/workspace/odra/examples/wasm/CounterV1.wasm&quot;. 💁 INFO : Deploying &quot;CounterV1&quot;. 🙄 WAIT : Waiting 10 for V1(TransactionV1Hash(58453efdf683f2271f558a22e406631edccff2771867069c2cbefb3386fc8833)). 💁 INFO : Transaction &quot;58453efdf683f2271f558a22e406631edccff2771867069c2cbefb3386fc8833&quot; successfully executed. 🔗 LINK : https://testnet.cspr.live/transaction/58453efdf683f2271f558a22e406631edccff2771867069c2cbefb3386fc8833 💁 INFO : Contract &quot;contract-package-b8b5003fe3ba05b4cae2e8acaeb777520e025958e12bd15394bf42e96f3f7b12&quot; deployed. 💁 INFO : Calling &quot;contract-package-b8b5003fe3ba05b4cae2e8acaeb777520e025958e12bd15394bf42e96f3f7b12&quot; directly with entrypoint &quot;increment&quot;. 🙄 WAIT : Waiting 10 for V1(TransactionV1Hash(5cd3920e6b7cab505e074eb5684cc1b191841d2f24a889079d9fb1a92167fd4f)). 🙄 WAIT : Waiting 10 for V1(TransactionV1Hash(5cd3920e6b7cab505e074eb5684cc1b191841d2f24a889079d9fb1a92167fd4f)). 💁 INFO : Transaction &quot;5cd3920e6b7cab505e074eb5684cc1b191841d2f24a889079d9fb1a92167fd4f&quot; successfully executed. 🔗 LINK : https://testnet.cspr.live/transaction/5cd3920e6b7cab505e074eb5684cc1b191841d2f24a889079d9fb1a92167fd4f  ","version":"next","tagName":"h2"},{"title":"Cspr.live​","type":1,"pageTitle":"Upgrading Contracts","url":"/docs/next/tutorials/upgrades#csprlive","content":"Let's take a look at cspr.live: https://testnet.cspr.live/contract-package/b8b5003fe3ba05b4cae2e8acaeb777520e025958e12bd15394bf42e96f3f7b12 It works! Now our contracts has three versions deployed:  ","version":"next","tagName":"h2"},{"title":"Conclusion​","type":1,"pageTitle":"Upgrading Contracts","url":"/docs/next/tutorials/upgrades#conclusion","content":"In this tutorial, we learned how to upgrade a smart contract on the blockchain using the Odra framework. We deployed a simple counter contract, made it upgradable, and then upgraded it twice: first to CounterV2, and then back to CounterV1. We also explored the testnet to verify our contract deployments. ","version":"next","tagName":"h2"},{"title":"Advanced Storage Concepts","type":0,"sectionRef":"#","url":"/docs/advanced/advanced-storage","content":"","keywords":"","version":"2.3.1"},{"title":"Recap and Basic Concepts​","type":1,"pageTitle":"Advanced Storage Concepts","url":"/docs/advanced/advanced-storage#recap-and-basic-concepts","content":"Before we delve into the advanced features, let's recap some basic storage concepts in Odra. In the realm of basic storage interaction, Odra provides several types for interacting with contract storage, including Var, Mapping, and List. These types enable contracts to store and retrieve data in a structured manner. The Var type is used to store a single value, while the List and Mapping types store collections of values. Var: A Var in Odra is a fundamental building block used for storing single values. Each Var is uniquely identified by its name in the contract. Mapping: Mapping in Odra serves as a key-value storage system. It stores an association of unique keys to values, and the value can be retrieved using the key. List: Built on top of the Var and Mapping building blocks, List in Odra allows storing an ordered collection of values that can be iterated over. If you need a refresher on these topics, please refer to our guide on basic storage in Odra. ","version":"2.3.1","tagName":"h2"},{"title":"Advanced Storage Concepts​","type":1,"pageTitle":"Advanced Storage Concepts","url":"/docs/advanced/advanced-storage#advanced-storage-concepts-1","content":"","version":"2.3.1","tagName":"h2"},{"title":"Sequence​","type":1,"pageTitle":"Advanced Storage Concepts","url":"/docs/advanced/advanced-storage#sequence","content":"The Sequence in Odra is a basic module that stores a single value in the storage that can be read or incremented. Internally, holds a Var which keeps track of the current value. pub struct Sequence&lt;T&gt; where T: Num + One + ToBytes + FromBytes + CLTyped { value: Var&lt;T&gt; }  The Sequence module provides functions get_current_value and next_value to get the current value and increment the value respectively. ","version":"2.3.1","tagName":"h3"},{"title":"Advanced Mapping​","type":1,"pageTitle":"Advanced Storage Concepts","url":"/docs/advanced/advanced-storage#advanced-mapping","content":"In Odra, a Mapping is a key-value storage system where the key is associated with a value. In previous examples, the value of the Mapping typically comprised a standard serializable type (such as number, string, or bool) or a custom type marked with the #[odra::odra_type] attribute. However, there are more advanced scenarios where the value of the Mapping represents a module itself. This approach is beneficial when managing a collection of modules, each maintaining its unique state. Let's consider the following example: examples/src/features/storage/mapping.rs use odra::casper_types::U256; use odra::prelude::*; use crate::owned_token::OwnedToken; #[odra::module] pub struct Mappings { strings: Mapping&lt;(String, u32, String), String&gt;, tokens: Mapping&lt;String, OwnedToken&gt; } #[odra::module] impl Mappings { ... pub fn total_supply(&amp;mut self, token_name: String) -&gt; U256 { self.tokens.module(&amp;token_name).total_supply() } pub fn get_string_api( &amp;self, key1: String, key2: u32, key3: String ) -&gt; String { let opt_string = self.strings.get(&amp;(key1, key2, key3)); opt_string.unwrap_or_revert(&amp;self.env()) } }  As you can see, a Mapping key can consist of a tuple of values, not limited to a single value. note Accessing Odra modules differs from accessing regular values such as strings or numbers. Firstly, within a Mapping, you don't encapsulate the module with Submodule. Secondly, rather than utilizing the Mapping::get() function, call Mapping::module(), which returns SubModule&lt;T&gt; and sets the appropriate namespace for nested modules. ","version":"2.3.1","tagName":"h3"},{"title":"AdvancedStorage Contract​","type":1,"pageTitle":"Advanced Storage Concepts","url":"/docs/advanced/advanced-storage#advancedstorage-contract","content":"The given code snippet showcases the AdvancedStorage contract that incorporates these storage concepts. use odra::casper_types::U512; use odra::prelude::*; use crate::modules::Token; #[odra::module] pub struct AdvancedStorage { counter: Sequence&lt;u32&gt;, tokens: Mapping&lt;(String, String), Token&gt;, } impl AdvancedStorage { pub fn current_value(&amp;self) -&gt; u32 { self.counter.get_current_value() } pub fn increment_and_get(&amp;mut self) -&gt; u32 { self.counter.next_value() } pub fn balance_of(&amp;mut self, token_name: String, creator: String, address: Address) -&gt; U512 { let token = self.tokens.module(&amp;(token_name, creator)); token.balance_of(&amp;address) } pub fn mint(&amp;self, token_name: String, creator: String, amount: U512, to: Address) { let mut token = self.tokens.module(&amp;(token_name, creator)); token.mint(amount, to); } }  ","version":"2.3.1","tagName":"h2"},{"title":"Conclusion​","type":1,"pageTitle":"Advanced Storage Concepts","url":"/docs/advanced/advanced-storage#conclusion","content":"Advanced storage features in Odra offer robust options for managing contract state. Two key takeaways from this document are: Odra offers a Sequence module, enabling contracts to store and increment a single value.Mappings support composite keys expressed as tuples and can store modules as values. Understanding these concepts can help developers design and implement more efficient and flexible smart contracts. ","version":"2.3.1","tagName":"h2"},{"title":"Building contracts manually","type":0,"sectionRef":"#","url":"/docs/advanced/building-manually","content":"","keywords":"","version":"2.3.1"},{"title":"Building the contract manually​","type":1,"pageTitle":"Building contracts manually","url":"/docs/advanced/building-manually#building-the-contract-manually","content":"To build the contract manually, cargo odra uses the following command: ODRA_MODULE=my_contract cargo build --release --target wasm32-unknown-unknown --bin my_project_build_contract  info Odra uses the environment variable ODRA_MODULE to determine which contract to build. Assuming that project's crate is named my_project, this command will build the my_contract contract in release mode and generate the wasm file. The file will be put into the target/wasm32-unknown-unknown/release directory under the name my_project_build_contract.wasm. The Odra Framework expects the contracts to be placed in the wasm directory, and to be named correctly, so the next step would be to move the file: mv target/wasm32-unknown-unknown/release/my_project_build_contract.wasm wasm/my_contract.wasm  ","version":"2.3.1","tagName":"h2"},{"title":"Optimizing the contract​","type":1,"pageTitle":"Building contracts manually","url":"/docs/advanced/building-manually#optimizing-the-contract","content":"To lower the size of the wasm file, cargo odra uses the wasm-strip tool: wasm-strip wasm/my_contract.wasm  To further optimize the wasm file, the wasm-opt tool is also used. wasm-opt --signext-lowering wasm/my_contract.wasm -o wasm/my_contract.wasm  danger This step is required, as the wasm file generated by the Rust compiler is not fully compatible with the Casper execution engine. ","version":"2.3.1","tagName":"h2"},{"title":"Running the tests manually​","type":1,"pageTitle":"Building contracts manually","url":"/docs/advanced/building-manually#running-the-tests-manually","content":"To run the tests manually, Odra needs to know which backend to use. To run tests against Casper backend, the following command needs to be used: ODRA_BACKEND=casper cargo test  ","version":"2.3.1","tagName":"h2"},{"title":"Wrapping up​","type":1,"pageTitle":"Building contracts manually","url":"/docs/advanced/building-manually#wrapping-up","content":"Let's say we want to build the my_contract in debug mode, run the tests against the casper backend and use the my-own-allocator feature from our my_project project. To do that, we can use the following set of commands: ODRA_MODULE=my_contract cargo build --target wasm32-unknown-unknown --bin my_project_build_contract mv target/wasm32-unknown-unknown/debug/my_project_build_contract.wasm wasm/my_contract.wasm wasm-strip wasm/my_contract.wasm wasm-opt --signext-lowering wasm/my_contract.wasm -o wasm/my_contract.wasm ODRA_BACKEND=casper cargo test --features my-own-allocator  ","version":"2.3.1","tagName":"h2"},{"title":"Attributes","type":0,"sectionRef":"#","url":"/docs/advanced/attributes","content":"","keywords":"","version":"2.3.1"},{"title":"Payable​","type":1,"pageTitle":"Attributes","url":"/docs/advanced/attributes#payable","content":"When writing a smart contract, you need to make sure that money can be both sent to and extracted from the contract. The 'payable' attribute helps wit this. Any function, except for a constructor, with the #[odra(payable)] attribute can send and take money in the form of native tokens. ","version":"2.3.1","tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"Attributes","url":"/docs/advanced/attributes#example","content":"examples/src/contracts/tlw.rs #[odra(payable)] pub fn deposit(&amp;mut self) { // Extract values let caller: Address = self.env().caller(); let amount: U256 = self.env().attached_value(); let current_block_time: u64 = self.env().get_block_time(); // Multiple lock check if self.balances.get(&amp;caller).is_some() { self.env.revert(Error::CannotLockTwice) } // Update state, emit event self.balances.set(&amp;caller, amount); self.lock_expiration_map .set(&amp;caller, current_block_time + self.lock_duration()); self.env() .emit_event(Deposit { address: caller, amount }); }  If you try to send tokens to a non-payable function, the transaction will be automatically rejected. ","version":"2.3.1","tagName":"h3"},{"title":"Non Reentrant​","type":1,"pageTitle":"Attributes","url":"/docs/advanced/attributes#non-reentrant","content":"Reentrancy attacks in smart contracts exploit the possibility of a function being called multiple times before its initial execution is completed, leading to the repeated unauthorized withdrawal of funds. To prevent such attacks, developers should ensure that all effects on the contract's state and balance checks occur before calling external contracts. They can also use reentrancy guards to block recursive calls to sensitive functions. In Odra you can just apply the #[odra(non_reentrant)] attribute to your function. ","version":"2.3.1","tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"Attributes","url":"/docs/advanced/attributes#example-1","content":"#[odra::module] pub struct NonReentrantCounter { counter: Var&lt;u32&gt; } #[odra::module] impl NonReentrantCounter { #[odra(non_reentrant)] pub fn count_ref_recursive(&amp;mut self, n: u32) { if n &gt; 0 { self.count(); ReentrancyMockRef::new(self.env(), self.env().self_address()).count_ref_recursive(n - 1); } } } impl NonReentrantCounter { fn count(&amp;mut self) { let c = self.counter.get_or_default(); self.counter.set(c + 1); } } #[cfg(test)] mod test { use super::*; use odra::host::{Deployer, NoArgs}; #[test] fn ref_recursion_not_allowed() { let test_env = odra_test::env(); let mut contract = NonReentrantCounter::deploy(&amp;test_env, NoArgs); let result = contract.count_ref_recursive(11); assert_eq!(result, ExecutionError::ReentrantCall.into()); } }  ","version":"2.3.1","tagName":"h3"},{"title":"Mixing attributes​","type":1,"pageTitle":"Attributes","url":"/docs/advanced/attributes#mixing-attributes","content":"A function can accept more than one attribute. The only exclusion is a constructor cannot be payable. To apply multiple attributes, you can write: #[odra(payable, non_reentrant)] fn deposit() { // your logic... }  or #[odra(payable)] #[odra(non_reentrant)] fn deposit() { // your logic... }  In both cases attributes order does not matter. ","version":"2.3.1","tagName":"h2"},{"title":"Using Proxy Caller","type":0,"sectionRef":"#","url":"/docs/next/tutorials/using-proxy-caller","content":"","keywords":"","version":"next"},{"title":"Contract​","type":1,"pageTitle":"Using Proxy Caller","url":"/docs/next/tutorials/using-proxy-caller#contract","content":"For this tutorial, we will use the TimeLockWallet contract from our examples. examples/src/contracts/tlw.rs use odra::prelude::*; use odra::casper_types::U512; #[odra::module(errors = Error, events = [Deposit, Withdrawal])] pub struct TimeLockWallet { balances: Mapping&lt;Address, U512&gt;, lock_expiration_map: Mapping&lt;Address, u64&gt;, lock_duration: Var&lt;u64&gt; } #[odra::module] impl TimeLockWallet { /// Initializes the contract with the lock duration. pub fn init(&amp;mut self, lock_duration: u64) { self.lock_duration.set(lock_duration); } /// Deposits the tokens into the contract. #[odra(payable)] pub fn deposit(&amp;mut self) { // Extract values let caller: Address = self.env().caller(); let amount: U512 = self.env().attached_value(); let current_block_time: u64 = self.env().get_block_time(); // Multiple lock check if self.balances.get(&amp;caller).is_some() { self.env().revert(Error::CannotLockTwice) } // Update state, emit event self.balances.set(&amp;caller, amount); self.lock_expiration_map .set(&amp;caller, current_block_time + self.lock_duration()); self.env().emit_event(Deposit { address: caller, amount }); } /// Withdraws the tokens from the contract. pub fn withdraw(&amp;mut self, amount: &amp;U512) { // code omitted for brevity } /// Returns the balance of the given account. pub fn get_balance(&amp;self, address: &amp;Address) -&gt; U512 { // code omitted for brevity } /// Returns the lock duration. pub fn lock_duration(&amp;self) -&gt; u64 { // code omitted for brevity } } /// Errors that may occur during the contract execution. #[odra::odra_error] pub enum Error { LockIsNotOver = 1, CannotLockTwice = 2, InsufficientBalance = 3 } /// Deposit event. #[odra::event] pub struct Deposit { pub address: Address, pub amount: U512 } /// Withdrawal event. #[odra::event] pub struct Withdrawal { pub address: Address, pub amount: U512 }  Full code can be found in our Github repo. ","version":"next","tagName":"h2"},{"title":"Client​","type":1,"pageTitle":"Using Proxy Caller","url":"/docs/next/tutorials/using-proxy-caller#client","content":"Before we can interact with the node, we need to set it up. We will use the casper-nctl-docker image. docker run --rm -it --name mynctl -d -p 11101:11101 -p 14101:14101 -p 18101:18101 makesoftware/casper-nctl  Make sure you have the contract's wasm file and the secret key. # Build the contract cargo odra build -c TimeLockWallet # Extract secret key docker exec mynctl /bin/bash -c &quot;cat /home/casper/casper-node/utils/nctl/assets/net-1/users/user-1/secret_key.pem&quot; &gt; your/path/secret_key.pem  RustTypeScript To interact with the contract, we use the livenet backend. It allows to write the code in the same manner as the test code, but it interacts with the live network (a local node in our case). Cargo.toml [package] name = &quot;odra-examples&quot; version = &quot;2.2.0&quot; edition = &quot;2021&quot; [dependencies] odra = { path = &quot;../odra&quot;, default-features = false } ... # other dependencies odra-casper-livenet-env = { version = &quot;2.2.0&quot;, optional = true } ... # other sections [features] default = [] livenet = [&quot;odra-casper-livenet-env&quot;] ... # other sections [[bin]] name = &quot;tlw_on_livenet&quot; path = &quot;bin/tlw_on_livenet.rs&quot; required-features = [&quot;livenet&quot;] test = false ... # other sections examples/bin/tlw_on_livenet.rs //! Deploys an [odra_examples::contracts::tlw::TimeLockWallet] contract, then deposits and withdraw some CSPRs. use odra::casper_types::{AsymmetricType, PublicKey, U512}; use odra::host::{Deployer, HostRef}; use odra::prelude::*; use odra_examples::contracts::tlw::{TimeLockWallet, TimeLockWalletInitArgs}; const DEPOSIT: u64 = 100; const WITHDRAWAL: u64 = 99; const GAS: u64 = 20u64.pow(9); fn main() { let env = odra_casper_livenet_env::env(); let caller = env.get_account(0); env.set_caller(caller); env.set_gas(GAS); let mut contract = TimeLockWallet::deploy( &amp;env, TimeLockWalletInitArgs { lock_duration: 60 * 60 } ); // Send 100 CSPRs to the contract. contract .with_tokens(U512::from(DEPOSIT)) .deposit(); println!(&quot;Caller's balance: {:?}&quot;, contract.get_balance(&amp;caller)); // Withdraw 99 CSPRs from the contract. contract.withdraw(&amp;U512::from(WITHDRAWAL)); println!(&quot;Remaining balance: {:?}&quot;, contract.get_balance(&amp;caller)); } To run the code, execute the following command: ODRA_CASPER_LIVENET_SECRET_KEY_PATH=path/to/secret_key.pem \\ ODRA_CASPER_LIVENET_NODE_ADDRESS=[NODE_ADDRESS] \\ ODRA_CASPER_LIVENET_CHAIN_NAME=casper-test \\ ODRA_CASPER_LIVENET_EVENTS_URL=[EVENTS_STREAM_ADDRESS] \\ cargo run --bin tlw_on_livenet --features=livenet Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.09s Running `../target/debug/tlw_on_livenet` 💁 INFO : Found wasm under &quot;/Users/kpob/workspace/odra/examples/wasm/TimeLockWallet.wasm&quot;. 💁 INFO : Deploying &quot;TimeLockWallet&quot;. 🙄 WAIT : Waiting 10 for V1(TransactionV1Hash(5ab45ba29c9e7b9a91c4b5a5fbd2ba31735f03f99f94dce542d3584c8776ce8a)). 🙄 WAIT : Waiting 10 for V1(TransactionV1Hash(5ab45ba29c9e7b9a91c4b5a5fbd2ba31735f03f99f94dce542d3584c8776ce8a)). 💁 INFO : Transaction &quot;5ab45ba29c9e7b9a91c4b5a5fbd2ba31735f03f99f94dce542d3584c8776ce8a&quot; successfully executed. 🔗 LINK : https://testnet.cspr.live/transaction/5ab45ba29c9e7b9a91c4b5a5fbd2ba31735f03f99f94dce542d3584c8776ce8a 💁 INFO : Contract &quot;contract-package-fe69f4dd63445cda6cdc3b4c066760227208a752857950af6bda8a41600781ea&quot; deployed. 💁 INFO : Calling &quot;contract-package-fe69f4dd63445cda6cdc3b4c066760227208a752857950af6bda8a41600781ea&quot; with entrypoint &quot;deposit&quot; through proxy. 🙄 WAIT : Waiting 10 for V1(TransactionV1Hash(86d07f72dc9383f46144b5fdfd912ddf15c7be539cf2c34e43f1214244da25b3)). 💁 INFO : Transaction &quot;86d07f72dc9383f46144b5fdfd912ddf15c7be539cf2c34e43f1214244da25b3&quot; successfully executed. 🔗 LINK : https://testnet.cspr.live/transaction/86d07f72dc9383f46144b5fdfd912ddf15c7be539cf2c34e43f1214244da25b3 Owner's balance: 100 💁 INFO : Calling &quot;contract-package-fe69f4dd63445cda6cdc3b4c066760227208a752857950af6bda8a41600781ea&quot; directly with entrypoint &quot;withdraw&quot;. 🙄 WAIT : Waiting 10 for V1(TransactionV1Hash(cbdedd1d5f528754904feb23a0e2087a53ed6f6ed27298367a98bc2accc5792f)). 💁 INFO : Transaction &quot;cbdedd1d5f528754904feb23a0e2087a53ed6f6ed27298367a98bc2accc5792f&quot; successfully executed. 🔗 LINK : https://testnet.cspr.live/transaction/cbdedd1d5f528754904feb23a0e2087a53ed6f6ed27298367a98bc2accc5792f Remaining balance: 1 As observed, the contract was successfully deployed, and the Caller deposited tokens. Subsequently, the caller withdrew 99 CSPRs from the contract, leaving the contract's balance at 1 CSPR. The logs display deploy hashes, the contract's hash, and even indicate if the call was made through the proxy, providing a comprehensive overview of the on-chain activity. ","version":"next","tagName":"h2"},{"title":"Conclusion​","type":1,"pageTitle":"Using Proxy Caller","url":"/docs/next/tutorials/using-proxy-caller#conclusion","content":"In this tutorial, we learned how to use the proxy_caller wasm to make a payable function call. We deployed the TimeLockWallet contract, deposited tokens using the proxy_caller with attached CSPRs, and withdrew them. You got to try it out in both Rust and TypeScript, so you can choose whichever you prefer. Rust code seemed simpler, thanks to the Odra livenet backend making chain interactions easier to handle. ","version":"next","tagName":"h2"},{"title":"Delegate","type":0,"sectionRef":"#","url":"/docs/advanced/delegate","content":"","keywords":"","version":"2.3.1"},{"title":"Overview​","type":1,"pageTitle":"Delegate","url":"/docs/advanced/delegate#overview","content":"To utilize the delegate feature in your contract, use the delegate! macro provided by Odra. This macro allows you to list the functions you wish to delegate to the child modules. By using the delegate! macro, your parent module remains clean and easy to understand. You can delegate functions to as many child modules as you like. The functions will be available as if they were implemented in the parent module itself. ","version":"2.3.1","tagName":"h2"},{"title":"Code Examples​","type":1,"pageTitle":"Delegate","url":"/docs/advanced/delegate#code-examples","content":"Consider the following basic example for better understanding: use crate::{erc20::Erc20, ownable::Ownable}; use odra::{casper_types::U256, prelude::*}; #[odra::module] pub struct OwnedToken { ownable: SubModule&lt;Ownable&gt;, erc20: SubModule&lt;Erc20&gt; } #[odra::module] impl OwnedToken { pub fn init(&amp;mut self, name: String, symbol: String, decimals: u8, initial_supply: U256) { let deployer = self.env().caller(); self.ownable.init(deployer); self.erc20.init(name, symbol, decimals, initial_supply); } delegate! { to self.erc20 { fn transfer(&amp;mut self, recipient: Address, amount: U256); fn transfer_from(&amp;mut self, owner: Address, recipient: Address, amount: U256); fn approve(&amp;mut self, spender: Address, amount: U256); fn name(&amp;self) -&gt; String; fn symbol(&amp;self) -&gt; String; fn decimals(&amp;self) -&gt; u8; fn total_supply(&amp;self) -&gt; U256; fn balance_of(&amp;self, owner: Address) -&gt; U256; fn allowance(&amp;self, owner: Address, spender: Address) -&gt; U256; } to self.ownable { fn get_owner(&amp;self) -&gt; Address; fn change_ownership(&amp;mut self, new_owner: Address); } } pub fn mint(&amp;mut self, address: Address, amount: U256) { self.ownable.ensure_ownership(self.env().caller()); self.erc20.mint(address, amount); } }  This OwnedToken contract includes two modules: Erc20 and Ownable. We delegate various functions from both modules using the delegate! macro. As a result, the contract retains its succinctness without compromising on functionality. The above example basically merges the functionalities of modules and adds some control over the minting process. But you can use delegation to build more complex contracts, cherry-picking just a few module functionalities. Let's take a look at another example. use crate::{erc20::Erc20, ownable::Ownable, exchange::Exchange}; use odra::{casper_types::U256, prelude::*}; #[odra::module] pub struct DeFiPlatform { ownable: SubModule&lt;Ownable&gt;, erc20: SubModule&lt;Erc20&gt;, exchange: SubModule&lt;Exchange&gt; } #[odra::module] impl DeFiPlatform { pub fn init(&amp;mut self, name: String, symbol: String, decimals: u8, initial_supply: U256, exchange_rate: u64) { let deployer = self.env().caller(); self.ownable.init(deployer); self.erc20.init(name, symbol, decimals, initial_supply); self.exchange.init(exchange_rate); } delegate! { to self.erc20 { fn transfer(&amp;mut self, recipient: Address, amount: U256); fn balance_of(&amp;self, owner: Address) -&gt; U256; } to self.ownable { fn get_owner(&amp;self) -&gt; Address; } to self.exchange { fn swap(&amp;mut self, sender: Address, recipient: Address); fn set_exchange_rate(&amp;mut self, new_rate: u64); } } pub fn mint(&amp;mut self, address: Address, amount: U256) { self.ownable.ensure_ownership(self.env().caller()); self.erc20.mint(address, amount); } }  In this DeFiPlatform contract, we include Erc20, Ownable, and Exchange modules. By delegating functions from these modules, the parent contract becomes a powerhouse of functionality while retaining its readability and structure. Remember, the possibilities are endless with Odra's. By leveraging this feature, you can write cleaner, more efficient, and modular smart contracts. ","version":"2.3.1","tagName":"h2"},{"title":"Delegating CSPR to Validators","type":0,"sectionRef":"#","url":"/docs/advanced/delegating-cspr","content":"","keywords":"","version":"2.3.1"},{"title":"Sample implementation​","type":1,"pageTitle":"Delegating CSPR to Validators","url":"/docs/advanced/delegating-cspr#sample-implementation","content":"The following code shows how to implement a simple contract that allows delegating CSPR tokens to a validator. examples/src/features/validators.rs use odra::{ casper_types::{PublicKey, U512}, prelude::* }; #[odra::module] pub struct ValidatorsContract { /// In this variable we store the validator's public key, this is the only way we can identify the validator validator: Var&lt;PublicKey&gt; } /// Implementation of the TestingContract #[odra::module] impl ValidatorsContract { /// Initializes the contract with the validator's public key pub fn init(&amp;mut self, validator: PublicKey) { self.validator.set(validator); } /// Stake the amount of tokens #[odra(payable)] pub fn stake(&amp;mut self) { // Get the amount of tokens attached to the call let amount = self.env().attached_value(); if amount.is_zero() { self.env().revert(ValError::InsufficientBalance); } // Use the ContractEnv's delegate method to delegate the tokens to the validator self.env().delegate(self.validator.get().unwrap(), amount); } /// Undelegate the amount from the validator pub fn unstake(&amp;mut self, amount: U512) { self.env().undelegate(self.validator.get().unwrap(), amount); } /// Withdraw the amount from the validator pub fn withdraw(&amp;mut self, amount: U512) { self.env().transfer_tokens(&amp;self.env().caller(), &amp;amount); } ... }  ","version":"2.3.1","tagName":"h2"},{"title":"Explanation​","type":1,"pageTitle":"Delegating CSPR to Validators","url":"/docs/advanced/delegating-cspr#explanation","content":"The above example can be a good starting point for implementing a liquid staking solution. The main things to remember are the new api methods in ContractEnv: pub fn delegate(&amp;self, validator: PublicKey, amount: U512); pub fn undelegate(&amp;self, validator: PublicKey, amount: U512); pub fn delegated_amount(&amp;self, validator: PublicKey) -&gt; U512;  As you can see, we identify the validator by its public key. Funds delegated to the validator are assigned to the calling contract. Remember, that the delegation and undelegation takes some time, depending on the configuration of the blockchain - it's not instant. For example in the Casper mainnet, the delegation takes 1 era and the undelegation takes 7 eras. ","version":"2.3.1","tagName":"h2"},{"title":"Testing​","type":1,"pageTitle":"Delegating CSPR to Validators","url":"/docs/advanced/delegating-cspr#testing","content":"It is possible to test the delegation and undelegation of tokens in the contract. The following code shows how to do it: examples/src/features/validators.rs ... let test_env = odra_test::env(); let auction_delay = test_env.auction_delay(); let unbonding_delay = test_env.unbonding_delay(); test_env.set_caller(test_env.get_account(0)); let mut staking = ValidatorsContract::deploy( &amp;test_env, ValidatorsContractInitArgs { validator: test_env.get_validator(0) } ); let initial_account_balance = test_env.balance_of(&amp;test_env.get_account(0)); // Stake some amount let staking_amount = U512::from(1_000_000_000_000u64); staking.with_tokens(staking_amount).stake(); assert_eq!(staking.currently_delegated_amount(), staking_amount); assert_eq!( test_env.balance_of(&amp;test_env.get_account(0)), initial_account_balance - staking_amount ); // Advance time, run auctions and give off rewards test_env.advance_with_auctions(auction_delay * 2); // Check that the amount is greater than the staking amount let staking_with_reward = staking.currently_delegated_amount(); assert!(staking_with_reward &gt; staking_amount); ...  You can see, that we use the new methods from HostEnv, namely:  fn advance_with_auctions(&amp;self, time_diff: u64); fn auction_delay(&amp;self) -&gt; u64; fn unbonding_delay(&amp;self) -&gt; u64; fn delegated_amount(&amp;self, delegator: Address, validator: PublicKey) -&gt; U512;  advance_with_auctions works in a similar way to advance_block_time, but it also runs the auctions and gives off rewards. The auction_delay and unbonding_delay methods return the values of the auction and unbonding delays specific to the network or backend. We used currently_delegated_amount in the example, it uses delegated_amount method from ContractEnv, but it is also possible to query this information from the HostEnv using delegated_amount method. ","version":"2.3.1","tagName":"h2"},{"title":"Signatures","type":0,"sectionRef":"#","url":"/docs/advanced/signatures","content":"","keywords":"","version":"2.3.1"},{"title":"Signature verification​","type":1,"pageTitle":"Signatures","url":"/docs/advanced/signatures#signature-verification","content":"Signature verification is conducted by a function in contract's env(): pub fn verify_signature(message: &amp;Bytes, signature: &amp;Bytes, public_key: &amp;PublicKey) -&gt; bool;  Here's the simplest example of this function used in a contract: examples/src/features/signature_verifier.rs #[odra::module] impl SignatureVerifier { pub fn verify_signature( &amp;self, message: &amp;Bytes, signature: &amp;Bytes, public_key: &amp;PublicKey ) -&gt; bool { self.env().verify_signature(message, signature, public_key) } }  ","version":"2.3.1","tagName":"h2"},{"title":"Testing​","type":1,"pageTitle":"Signatures","url":"/docs/advanced/signatures#testing","content":"Besides the above function in the contract context, Odra provides corresponding functions in the HostEnv: pub fn sign_message(message: &amp;Bytes, address: &amp;Address) -&gt; Bytes; pub fn public_key(address: &amp;Address) -&gt; PublicKey;  sign_message will return a signed message. The signing itself will be performed using a private key of an account behind the address. public_key returns the PublicKey of an address account. Here's a complete example of how to test the signature verification in the contract: examples/src/features/signature_verifier.rs #[test] fn signature_verification_works() { let test_env = odra_test::env(); let message = &quot;Message to be signed&quot;; let message_bytes = Bytes::from(message.as_bytes()); let account = test_env.get_account(0); let signature = test_env.sign_message(&amp;message_bytes, &amp;account); let public_key = test_env.public_key(&amp;account); let signature_verifier = SignatureVerifier::deploy(&amp;test_env, NoArgs); assert!(signature_verifier.verify_signature(&amp;message_bytes, &amp;signature, &amp;public_key)); }  If you want, you can also test signatures created outside Odra: examples/src/features/signature_verifier.rs #[test] fn verify_signature_casper_wallet() { // Casper Wallet for the message &quot;Ahoj przygodo!&quot; signed using SECP256K1 key // produces the following signature: // 1e87e186238fa1df9c222b387a79910388c6ef56285924c7e4f6d7e77ed1d6c61815312cf66a5318db204c693b79e020b1d392dafe8c1b3841e1f6b4c41ca0fa // Casper Wallet adds &quot;Casper Message:\\n&quot; prefix to the message: let message = &quot;Casper Message:\\nAhoj przygodo!&quot;; let message_bytes = Bytes::from(message.as_bytes()); // Depending on the type of the key, we need to prefix the signature with a tag: // 0x01 for ED25519 // 0x02 for SECP256K1 let signature_hex = &quot;021e87e186238fa1df9c222b387a79910388c6ef56285924c7e4f6d7e77ed1d6c61815312cf66a5318db204c693b79e020b1d392dafe8c1b3841e1f6b4c41ca0fa&quot;; let signature: [u8; 65] = hex::decode(signature_hex).unwrap().try_into().unwrap(); let signature_bytes = Bytes::from(signature.as_slice()); // Similar to the above, the public key is tagged: let public_key_hex = &quot;02036d9b880e44254afaf34330e57703a63aec53b5918d4470059b67a4a906350105&quot;; let public_key_decoded = hex::decode(public_key_hex).unwrap(); let (public_key, _) = PublicKey::from_bytes(public_key_decoded.as_slice()).unwrap(); let signature_verifier = SignatureVerifier::deploy(&amp;odra_test::env(), NoArgs); assert!(signature_verifier.verify_signature(&amp;message_bytes, &amp;signature_bytes, &amp;public_key)); }  ","version":"2.3.1","tagName":"h2"},{"title":"Storage Layout","type":0,"sectionRef":"#","url":"/docs/advanced/storage-layout","content":"","keywords":"","version":"2.3.1"},{"title":"Casper VM Perspective​","type":1,"pageTitle":"Storage Layout","url":"/docs/advanced/storage-layout#casper-vm-perspective","content":"The Casper Execution Engine (VM) enables the storage of data in named keys or dictionaries. However, a smart contract has a limited number of named keys, making it unsuitable for storing substantial data volumes. Odra resolves this issue by storing all user-generated data in a dictionary called state. This dictionary operates as a key-value store, where keys are strings with a maximum length of 64 characters, and values are arbitrary byte arrays. Here is an example of what the interface for reading and writing data could look like: pub trait CasperStorage { fn read(key: &amp;str) -&gt; Option&lt;Vec&lt;u8&gt;&gt;; fn write(key: &amp;str, value: Vec&lt;u8&gt;); }  ","version":"2.3.1","tagName":"h2"},{"title":"Odra Perspective​","type":1,"pageTitle":"Storage Layout","url":"/docs/advanced/storage-layout#odra-perspective","content":"Odra was conceived with modularity and code reusability in mind. Additionally, we aimed to streamline storage definition through the struct object. Consider this straightforward storage definition: #[odra::module] pub struct Token { name: Var&lt;String&gt;, balances: Mapping&lt;Address, U256&gt; }  The Token structure contains two fields: name of type String andbalances, which functions as a key-value store with Address as keys andU256 as values. The Token module can be reused in another module, as demonstrated in a more complex example: #[odra::module] pub struct Loans { lenders: SubModule&lt;Token&gt;, borrowers: SubModule&lt;Token&gt;, }  The Loans module has two fields: lenders and borrowers, both of which have the same storage layout as defined by the Token module. Odra guarantees thatlenders and borrowers are stored under distinct keys within the storage dictionary. Both Token and Loans serve as examples to show how Odra's storage layout operates. ","version":"2.3.1","tagName":"h2"},{"title":"Key generation.​","type":1,"pageTitle":"Storage Layout","url":"/docs/advanced/storage-layout#key-generation","content":"Every element of a module (struct) with N elements is associated with an index ranging from 0 to N-1, represented as a u8 with a maximum of 256 elements. If an element of a module is another module (SubModule&lt;...&gt;), the associated index serves as a prefix for the indexes of the inner module. While this may initially appear complex, it is easily understood through an example. In the example, indexes are presented as bytes, reflecting the actual implementation. Loans { lenders: Token { // prefix: 0x0001 name: 1, // key: 0x0001_0001 balances: 2 // key: 0x0001_0010 }, borrowers: Token { // prefix: 0x0010 name: 1, // key: 0x0010_0001 balances: 2 // key: 0x0010_0010 } }  Additionally, it's worth mentioning how Mapping's keys are used in thestorage. They are simply concatenated with the index of the module, as demonstrated in the example. For instance, triggering borrowers.balances.get(0x1234abcd) would result in a key: 0x0001_0001_1234_abcd  Finally, the key must be hashed to fit within the 64-character limit and then encoded in hexadecimal format. ","version":"2.3.1","tagName":"h2"},{"title":"Value serialization​","type":1,"pageTitle":"Storage Layout","url":"/docs/advanced/storage-layout#value-serialization","content":"Before being stored in the storage, each value is serialized into bytes using the CLType serialization method and subsequently encapsulated with Casper'sBytes types. ","version":"2.3.1","tagName":"h2"},{"title":"Memory allocators","type":0,"sectionRef":"#","url":"/docs/advanced/using-different-allocator","content":"","keywords":"","version":"2.3.1"},{"title":"Using a different allocator​","type":1,"pageTitle":"Memory allocators","url":"/docs/advanced/using-different-allocator#using-a-different-allocator","content":"If the default allocator does not suit your needs, or you use a crate that already provides an allocator, you can disable the default allocator by enabling the disable-allocator feature in the odra dependency in your project: [dependencies] odra = { path = &quot;../odra&quot;, features = [&quot;disable-allocator&quot;] }  If you want to have a better control over the features that are enabled during the building and tests, see the next article on building manually. ","version":"2.3.1","tagName":"h2"},{"title":"OdraVM","type":0,"sectionRef":"#","url":"/docs/backends/odra-vm","content":"","keywords":"","version":"2.3.1"},{"title":"Usage​","type":1,"pageTitle":"OdraVM","url":"/docs/backends/odra-vm#usage","content":"The OdraVM is the default backend for Odra framework, so each time you run cargo odra test  You are running your code against it. ","version":"2.3.1","tagName":"h2"},{"title":"Architecture​","type":1,"pageTitle":"OdraVM","url":"/docs/backends/odra-vm#architecture","content":"OdraVM consists of two main parts: the Contract Register and the State. The Contract Register is a list of contracts deployed onto the OdraVM, identified by an Address. Contracts and Test Env functions can modify the State of the OdraVM. Contrary to the &quot;real&quot; backend, which holds the whole history of the blockchain, the OdraVM State holds only the current state of the OdraVM. Thanks to this and the fact that we do not need the blockchain itself, OdraVM starts instantly and runs the tests in the native speed. ","version":"2.3.1","tagName":"h2"},{"title":"Execution​","type":1,"pageTitle":"OdraVM","url":"/docs/backends/odra-vm#execution","content":"When the OdraVM backend is enabled, the #[odra::module] attribute is responsible for converting your pub functions into a list of Entrypoints, which are put into a Contract Container. When the contract is deployed, its Container registered into a Registry under an address. During the contract call, OdraVM finds an Entrypoint and executes the code. ","version":"2.3.1","tagName":"h2"},{"title":"Casper","type":0,"sectionRef":"#","url":"/docs/backends/casper","content":"","keywords":"","version":"2.3.1"},{"title":"Contract Env​","type":1,"pageTitle":"Casper","url":"/docs/backends/casper#contract-env","content":"As with any other backend, Casper Backend must implement the same features, but some do not have native support. Let's take a closer look at how Odra overcomes these hindrances. ","version":"2.3.1","tagName":"h2"},{"title":"Events​","type":1,"pageTitle":"Casper","url":"/docs/backends/casper#events","content":"An event is not a first-class citizen in Casper like in Ethereum, so Odra mimics it. As you've already learned from the events article, in Odra you emit an event, similarly, you would do it in Solidity. Under the hood, Odra integrates with Casper Event Standard and creates a few URefs in the global state when a contract is being installed: __events - a dictionary that stores events' data.__events_length - the evens count.__events_ces_version - the version of Casper Event Standard. __events_schema - a dictionary that stores event schemas. Besides that, all the events the contract emits are registered - events schemas are written to the storage under the __events_schema key. So, Events are nothing different from any other data stored by a contract. A struct to be an event must implement traits defined by Casper Event Standard, thankfully you can derive them using #[odra::event]. note Don't forget to expose events in the module using #[odra::module(events = [...])]. ","version":"2.3.1","tagName":"h3"},{"title":"Payable​","type":1,"pageTitle":"Casper","url":"/docs/backends/casper#payable","content":"The first Odra idiom is a Contract Main Purse. It is a purse associated with a contract. The purse is created lazily - when the first transfer to the contract occurs, a proper URef and a purse are created and stored under the __contract_main_purse key. Casper does not allow direct transfers from an account to a contract, so Odra comes up with the second idiom - a Cargo Purse. It is a one-time-use purse proxy between an account and a contract. First, motes go from the account to the cargo purse and then to the contract's main purse. Behind the scenes, Odra handles an account-contract transfer via a cargo purse when a function is marked as payable. If under the way something goes wrong with the transfer, the contract reverts. The transferred amount can be read inside the contract by calling self.env().attached_value(). note Odra expects the cargo_purse runtime argument to be attached to a contract call. In case of its absence, the contract_env::attached_value() returns zero. ","version":"2.3.1","tagName":"h3"},{"title":"Revert​","type":1,"pageTitle":"Casper","url":"/docs/backends/casper#revert","content":"In Casper, we can stop the execution pretty straightforwardly - call the runtime::revert(). Odra adds an extra abstraction layer - in a contract ExecutionErrors are defined, which ultimately are transformed into Casper's ApiError::User. ","version":"2.3.1","tagName":"h3"},{"title":"Context​","type":1,"pageTitle":"Casper","url":"/docs/backends/casper#context","content":"Casper equips developers with very low-level tooling, which can be cumbersome for newcomers. If you want to check who called the contract or its address, you can not do it off-hand - you must analyze the call stack. The self.env().self_address() function takes the first element of the callstack (runtime::get_call_stack()) and casts it to Address. The self.env().caller() function takes the second element of the call stack (runtime::get_call_stack()) and casts it to Address. As mentioned in the [Payable] section, to store CSPR, each contract creates its purse. To read the contract balance, you call self.env().self_balance(), which checks the balance of the purse stored under __contract_main_purse. ","version":"2.3.1","tagName":"h3"},{"title":"Test Env​","type":1,"pageTitle":"Casper","url":"/docs/backends/casper#test-env","content":"Test environment allows you to test wasm contracts before you deploy them onto the testnet or livenet. It is built on top of the Casper Execution Engine. In your test, you can freely switch execution context by setting as a caller (test_env::set_caller()) one of the 20 predefined accounts. Each account possesses the default amount of Motes (100_000_000_000_000_000). The Test Env internally keeps track of the current block time, error and attached value. Each test is executed on a fresh instance of the Test Env. ","version":"2.3.1","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"Casper","url":"/docs/backends/casper#usage","content":"Name of the Casper backend in Odra is casper, so to run the tests against it, simply pass it as a -bparameter: cargo odra test -b casper  If you want to just generate a wasm file, simply run: cargo odra build -b casper  ","version":"2.3.1","tagName":"h2"},{"title":"Deploying a contract to Casper network​","type":1,"pageTitle":"Casper","url":"/docs/backends/casper#deploying-a-contract-to-casper-network","content":"There would be no point in writing a contract if you couldn't deploy it to the blockchain. You can do it in two ways: provided by the Casper itself: using the casper-client tool or using the Odra's Livenet integration. note In the commands below, we use casper-client version 5.0.0. Let's explore the first option to better understand the process. note If you wish, you can skip the following section and jump to the Livenet integration. ","version":"2.3.1","tagName":"h2"},{"title":"WASM arguments​","type":1,"pageTitle":"Casper","url":"/docs/backends/casper#wasm-arguments","content":"When deploying a new contract you can pass some arguments to it. Every contract written in Odra expects those arguments to be set: odra_cfg_package_hash_key_name - String type. The key under which the package hash of the contract will be stored.odra_cfg_allow_key_override - Bool type. If true and the key specified in odra_cfg_package_hash_key_name already exists, it will be overwritten.odra_cfg_is_upgradable - Bool type. If true, the contract will be deployed as upgradable.odra_cfg_is_upgrade - Bool type. If true, the contract will be upgraded. If we want to install a contract to should be set to false. Additionally, if required by the contract, you can pass constructor arguments. When working with the test env via cargo odra or when usingLivenet integration this is handled automatically. However, if you rather usecasper-client directly, you have to pass them manually: ","version":"2.3.1","tagName":"h3"},{"title":"Example: Deploy Counter​","type":1,"pageTitle":"Casper","url":"/docs/backends/casper#example-deploy-counter","content":"To deploy your contract with a constructor using casper-client, you need to pass the above arguments. Additionally, you need to pass the value argument, which sets the arbitrary initial value for the counter. casper-client put-transaction session \\ --node-address [NODE_ADDRESS] \\ --chain-name casper-test \\ --secret-key [PATH_TO_YOUR_KEY]/secret_key.pem \\ --payment-amount 5000000000000 \\ --gas-price-tolerance 1 \\ --standard-payment true \\ --wasm-path ./wasm/counter.wasm \\ --session-arg &quot;odra_cfg_package_hash_key_name:string:'counter_package_hash'&quot; \\ --session-arg &quot;odra_cfg_allow_key_override:bool:'true'&quot; \\ --session-arg &quot;odra_cfg_is_upgradable:bool:'true'&quot; \\ --session-arg &quot;odra_cfg_is_upgrade:bool:'false'&quot; \\ --session-arg &quot;value:u32:42&quot;  For a more in-depth tutorial, please refer to the Casper's 'Writing On-Chain Code'. ","version":"2.3.1","tagName":"h3"},{"title":"Example: Deploy ERC721​","type":1,"pageTitle":"Casper","url":"/docs/backends/casper#example-deploy-erc721","content":"Odra comes with a standard ERC721 token implementation. Clone the main Odra repo and navigate to the modules directory. Firstly contract needs to be compiled. cargo odra build -b casper -c erc721_token  It produces the erc721_token.wasm file in the wasm directory. Now it's time to deploy the contract. casper-client put-transaction session \\ --node-address [NODE_ADDRESS] \\ --chain-name casper-test \\ --secret-key [PATH_TO_YOUR_KEY]/secret_key.pem \\ --payment-amount 300000000000 \\ --gas-price-tolerance 1 \\ --standard-payment true \\ --wasm-path ./wasm/erc721_token.wasm \\ --session-arg &quot;odra_cfg_package_hash_key_name:string:'my_nft'&quot; \\ --session-arg &quot;odra_cfg_allow_key_override:bool:'false'&quot; \\ --session-arg &quot;odra_cfg_is_upgradable:bool:'true'&quot; \\ --session-arg &quot;odra_cfg_is_upgrade:bool:'false'&quot; \\ --session-arg &quot;name:string:'MyNFT'&quot; \\ --session-arg &quot;symbol:string:'NFT'&quot; \\ --session-arg &quot;base_uri:string:'https://example.com/'&quot;  It's done. The contract is deployed and ready to use. Your account is the owner of the contract and you can mint and burn tokens. For more details see the code of the ERC721 module. To obtain the package hash of the contract search for my_nft key in your account's named keys. ","version":"2.3.1","tagName":"h3"},{"title":"Example: Deploy ERC1155​","type":1,"pageTitle":"Casper","url":"/docs/backends/casper#example-deploy-erc1155","content":"The process is similar to the one described in the previous section. Contract compilation: cargo odra build -b casper -c erc1155_token  Contract deployment: casper-client put-transaction session \\ --node-address [NODE_ADDRESS] \\ --chain-name casper-test \\ --secret-key [PATH_TO_YOUR_KEY]/secret_key.pem \\ --payment-amount 300000000000 \\ --gas-price-tolerance 1 \\ --standard-payment true \\ --wasm-path ./wasm/erc1155_token.wasm \\ --session-arg &quot;odra_cfg_package_hash_key_name:string:'my_tokens'&quot; \\ --session-arg &quot;odra_cfg_allow_key_override:bool:'false'&quot; \\ --session-arg &quot;odra_cfg_is_upgradable:bool:'true'&quot; \\ --session-arg &quot;odra_cfg_is_upgrade:bool:'false'&quot; \\ --session-arg &quot;odra_cfg_constructor:string:'init'&quot; \\  As previously, your account is the owner and can mint and burn tokens. For more details see the code of the ERC1155 module. ","version":"2.3.1","tagName":"h3"},{"title":"Sending CSPR to a contract​","type":1,"pageTitle":"Casper","url":"/docs/backends/casper#sending-cspr-to-a-contract","content":"Defining payable entry points is described in Native Token section. What is happening under the hood is that Odra creates a new cargo_purse argument for each payable entry point. The cargo_purse needs to be top-upped with CSPR before calling the contract. When a contract adds CSPR to another contract call, Odra handles it for you. The problem arises when you want to call an entry point and attach CSPR as an account. The only way of doing that is by executing code in the sessions context, that top-ups the cargo_purse and then calls the contract. Odra provides a generic proxy_caller.wasm that does exactly that. You can build it by yourself from the main Odra repository, or use the proxy_caller.wasmwe maintain. ","version":"2.3.1","tagName":"h2"},{"title":"Using proxy_caller.wasm​","type":1,"pageTitle":"Casper","url":"/docs/backends/casper#using-proxy_callerwasm","content":"To use the proxy_caller.wasm you need to attach the following arguments: contract_package_hash - BytesArray(32) type. The package hash of the contract you want to call. Result of to_bytes on CasperPackageHash.entry_point - String type. The name of the entry point you want to call.args - Bytes type. It is a serialized RuntimeArgs with the arguments you want to pass to the entry point. To be specific it is the result of to_bytes method wrapped with Bytes type.attached_value. U512 type. The amount of CSPR you want to attach to the call.amount. U512 type. Should be the same value as attached_value if not None. It is a special Casper argument that enables the access to account's main purse. Currently casper-client doesn't allow building such arguments. You have to build it using your SDK. See an example in the Tutorial section. ","version":"2.3.1","tagName":"h3"},{"title":"Execution​","type":1,"pageTitle":"Casper","url":"/docs/backends/casper#execution","content":"First thing Odra does with your code, is similar to the one used in OdraVM - a list of entrypoints is generated, thanks to the #[odra::module] attribute. ","version":"2.3.1","tagName":"h2"},{"title":"Livenet","type":0,"sectionRef":"#","url":"/docs/backends/livenet","content":"","keywords":"","version":"2.3.1"},{"title":"Setup​","type":1,"pageTitle":"Livenet","url":"/docs/backends/livenet#setup","content":"To use Livenet backend, we need to provide Odra with some information - the network address, our private key and the name of the chain we want to use. Optionally, we can add multiple private keys to use more than one account in our tests. Those values are passed using environment variables. We can use .env file to store them - let's take a look at an example .env file, created from the .env.sample file from the examples folder: # .env file used by Livenet integration. You can use multiple .env files to manage deploys on multiple chains # by naming them casper-test.env, casper-livenet.env, etc. and calling the deploy script with the name of the # ennviroment provided in the &quot;ODRA_CASPER_LIVENET_ENV&quot; variable. For example: # ODRA_CASPER_LIVENET_ENV=casper-test cargo run --bin livenet_tests --features livenet # This will load integration.env file first, and then fill the missing values with the values from casper-test.env. # Path to the secret key of the account that will be used to deploy the contracts. # If you are using the nctl, you can use the following command to extract the secret key from the container: # docker exec mynctl /bin/bash -c &quot;cat /home/casper/casper-nctl/assets/net-1/users/user-1/secret_key.pem&quot; &gt; examples/.node-keys/secret_key.pem # docker exec mynctl /bin/bash -c &quot;cat /home/casper/casper-nctl/assets/net-1/users/user-2/secret_key.pem&quot; &gt; examples/.node-keys/secret_key_1.pem ODRA_CASPER_LIVENET_SECRET_KEY_PATH=&lt;path to secret_key.pem&gt; # RPC address of the node that will be used to deploy the contracts. # For CSPR.cloud, you can use the following addresses: # - https://node.cspr.cloud # - https://node.testnet.cspr.cloud # For nctl, default is: # - http://localhost:11101 ODRA_CASPER_LIVENET_NODE_ADDRESS=&lt;node address&gt; # Events url # For CSPR.cloud, you can use the following addresses: # - https://node.cspr.cloud/events # For nctl, default is: # - http://localhost:18101/events ODRA_CASPER_LIVENET_EVENTS_URL=&lt;events url&gt; # Chain name of the network. The mainnet is &quot;casper&quot; and test net is &quot;casper-test&quot;. # The integration network uses the &quot;integration-test&quot; chain name. # For nctl default is &quot;casper-net-1&quot; ODRA_CASPER_LIVENET_CHAIN_NAME=&lt;chain_name&gt; # Optionally, paths to the secret keys of the additional acccounts. Main secret key will be 0th account. # The following will work for nctl if you used the command above to extract the secret keys: # ODRA_CASPER_LIVENET_KEY_1=./keys/secret_key_1.pem #ODRA_CASPER_LIVENET_KEY_1=&lt;path to secret_key_1.pem&gt; # If using CSPR.cloud, you can set the auth token here. # CSPR_CLOUD_AUTH_TOKEN= # Optionally, you can set the TTL for the deploys. Default is 5 minutes. # ODRA_CASPER_LIVENET_TTL=  note CSPR.cloud is a service that provides mainnet and testnet Casper nodes on demand. With the proper value in place, we can write our tests or deploy scenarios. In the examples, we can find a simple binary that deploys a contract and calls it. The test is located in the erc20_on_livenet.rs file. Let's go through the code: //! Deploys an ERC20 contract and transfers some tokens to another address. use odra::casper_types::U256; use odra::host::{Deployer, HostEnv, HostRefLoader, InstallConfig}; use odra::prelude::*; use odra_modules::erc20::{Erc20, Erc20HostRef, Erc20InitArgs}; use std::str::FromStr; fn main() { let env = odra_casper_livenet_env::env(); let owner = env.caller(); let recipient = &quot;hash-2c4a6ce0da5d175e9638ec0830e01dd6cf5f4b1fbb0724f7d2d9de12b1e0f840&quot;; let recipient = Address::from_str(recipient).unwrap(); // Deploy new contract. let mut token = deploy_erc20(&amp;env); println!(&quot;Token address: {}&quot;, token.address().to_string()); // Uncomment to load existing contract. // let mut token = load_erc20(&amp;env); println!(&quot;Token name: {}&quot;, token.name()); env.set_gas(3_000_000_000u64); token.transfer(&amp;recipient, &amp;U256::from(1000)); println!(&quot;Owner's balance: {:?}&quot;, token.balance_of(&amp;owner)); println!(&quot;Recipient's balance: {:?}&quot;, token.balance_of(&amp;recipient)); } /// Loads an ERC20 contract. fn _load_erc20(env: &amp;HostEnv) -&gt; Erc20HostRef { let address = &quot;hash-d26fcbd2106e37be975d2045c580334a6d7b9d0a241c2358a4db970dfd516945&quot;; let address = Address::from_str(address).unwrap(); Erc20::load(env, address) } /// Deploys an ERC20 contract. pub fn deploy_erc20(env: &amp;HostEnv) -&gt; Erc20HostRef { let name = String::from(&quot;Plascoin&quot;); let symbol = String::from(&quot;PLS&quot;); let decimals = 10u8; let initial_supply = Some(U256::from(10_000)); let init_args = Erc20InitArgs { name, symbol, decimals, initial_supply }; env.set_gas(450_000_000_000u64); // You may configure a deploy passing `InstallConfig`. // Erc20::deploy_with_cfg(env, init_args, InstallConfig::upgradable::&lt;Erc20&gt;()) Erc20::deploy(env, init_args) }  note The above example is a rust binary, not a test. Note that it is also added as a section of theCargo.toml file: [bin] name = &quot;erc20_on_livenet&quot; path = &quot;src/bin/erc20_on_livenet.rs&quot; required-features = [&quot;livenet&quot;] test = false  ","version":"2.3.1","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"Livenet","url":"/docs/backends/livenet#usage","content":"To run the above code, we simply need to run the binary with the livenet feature enabled: cargo run --bin erc20_on_livenet --features=livenet  note Before executing the binary, make sure you built a wasm file. A part of a sample output should look like this: ... 💁 INFO : Calling &quot;contract-package-b796cf8e527472d7ced8c4f8db5adb30eb577176f4c7ce956675590e0cac4bb8&quot; directly with entrypoint &quot;transfer&quot;. 🙄 WAIT : Waiting 10 for V1(TransactionV1Hash(775913daa0ffbded9aaf2216942217d682f03d1c04e6e2560d1e4b3329ebd2d6)). 💁 INFO : Transaction &quot;775913daa0ffbded9aaf2216942217d682f03d1c04e6e2560d1e4b3329ebd2d6&quot; successfully executed. 🔗 LINK : Owner's balance: 9000 Recipient's balance: 1000  Those logs are a result of the last 4 lines of the above listing. Each deployment or a call to the blockchain will be noted and will take some time to execute. We can see that the transfer call took over 15 seconds to execute. But calling balance_of was nearly instant and cost us nothing. How it is possible? info You can see the deployment on http://cspr.live/ - the transfer from the example can be seen here. ","version":"2.3.1","tagName":"h2"},{"title":"How Livenet backend works​","type":1,"pageTitle":"Livenet","url":"/docs/backends/livenet#how-livenet-backend-works","content":"All calls of entrypoints executed on a Casper blockchain cost gas - even if they do not change the state. It is possible, however, to query the state of the blockchain for free. This principle is used in the Livenet backend - all calls that do not change the state of the blockchain are really executed offline - the only thing that is requested from the node is the current state. This is why the balance_of call was almost instant and free. Basically, if the entrypoint function is not mutable or does not make a call to an unknown external contract (see Cross Calls), it is executed offline and node is used for the state query only. However, the Livenet needs to know the connection between the contracts and the code, so make sure to deploy or load already deployed contracts ","version":"2.3.1","tagName":"h2"},{"title":"Multiple environments​","type":1,"pageTitle":"Livenet","url":"/docs/backends/livenet#multiple-environments","content":"It is possible to have multiple environments for the Livenet backend. This is useful if we want to easily switch between multiple accounts, multiple nodes or even multiple chains. To do this, simply create a new .env file with a different prefix - for example, integration.env and mainnet.env. Then, pass the ODRA_CASPER_LIVENET_ENV variable with value either integration or mainnet to select which file has to be used first. If your integration.env file has a value that IS present in the .env file, it will override the value from the .env file. ODRA_CASPER_LIVENET_ENV=integration cargo run --bin erc20_on_livenet --features=livenet  To sum up - this command will firstly load the integration.env file and then load the missing values from .env file. ","version":"2.3.1","tagName":"h2"},{"title":"What is a backend?","type":0,"sectionRef":"#","url":"/docs/backends/what-is-a-backend","content":"","keywords":"","version":"2.3.1"},{"title":"Contract Env​","type":1,"pageTitle":"What is a backend?","url":"/docs/backends/what-is-a-backend#contract-env","content":"The Contract Env is a simple interface that each backend needs to implement, exposing features of the blockchain from the perspective of the contract. It gives Odra a set of functions, which allows implementing more complex concepts - for example, to implement Mapping, Odra requires some kind of storage integration. The exact implementation of those functions is a responsibility of a backend, making Odra and its user free to implement the contract logic, instead of messing with the blockchain internals. Other functions from Contract Env include handling transfers, addresses, block time, errors and events. ","version":"2.3.1","tagName":"h2"},{"title":"Host Env​","type":1,"pageTitle":"What is a backend?","url":"/docs/backends/what-is-a-backend#host-env","content":"Similarly to the Contract Env, the Host Env exposes a set of functions that allows the communication with the backend from the outside world - really useful for implementing tests. This ranges from interacting with the blockchain - like deploying new, loading existing and calling the contracts, to the more test-oriented - handling errors, forwarding the block time, etc. ","version":"2.3.1","tagName":"h2"},{"title":"What's next​","type":1,"pageTitle":"What is a backend?","url":"/docs/backends/what-is-a-backend#whats-next","content":"We will take a look at backends Odra implements in more detail. ","version":"2.3.1","tagName":"h2"},{"title":"Cargo Odra","type":0,"sectionRef":"#","url":"/docs/basics/cargo-odra","content":"","keywords":"","version":"2.3.1"},{"title":"Managing projects​","type":1,"pageTitle":"Cargo Odra","url":"/docs/basics/cargo-odra#managing-projects","content":"Two commands help you create a new project. The first one is cargo odra new. You need to pass one parameter, namely --name {PROJECT_NAME}: cargo odra new --name my-project  This creates a new project in the my_project folder and name it my_project. You can see it for yourself, for example by taking a look into a Cargo.toml file created in your project's folder: [package] name = &quot;my_project&quot; version = &quot;0.1.0&quot; edition = &quot;2021&quot;  The project is created using the template located in Odra's main repository. By default it uses full template, if you want, you can use minimalistic blank by running: cargo odra new -t blank --name my-project  The third available template is workspace, which creates a workspace with two projects, similar to the one created with the full template. There are also two templates which create a project with a sample tokens native to Casper Network: cep18 and cep78. By default, the latest release of Odra will be used for the template and as a dependency. You can pass a source of Odra you want to use, by using -s parameter: cargo odra new -n my-project -s ../odra # will use local folder of odra cargo odra new -n my-project -s release/0.9.0 # will use github branch, e.g. if you want to test new release cargo odra new -n my-project -s 1.1.0 # will use a version released on crates.io  The second way of creating a project is by using init command: cargo odra init --name my-project  It works in the same way as new, but instead of creating a new folder, it creates a project in the current, empty directory. ","version":"2.3.1","tagName":"h2"},{"title":"Generating code​","type":1,"pageTitle":"Cargo Odra","url":"/docs/basics/cargo-odra#generating-code","content":"If you want to quickly create a new contract code, you can use the generate command: cargo odra generate -c counter  This creates a new file src/counter.rs with sample code, add appropriate use and mod sections to src/lib.rs and update the Odra.toml file accordingly. To learn more about Odra.toml file, visit Odra.toml. ","version":"2.3.1","tagName":"h2"},{"title":"Testing​","type":1,"pageTitle":"Cargo Odra","url":"/docs/basics/cargo-odra#testing","content":"The most used command during the development of your project should be this one: cargo odra test  It runs your tests against Odra's MockVM. It is substantially faster than CasperVMand implements all the features Odra uses. When you want to run tests against a &quot;real&quot; VM, just provide the name of the backend using -boption: cargo odra test -b casper  In the example above, Cargo Odra builds the project, generates the wasm files, spin up CasperVM instance, deploys the contracts onto it and runs the tests against it. Pretty neat. Keep in mind that this is a lot slower than OdraVM and you cannot use the debugger. This is why OdraVM was created and should be your first choice when developing contracts. Of course, testing all of your code against a blockchain VM is a must in the end. If you want to run only some of the tests, you can pass arguments to the cargo test command (which is run in the background obviously): cargo odra test -- this-will-be-passed-to-cargo-test  If you want to run tests which names contain the word two, you can execute: cargo odra test -- two  Of course, you can do the same when using the backend: cargo odra test -b casper -- two  ","version":"2.3.1","tagName":"h2"},{"title":"Building code​","type":1,"pageTitle":"Cargo Odra","url":"/docs/basics/cargo-odra#building-code","content":"You can also build the code itself and generate the output contracts without running the tests. To do so, simply run: cargo odra build  If the build process finishes successfully, wasm files will be located in wasm folder. Notice, that this command does not require the -b option. If you want to build specific contract, you can use -c option: cargo odra build -c counter # you pass many comma separated contracts  ","version":"2.3.1","tagName":"h2"},{"title":"Skipping building​","type":1,"pageTitle":"Cargo Odra","url":"/docs/basics/cargo-odra#skipping-building","content":"As building wasm files can take a long time, especially if you have a lot of contracts. If you did not change anything in your contracts and you just want to rerun the tests for the casper backend, use the -s option: cargo odra test -b casper -s  ","version":"2.3.1","tagName":"h2"},{"title":"Generating contract schema​","type":1,"pageTitle":"Cargo Odra","url":"/docs/basics/cargo-odra#generating-contract-schema","content":"If you want to generate a schema (including the name, entrypoints, events, etc.) for your contract, you can use the schema command: cargo odra schema  This generates a schema file in JSON format for all your contracts and places them in the resources folder. If the resources folder does not exist, it creates the folder for you. Like with the build command, you can use the -c option to generate a schema for a specific contract. ","version":"2.3.1","tagName":"h2"},{"title":"What's next​","type":1,"pageTitle":"Cargo Odra","url":"/docs/basics/cargo-odra#whats-next","content":"In the next section, we will take a look at all the files and directories that cargo odra created for us and explain their purpose. ","version":"2.3.1","tagName":"h2"},{"title":"Host Communication","type":0,"sectionRef":"#","url":"/docs/basics/communicating-with-host","content":"","keywords":"","version":"2.3.1"},{"title":"What's next​","type":1,"pageTitle":"Host Communication","url":"/docs/basics/communicating-with-host#whats-next","content":"In the next article, we'll dive into testing your contracts with Odra, so you can check that the code we presented in fact works! ","version":"2.3.1","tagName":"h2"},{"title":"directory-structure","type":0,"sectionRef":"#","url":"/docs/basics/directory-structure","content":"","keywords":"","version":"2.3.1"},{"title":"Directory structure​","type":1,"pageTitle":"directory-structure","url":"/docs/basics/directory-structure#directory-structure","content":"After creating a new project using Odra and running the tests, you will be presented with the following files and directories: . ├── Cargo.lock ├── Cargo.toml ├── CHANGELOG.md ├── Odra.toml ├── README.md ├── rust-toolchain ├── src/ │ ├── flipper.rs │ └── lib.rs ├── bin/ | |── build_contract.rs | └── build_schema.rs ├── target/ └── wasm/  ","version":"2.3.1","tagName":"h2"},{"title":"Cargo.toml​","type":1,"pageTitle":"directory-structure","url":"/docs/basics/directory-structure#cargotoml","content":"Let's first take a look at Cargo.toml file: [package] name = &quot;sample&quot; version = &quot;0.1.0&quot; edition = &quot;2021&quot; [dependencies] odra = &quot;2.2.0&quot; [dev-dependencies] odra-test = &quot;2.2.0&quot; [build-dependencies] odra-build = &quot;2.2.0&quot; [[bin]] name = &quot;sample_build_contract&quot; path = &quot;bin/build_contract.rs&quot; test = false [[bin]] name = &quot;sample_build_schema&quot; path = &quot;bin/build_schema.rs&quot; test = false [profile.release] codegen-units = 1 lto = true [profile.dev.package.&quot;*&quot;] opt-level = 3  By default, your project will use the latest odra version available at crates.io. For testing purposes,odra-test is also added as a dev dependency. ","version":"2.3.1","tagName":"h3"},{"title":"Odra.toml​","type":1,"pageTitle":"directory-structure","url":"/docs/basics/directory-structure#odratoml","content":"This is the file that holds information about contracts that will be generated when running cargo odra build andcargo odra test: [[contracts]] fqn = &quot;sample::Flipper&quot;  As we can see, we have a single contract, its fqn (Fully Qualified Name) corresponds to the contract is located in src/flipper.rs. More contracts can be added here by hand, or by using cargo odra generate command. ","version":"2.3.1","tagName":"h3"},{"title":"src/​","type":1,"pageTitle":"directory-structure","url":"/docs/basics/directory-structure#src","content":"This is the folder where your smart contract files live. ","version":"2.3.1","tagName":"h3"},{"title":"bin/​","type":1,"pageTitle":"directory-structure","url":"/docs/basics/directory-structure#bin","content":"This is the folder where scripts that will be used to generate code or schemas live. You don't need to modify those files, they are generated by cargo odra new command and are used by cargo odra build, cargo odra test and cargo odra schema commands. ","version":"2.3.1","tagName":"h3"},{"title":"target/​","type":1,"pageTitle":"directory-structure","url":"/docs/basics/directory-structure#target","content":"Files generated by cargo during the build process are put here. ","version":"2.3.1","tagName":"h3"},{"title":"wasm/​","type":1,"pageTitle":"directory-structure","url":"/docs/basics/directory-structure#wasm","content":"WASM files generated by cargo odra build and cargo odra test are put here. You can grab those WASM files and deploy them on the blockchain. ","version":"2.3.1","tagName":"h3"},{"title":"What's next​","type":1,"pageTitle":"directory-structure","url":"/docs/basics/directory-structure#whats-next","content":"Now, let's take a look at one of the files mentioned above in more detail, namely the Odra.toml file. ","version":"2.3.1","tagName":"h2"},{"title":"Cross calls","type":0,"sectionRef":"#","url":"/docs/basics/cross-calls","content":"","keywords":"","version":"2.3.1"},{"title":"Contract Ref​","type":1,"pageTitle":"Cross calls","url":"/docs/basics/cross-calls#contract-ref","content":"We mentioned HostRef already in our Testing article - a host side reference to already deployed contract. In the module context we use a ContractRef instead, to call other contracts. Similarly to the HostRef trait implemetation for the module, the {{ModuleName}}ContractRef is generated automatically, by the #[odra::module] attribute. The reference implements all the public endpoints to the contract (those marked as pub in #[odra::module]impl), and the {{ModuleName}}ContractRef::address() function, which returns the address of the contract. External Contracts Sometimes in our contract, we would like to interact with a someone else's contract, already deployed onto the blockchain. The only thing we know about the contract is the ABI. For that purpose, we use #[odra:external_contract] attribute. This attribute should be applied to a trait. The trait defines the part of the ABI we would like to take advantage of. Let's pretend the MathEngine we defined is an external contract. There is a contract with add() function that adds two numbers somewhere. #[odra::external_contract] pub trait Adder { fn add(&amp;self, n1: u32, n2: u32) -&gt; u32; }  Odra automatically creates the AdderContractRef struct. Having an address, in the module context we can call: struct Contract { adder: External&lt;AdderContractRef&gt; } // in some function self.adder.add(3, 5) // or struct Contract { adder: Var&lt;Address&gt; } // in some function AdderContractRef::new(self.env(), address).add(3, 5)  ","version":"2.3.1","tagName":"h2"},{"title":"Loading the contract​","type":1,"pageTitle":"Cross calls","url":"/docs/basics/cross-calls#loading-the-contract","content":"Sometimes it is useful to load the deployed contract instead of deploying it by ourselves. This is especially useful when we want to test our contracts in Livenet backend. We can load the contract using load method on the Deployer: examples/bin/erc20_on_livenet.rs fn _load_erc20(env: &amp;HostEnv) -&gt; Erc20HostRef { let address = &quot;hash-d26fcbd2106e37be975d2045c580334a6d7b9d0a241c2358a4db970dfd516945&quot;; let address = Address::from_str(address).unwrap(); Erc20::load(env, address) }  ","version":"2.3.1","tagName":"h3"},{"title":"Testing​","type":1,"pageTitle":"Cross calls","url":"/docs/basics/cross-calls#testing","content":"Let's see how we can test our cross calls using this knowledge: examples/src/features/cross_calls.rs #[cfg(test)] mod tests { use super::{CrossContract, CrossContractInitArgs, MathEngineHostRef}; use odra::host::{Deployer, NoArgs}; use odra::prelude::*; #[test] fn test_cross_calls() { let test_env = odra_test::env(); let math_engine_contract = MathEngine::deploy(&amp;test_env, NoArgs); let cross_contract = CrossContract::deploy( &amp;test_env, CrossContractInitArgs { math_engine_address: *math_engine_contract.address() } ); assert_eq!(cross_contract.add_using_another(), 8); } }  Each test begins with a clean instance of the blockchain, with no contracts deployed. To test an external contract, we first deploy a MathEngine contract, although we won't directly utilize it. Instead, we only extract its address. Let's continue assuming there is a contract featuring the add() function that we intend to utilize. #[cfg(test)] mod tests { use super::*; use odra::host::{Deployer, NoArgs}; use odra::prelude::*; #[test] fn test_ext() { let test_env = odra_test::env(); let adder = Adder::new(&amp;test_env, get_adder_address(&amp;test_env)).add(3, 5) assert_eq!(adder.add(1, 2), 3); } fn get_adder_address(test_env: &amp;HostEnv) -&gt; Address { let contract = MathEngine::deploy(test_env, NoArgs); contract.address() } }  ","version":"2.3.1","tagName":"h2"},{"title":"Errors","type":0,"sectionRef":"#","url":"/docs/basics/errors","content":"","keywords":"","version":"2.3.1"},{"title":"Testing errors​","type":1,"pageTitle":"Errors","url":"/docs/basics/errors#testing-errors","content":"Okay, but how about testing it? Let's write a test that will check if the error is thrown when the caller is not an owner: examples/src/features/handling_errors.rs #[cfg(test)] mod tests { use super::{Error, OwnedContract, OwnedContractInitArgs}; use odra::{host::Deployer, prelude::*}; #[test] fn test_owner_error() { let test_env = odra_test::env(); let owner = test_env.get_account(0); let not_an_owner = test_env.get_account(1); test_env.set_caller(owner); let init_args = OwnedContractInitArgs { name: &quot;OwnedContract&quot;.to_string() }; let mut owned_contract = OwnedContract::deploy(&amp;test_env, init_args); test_env.set_caller(not_an_owner); assert_eq!( owned_contract .try_change_name(&quot;NewName&quot;.to_string()) .unwrap_err(), Error::NotAnOwner.into() ); } }  Each deployed contract is of {{ModuleName}}HostRef type and has try_{{entry_point_name}} functions that return an OdraResult.OwnedContractHostRef implements regular entrypoints: name, owner, change_name, and and safe its safe version: try_name, try_owner, try_change_name. In our example, we are calling try_change_name and expecting an error to be thrown. For assertions, we are using a standard assert_eq! macro. As the contract call returns an OdraError, we need to convert our custom error to OdraError using Into::into(). ","version":"2.3.1","tagName":"h2"},{"title":"What's next​","type":1,"pageTitle":"Errors","url":"/docs/basics/errors#whats-next","content":"We will learn how to emit and test events using Odra. ","version":"2.3.1","tagName":"h2"},{"title":"Casper Contract Schema","type":0,"sectionRef":"#","url":"/docs/basics/casper-contract-schema","content":"","keywords":"","version":"2.3.1"},{"title":"Odra and CCS​","type":1,"pageTitle":"Casper Contract Schema","url":"/docs/basics/casper-contract-schema#odra-and-ccs","content":"There is almost nothing you need to do to use CCS in your Odra project. The only thing to be taken care of is using odra attributes namely: module, event, odra_error and odra_type. The schema will be generated for you and available in the resources directory. note If you forget to register events and errors in the module attribute, the definition remains valid; however, the errors and events will not be incorporated into the schema. src/contract.rs use odra::prelude::*; #[odra::module( // the name of the contract, default is the module name name = &quot;MyContract&quot;, // the version of the contract, default is the version of the crate version = &quot;0.1.0&quot;, // events that the contract can emit, collected recursively if submodules are used events = [ Created, Updated ], // the error enum the contract can revert with, collected recursively if submodules are used errors = MyErrors )] pub struct MyContract { name: Var&lt;String&gt;, owner: Var&lt;Address&gt;, } #[odra::module] impl MyContract { /// Initializes the contract, sets the name and owner and emits an event pub fn init(&amp;mut self, name: String, owner: Address) { self.name.set(name.clone()); self.owner.set(owner.clone()); self.env().emit_event(Created { name }); } /// Updates the name of the contract and emits an event pub fn update(&amp;mut self, name: String) { self.name.set(name.clone()); self.env().emit_event(Updated { name }); } /// Returns the data of the contract pub fn get_data(&amp;self) -&gt; Data { Data { name: self.name.get_or_default(), owner: self.owner.get_or_revert_with(MyErrors::InvalidOwner), } } } // The struct will we visible in the schema in the types section #[odra::odra_type] pub struct Data { name: String, owner: Address, } // The enum variants will we visible in the schema in the errors section #[odra::odra_error] pub enum MyErrors { /// The owner is invalid InvalidOwner, /// The name is invalid InvalidName, } // The struct will we visible in the schema in the types and events section #[odra::event] pub struct Updated { name: String, } // The struct will we visible in the schema in the types section and events section #[odra::event] pub struct Created { name: String, }  ","version":"2.3.1","tagName":"h2"},{"title":"Generating the Schema​","type":1,"pageTitle":"Casper Contract Schema","url":"/docs/basics/casper-contract-schema#generating-the-schema","content":"To generate the schema run the following cargo-odra command: cargo odra schema # or pass -c flag to generate the schema for a specific contract  ","version":"2.3.1","tagName":"h2"},{"title":"Schema Output​","type":1,"pageTitle":"Casper Contract Schema","url":"/docs/basics/casper-contract-schema#schema-output","content":"The generated schema will be available in the resources directory. The schema is a JSON file that contains all the information about the contract. Here is an example of the generated schema: resources/my_contract_schema.json { &quot;casper_contract_schema_version&quot;: 1, &quot;toolchain&quot;: &quot;rustc 1.77.0-nightly (5bd5d214e 2024-01-25)&quot;, &quot;authors&quot;: [], &quot;repository&quot;: null, &quot;homepage&quot;: null, &quot;contract_name&quot;: &quot;MyContract&quot;, &quot;contract_version&quot;: &quot;0.1.0&quot;, &quot;types&quot;: [ { &quot;struct&quot;: { &quot;name&quot;: &quot;Created&quot;, &quot;description&quot;: null, &quot;members&quot;: [ { &quot;name&quot;: &quot;name&quot;, &quot;description&quot;: null, &quot;ty&quot;: &quot;String&quot; } ] } }, { &quot;struct&quot;: { &quot;name&quot;: &quot;Data&quot;, &quot;description&quot;: null, &quot;members&quot;: [ { &quot;name&quot;: &quot;name&quot;, &quot;description&quot;: null, &quot;ty&quot;: &quot;String&quot; }, { &quot;name&quot;: &quot;owner&quot;, &quot;description&quot;: null, &quot;ty&quot;: &quot;Key&quot; } ] } }, { &quot;struct&quot;: { &quot;name&quot;: &quot;Updated&quot;, &quot;description&quot;: null, &quot;members&quot;: [ { &quot;name&quot;: &quot;name&quot;, &quot;description&quot;: null, &quot;ty&quot;: &quot;String&quot; } ] } } ], &quot;errors&quot;: [ { &quot;name&quot;: &quot;InvalidName&quot;, &quot;description&quot;: &quot;The name is invalid&quot;, &quot;discriminant&quot;: 1 }, { &quot;name&quot;: &quot;InvalidOwner&quot;, &quot;description&quot;: &quot;The owner is invalid&quot;, &quot;discriminant&quot;: 0 } ], &quot;entry_points&quot;: [ { &quot;name&quot;: &quot;update&quot;, &quot;description&quot;: &quot;Updates the name of the contract and emits an event&quot;, &quot;is_mutable&quot;: true, &quot;arguments&quot;: [ { &quot;name&quot;: &quot;name&quot;, &quot;description&quot;: null, &quot;ty&quot;: &quot;String&quot;, &quot;optional&quot;: false } ], &quot;return_ty&quot;: &quot;Unit&quot;, &quot;is_contract_context&quot;: true, &quot;access&quot;: &quot;public&quot; }, { &quot;name&quot;: &quot;get_data&quot;, &quot;description&quot;: &quot;Returns the data of the contract&quot;, &quot;is_mutable&quot;: false, &quot;arguments&quot;: [], &quot;return_ty&quot;: &quot;Data&quot;, &quot;is_contract_context&quot;: true, &quot;access&quot;: &quot;public&quot; } ], &quot;events&quot;: [ { &quot;name&quot;: &quot;Created&quot;, &quot;ty&quot;: &quot;Created&quot; }, { &quot;name&quot;: &quot;Updated&quot;, &quot;ty&quot;: &quot;Updated&quot; } ], &quot;call&quot;: { &quot;wasm_file_name&quot;: &quot;MyContract.wasm&quot;, &quot;description&quot;: &quot;Initializes the contract, sets the name and owner and emits an event&quot;, &quot;arguments&quot;: [ { &quot;name&quot;: &quot;odra_cfg_package_hash_key_name&quot;, &quot;description&quot;: &quot;The arg name for the package hash key name.&quot;, &quot;ty&quot;: &quot;String&quot;, &quot;optional&quot;: false }, { &quot;name&quot;: &quot;odra_cfg_allow_key_override&quot;, &quot;description&quot;: &quot;The arg name for the allow key override.&quot;, &quot;ty&quot;: &quot;Bool&quot;, &quot;optional&quot;: false }, { &quot;name&quot;: &quot;odra_cfg_is_upgradable&quot;, &quot;description&quot;: &quot;The arg name for the contract upgradeability setting.&quot;, &quot;ty&quot;: &quot;Bool&quot;, &quot;optional&quot;: false }, { &quot;name&quot;: &quot;name&quot;, &quot;description&quot;: null, &quot;ty&quot;: &quot;String&quot;, &quot;optional&quot;: false }, { &quot;name&quot;: &quot;owner&quot;, &quot;description&quot;: null, &quot;ty&quot;: &quot;Key&quot;, &quot;optional&quot;: false } ] } }  ","version":"2.3.1","tagName":"h2"},{"title":"Schema Fields​","type":1,"pageTitle":"Casper Contract Schema","url":"/docs/basics/casper-contract-schema#schema-fields","content":"casper_contract_schema_version is the version of the schema.toolchain is the version of the Rust compiler used to compile the contract.Fields authors, repository, and homepage are optional and can be set in the Cargo.toml file.contract_name is the name of the contract - by default is the module name, may be overriden by the module attribute.contract_version denotes the version of the contract, defaulting to the version specified in the Cargo.toml file, but can be overridden by the module attribute.types comprises a list of custom structs and enums defined within the contract. Each struct or enum includes a name, description (not currently supported, with the value set to null), and a list of members.errors is a list of error enums defined within the contract. Each error includes a name, description (the first line of the variant documentation), and a discriminant.entry_points is a list of contract functions that can be called from the outside. Each entry point includes a name, description (not currently supported, with the value set to null), whether the function is mutable, a list of arguments, the return type, whether the function is called in the contract context, and the access level.events is a list of events that the contract can emit. Each event includes a name and the type (earlier defined in types) of the event.The call section provides details regarding the contract's call function, which executes upon contract deployment. It includes the name of the Wasm file, a description (reflecting the constructor's description, typically the init function), and a list of arguments. These arguments are a combination of Odra configuration arguments and constructor arguments. ","version":"2.3.1","tagName":"h2"},{"title":"Events","type":0,"sectionRef":"#","url":"/docs/basics/events","content":"","keywords":"","version":"2.3.1"},{"title":"Testing events​","type":1,"pageTitle":"Events","url":"/docs/basics/events#testing-events","content":"Odra's HostEnv comes with a few functions which lets you easily test the events that a given contract has emitted: examples/src/features/events.rs use super::{PartyContract, PartyStarted}; use odra::host::{Deployer, HostEnv, NoArgs}; #[test] fn test_party() { let test_env: HostEnv = odra_test::env(); let party_contract = PartyContract::deploy(&amp;test_env, NoArgs); assert!(test_env.emitted_event( &amp;party_contract, PartyStarted { caller: test_env.get_account(0), block_time: 0 } )); assert!(test_env.emitted_native_event( &amp;party_contract, NativePartyStarted { caller: test_env.get_account(0), block_time: 0 } )); // If you do not want to check the exact event, you can use `emitted` function assert!(test_env.emitted(&amp;party_contract, &quot;PartyStarted&quot;)); // Or `emitted_native` for the native events assert!(test_env.emitted_native(&amp;party_contract, &quot;NativePartyStarted&quot;)); // You can also check how many events were emitted: assert_eq!(test_env.events_count(&amp;party_contract), 1); assert_eq!(test_env.native_events_count(&amp;party_contract), 1); }  To explore more event testing functions, check the HostEnv documentation. ","version":"2.3.1","tagName":"h2"},{"title":"What's next​","type":1,"pageTitle":"Events","url":"/docs/basics/events#whats-next","content":"Read the next article to learn how to call other contracts from the contract context. ","version":"2.3.1","tagName":"h2"},{"title":"Flipper Internals","type":0,"sectionRef":"#","url":"/docs/basics/flipper-internals","content":"","keywords":"","version":"2.3.1"},{"title":"Header​","type":1,"pageTitle":"Flipper Internals","url":"/docs/basics/flipper-internals#header","content":"flipper.rs use odra::prelude::*;  The first line of the file imports the odra crate. The prelude module contains all the necessary types and traits that you will need to write your contract. It is a good practice to import theodra::prelude::* module in every file that contains Odra code. This way, you will not have to import each type or trait separately. ","version":"2.3.1","tagName":"h2"},{"title":"Struct​","type":1,"pageTitle":"Flipper Internals","url":"/docs/basics/flipper-internals#struct","content":"flipper.rs /// A module definition. Each module struct consists of Vars and Mappings /// or/and other modules. #[odra::module] pub struct Flipper { /// The module itself does not store the value, /// it's a proxy that writes/reads value to/from the host. value: Var&lt;bool&gt;, }  In Odra, all contracts are also modules, which can be reused between contracts. That's why we need to mark the struct with the #[odra::module] attribute. In the struct definition itself, we state all the fields of the contract. Those fields can be regular Rust data types, however - those will not be persisted on the blockchain. They can also be Odra modules - defined in your project or coming from Odra itself. Finally, to make the data persistent on the blockchain, you can use something likeVar&lt;T&gt; showed above. To learn more about storage interaction, take a look at thenext article. ","version":"2.3.1","tagName":"h2"},{"title":"Impl​","type":1,"pageTitle":"Flipper Internals","url":"/docs/basics/flipper-internals#impl","content":"flipper.rs /// Module implementation. /// /// To generate entrypoints, /// an implementation block must be marked as #[odra::module]. #[odra::module] impl Flipper { /// Odra constructor. /// /// Initializes the contract with the value of value. pub fn init(&amp;mut self) { self.value.set(false); } ...  Similarly to the struct, we mark the impl section with the #[odra::module] attribute. Odra will take allpub functions from this section and create contract endpoints from them. So, if you wish to have functions that are not available for calling outside the contract, do not make them public. Alternatively, you can create a separate impl section without the attribute - all functions defined there, even marked with pub will be not callable. The function named init is the constructor of the contract. This function will be limited only to a single call, all further calls to it will result in an error. The init function is optional, if your contract does not need any initialization, you can skip it. flipper.rs ... /// Replaces the current value with the passed argument. pub fn set(&amp;mut self, value: bool) { self.value.set(value); } /// Replaces the current value with the opposite value. pub fn flip(&amp;mut self) { self.value.set(!self.get()); } ...  The endpoints above show you how to interact with the simplest type of storage - Var&lt;T&gt;. The data saved there using set function will be persisted in the blockchain. ","version":"2.3.1","tagName":"h2"},{"title":"Tests​","type":1,"pageTitle":"Flipper Internals","url":"/docs/basics/flipper-internals#tests","content":"flipper.rs #[cfg(test)] mod tests { use crate::flipper::Flipper; use odra::host::{Deployer, NoArgs}; #[test] fn flipping() { let env = odra_test::env(); // To test a module we need to deploy it. `Flipper` implements `Deployer` trait, // so we can use it to deploy the module. let mut contract = Flipper::deploy(&amp;env, NoArgs); assert!(!contract.get()); contract.flip(); assert!(contract.get()); } ...  You can write tests in any way you prefer and know in Rust. In the example above we are deploying the contract using Deployer::deploy function called on Flipper - a piece of code generated by the #[odra::module]. Because the module implements the constructor but does not accept any arguments, as the second argument of the deploy function, we pass NoArgs - one of the implementations of the InitArgs trait provided with the framework. The contract will be deployed on the VM you chose while running cargo odra test. ","version":"2.3.1","tagName":"h2"},{"title":"What's next​","type":1,"pageTitle":"Flipper Internals","url":"/docs/basics/flipper-internals#whats-next","content":"Now let's take a look at the different types of storage that Odra provides and how to use them. ","version":"2.3.1","tagName":"h2"},{"title":"Odra.toml","type":0,"sectionRef":"#","url":"/docs/basics/odra-toml","content":"","keywords":"","version":"2.3.1"},{"title":"Adding a new contract manually​","type":1,"pageTitle":"Odra.toml","url":"/docs/basics/odra-toml#adding-a-new-contract-manually","content":"Besides using the cargo odra generate command, you can add a new contract to be compiled by hand. To do this, add another [[contracts]] element, name it and make sure that the fqn is set correctly. For example, if you want to create a new contract called counter, your Odra.toml file should finally look like this: [[contracts]] fqn = &quot;sample::Flipper&quot; [[contracts]] fqn = &quot;sample::Counter&quot;  ","version":"2.3.1","tagName":"h2"},{"title":"What's next​","type":1,"pageTitle":"Odra.toml","url":"/docs/basics/odra-toml#whats-next","content":"In the next section, we'll take a closer look at the code that was generated by Odra by default - the famousFlipper contract. ","version":"2.3.1","tagName":"h2"},{"title":"Modules","type":0,"sectionRef":"#","url":"/docs/basics/modules","content":"","keywords":"","version":"2.3.1"},{"title":"Testing​","type":1,"pageTitle":"Modules","url":"/docs/basics/modules#testing","content":"As we don't need to hold addresses, the test is really simple: examples/src/features/modules.rs #[cfg(test)] mod tests { use super::ModulesContract; use odra::host::{Deployer, NoArgs}; #[test] fn test_modules() { let test_env = odra_test::env(); let modules_contract = ModulesContract::deploy(&amp;test_env, NoArgs); assert_eq!(modules_contract.add_using_module(), 8); } }  ","version":"2.3.1","tagName":"h2"},{"title":"What's next​","type":1,"pageTitle":"Modules","url":"/docs/basics/modules#whats-next","content":"We will see how to handle native token transfers. ","version":"2.3.1","tagName":"h2"},{"title":"Native token","type":0,"sectionRef":"#","url":"/docs/basics/native-token","content":"","keywords":"","version":"2.3.1"},{"title":"Testing​","type":1,"pageTitle":"Native token","url":"/docs/basics/native-token#testing","content":"To be able to test how many tokens a contract (or any address) has, HostEnv comes with a function -balance_of: examples/src/features/native_token.rs #[cfg(test)] mod tests { use super::PublicWallet; use odra::{casper_types::U512, host::{Deployer, HostRef, NoArgs}}; #[test] fn test_modules() { let test_env = odra_test::env(); let mut my_contract = PublicWallet::deploy(&amp;test_env, NoArgs); assert_eq!(test_env.balance_of(&amp;my_contract), U512::zero()); my_contract.with_tokens(U512::from(100)).deposit(); assert_eq!(test_env.balance_of(&amp;my_contract), U512::from(100)); my_contract.withdraw(U512::from(25)); assert_eq!(test_env.balance_of(&amp;my_contract), U512::from(75)); } }  ","version":"2.3.1","tagName":"h2"},{"title":"HostEnv​","type":1,"pageTitle":"Native token","url":"/docs/basics/native-token#hostenv","content":"In a broader context of the host environment (test, livenet), you can also transfer CSPR tokens between accounts: let env = odra_casper_livenet_env::env(); //let env = odra_test::env(); let (alice, bob) = (env.get_account(0), env.get_account(1)); env.set_caller(alice); let result = env.transfer_tokens(bob, odra::casper_types::U512::from(100));  ","version":"2.3.1","tagName":"h2"},{"title":"Odra for Solidity developers","type":0,"sectionRef":"#","url":"/docs/next/tutorials/odra-solidity","content":"","keywords":"","version":"next"},{"title":"Introduction​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/next/tutorials/odra-solidity#introduction","content":"Hi, stranger Solidity developer! If you are looking to expand your horizons into Rust-based smart contract development, you've come to the right place. Odra is a high-level framework designed to simplify the development of smart contracts for the Casper Network. This tutorial will guide you through the basics of transitioning from Solidity to Odra, highlighting key differences and providing practical examples. Before we delve into the details, we have great news for you. From the very beginning, we have been thinking of you. Our main goal was to design the framework in a way that flattens the learning curve, especially for Solidity developers. ","version":"next","tagName":"h2"},{"title":"Prerequisites​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/next/tutorials/odra-solidity#prerequisites","content":"To follow this guide, you should have: Knowledge of Solidity.Familiarity with Ethereum and smart contract concepts.Basic understanding of Rust, as Odra is based on it. ","version":"next","tagName":"h2"},{"title":"Hello World​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/next/tutorials/odra-solidity#hello-world","content":"Let's start with a simple &quot;Hello World&quot; contract in Odra. The following code snippet demonstrates a basic smart contract that stores a greeting message. OdraSolidity use odra::prelude::*; #[odra::module] pub struct HelloWorld { greet: Var&lt;String&gt;, } #[odra::module] impl HelloWorld { pub fn init(&amp;mut self, message: String) { self.greet.set(message); } pub fn get(&amp;self) -&gt; String { self.greet.get_or_default() } }  As you may have noticed, the Odra code is slightly more verbose than the Solidity code. To define a contract in Odra, you need to create a struct and implement a module for it, both annotated with the odra::module attribute. The struct contains the contract's state variables, while the module defines the contract's functions. In this example, the HelloWorld struct has a single state variable greet, which stores the greeting message. The module contains two functions: init to set the greeting message and get to retrieve it. Two key differences are: Odra does not generate getters for public state variables automatically, so you need to define them explicitly.To initialize values, you must do it in the init function, which is the contract constructor. You can't assign defaults outside the constructor. ","version":"next","tagName":"h2"},{"title":"Variable Storage and State Management​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/next/tutorials/odra-solidity#variable-storage-and-state-management","content":"","version":"next","tagName":"h2"},{"title":"Data Types​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/next/tutorials/odra-solidity#data-types","content":"OdraSolidity use core::str::FromStr; use odra::{casper_types::{bytesrepr::Bytes, U256}, prelude::*}; #[odra::module] pub struct Primitives { boo: Var&lt;bool&gt;, u: Var&lt;u8&gt;, // u8 is the smallest unsigned integer type u2: Var&lt;U256&gt;, // U256 is the biggest unsigned integer type i: Var&lt;i32&gt;, // i32 is the smallest signed integer type i2: Var&lt;i64&gt;, // i64 is the biggest signed integer type address: Var&lt;Address&gt;, bytes: Var&lt;Bytes&gt;, default_boo: Var&lt;bool&gt;, default_uint: Var&lt;U256&gt;, default_int: Var&lt;i64&gt;, default_addr: Var&lt;Address&gt;, } #[odra::module] impl Primitives { pub fn init(&amp;mut self) { self.boo.set(true); self.u.set(1); self.u2.set(U256::from(456)); self.i.set(-1); self.i2.set(456); self.address.set( Address::from_str( &quot;hash-d4b8fa492d55ac7a515c0c6043d72ba43c49cd120e7ba7eec8c0a330dedab3fb&quot;, ) .unwrap_or_revert(&amp;self.env()), ); self.bytes.set(Bytes::from(vec![0xb5])); let _min_int = U256::zero(); let _max_int = U256::MAX; } // For the types that have default values, we can use the get_or_default method pub fn get_default_boo(&amp;self) -&gt; bool { self.default_boo.get_or_default() } pub fn get_default_uint(&amp;self) -&gt; U256 { self.default_uint.get_or_default() } pub fn get_default_int(&amp;self) -&gt; i64 { self.default_int.get_or_default() } // Does not compile - Address does not have the default value pub fn get_default_addr(&amp;self) -&gt; Address { self.default_addr.get_or_default() } }  The range of integer types in Odra is slightly different from Solidity. Odra provides a wide range of integer types: u8, u16, u32, u64, U128, and U256 for unsigned integers, and i32 and i64 for signed integers. The Address type in Odra is used to represent account and contract addresses. In Odra, there is no default/zero value for the Address type; the workaround is to use Option&lt;Address&gt;. The Bytes type is used to store byte arrays. Values are stored in units called Named Keys and Dictionaries. Additionally, local variables are available within the entry points and can be used to perform necessary actions or computations within the scope of each entry point. ","version":"next","tagName":"h3"},{"title":"Constants and Immutability​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/next/tutorials/odra-solidity#constants-and-immutability","content":"OdraSolidity use odra::{casper_types::{account::AccountHash, U256}, prelude::*}; #[odra::module] pub struct Constants; #[odra::module] impl Constants { pub const MY_UINT: U256 = U256([123, 0, 0, 0]); pub const MY_ADDRESS: Address = Address::Account( AccountHash([0u8; 32]) ); }  In Odra, you can define constants using the const keyword. Constants are immutable and can be of any type, including custom types. In addition to constants, Solidity also supports the immutable keyword, which is used to set the value of a variable once, in the constructor. Further attempts to alter this value result in a compile error. Odra/Rust does not have an equivalent to Solidity's immutable keyword. ","version":"next","tagName":"h3"},{"title":"Variables​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/next/tutorials/odra-solidity#variables","content":"OdraSolidity use odra::{casper_types::U256, prelude::*}; #[odra::module] pub struct Variables { text: Var&lt;String&gt;, my_uint: Var&lt;U256&gt;, } #[odra::module] impl Variables { pub fn init(&amp;mut self) { self.text.set(&quot;Hello&quot;.to_string()); self.my_uint.set(U256::from(123)); } pub fn do_something(&amp;self) { // Local variables let i = 456; // Env variables let timestamp = self.env().get_block_time(); let sender = self.env().caller(); } }  In Solidity there are three types of variables: state variables, local variables, and global variables. State variables are stored on the blockchain and are accessible by all functions within the contract. Local variables are not stored on the blockchain and are only available within the function in which they are declared. Global variables provide information about the blockchain. Odra uses very similar concepts, but with some differences. In Odra, state variables are a part of a module definition, and local variables are available within the entry points and can be used to perform necessary actions or computations within the scope of each entry point. Global variables are accessed using an instance of ContractEnv retrieved using the env() function. ","version":"next","tagName":"h3"},{"title":"Arrays and Mappings​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/next/tutorials/odra-solidity#arrays-and-mappings","content":"OdraSolidity use odra::{casper_types::U256, prelude::*}; #[odra::module] pub struct MappingContract { my_map: Mapping&lt;Address, Option&lt;U256&gt;&gt; } #[odra::module] impl MappingContract { pub fn get(&amp;self, addr: Address) -&gt; U256 { // self.my_map.get(&amp;addr) would return Option&lt;Option&lt;U256&gt;&gt; // so we use get_or_default instead and unwrap the inner Option self.my_map.get_or_default(&amp;addr).unwrap_or_default() } pub fn set(&amp;mut self, addr: Address, i: U256) { self.my_map.set(&amp;addr, Some(i)); } pub fn remove(&amp;mut self, addr: Address) { self.my_map.set(&amp;addr, None); } } #[odra::module] pub struct NestedMapping { my_map: Mapping&lt;(Address, U256), Option&lt;bool&gt;&gt; } #[odra::module] impl NestedMapping { pub fn get(&amp;self, addr: Address, i: U256) -&gt; bool { self.my_map.get_or_default(&amp;(addr, i)).unwrap_or_default() } pub fn set(&amp;mut self, addr: Address, i: U256, boo: bool) { self.my_map.set(&amp;(addr, i), Some(boo)); } pub fn remove(&amp;mut self, addr: Address, i: U256) { self.my_map.set(&amp;(addr, i), None); } }  OdraSolidity use odra::prelude::*; #[odra::module] pub struct Array { // the size of the array must be known at compile time arr: Var&lt;[u8; 10]&gt;, vec: Var&lt;Vec&lt;u32&gt;&gt;, } #[odra::module] impl Array { pub fn init(&amp;mut self) { self.arr.set([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]); self.vec.set(vec![1, 2, 3, 4, 5]); } pub fn get_arr(&amp;self) -&gt; [u8; 10] { self.arr.get_or_default() } pub fn push_vec(&amp;mut self, value: u32) { let mut vec = self.vec.get_or_default(); vec.push(value); self.vec.set(vec); } pub fn pop_vec(&amp;mut self) { let mut vec = self.vec.get_or_default(); vec.pop(); self.vec.set(vec); } pub fn update_arr(&amp;mut self, index: u8, value: u8) { let mut arr = self.arr.get_or_default(); arr[index as usize] = value; self.arr.set(arr); } }  For storing a collection of data as a single unit, Odra uses the Vec type for dynamic arrays and fixed-size arrays, both wrapped with the Var container. As in Solidity, you must be aware that reading the entire array in one go can be expensive, so it's better to avoid it for large arrays. In many cases, you can use a Mapping or List instead of an array or vector to store data. ","version":"next","tagName":"h3"},{"title":"Custom types​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/next/tutorials/odra-solidity#custom-types","content":"OdraSolidity use odra::prelude::*; #[odra::odra_type] #[derive(Default)] pub enum Status { #[default] Pending, Shipped, Accepted, Rejected, Canceled, } #[odra::module] pub struct Enum { status: Var&lt;Status&gt;, } #[odra::module] impl Enum { pub fn get(&amp;self) -&gt; Status { self.status.get_or_default() } pub fn set(&amp;mut self, status: Status) { self.status.set(status); } pub fn cancel(&amp;mut self) { self.status.set(Status::Canceled); } pub fn reset(&amp;mut self) { self.status.set(Default::default()); } }  In Odra, custom types are defined using the #[odra::odra_type] attribute. The enum can have a default value specified using the #[default] attribute if derived from the Default trait. The enum can be used as a state variable in a contract, and its value can be set and retrieved using the set and get functions. The value cannot be deleted; however, it can be set using the Default::default() function. OdraSolidity use odra::prelude::*; #[odra::odra_type] pub struct Todo { text: String, completed: bool, } #[odra::module] pub struct Enum { // You could also use Var&lt;Vec&lt;Todo&gt;&gt; instead of List&lt;Todo&gt;, // but List is more efficient for large arrays, // it loads items lazily. todos: List&lt;Todo&gt;, } #[odra::module] impl Enum { pub fn create(&amp;mut self, text: String) { self.todos.push(Todo { text, completed: false, }); } pub fn update_text(&amp;mut self, index: u32, text: String) { if let Some(mut todo) = self.todos.get(index) { todo.text = text; self.todos.replace(index, todo); } } pub fn toggle_complete(&amp;mut self, index: u32) { if let Some(mut todo) = self.todos.get(index) { todo.completed = !todo.completed; self.todos.replace(index, todo); } } // Odra does not create getters by default pub fn get(&amp;self, index: u32) -&gt; Option&lt;Todo&gt; { self.todos.get(index) } }  Similarly to enums, custom structs are defined using the #[odra::odra_type] attribute. The struct can be used to define a list of items in a contract. The list can be created using the List type, which is more efficient for large arrays as it loads items lazily. ","version":"next","tagName":"h3"},{"title":"Data Location​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/next/tutorials/odra-solidity#data-location","content":"In Solidity, data location is an important concept that determines where the data is stored and how it can be accessed. The data location can be memory, storage, or calldata. In Odra, data location is not explicitly defined, but whenever interacting with storage primitives (e.g., Var, Mapping, List), the data is stored in the contract's storage. ","version":"next","tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/next/tutorials/odra-solidity#functions","content":"Odra contracts define their entry point and internal functions within the impl block. Here's an example of a transfer function: impl Erc20 { pub fn transfer(&amp;mut self, recipient: &amp;Address, amount: &amp;U256) { self.internal_transfer(&amp;self.env().caller(), recipient, amount); // Transfer logic goes here } fn internal_transfer(&amp;mut self, sender: &amp;Address, recipient: &amp;Address, amount: &amp;U256) { // Internal transfer logic goes here } }  Functions can modify contract state and emit events using the ContractEnv function. ","version":"next","tagName":"h2"},{"title":"View and Pure​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/next/tutorials/odra-solidity#view-and-pure","content":"OdraSolidity use odra::prelude::*; #[odra::module] pub struct ViewAndPure { x: Var&lt;u32&gt; } #[odra::module] impl ViewAndPure { pub fn add_to_x(&amp;self, y: u32) -&gt; u32 { self.x.get_or_default() + y } } pub fn add(i: u32, j: u32) -&gt; u32 { i + j }  In Odra, you don't need to specify view or pure functions explicitly. All functions are considered view functions by default, meaning they can read contract state but not modify it. To modify the state, the first parameter (called the receiver parameter) should be &amp;mut self. If you want to create a pure function that doesn't read or modify state, you can define it as a regular Rust function without any side effects. ","version":"next","tagName":"h3"},{"title":"Modifiers​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/next/tutorials/odra-solidity#modifiers","content":"OdraSolidity use odra::prelude::*; #[odra::module] pub struct FunctionModifier { x: Var&lt;u32&gt;, locked: Var&lt;bool&gt;, } #[odra::module] impl FunctionModifier { pub fn decrement(&amp;mut self, i: u32) { self.lock(); self.x.set(self.x.get_or_default() - i); if i &gt; 1 { self.decrement(i - 1); } self.unlock(); } #[inline] fn lock(&amp;mut self) { if self.locked.get_or_default() { self.env().revert(Error::NoReentrancy); } self.locked.set(true); } #[inline] fn unlock(&amp;mut self) { self.locked.set(false); } } #[odra::odra_error] pub enum Error { NoReentrancy = 1, }  In Odra, there is no direct equivalent to Solidity's function modifiers. Instead, you can define functions that perform certain actions before or after the main function logic. In the example above, the lock and unlock functions are called before and after the decrement function, respectively, but they must be called explicitly. As often as practicable, developers should inline functions by including the body of the function within their code using the #[inline] attribute. In the context of coding for Casper blockchain purposes, this reduces the overhead of executed Wasm and prevents unexpected errors due to exceeding resource tolerances. ","version":"next","tagName":"h3"},{"title":"Visibility​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/next/tutorials/odra-solidity#visibility","content":"Functions and state variables have to declare whether they are accessible by other contracts. Functions can be declared as: OdraSolidity `pub` inside `#[odra::module]` impl block - any contract/submodule and account can call. `pub` inside a regular impl block - any submodule can call. `default/no modifier/private` - only inside the contract that defines the function.  ","version":"next","tagName":"h3"},{"title":"Payable​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/next/tutorials/odra-solidity#payable","content":"OdraSolidity use odra::{casper_types::U512, prelude::*}; #[odra::module] pub struct Payable { owner: Var&lt;Address&gt;, } #[odra::module] impl Payable { pub fn init(&amp;mut self) { self.owner.set(self.env().caller()); } #[odra(payable)] pub fn deposit(&amp;self) { } pub fn not_payable(&amp;self) { } pub fn withdraw(&amp;self) { let amount = self.env().self_balance(); self.env().transfer_tokens(&amp;self.owner.get_or_revert_with(ExecutionError::UnwrapError), &amp;amount); } pub fn transfer(&amp;self, to: Address, amount: U512) { self.env().transfer_tokens(&amp;to, &amp;amount); } }  In Odra, you can define a function with the #[odra(payable)] attribute to indicate that the function can receive CSPRs. In Solidity, the payable keyword is used to define functions that can receive Ether. ","version":"next","tagName":"h3"},{"title":"Selectors​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/next/tutorials/odra-solidity#selectors","content":"In Solidity, when a function is called, the first 4 bytes of calldata specify which function to call. This is called a function selector. contract_addr.call( abi.encodeWithSignature(&quot;transfer(address,uint256)&quot;, address, 1234) )  Odra does not support such a mechanism. You must have access to the contract interface to call a function. ","version":"next","tagName":"h3"},{"title":"Events and Logging​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/next/tutorials/odra-solidity#events-and-logging","content":"OdraSolidity use odra::prelude::*; #[odra::event] pub struct Log { sender: Address, message: String, } #[odra::event] pub struct AnotherLog {} #[odra::module] struct Event; #[odra::module] impl Event { pub fn test(&amp;self) { let env = self.env(); env.emit_event(Log { sender: env.caller(), message: &quot;Hello World!&quot;.to_string(), }); env.emit_event(Log { sender: env.caller(), message: &quot;Hello Casper!&quot;.to_string(), }); env.emit_event(AnotherLog {}); } }  In Odra, events are regular structs defined using the #[odra::event] attribute. The event struct can contain multiple fields, which can be of any type (primitive or custom Odra type). To emit an event, use the env's emit_event() function, passing the event struct as an argument. note Events in Solidity are used to emit logs that off-chain services can capture. However, Casper does not support events natively. Odra mimics this feature. Read more about it in the Basics section. ","version":"next","tagName":"h2"},{"title":"Error Handling​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/next/tutorials/odra-solidity#error-handling","content":"OdraSolidity use odra::{prelude::*, casper_types::{U256, U512}}; #[odra::odra_error] pub enum CustomError { InsufficientBalance = 1, InputLowerThanTen = 2, } #[odra::module] pub struct Error; #[odra::module] impl Error { pub fn test_require(&amp;mut self, i: U256) { if i &lt;= 10.into() { self.env().revert(CustomError::InputLowerThanTen); } } pub fn execute_external_call(&amp;self, withdraw_amount: U512) { let balance = self.env().self_balance(); if balance &lt; withdraw_amount { self.env().revert(CustomError::InsufficientBalance); } } }  In Solidity, there are four ways to handle errors: require, revert, assert, and custom errors. In Odra, there is only one way to revert the execution of a function - by using the env().revert() function. The function takes an error type as an argument and stops the execution of the function. You define an error type using the #[odra::odra_error] attribute. On Casper, an error is only a number, so you can't pass a message with the error. ","version":"next","tagName":"h2"},{"title":"Composition vs. Inheritance​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/next/tutorials/odra-solidity#composition-vs-inheritance","content":"In Solidity, developers often use inheritance to reuse code and establish relationships between contracts. However, Odra and Rust follow a different paradigm known as composition. Instead of inheriting behavior from parent contracts, Odra encourages the composition of contracts by embedding one contract within another. Let's take a look at the difference between inheritance in Solidity and composition in Odra. OdraSolidity use odra::prelude::*; #[odra::module] pub struct A; #[odra::module] impl A { pub fn foo(&amp;self) -&gt; String { &quot;A&quot;.to_string() } } #[odra::module] pub struct B { a: SubModule&lt;A&gt; } #[odra::module] impl B { pub fn foo(&amp;self) -&gt; String { &quot;B&quot;.to_string() } } #[odra::module] pub struct C { a: SubModule&lt;A&gt; } #[odra::module] impl C { pub fn foo(&amp;self) -&gt; String { &quot;C&quot;.to_string() } } #[odra::module] pub struct D { b: SubModule&lt;B&gt;, c: SubModule&lt;C&gt; } #[odra::module] impl D { pub fn foo(&amp;self) -&gt; String { self.c.foo() } } #[odra::module] pub struct E { b: SubModule&lt;B&gt;, c: SubModule&lt;C&gt; } #[odra::module] impl E { pub fn foo(&amp;self) -&gt; String { self.b.foo() } } #[odra::module] pub struct F { a: SubModule&lt;A&gt;, b: SubModule&lt;B&gt;, } #[odra::module] impl F { pub fn foo(&amp;self) -&gt; String { self.a.foo() } }  Solidity supports both single and multiple inheritance. This means a contract can inherit from one or more contracts. Solidity uses a technique called &quot;C3 linearization&quot; to resolve the order in which base contracts are inherited in the case of multiple inheritance. This helps to ensure a consistent method resolution order. However, multiple inheritance can lead to complex code and potential issues, especially for inexperienced developers. In contrast, Rust does not have a direct equivalent to the inheritance model, but it achieves similar goals through composition. Each contract is defined as a struct, and contracts can be composed by embedding one struct within another. This approach provides a more flexible and modular way to reuse code and establish relationships between contracts. ","version":"next","tagName":"h2"},{"title":"Libraries and Utility​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/next/tutorials/odra-solidity#libraries-and-utility","content":"OdraSolidity use odra::{casper_types::U256, prelude::*}; mod math { use odra::casper_types::U256; pub fn sqrt(y: U256) -&gt; U256 { let mut z = y; if y &gt; 3.into() { let mut x = y / 2 + 1; while x &lt; z { z = x; x = (y / x + x) / 2; } } else if y != U256::zero() { z = U256::one(); } z } } #[odra::module] struct TestMath; #[odra::module] impl TestMath { pub fn test_square_root(&amp;self, x: U256) -&gt; U256 { math::sqrt(x) } } #[odra::odra_error] enum Error { EmptyArray = 100, } trait Removable { fn remove(&amp;mut self, index: usize); } impl Removable for Var&lt;Vec&lt;U256&gt;&gt; { fn remove(&amp;mut self, index: usize) { let env = self.env(); let mut vec = self.get_or_default(); if vec.is_empty() { env.revert(Error::EmptyArray); } vec[index] = vec.pop().unwrap_or_revert(&amp;env); self.set(vec); } } #[odra::module] struct TestArray { arr: Var&lt;Vec&lt;U256&gt;&gt;, } #[odra::module] impl TestArray { pub fn test_array_remove(&amp;mut self) { let mut arr = self.arr.get_or_default(); for i in 0..3 { arr.push(i.into()); } self.arr.set(arr); self.arr.remove(1); let arr = self.arr.get_or_default(); assert_eq!(arr.len(), 2); assert_eq!(arr[0], 0.into()); assert_eq!(arr[1], 2.into()); } }  In Solidity, libraries are similar to contracts but can't declare any state variables and can't receive Ether. In the sample code above, the Math library contains a square root function, while the Array library provides a function to remove an element from an array. Both libraries are consumed in different ways: the TestMath contract calls the sqrt function directly, while the TestArray contract uses the using keyword, which extends the type uint256[] by adding the remove function. In Odra, you use language-level features: modules and traits. The mod keyword defines a module, which is similar to a library in Solidity. Modules can contain functions, types, and other items that can be reused across multiple contracts. Traits are similar to interfaces in other programming languages, defining a set of functions that a type must implement. Implementing the Removable trait for the Var&lt;Vec&lt;U256&gt;&gt; type allows the remove function to be called on a variable that stores a vector of U256 values. ","version":"next","tagName":"h2"},{"title":"Fallback and Receive Functions​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/next/tutorials/odra-solidity#fallback-and-receive-functions","content":"In Solidity, a contract receiving Ether must implement a receive() and/or fallback() function. The receive() function is called when Ether is sent to the contract with no data, while the fallback() function is called when the contract receives Ether with data or when a function that does not exist is called. Odra does not have a direct equivalent to the receive() and fallback() functions. Instead, you can define a function with the #[odra(payable)] attribute to indicate that the function can receive CSPRs. ","version":"next","tagName":"h2"},{"title":"Miscellaneous​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/next/tutorials/odra-solidity#miscellaneous","content":"","version":"next","tagName":"h2"},{"title":"Hashing​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/next/tutorials/odra-solidity#hashing","content":"OdraSolidity use odra::{casper_types::{bytesrepr::ToBytes, U256}, prelude::*}; #[odra::module] pub struct HashFunction; #[odra::module] impl HashFunction { pub fn hash(&amp;self, text: String, num: U256, addr: Address) -&gt; [u8; 32] { let env = self.env(); let mut data = Vec::new(); data.extend(text.to_bytes().unwrap_or_revert(&amp;env)); data.extend(num.to_bytes().unwrap_or_revert(&amp;env)); data.extend(addr.to_bytes().unwrap_or_revert(&amp;env)); env.hash(data) } } #[odra::module] pub struct GuessTheMagicWord { answer: Var&lt;[u8; 32]&gt;, } #[odra::module] impl GuessTheMagicWord { /// Initializes the contract with the magic word hash. pub fn init(&amp;mut self) { self.answer.set([ 0x86, 0x67, 0x15, 0xbb, 0x0b, 0x96, 0xf1, 0x06, 0xe0, 0x68, 0x07, 0x89, 0x22, 0x84, 0x42, 0x81, 0x19, 0x6b, 0x1e, 0x61, 0x45, 0x50, 0xa5, 0x70, 0x4a, 0xb0, 0xa7, 0x55, 0xbe, 0xd7, 0x56, 0x08, ]); } /// Checks if the `word` is the magic word. pub fn guess(&amp;self, word: String) -&gt; bool { let env = self.env(); let hash = env.hash(word.to_bytes().unwrap_or_revert(&amp;env)); hash == self.answer.get_or_default() } }  The key difference between the two is that in Solidity, the keccak256 function is used to hash data, while in Odra, the env.hash() function is used, which implements the blake2b algorithm. Both functions take a byte array as input and return a 32-byte hash. ","version":"next","tagName":"h3"},{"title":"Try-catch​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/next/tutorials/odra-solidity#try-catch","content":"OdraSolidity use odra::prelude::*; #[odra::module] pub struct Example { other_contract: External&lt;OtherContractContractRef&gt;, } #[odra::module] impl Example { pub fn init(&amp;mut self, other_contract: Address) { self.other_contract.set(other_contract); } pub fn execute_external_call(&amp;self) { let result = self.other_contract.some_function(); match result { Ok(success) =&gt; { // Code to execute if the external call was successful } Err(reason) =&gt; { // Code to execute if the external call failed } } } } #[odra::module] pub struct OtherContract; #[odra::module] impl OtherContract { pub fn some_function(&amp;self) -&gt; Result&lt;bool, ()&gt; { Ok(true) } }  In Solidity, try/catch is a feature that allows developers to handle exceptions and errors more gracefully. The try/catch statement allows developers to catch and handle exceptions that occur during external function calls and contract creation. In Odra, there is no direct equivalent to the try/catch statement in Solidity. However, you can use the Result type to handle errors in a similar way. The Result type is an enum that represents either success (Ok) or failure (Err). You can use the match statement to handle the Result type and execute different code based on the result. However, if an unexpected error occurs on the way, the whole transaction reverts. ","version":"next","tagName":"h3"},{"title":"Conclusion​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/next/tutorials/odra-solidity#conclusion","content":"Congratulations! You've now learned the main differences in writing smart contracts with the Odra Framework. By understanding the structure, initialization, error handling, and the composition pattern in Odra, you can effectively transition from Solidity to Odra for Casper blockchain development. Experiment with the provided code samples, explore more advanced features, and unleash the full potential of the Odra Framework. Read more about the Odra Framework in the Basics and Advanced sections. Learn by example with our Tutorial series, you will find there a contract you likely familiar with - the Erc20 standard implementation. If you have any further questions or need clarification on specific topics, feel free to join our Discord! ","version":"next","tagName":"h2"},{"title":"Testing","type":0,"sectionRef":"#","url":"/docs/basics/testing","content":"","keywords":"","version":"2.3.1"},{"title":"HostEnv​","type":1,"pageTitle":"Testing","url":"/docs/basics/testing#hostenv","content":"Odra gives us some additional functions that we can use to communicate with the host (outside the contract context) and to configure how the contracts are deployed and called. Let's revisit the example from the previous article about host communication and implement the tests that prove it works: examples/src/features/testing.rs #[cfg(test)] mod tests { use crate::features::testing::{TestingContract, TestingContractInitArgs}; use odra::{host::{Deployer, HostEnv}, prelude::*}; #[test] fn env() { let test_env: HostEnv = odra_test::env(); test_env.set_caller(test_env.get_account(0)); let init_args = TestingContractInitArgs { name: &quot;MyContract&quot;.to_string() }; let testing_contract = TestingContract::deploy(&amp;test_env, init_args); let creator = testing_contract.created_by(); test_env.set_caller(test_env.get_account(1)); let init_args = TestingContractInitArgs { name: &quot;MyContract2&quot;.to_string() }; let testing_contract2 = TestingContract::deploy(&amp;test_env, init_args); let creator2 = testing_contract2.created_by(); assert_ne!(creator, creator2); } }  In the code above, at the beginning of the test, we are obtaining a HostEnv instance using odra_test::env(). Next, we are deploying two instances of the same contract, but we're using HostEnv::set_callerto change the caller - so the Address which is deploying the contract. This changes the result of the odra::ContractEnv::caller()the function we are calling inside the contract. HostEnv comes with a set of functions that will let you write better tests: fn set_caller(&amp;self, address: Address) - you've seen it in action just nowfn balance_of&lt;T: Addressable&gt;(&amp;self, addr: &amp;T) -&gt; U512 - returns the balance of the account associated with the given addressfn advance_block_time(&amp;self, time_diff: u64) - increases the current value of block_timefn get_account(&amp;self, n: usize) -&gt; Address - returns an n-th address that was prepared for you by Odra in advance; by default, you start with the 0-th accountfn emitted_event&lt;T: ToBytes + EventInstance, R: Addressable&gt;(&amp;self, contract_address: &amp;R, event: T) -&gt; bool - verifies if the event was emitted by the contract Full list of functions can be found in the HostEnv documentation. ","version":"2.3.1","tagName":"h2"},{"title":"What's next​","type":1,"pageTitle":"Testing","url":"/docs/basics/testing#whats-next","content":"We take a look at how Odra handles errors! ","version":"2.3.1","tagName":"h2"},{"title":"Storage interaction","type":0,"sectionRef":"#","url":"/docs/basics/storage-interaction","content":"","keywords":"","version":"2.3.1"},{"title":"Var​","type":1,"pageTitle":"Storage interaction","url":"/docs/basics/storage-interaction#var","content":"The Var is the simplest storage type available in the Odra framework. It serializes the data and stores it under a single key in the blockchain storage. To use it, just wrap your variable in the Var type. Let's look at a &quot;real world&quot; example of a contract that represents a dog: examples/src/features/storage/variable.rs use odra::prelude::*; #[odra::module] pub struct DogContract { barks: Var&lt;bool&gt;, weight: Var&lt;u32&gt;, name: Var&lt;String&gt;, walks: Var&lt;Vec&lt;u32&gt;&gt;, }  You can see the Var wrapping the data. Even complex types like Vec can be wrapped (with some caveats)! Let's make this contract usable, by providing a constructor and some getter functions: examples/src/features/storage/variable.rs #[odra::module] impl DogContract { pub fn init(&amp;mut self, barks: bool, weight: u32, name: String) { self.barks.set(barks); self.weight.set(weight); self.name.set(name); self.walks.set(Vec::&lt;u32&gt;::default()); } pub fn barks(&amp;self) -&gt; bool { self.barks.get_or_default() } pub fn weight(&amp;self) -&gt; u32 { self.weight.get_or_default() } pub fn name(&amp;self) -&gt; String { self.name.get_or_default() } pub fn walks_amount(&amp;self) -&gt; u32 { let walks = self.walks.get_or_default(); walks.len() as u32 } pub fn walks_total_length(&amp;self) -&gt; u32 { let walks = self.walks.get_or_default(); walks.iter().sum() } }  As you can see, you can access the data, by using get_or_default function: examples/src/features/storage/variable.rs ... self.barks.get_or_default() ...  note Keep in mind that using get() will result in an Option that you'll need to unwrap - the variable doesn't have to be initialized! To modify the data, use the set() function: examples/src/features/storage/variable.rs self.barks.set(barks);  A Var is easy to use and efficient for simple data types. One of its downsides is that it serializes the data as a whole, so when you're using complex types like Vec or HashMap, each time you get or set the whole data is read and written to the blockchain storage. In the example above, if we want to see how many walks our dog had, we would use the function: examples/src/features/storage/variable.rs pub fn walks_amount(&amp;self) -&gt; usize { let walks = self.walks.get_or_default(); walks.len() }  But to do so, we need to extract the whole serialized vector from the storage, which would inefficient, especially for larger sets of data. To tackle this issue following two types were created. ","version":"2.3.1","tagName":"h2"},{"title":"Mapping​","type":1,"pageTitle":"Storage interaction","url":"/docs/basics/storage-interaction#mapping","content":"The Mapping is used to store and access data as key-value pairs. To define a Mapping, you need to pass two values - the key type and the value type. Let's look at the variation of the Dog contract, that uses Mapping to store information about our dog's friends and how many times they visited: examples/src/features/storage/mapping.rs use odra::prelude::*; #[odra::module] pub struct DogContract2 { name: Var&lt;String&gt;, friends: Mapping&lt;String, u32&gt;, }  In the example above, our key is a String (it is a name of the friend) and we are storing u32 values (amount of visits). To read and write values from and into a Mapping we use a similar approach to the one shown in the Vars section with one difference - we need to pass a key: examples/src/features/storage/mapping.rs pub fn visit(&amp;mut self, friend_name: String) { let visits = self.visits(friend_name.clone()); self.friends.set(&amp;friend_name, visits + 1); } pub fn visits(&amp;self, friend_name: String) -&gt; u32 { self.friends.get_or_default(&amp;friend_name) }  The biggest improvement over a Var is that we can model functionality of a HashMap using Mapping. The amount of data written to and read from the storage is minimal. However, we cannot iterate over Mapping. We could implement such behavior by using a numeric type key and saving the length of the set in a separate variable. Thankfully Odra comes with a prepared solution - the List type. note If you take a look into List implementation in Odra, you'll see that in fact it is just a Mapping with a Var working together: core/src/list.rs use odra::prelude::*; pub struct List&lt;T&gt; { values: Mapping&lt;u32, T&gt;, index: Var&lt;u32&gt; }  ","version":"2.3.1","tagName":"h2"},{"title":"List​","type":1,"pageTitle":"Storage interaction","url":"/docs/basics/storage-interaction#list","content":"Going back to our DogContract example - let's revisit the walk case. This time, instead of Vec, we'll use the list: examples/src/features/storage/list.rs use odra::prelude::*; #[odra::module] pub struct DogContract3 { name: Var&lt;String&gt;, walks: List&lt;u32&gt;, }  As you can see, the notation is very similar to the Vec. To understand the usage, take a look at the reimplementation of the functions with an additional function that takes our dog for a walk (it writes the data to the storage): examples/src/features/storage/list.rs #[odra::module] impl DogContract3 { pub fn init(&amp;mut self, name: String) { self.name.set(name); } pub fn name(&amp;self) -&gt; String { self.name.get_or_default() } pub fn walks_amount(&amp;self) -&gt; u32 { self.walks.len() } pub fn walks_total_length(&amp;self) -&gt; u32 { self.walks.iter().sum() } pub fn walk_the_dog(&amp;mut self, length: u32) { self.walks.push(length); } }  Now, we can know how many walks our dog had without loading the whole vector from the storage. We need to do this to sum the length of all the walks, but the Odra framework cannot (yet) handle all the cases for you. info All of the above examples, alongside the tests, are available in the Odra repository in the examples/src/features/ folder. ","version":"2.3.1","tagName":"h2"},{"title":"Custom Types​","type":1,"pageTitle":"Storage interaction","url":"/docs/basics/storage-interaction#custom-types","content":"By default you can store only built-in types like numbers, Options, Results, Strings, Vectors. Implementing custom types is straightforward, your type must add #[odra::odra_type] attribute. Let's see how to implement a Dog type: use odra::prelude::*; #[odra::odra_type] pub struct Dog { pub name: String, pub age: u8, pub owner: Option&lt;Address&gt; }  #[odra_type] is applicable to named field structs and enums. It generates serialization, deserialization and schema code for your type.CLType of a custom type is CLType::Any, except for an unit-only enum, which is CLType::U8. unit_only_enum.rs enum Enum { Foo = 3, Bar = 2, Baz = 1, }  note Each custom typed field of your struct must be marked with the #[odra::odra_type] attribute . ","version":"2.3.1","tagName":"h2"},{"title":"What's next​","type":1,"pageTitle":"Storage interaction","url":"/docs/basics/storage-interaction#whats-next","content":"In the next article, we'll see how to query the host for information about the world and our contract. ","version":"2.3.1","tagName":"h2"},{"title":"odra-examples","type":0,"sectionRef":"#","url":"/docs/examples/odra-examples","content":"","keywords":"","version":"2.3.1"},{"title":"What's next​","type":1,"pageTitle":"odra-examples","url":"/docs/examples/odra-examples#whats-next","content":"Read the next article to learn about reusable Odra components encapsulated in odra-modules. ","version":"2.3.1","tagName":"h2"},{"title":"Installation","type":0,"sectionRef":"#","url":"/docs/getting-started/installation","content":"","keywords":"","version":"2.3.1"},{"title":"Prerequisites​","type":1,"pageTitle":"Installation","url":"/docs/getting-started/installation#prerequisites","content":"To start working with Odra, you need to have the following installed on your machine: Rust toolchain installed (see rustup.rs)wasmstrip tool installed (see wabt)wasm-opt tool installed (see binaryen) We do not provide exact commands for installing these tools, as they are different for different operating systems. Please refer to the documentation of the tools themselves. With Rust toolchain ready, you can add a new target: rustup target add wasm32-unknown-unknown  note wasm32-unknown-unknown is a target that will be used by Odra to compile your smart contracts to WASM files. ","version":"2.3.1","tagName":"h2"},{"title":"Installing Cargo Odra​","type":1,"pageTitle":"Installation","url":"/docs/getting-started/installation#installing-cargo-odra","content":"Cargo Odra is a helpful tool that will help you to build and test your smart contracts. It is not required to use Odra, but the documentation will assume that you have it installed. To install it, simply execute the following command: cargo install cargo-odra --locked  To check if it was installed correctly and see available commands, type: cargo odra --help  If everything went fine, we can proceed to the next step. ","version":"2.3.1","tagName":"h2"},{"title":"Creating a new Odra project​","type":1,"pageTitle":"Installation","url":"/docs/getting-started/installation#creating-a-new-odra-project","content":"To create a new project, simply execute: cargo odra new --name my-project &amp;&amp; cd my_project  This will create a new folder called my_project and initialize Odra there. Cargo Odra will create a sample contract for you in src directory. You can run the tests of this contract by executing: cargo odra test  This will run tests using Odra's internal OdraVM. You can run those tests against a real backend, let's use CasperVM: cargo odra test -b casper  Congratulations! Now you are ready to create contracts using Odra framework! If you had any problems during the installation process, feel free to ask for help on our Discord. ","version":"2.3.1","tagName":"h2"},{"title":"What's next?​","type":1,"pageTitle":"Installation","url":"/docs/getting-started/installation#whats-next","content":"If you want to see the code that you just tested, continue to the description of Flipper example. ","version":"2.3.1","tagName":"h2"},{"title":"Flipper example","type":0,"sectionRef":"#","url":"/docs/getting-started/flipper","content":"","keywords":"","version":"2.3.1"},{"title":"Let's flip​","type":1,"pageTitle":"Flipper example","url":"/docs/getting-started/flipper#lets-flip","content":"flipper.rs use odra::prelude::*; /// A module definition. Each module struct consists Vars and Mappings /// or/and another modules. #[odra::module] pub struct Flipper { /// The module itself does not store the value, /// it's a proxy that writes/reads value to/from the host. value: Var&lt;bool&gt;, } /// Module implementation. /// /// To generate entrypoints, /// an implementation block must be marked as #[odra::module]. #[odra::module] impl Flipper { /// Odra constructor. /// /// Initializes the contract. pub fn init(&amp;mut self) { self.value.set(false); } /// Replaces the current value with the passed argument. pub fn set(&amp;mut self, value: bool) { self.value.set(value); } /// Replaces the current value with the opposite value. pub fn flip(&amp;mut self) { self.value.set(!self.get()); } /// Retrieves value from the storage. /// If the value has never been set, the default value is returned. pub fn get(&amp;self) -&gt; bool { self.value.get_or_default() } } #[cfg(test)] mod tests { use crate::flipper::Flipper; use odra::host::{Deployer, NoArgs}; #[test] fn flipping() { let env = odra_test::env(); // To test a module we need to deploy it. `Flipper` implements `Deployer` trait, // so we can use it to deploy the module. let mut contract = Flipper::deploy(&amp;env, NoArgs); assert!(!contract.get()); contract.flip(); assert!(contract.get()); } }  ","version":"2.3.1","tagName":"h2"},{"title":"Testing​","type":1,"pageTitle":"Flipper example","url":"/docs/getting-started/flipper#testing","content":"To run the tests, execute the following command: cargo odra test # or add the `-b casper` flag to run tests on the CasperVM  ","version":"2.3.1","tagName":"h2"},{"title":"What's next​","type":1,"pageTitle":"Flipper example","url":"/docs/getting-started/flipper#whats-next","content":"In the next category of articles, we will go through basic concepts of Odra. ","version":"2.3.1","tagName":"h2"},{"title":"Using odra-modules","type":0,"sectionRef":"#","url":"/docs/examples/using-odra-modules","content":"","keywords":"","version":"2.3.1"},{"title":"Available modules​","type":1,"pageTitle":"Using odra-modules","url":"/docs/examples/using-odra-modules#available-modules","content":"Odra modules comes with couple of ready-to-use modules and reusable extensions. ","version":"2.3.1","tagName":"h2"},{"title":"Tokens​","type":1,"pageTitle":"Using odra-modules","url":"/docs/examples/using-odra-modules#tokens","content":"CEP-18​ Casper Ecosystem Proposal 18 (CEP-18) is a standard interface for the CSPR and the custom made tokens. Inspired by the ERC20 standard. Read more about the CEP-18 here. CEP-95​ Casper Ecosystem Proposal 95 (CEP-95) is a Casper NFT Standard. It aims to replace CEP-47 and CEP-78, which have flaws that complicate their support in the ecosystem. This standard is aligned with Ethereum's ERC-721, but makes adjustments relevant for the Casper Ecosystem. Similarly to ERC-721, this standard can be used to represent a various range of tokenized assets Read more about the CEP-95 here. Erc20​ The Erc20 module implements the ERC20 standard. Erc721​ The Erc721Base module implements the ERC721 standard, adjusted for the Odra framework. The Erc721Token module implements the ERC721Base and additionally uses the Erc721Metadata and Ownable extensions. The Erc721Receiver trait lets you implement your own logic for receiving NFTs. The OwnedErc721WithMetadata trait is a combination of Erc721Token, Erc721Metadata and Ownable modules. Erc1155​ The Erc1155Base module implements the ERC1155 standard, adjusted for the Odra framework. The Erc1155Token module implements the ERC1155Base and additionally uses the Ownable extension. The OwnedErc1155 trait is a combination of Erc1155Token and Ownable modules. Wrapped native token​ The WrappedNativeToken module implements the Wrapper for the native token, it was inspired by the WETH. ","version":"2.3.1","tagName":"h3"},{"title":"Access​","type":1,"pageTitle":"Using odra-modules","url":"/docs/examples/using-odra-modules#access","content":"AccessControl​ This module enables the implementation of role-based access control mechanisms for children modules. Roles are identified by their 32-bytes identifier, which should be unique and exposed in the external API. Ownable​ This module provides a straightforward access control feature that enables exclusive access to particular functions by an account, known as the owner. The account that initiates the module is automatically assigned as the owner. However, ownership can be transferred later by using thetransfer_ownership() function. Ownable2Step​ An extension of the Ownable module. Ownership can be transferred in a two-step process by using transfer_ownership() and accept_ownership() functions. ","version":"2.3.1","tagName":"h3"},{"title":"Security​","type":1,"pageTitle":"Using odra-modules","url":"/docs/examples/using-odra-modules#security","content":"Pausable​ A module allowing to implement an emergency stop mechanism that can be triggered by any account. ","version":"2.3.1","tagName":"h3"},{"title":"Migration guide to v1.3.0","type":0,"sectionRef":"#","url":"/docs/migrations/to-1.3.0","content":"","keywords":"","version":"2.3.1"},{"title":"Migrating to Odra v1.3.0​","type":1,"pageTitle":"Migration guide to v1.3.0","url":"/docs/migrations/to-1.3.0#migrating-to-odra-v130","content":"To migrate your smart contracts to Odra v1.3.0, remove the use the deploy method from the module instead of the {{ModuleName}}HostRef struct: before.rs let token = TokenHostRef::deploy(env, init_args); let another_token = AnotherTokenHostRef::load(env, address);  after.rs let token = Token::deploy(env, init_args); let another_token = AnotherToken::load(env, address);  ","version":"2.3.1","tagName":"h2"},{"title":"Migration guide to v2.0.0 from 1.*","type":0,"sectionRef":"#","url":"/docs/migrations/to-2.0.0","content":"","keywords":"","version":"2.3.1"},{"title":"Updating rustc version​","type":1,"pageTitle":"Migration guide to v2.0.0 from 1.*","url":"/docs/migrations/to-2.0.0#updating-rustc-version","content":"Update rust-toolchain file in your project: nightly-2024-07-31  ","version":"2.3.1","tagName":"h2"},{"title":"Migration guide to v2.1.0 from 2.0.*","type":0,"sectionRef":"#","url":"/docs/migrations/to-2.1.0","content":"","keywords":"","version":"2.3.1"},{"title":"Updating the test code​","type":1,"pageTitle":"Migration guide to v2.1.0 from 2.0.*","url":"/docs/migrations/to-2.1.0#updating-the-test-code","content":"Function that required an event reference as an argument has been changed to accept an event type instead. before.rs assert!(test_env.emitted_event( &amp;party_contract, &amp;PartyStarted { caller: test_env.get_account(0), block_time: 0 } ));  after.rs assert!(test_env.emitted_event( &amp;party_contract, PartyStarted { caller: test_env.get_account(0), block_time: 0 } ));  In the previous version, the HostRef and Addressable traits both included a function called address, which may have caused confusion and led to exporting the address function from the wrong trait. In the updated version, address is now defined only in the Addressable trait, while the HostRef trait provides a separate function called contract_address instead. ","version":"2.3.1","tagName":"h2"},{"title":"Access Control","type":0,"sectionRef":"#","url":"/docs/tutorials/access-control","content":"","keywords":"","version":"2.3.1"},{"title":"Code​","type":1,"pageTitle":"Access Control","url":"/docs/tutorials/access-control#code","content":"Before we start writing code, we list the functionalities of our access control layer. A Role type is used across the module.A Role can be assigned to many Addresses.Each Role may have a corresponding admin role.Only an admin can grant/revoke a Role.A Role can be renounced.A Role cannot be renounced on someone's behalf.Each action triggers an event.Unauthorized access stops contract execution. ","version":"2.3.1","tagName":"h2"},{"title":"Project Structure​","type":1,"pageTitle":"Access Control","url":"/docs/tutorials/access-control#project-structure","content":"access-control ├── src │ ├── access │ │ ├── access_control.rs │ │ ├── events.rs │ │ └── errors.rs │ └── lib.rs |── build.rs |── Cargo.toml └── Odra.toml  ","version":"2.3.1","tagName":"h3"},{"title":"Events and Errors​","type":1,"pageTitle":"Access Control","url":"/docs/tutorials/access-control#events-and-errors","content":"There are three actions that can be performed concerning a Role: granting, revoking, and altering the admin role. Let us establish standard Odra events for each of these actions. events.rs use odra::prelude::*; use super::access_control::Role; #[odra::event] pub struct RoleGranted { pub role: Role, pub address: Address, pub sender: Address } #[odra::event] pub struct RoleRevoked { pub role: Role, pub address: Address, pub sender: Address } #[odra::event] pub struct RoleAdminChanged { pub role: Role, pub previous_admin_role: Role, pub new_admin_role: Role }  L4-L16 - to describe the grant or revoke actions, our events specify the Role, and Addresses indicating who receives or loses access and who provides or withdraws it.L18-L23 - the event describing the admin role change, requires the subject Role, the previous and the current admin Role. errors.rs #[odra::odra_error] pub enum Error { MissingRole = 20_000, RoleRenounceForAnotherAddress = 20_001, }  Errors definition is straightforward - there are only two invalid states: An action is triggered by an unauthorized actor.The caller is attempting to resign the Role on someone's behalf.  ","version":"2.3.1","tagName":"h3"},{"title":"Module​","type":1,"pageTitle":"Access Control","url":"/docs/tutorials/access-control#module","content":"Now, we are stepping into the most interesting part: the module definition and implementation. access_control.rs use super::events::*; use super::errors::Error; use odra::prelude::*; pub type Role = [u8; 32]; pub const DEFAULT_ADMIN_ROLE: Role = [0u8; 32]; #[odra::module(events = [RoleAdminChanged, RoleGranted, RoleRevoked], errors = Error)] pub struct AccessControl { roles: Mapping&lt;(Role, Address), bool&gt;, role_admin: Mapping&lt;Role, Role&gt; } #[odra::module] impl AccessControl { pub fn has_role(&amp;self, role: &amp;Role, address: &amp;Address) -&gt; bool { self.roles.get_or_default(&amp;(*role, *address)) } pub fn get_role_admin(&amp;self, role: &amp;Role) -&gt; Role { let admin_role = self.role_admin.get(role); if let Some(admin) = admin_role { admin } else { DEFAULT_ADMIN_ROLE } } pub fn grant_role(&amp;mut self, role: &amp;Role, address: &amp;Address) { self.check_role(&amp;self.get_role_admin(role), &amp;self.env().caller()); self.unchecked_grant_role(role, address); } pub fn revoke_role(&amp;mut self, role: &amp;Role, address: &amp;Address) { self.check_role(&amp;self.get_role_admin(role), &amp;self.env().caller()); self.unchecked_revoke_role(role, address); } pub fn renounce_role(&amp;mut self, role: &amp;Role, address: &amp;Address) { if address != &amp;self.env().caller() { self.env().revert(Error::RoleRenounceForAnotherAddress); } self.unchecked_revoke_role(role, address); } } impl AccessControl { pub fn check_role(&amp;self, role: &amp;Role, address: &amp;Address) { if !self.has_role(role, address) { self.env().revert(Error::MissingRole); } } pub fn set_admin_role(&amp;mut self, role: &amp;Role, admin_role: &amp;Role) { let previous_admin_role = self.get_role_admin(role); self.role_admin.set(role, *admin_role); self.env().emit_event(RoleAdminChanged { role: *role, previous_admin_role, new_admin_role: *admin_role }); } pub fn unchecked_grant_role(&amp;mut self, role: &amp;Role, address: &amp;Address) { if !self.has_role(role, address) { self.roles.set(&amp;(*role, *address), true); self.env().emit_event(RoleGranted { role: *role, address: *address, sender: self.env().caller() }); } } pub fn unchecked_revoke_role(&amp;mut self, role: &amp;Role, address: &amp;Address) { if self.has_role(role, address) { self.roles.set(&amp;(*role, *address), false); self.env().emit_event(RoleRevoked { role: *role, address: *address, sender: self.env().caller() }); } } }  L5 - Firstly, we need the Role type. It is simply an alias for a 32-byte array.L7 - The default role is an array filled with zeros.L10-L13 - The storage consists of two mappings: roles - a nested mapping that stores information about whether a certain Role is granted to a given Address.role_admin - each Role can have a single admin Role. L17-L19 - This is a simple check to determine if a Role has been granted to a given Address. It is an exposed entry point and an important building block widely used throughout the entire module.L48 - This is a non-exported block containing helper functions.L49-L53 - The check_role() function serves as a guard function. Before a Role is granted or revoked, we must ensure that the caller is allowed to do so. For this purpose, the function reads the roles mapping. If the role has not been granted to the address, the contract reverts with Error::MissingRole.L55-L63 - The set_admin_role() function simply updates the role_admin mapping and emits the RoleAdminChanged event.L65-L85 - The unchecked_grant_role() and unchecked_revoke_role() functions are mirror functions that update the roles mapping and post RoleGranted or RoleRevoked events. If the role is already granted, unchecked_grant_role() has no effect (the opposite check is made in the case of revoking a role).L21-L28 - The get_role_admin() entry point reads the role_admin. If there is no admin role for a given role, it returns the default role.L30-L45 - This is a combination of check_role() and unchecked_*_role(). Entry points fail on unauthorized access. ","version":"2.3.1","tagName":"h3"},{"title":"Migration guide to v0.9.0","type":0,"sectionRef":"#","url":"/docs/migrations/to-0.9.0","content":"","keywords":"","version":"2.3.1"},{"title":"1. Prerequisites​","type":1,"pageTitle":"Migration guide to v0.9.0","url":"/docs/migrations/to-0.9.0#1-prerequisites","content":"","version":"2.3.1","tagName":"h2"},{"title":"1.1. Update cargo-odra​","type":1,"pageTitle":"Migration guide to v0.9.0","url":"/docs/migrations/to-0.9.0#11-update-cargo-odra","content":"Before you begin the migration process, make sure you installed the latest version of the Cargo Odra toolchain. You can install it by running the following command: cargo install cargo-odra --force --locked  ","version":"2.3.1","tagName":"h3"},{"title":"1.2. Review the Changelog​","type":1,"pageTitle":"Migration guide to v0.9.0","url":"/docs/migrations/to-0.9.0#12-review-the-changelog","content":"Before you move to changing your code, start by reviewing the Changelog to understand the changes introduced in v0.9.0. ","version":"2.3.1","tagName":"h3"},{"title":"2. Migration Steps​","type":1,"pageTitle":"Migration guide to v0.9.0","url":"/docs/migrations/to-0.9.0#2-migration-steps","content":"","version":"2.3.1","tagName":"h2"},{"title":"2.1 Update build_schema.rs bin​","type":1,"pageTitle":"Migration guide to v0.9.0","url":"/docs/migrations/to-0.9.0#21-update-build_schemars-bin","content":"Odra 0.9.0 adds a new standardized way of generating contract schema - Casper Contract Schema. You can find the updated build_schema.rs file in templates directory in the Odra main repository. You can choose whatever template you want to use and copy the files to your project. In both files, you should replace {{project-name}} with the name of your project. ","version":"2.3.1","tagName":"h3"},{"title":"2.2 Update smart contract code​","type":1,"pageTitle":"Migration guide to v0.9.0","url":"/docs/migrations/to-0.9.0#22-update-smart-contract-code","content":"The main changes in the smart contract code are related to the way of defining custom types, events and errors. The following sections will guide you through the necessary changes. 2.2.1. Update custom types definitions.​ #[derive(OdraType)] attribute has been replace with #[odra::odra_type] attribute. 0.9.00.8.0 use odra::Address; #[odra::odra_type] pub struct Dog { pub name: String, pub age: u8, pub owner: Option&lt;Address&gt; }  2.2.2. Update errors definitions.​ #[derive(OdraError)] attribute has been replace with #[odra::odra_error] attribute. Error enum should be passed as a parameter to the #[odra::module] attribute. 0.9.00.8.0 #[odra::module(events = [/* events go here */], errors = Error)] pub struct Erc20 { // fields } #[odra::odra_error] pub enum Error { InsufficientBalance = 30_000, InsufficientAllowance = 30_001, NameNotSet = 30_002, SymbolNotSet = 30_003, DecimalsNotSet = 30_004 }  2.2.3. Update events definitions.​ #[derive(Event)] attribute has been replace with #[odra::event] attribute. 0.9.00.8.0 use odra::prelude::*; use odra::{Address, casper_types::U256}; #[odra::event] pub struct Transfer { pub from: Option&lt;Address&gt;, pub to: Option&lt;Address&gt;, pub amount: U256 }  ","version":"2.3.1","tagName":"h3"},{"title":"3. Code Examples​","type":1,"pageTitle":"Migration guide to v0.9.0","url":"/docs/migrations/to-0.9.0#3-code-examples","content":"Here is a complete example of a smart contract after and before the migration to v0.9.0. 0.9.0Prev src/erc20.rs use crate::erc20::errors::Error; use crate::erc20::events::*; use odra::prelude::*; use odra::{casper_types::U256, Address, Mapping, Var}; #[odra::module(events = [Approval, Transfer], errors = Error)] pub struct Erc20 { decimals: Var&lt;u8&gt;, symbol: Var&lt;String&gt;, name: Var&lt;String&gt;, total_supply: Var&lt;U256&gt;, balances: Mapping&lt;Address, U256&gt;, allowances: Mapping&lt;(Address, Address), U256&gt; } #[odra::module] impl Erc20 { pub fn init( &amp;mut self, symbol: String, name: String, decimals: u8, initial_supply: Option&lt;U256&gt; ) { let caller = self.env().caller(); self.symbol.set(symbol); self.name.set(name); self.decimals.set(decimals); if let Some(initial_supply) = initial_supply { self.total_supply.set(initial_supply); self.balances.set(&amp;caller, initial_supply); if !initial_supply.is_zero() { self.env().emit_event(Transfer { from: None, to: Some(caller), amount: initial_supply }); } } } pub fn transfer(&amp;mut self, recipient: &amp;Address, amount: &amp;U256) { let caller = self.env().caller(); self.raw_transfer(&amp;caller, recipient, amount); } pub fn transfer_from(&amp;mut self, owner: &amp;Address, recipient: &amp;Address, amount: &amp;U256) { let spender = self.env().caller(); self.spend_allowance(owner, &amp;spender, amount); self.raw_transfer(owner, recipient, amount); } pub fn approve(&amp;mut self, spender: &amp;Address, amount: &amp;U256) { let owner = self.env().caller(); self.allowances.set(&amp;(owner, *spender), *amount); self.env().emit_event(Approval { owner, spender: *spender, value: *amount }); } pub fn name(&amp;self) -&gt; String { self.name.get_or_revert_with(Error::NameNotSet) } // Other getter functions... pub fn allowance(&amp;self, owner: &amp;Address, spender: &amp;Address) -&gt; U256 { self.allowances.get_or_default(&amp;(*owner, *spender)) } pub fn mint(&amp;mut self, address: &amp;Address, amount: &amp;U256) { self.total_supply.add(*amount); self.balances.add(address, *amount); self.env().emit_event(Transfer { from: None, to: Some(*address), amount: *amount }); } pub fn burn(&amp;mut self, address: &amp;Address, amount: &amp;U256) { if self.balance_of(address) &lt; *amount { self.env().revert(Error::InsufficientBalance); } self.total_supply.subtract(*amount); self.balances.subtract(address, *amount); self.env().emit_event(Transfer { from: Some(*address), to: None, amount: *amount }); } } impl Erc20 { fn raw_transfer(&amp;mut self, owner: &amp;Address, recipient: &amp;Address, amount: &amp;U256) { if *amount &gt; self.balances.get_or_default(owner) { self.env().revert(Error::InsufficientBalance) } self.balances.subtract(owner, *amount); self.balances.add(recipient, *amount); self.env().emit_event(Transfer { from: Some(*owner), to: Some(*recipient), amount: *amount }); } fn spend_allowance(&amp;mut self, owner: &amp;Address, spender: &amp;Address, amount: &amp;U256) { let allowance = self.allowances.get_or_default(&amp;(*owner, *spender)); if allowance &lt; *amount { self.env().revert(Error::InsufficientAllowance) } self.allowances.subtract(&amp;(*owner, *spender), *amount); self.env().emit_event(Approval { owner: *owner, spender: *spender, value: allowance - *amount }); } } pub mod events { use odra::prelude::*; use odra::{casper_types::U256, Address}; #[odra::event] pub struct Transfer { pub from: Option&lt;Address&gt;, pub to: Option&lt;Address&gt;, pub amount: U256 } #[odra::event] pub struct Approval { pub owner: Address, pub spender: Address, pub value: U256 } } pub mod errors { #[odra::odra_error] pub enum Error { InsufficientBalance = 30_000, InsufficientAllowance = 30_001, NameNotSet = 30_002, SymbolNotSet = 30_003, DecimalsNotSet = 30_004 } } #[cfg(test)] mod tests { // nothing changed in the tests }  ","version":"2.3.1","tagName":"h2"},{"title":"4. Troubleshooting​","type":1,"pageTitle":"Migration guide to v0.9.0","url":"/docs/migrations/to-0.9.0#4-troubleshooting","content":"If you encounter any further issues after completing the migration steps, please don't hesitate to reach out to us on Discord or explore the other sections this documentation. You can also refer to the technical documentation for more detailed information. Additionally, our examples repository offers a wide range of examples to assist you in understanding the new features and APIs. Be sure to carefully review any compilation errors and warnings, as they may provide valuable insights into the necessary adjustments. ","version":"2.3.1","tagName":"h2"},{"title":"5. References​","type":1,"pageTitle":"Migration guide to v0.9.0","url":"/docs/migrations/to-0.9.0#5-references","content":"ChangelogOdra DocumentationDocs.rsExamples ","version":"2.3.1","tagName":"h2"},{"title":"Build, Deploy and Read the State of a Contract","type":0,"sectionRef":"#","url":"/docs/tutorials/build-deploy-read","content":"","keywords":"","version":"2.3.1"},{"title":"Contract​","type":1,"pageTitle":"Build, Deploy and Read the State of a Contract","url":"/docs/tutorials/build-deploy-read#contract","content":"Let's write a contract with complex storage layout. The contract stores a plain numeric value, a custom nested type and a submodule with another submodule with stores a Mapping. We will expose two methods: The constructor init which sets the metadata and the version of the contract.The method set_data which sets the value of the numeric field and the values of the mapping. custom_item.rs use odra::{casper_types::U256, prelude::*}; // A custom type with a vector of another custom type #[odra::odra_type] pub struct Metadata { name: String, description: String, prices: Vec&lt;Price&gt;, } #[odra::odra_type] pub struct Price { value: U256, } // The main contract with a version, metadata and a submodule #[odra::module] pub struct CustomItem { version: Var&lt;u32&gt;, meta: Var&lt;Metadata&gt;, data: SubModule&lt;Data&gt; } #[odra::module] impl CustomItem { pub fn init(&amp;mut self, name: String, description: String, price_1: U256, price_2: U256) { let meta = Metadata { name, description, prices: vec![ Price { value: price_1 }, Price { value: price_2 } ] }; self.meta.set(meta); self.version.set(self.version.get_or_default() + 1); } pub fn set_data(&amp;mut self, value: u32, name: String, name2: String) { self.data.value.set(value); self.data.inner.named_values.set(&amp;name, 10); self.data.inner.named_values.set(&amp;name2, 20); } } // A submodule with a numeric value and another submodule #[odra::module] struct Data { value: Var&lt;u32&gt;, inner: SubModule&lt;InnerData&gt;, } // A submodule with a mapping #[odra::module] struct InnerData { named_values: Mapping&lt;String, u32&gt;, }  ","version":"2.3.1","tagName":"h3"},{"title":"Deploying the contract​","type":1,"pageTitle":"Build, Deploy and Read the State of a Contract","url":"/docs/tutorials/build-deploy-read#deploying-the-contract","content":"First, we need to setup the chain. We will use the NCTL docker image to run a local network. docker run --rm -it --name mynctl -d -p 11101:11101 -p 14101:14101 -p 18101:18101 makesoftware/casper-nctl  Next, we need to compile the contract to a Wasm file. cargo odra build -c custom_item  Then, we can deploy the contract using the casper-client tool. casper-client put-transaction session \\ --node-address http://localhost:11101 \\ --chain-name casper-net-1 \\ --secret-key path/to/your/secret_key.pem \\ --wasm-path ./wasm/Erc20.wasm \\ --payment-amount 450000000000 \\ --gas-price-tolerance 1 \\ --standard-payment true \\ --session-arg &quot;odra_cfg_package_hash_key_name:string:'test_contract_package_hash'&quot; \\ --session-arg &quot;odra_cfg_allow_key_override:bool:'true'&quot; \\ --session-arg &quot;odra_cfg_is_upgradable:bool:'true'&quot; \\ --session-arg &quot;odra_cfg_is_upgrade:bool:'false'&quot; \\ --session-arg &quot;name:string='My Name'&quot; \\ --session-arg &quot;description:string='My Description'&quot; \\ --session-arg &quot;price_1:u256='101'&quot; \\ --session-arg &quot;price_2:u256='202'&quot;  Finally, we can call the set_data method to set the values of the contract. casper-client put-transaction package \\ --node-address http://localhost:11101 \\ --chain-name casper-net-1 \\ --secret-key path/to/your/secret_key.pem \\ --gas-price-tolerance 1 \\ --contract-package-hash &quot;hash-...&quot; \\ --payment-amount 2500000000 \\ --standard-payment &quot;true&quot; \\ --session-entry-point &quot;set_data&quot; \\ --session-arg &quot;value:u32:'666'&quot; \\ --session-arg &quot;name:string='alice'&quot; \\ --session-arg &quot;name2:string='bob'&quot;  ","version":"2.3.1","tagName":"h3"},{"title":"Storage Layout​","type":1,"pageTitle":"Build, Deploy and Read the State of a Contract","url":"/docs/tutorials/build-deploy-read#storage-layout","content":"To read the state of the contract, we need to understand the storage layout. The first step is to calculate the index of the keys. Storage Layout CustomItem: prefix: 0x0..._0000_0000_0000 0 version: u32, 0x0..._0000_0000_0001 1 meta: Metadata, 0x0..._0000_0000_0010 2 data: Data: prefix: 0x0..._0000_0000_0011 3 value: u32, 0x0..._0000_0011_0001 (3 &lt;&lt; 4) + 1 inner: InnerData: prefix: 0x0..._0000_0011_0010 (3 &lt;&lt; 4) + 2 named_values: Mapping 0x0..._0011_0010_0001 ((3 &lt;&lt; 4) + 2) &lt;&lt; 4 + 1  The actual key is obtained as follows: Convert the index to a big-endian byte array.Concatenate the index with the mapping data.Hash the concatenated bytes using blake2b.Return the hex representation of the hash (the stored key must be utf-8 encoded). In more detail, the storage layout is described in the Storage Layout article. ","version":"2.3.1","tagName":"h3"},{"title":"Reading the state​","type":1,"pageTitle":"Build, Deploy and Read the State of a Contract","url":"/docs/tutorials/build-deploy-read#reading-the-state","content":"RustTypeScript main.rs use casper_client::{rpcs::DictionaryItemIdentifier, types::StoredValue, Verbosity}; use casper_types::{ bytesrepr::{FromBytes, ToBytes}, U256, }; // replace with your contract hash const CONTRACT_HASH: &amp;str = &quot;hash-...&quot;; const NODE_ADDRESS: &amp;str = &quot;http://localhost:11101/rpc&quot;; const RPC_ID: &amp;str = &quot;casper-net-1&quot;; const DICTIONARY_NAME: &amp;str = &quot;state&quot;; #[derive(Debug, PartialEq, Eq, Hash)] pub struct Metadata { name: String, description: String, prices: Vec&lt;Price&gt;, } #[derive(Debug, PartialEq, Eq, Hash)] pub struct Price { value: U256, } async fn read_state_key(key: String) -&gt; Vec&lt;u8&gt; { let state_root_hash = casper_client::get_state_root_hash( RPC_ID.to_string().into(), NODE_ADDRESS, Verbosity::Low, None, ) .await .unwrap() .result .state_root_hash .unwrap(); // Read the value from the `state` dictionary. let result = casper_client::get_dictionary_item( RPC_ID.to_string().into(), NODE_ADDRESS, Verbosity::Low, state_root_hash, DictionaryItemIdentifier::ContractNamedKey { key: CONTRACT_HASH.to_string(), dictionary_name: DICTIONARY_NAME.to_string(), dictionary_item_key: key, }, ) .await .unwrap() .result .stored_value; // We expect the value to be a CLValue if let StoredValue::CLValue(cl_value) = result { // Ignore the first 4 bytes, which are the length of the CLType. cl_value.inner_bytes()[4..].to_vec() } else { vec![] } } async fn metadata() -&gt; Metadata { // The key for the metadata is 2, and it has no mapping data let key = key(2, &amp;[]); let bytes = read_state_key(key).await; // Read the name and store the remaining bytes let (name, bytes) = String::from_bytes(&amp;bytes).unwrap(); // Read the description and store the remaining bytes let (description, bytes) = String::from_bytes(&amp;bytes).unwrap(); // A vector is stored as a u32 size followed by the elements // Read the size of the vector and store the remaining bytes let (size, mut bytes) = u32::from_bytes(&amp;bytes).unwrap(); let mut prices = vec![]; // As we know the size of the vector, we can loop over it for _ in 0..size { // Read the value and store the remaining bytes let (value, rem) = U256::from_bytes(&amp;bytes).unwrap(); bytes = rem; prices.push(Price { value }); } // Anytime you finish parsing a value, you should check if there are any remaining bytes // if there are, it means you have a bug in your parsing logic. // For simplicity, we will ignore the remaining bytes here. Metadata { name, description, prices } } async fn value() -&gt; u32 { // The key for the value is (3 &lt;&lt; 4) + 1, and it has no mapping data let key = key((3 &lt;&lt; 4) + 1, &amp;[]); let bytes = read_state_key(key).await; // Read the value and ignore the remaining bytes for simplicity u32::from_bytes(&amp;bytes).unwrap().0 } async fn named_value(name: &amp;str) -&gt; u32 { // The key for the named value is (((3 &lt;&lt; 4) + 2) &lt;&lt; 4) + 1, and the mapping data is the name as bytes let mapping_data = name.to_bytes().unwrap(); let key = key((((3 &lt;&lt; 4) + 2) &lt;&lt; 4) + 1, &amp;mapping_data); let bytes = read_state_key(key).await; // Read the value and ignore the remaining bytes for simplicity u32::from_bytes(&amp;bytes).unwrap().0 } fn main() { let runtime = tokio::runtime::Runtime::new().unwrap(); dbg!(runtime.block_on(metadata())); dbg!(runtime.block_on(value())); dbg!(runtime.block_on(named_value(&quot;alice&quot;))); dbg!(runtime.block_on(named_value(&quot;bob&quot;))); } // The key is a combination of the index and the mapping data // The algorithm is as follows: // 1. Convert the index to a big-endian byte array // 2. Concatenate the index with the mapping data // 3. Hash the concatenated bytes using blake2b // 4. Return the hex representation of the hash (the stored key must be utf-8 encoded) fn key(idx: u32, mapping_data: &amp;[u8]) -&gt; String { let mut key = Vec::new(); key.extend_from_slice(idx.to_be_bytes().as_ref()); key.extend_from_slice(mapping_data); let hashed_key = blake2b(&amp;key); hex::encode(&amp;hashed_key) } fn blake2b(bytes: &amp;[u8]) -&gt; [u8; 32] { let mut result = [0u8; 32]; let mut hasher = &lt;blake2::Blake2bVar as blake2::digest::VariableOutput&gt;::new(32) .expect(&quot;should create hasher&quot;); let _ = std::io::Write::write(&amp;mut hasher, bytes); blake2::digest::VariableOutput::finalize_variable(hasher, &amp;mut result) .expect(&quot;should copy hash to the result array&quot;); result } cargo run [src/main.rs:116:5] runtime.block_on(metadata()) = Metadata { name: &quot;My Contract&quot;, description: &quot;My Description&quot;, prices: [ Price { value: 123, }, Price { value: 321, }, ], } [src/main.rs:117:5] runtime.block_on(value()) = 666 [src/main.rs:118:5] runtime.block_on(named_value(&quot;alice&quot;)) = 20 [src/main.rs:119:5] runtime.block_on(named_value(&quot;bob&quot;)) = 10  ","version":"2.3.1","tagName":"h3"},{"title":"Deploying a Token on Casper Livenet","type":0,"sectionRef":"#","url":"/docs/tutorials/deploying-on-casper","content":"","keywords":"","version":"2.3.1"},{"title":"Casper Wallet​","type":1,"pageTitle":"Deploying a Token on Casper Livenet","url":"/docs/tutorials/deploying-on-casper#casper-wallet","content":"We will be using Casper Wallet to do some tasks in this tutorial. To install it, please follow the instructions on the official website. After setting up the wallet, extract the private key of the account you want to use for our testing. You can do this by clicking on the Menu &gt; Download account keys. danger You are solely responsible for the security of your private keys. We recommend creating a new account for the testing purposes. Why do we need the private key? We will use it in Odra to deploy our contract to the Casper network using Livenet backend. ","version":"2.3.1","tagName":"h2"},{"title":"Getting tokens​","type":1,"pageTitle":"Deploying a Token on Casper Livenet","url":"/docs/tutorials/deploying-on-casper#getting-tokens","content":"To deploy the contract on the Livenet, we need to have some CSPR. The easiest way to get them is to use the faucet, which will send us 1000 CSPR for free. Unfortunately, only on the Testnet. To use the faucet, go to the Casper Testnet Faucet. Log in using your Casper Wallet account and click on the &quot;Request Tokens&quot; button. note One account can request tokens only once. If you run out of tokens, you can either ask someone in the Casper community to send you some, or simply create a new account in the wallet. Now, when we have the tokens, we can deploy the contract. Let's do it using Odra! ","version":"2.3.1","tagName":"h2"},{"title":"Odra Livenet​","type":1,"pageTitle":"Deploying a Token on Casper Livenet","url":"/docs/tutorials/deploying-on-casper#odra-livenet","content":"Odra Livenet is described in detail in thebackends section of this documentation. We will then briefly describe how to use set it up in this tutorial. In your contract code, create a new file in the bin folder: bin/our_token_livenet.rs //! Deploys a new OurToken contract on the Casper livenet and mints some tokens for the tutorial //! creator. use std::str::FromStr; use odra::casper_types::U256; use odra::host::{Deployer, HostEnv, HostRef, HostRefLoader}; use odra::prelude::Address; use ourcoin::token::{OurToken, OurToken, OurTokenInitArgs}; fn main() { // Load the Casper livenet environment. let env = odra_casper_livenet_env::env(); // Caller is the deployer and the owner of the private key. let owner = env.caller(); // Just some random address... let recipient = &quot;hash-48bd92253a1370d1d913c56800296145547a243d13ff4f059ba4b985b1e94c26&quot;; let recipient = Address::from_str(recipient).unwrap(); // Deploy new contract. let mut token = deploy_our_token(&amp;env); println!(&quot;Token address: {}&quot;, token.address().to_string()); env.set_gas(2_500_000_000u64); // Propose minting new tokens. token.propose_new_mint(recipient, U256::from(1_000)); // Vote, we are the only voter. token.vote(true, U256::from(1_000)); // Let's advance the block time by 11 minutes, as // we set the voting time to 10 minutes. // OH NO! It is the Livenet, so we need to wait real time... // Hopefully you are not in a hurry. env.advance_block_time(11 * 60 * 1000); // Tally the votes. token.tally(); // Check the balances. println!(&quot;Owner's balance: {:?}&quot;, token.balance_of(&amp;owner)); println!( &quot;Tutorial creator's balance: {:?}&quot;, token.balance_of(&amp;recipient) ); } /// Deploys a contract. pub fn deploy_our_token(env: &amp;HostEnv) -&gt; OurTokenHostRef { let name = String::from(&quot;OurToken&quot;); let symbol = String::from(&quot;OT&quot;); let decimals = 0; let initial_supply = U256::from(1_000); let init_args = OurTokenInitArgs { name, symbol, decimals, initial_supply, }; env.set_gas(400_000_000_000u64); OurToken::deploy(env, init_args) // OurToken::deploy_with_cfg(env, init_args, odra::host::InstallConfig { // package_named_key: String::from(&quot;OurToken&quot;), // is_upgradable: true, // allow_key_override: true, // }) } /// Loads a contract. Just in case you need to load an existing contract later... fn _load_our_token(env: &amp;HostEnv) -&gt; OurTokenHostRef { let address = &quot;hash-XXXXX&quot;; let address = Address::from_str(address).unwrap(); OurToken::load(env, address) }  You can deploy a contract with the default configuration or with a custom configuration calling deploy_with_cfg. Read more about InstallConfig in the Odra documentation. In your Cargo.toml file, we need to add a new dependency, a feature and register the new binary. In the end, it should look like this: Cargo.toml [package] name = &quot;ourcoin&quot; version = &quot;0.1.0&quot; edition = &quot;2021&quot; [dependencies] odra = { version = &quot;2.2.0&quot;, features = [], default-features = false } odra-modules = { version = &quot;2.2.0&quot;, features = [], default-features = false } odra-casper-livenet-env = { version = &quot;2.2.0&quot;, optional = true } [dev-dependencies] odra-test = { version = &quot;2.2.0&quot;, features = [], default-features = false } [build-dependencies] odra-build = { version = &quot;2.2.0&quot;, features = [], default-features = false } [features] default = [] livenet = [&quot;odra-casper-livenet-env&quot;] [[bin]] name = &quot;ourcoin_build_contract&quot; path = &quot;bin/build_contract.rs&quot; test = false [[bin]] name = &quot;ourcoin_build_schema&quot; path = &quot;bin/build_schema.rs&quot; test = false [[bin]] name = &quot;our_token_livenet&quot; path = &quot;bin/our_token_livenet.rs&quot; required-features = [&quot;livenet&quot;] [profile.release] codegen-units = 1 lto = true [profile.dev.package.&quot;*&quot;] opt-level = 3  Finally, add the .env file with the following content: .env # Path to the secret key of the account that will be used to deploy the contracts. ODRA_CASPER_LIVENET_SECRET_KEY_PATH=folder_with_your_secret_key/secret_key.pem # RPC address of the node that will be used to deploy the contracts. # For CSPR.cloud, you can use the following addresses: # - https://node.cspr.cloud # - https://node.testnet.cspr.cloud # For nctl, default is: # - http://localhost:11101 ODRA_CASPER_LIVENET_NODE_ADDRESS=&lt;node_address&gt; # Chain name of the network. The mainnet is &quot;casper&quot; and test net is &quot;casper-test&quot;. # The integration network uses the &quot;integration-test&quot; chain name. # For nctl default is &quot;casper-net-1&quot; ODRA_CASPER_LIVENET_CHAIN_NAME=&lt;chain_name&gt; # Events url # For CSPR.cloud, you can use the following addresses: # - https://node.cspr.cloud/events # For nctl, default is: # - http://localhost:18101/events ODRA_CASPER_LIVENET_EVENTS_URL=&lt;events url&gt;  Of course, you need to replace the secret key's path with the path to the secret key file you downloaded from the Casper Wallet. note One of the problems you may encounter is that the node you are using will be down or will not accept your calls. In this case, you will have to find and use another node IP address. Now, we will run our code: cargo run --bin our_token_livenet --features livenet  If everything is set up correctly, you should see the output similar to this: cargo run --bin our_token_livenet --features livenet Compiling ourcoin v0.1.0 (/Users/kpob/workspace/odra/examples/ourcoin) Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.33s Running `../../target/debug/our_token_livenet` 💁 INFO : Found wasm under &quot;/Users/kpob/workspace/odra/examples/ourcoin/wasm/OurToken.wasm&quot;. 💁 INFO : Deploying &quot;OurToken&quot;. 🙄 WAIT : Waiting 10 for V1(TransactionV1Hash(c856983e995c79d8459540bd9d29d196535f63ceb8bac0f73ea747c5c9c74d76)). 💁 INFO : Transaction &quot;c856983e995c79d8459540bd9d29d196535f63ceb8bac0f73ea747c5c9c74d76&quot; successfully executed. 🔗 LINK : https://testnet.cspr.live/transaction/c856983e995c79d8459540bd9d29d196535f63ceb8bac0f73ea747c5c9c74d76 💁 INFO : Contract &quot;contract-package-e39aa2f8e4d509c0253dcd1709a9f08449477eef0f22f0ad5912fff327f509c8&quot; deployed. Token address: hash-e39aa2f8e4d509c0253dcd1709a9f08449477eef0f22f0ad5912fff327f509c8 💁 INFO : Calling &quot;contract-package-e39aa2f8e4d509c0253dcd1709a9f08449477eef0f22f0ad5912fff327f509c8&quot; directly with entrypoint &quot;propose_new_mint&quot;. 🙄 WAIT : Waiting 10 for V1(TransactionV1Hash(2d1aafe8f06748c7cfaf7972caee6b701de7a817430b52a73215f5ad9a175e77)). 💁 INFO : Transaction &quot;2d1aafe8f06748c7cfaf7972caee6b701de7a817430b52a73215f5ad9a175e77&quot; successfully executed. 🔗 LINK : https://testnet.cspr.live/transaction/2d1aafe8f06748c7cfaf7972caee6b701de7a817430b52a73215f5ad9a175e77 💁 INFO : Calling &quot;contract-package-e39aa2f8e4d509c0253dcd1709a9f08449477eef0f22f0ad5912fff327f509c8&quot; directly with entrypoint &quot;vote&quot;. 🙄 WAIT : Waiting 10 for V1(TransactionV1Hash(b565acd01c2ebbab78fa91a3f0091b849a037f1984ca4c996788b92fcd9521db)). 🙄 WAIT : Waiting 10 for V1(TransactionV1Hash(b565acd01c2ebbab78fa91a3f0091b849a037f1984ca4c996788b92fcd9521db)). 💁 INFO : Transaction &quot;b565acd01c2ebbab78fa91a3f0091b849a037f1984ca4c996788b92fcd9521db&quot; successfully executed. 🔗 LINK : https://testnet.cspr.live/transaction/b565acd01c2ebbab78fa91a3f0091b849a037f1984ca4c996788b92fcd9521db 💁 INFO : advance_block_time called - Waiting for 660000 ms 💁 INFO : Calling &quot;contract-package-e39aa2f8e4d509c0253dcd1709a9f08449477eef0f22f0ad5912fff327f509c8&quot; directly with entrypoint &quot;tally&quot;. 🙄 WAIT : Waiting 10 for V1(TransactionV1Hash(8d24de09298522b028073be5ba05542bf4efd0f03d0e8771d5c5a727832eba94)). 🙄 WAIT : Waiting 10 for V1(TransactionV1Hash(8d24de09298522b028073be5ba05542bf4efd0f03d0e8771d5c5a727832eba94)). 💁 INFO : Transaction &quot;8d24de09298522b028073be5ba05542bf4efd0f03d0e8771d5c5a727832eba94&quot; successfully executed. 🔗 LINK : https://testnet.cspr.live/transaction/8d24de09298522b028073be5ba05542bf4efd0f03d0e8771d5c5a727832eba94 Owner's balance: 1000 Tutorial creator's balance: 1000  Congratulations, your contract is now deployed on the Casper network! Before we move on, note the address of the token! We will use it in the next section to interact with the token. In our case it ishash-e39aa2f8e4d509c0253dcd1709a9f08449477eef0f22f0ad5912fff327f509c8. ","version":"2.3.1","tagName":"h2"},{"title":"Cspr.live​","type":1,"pageTitle":"Deploying a Token on Casper Livenet","url":"/docs/tutorials/deploying-on-casper#csprlive","content":"The first thing we will do is to explore Casper's network block explorer,cspr.live. We can put the address of our token in the search bar to find it. note If you deployed your contract on the Testnet, remember to make sure that the Testnet network is selected in the dropdown menu in the top right corner. If everything is set up correctly, you should see the contract package's details. Besides the owner, keys etc., you can also see the contract's metdata, if it was developed using a standard that cspr.live supports. Indeed, we can see that it detected that our contract is a CEP-18 token! We see the name, symbol and total supply. All the mentions of the contract on the website will use the token name instead of the contract address.  Additionally, on the Token Txs tab, we can see the transactions that happened with the token. We can see the minting transaction we did in the previous section and transfers done during the voting process.  If we click on one of the accounts that recieved the tokens, we will go to the account page. Here, on the Tokens tab, we can see all the tokens that the account has - and OurToken is one of them! If you wish, you can check the status of the contract deployed during the development of this tutorial here. ","version":"2.3.1","tagName":"h2"},{"title":"Transferring Tokens using Casper Wallet​","type":1,"pageTitle":"Deploying a Token on Casper Livenet","url":"/docs/tutorials/deploying-on-casper#transferring-tokens-using-casper-wallet","content":"Casper wallet can do much more than just logging in to the faucet, exporting the private keys and transferring CSPR. It can also interact with the contracts deployed on the network. If you deployed the contract and left some OT tokens to yourself, you should see them in the Casper Wallet window. You should also be able to transfer them to another account!  ","version":"2.3.1","tagName":"h2"},{"title":"Conclusion​","type":1,"pageTitle":"Deploying a Token on Casper Livenet","url":"/docs/tutorials/deploying-on-casper#conclusion","content":"We've successfully deployed a token on the Casper network and interacted with it using the Odra backend and Casper Wallet. We've also learned how to use the cspr.live block explorer to check the status of your contract. Odra, Cspr.live and Casper Wallet are just a few of the tools that the Casper ecosystem provides. Feel free to explore them on casperecosystem.io. ","version":"2.3.1","tagName":"h2"},{"title":"CEP-18","type":0,"sectionRef":"#","url":"/docs/tutorials/cep18","content":"","keywords":"","version":"2.3.1"},{"title":"Self-governing token​","type":1,"pageTitle":"CEP-18","url":"/docs/tutorials/cep18#self-governing-token","content":"There are many ways to implement a governance mechanism for a token, each more complex than the other. In our example, we will use a simple one, where the community of token holders can vote to mint new tokens. ","version":"2.3.1","tagName":"h2"},{"title":"Token implementation​","type":1,"pageTitle":"CEP-18","url":"/docs/tutorials/cep18#token-implementation","content":"Let's start by creating a new project, choosing a clever name and using cep18 as our starting template: cargo odra new --name ourcoin --template cep18  Let's glance at our token code: src/token.rs #[odra::module] pub struct MyToken { token: SubModule&lt;Cep18&gt;, } impl MyToken { // Delegate all Cep18 functions to the token sub-module. delegate! { to self.token { ... fn name(&amp;self) -&gt; String; fn symbol(&amp;self) -&gt; String; ...  As we can see, it indeed uses the Cep18 module and delegates all the methods to it. The only thing to do is to change the name of the struct to more appropriate OurToken, run the provided tests using cargo odra test, and continue with the implementation of the governance. note Remember to change the name of the struct and its usages as well as the struct name in the Odra.toml file! ","version":"2.3.1","tagName":"h2"},{"title":"Governance implementation​","type":1,"pageTitle":"CEP-18","url":"/docs/tutorials/cep18#governance-implementation","content":"Let's go through the process of implementing the governance mechanism. If we don't want to, we don't have to hide entrypoints from the public responsible for minting new tokens. By default, minting Modalityis turned off, so any attempt of direct minting will result in an error. We will however implement a voting mechanism, where the token holders can vote to mint new tokens. ","version":"2.3.1","tagName":"h2"},{"title":"Voting mechanism​","type":1,"pageTitle":"CEP-18","url":"/docs/tutorials/cep18#voting-mechanism","content":"Our voting system will be straightforward: Anyone with the tokens can propose a new mint.Anyone with the tokens can vote for the new mint by staking their tokens.If the majority of the token holders vote for the mint, it is executed. Storage​ We will need to store some additional information about the votes, so let's add some fields to our token struct: src/token.rs #[odra::module] pub struct OurToken { /// A sub-module that implements the CEP-18 token standard. token: SubModule&lt;Cep18&gt;, /// The proposed mint. proposed_mint: Var&lt;(Address, U256)&gt;, /// The list of votes cast in the current vote. votes: List&lt;Ballot&gt;, /// Whether a vote is open. is_vote_open: Var&lt;bool&gt;, /// The time when the vote ends. vote_end_time: Var&lt;u64&gt;, } /// A ballot cast by a voter. #[odra::odra_type] struct Ballot { voter: Address, choice: bool, amount: U256, }  Notice that proposed_mint contains a tuple containing the address of the proposer and the amount of tokens to mint. Moreover, we need to keep track if the vote time has ended, but also if it was already tallied, that's why we need both is_vote_open and vote_end_time. We will also use the power of the Listtype to store the Ballots. Proposing a new mint​ To implement the endpoint that allows token holders to propose a new mint, we need to add a new function to our token module: src/token.rs /// Proposes a new mint for the contract. pub fn propose_new_mint(&amp;mut self, account: Address, amount: U256) { // Only allow proposing a new mint if there is no vote in progress. if self.is_vote_open().get_or_default() { self.env().revert(GovernanceError::VoteAlreadyOpen); } // Only the token holders can propose a new mint. if self.balance_of(&amp;self.env().caller()) == U256::zero() { self.env().revert(GovernanceError::OnlyTokenHoldersCanPropose); } // Set the proposed mint. self.proposed_mint.set((account, amount)); // Open a vote. self.is_vote_open.set(true); // Set the vote end time to 10 minutes from now. self.vote_end_time .set(self.env().get_block_time() + 60 * 10 * 1000); }  As a parameters to the function, we pass the address of the account that should be the receiver of the minted tokens, and the amount. After some validation, we open the vote by setting the is_vote_open to true, and setting the vote_end_time to 10 minutes. In real-world scenarios, the time could be configurable, but for the sake of simplicity, we hardcoded it. Also, it should be quite longer than 10 minutes, but it will come in handy when we test it on Livenet. Voting for the mint​ Next, we need an endpoint that will allow us to cast a ballot: src/token.rs /// Votes on the proposed mint. pub fn vote(&amp;mut self, choice: bool, amount: U256) { // Only allow voting if there is a vote in progress. self.assert_vote_in_progress(); let voter = self.env().caller(); let contract = self.env().self_address(); // Transfer the voting tokens from the voter to the contract. self.token .transfer(&amp;contract, &amp;amount); // Add the vote to the list. self.votes.push(Ballot { voter, choice, amount, }); }  The most interesting thing here is that we are using a mechanism of staking, where we transfer our tokens to the contract, to show that we really mean it. The tokens will be locked until the vote is over, and tallied. Speaking of tallying... Tallying the votes​ The last step is to tally the votes and mint the tokens if the majority of voters agreed to do so: src/token.rs /// Count the votes and perform the action pub fn tally(&amp;mut self) { // Only allow tallying the votes once. if !self.is_vote_open.get_or_default() { self.env().revert(GovernanceError::NoVoteInProgress); } // Only allow tallying the votes after the vote has ended. let finish_time = self .vote_end_time .get_or_revert_with(GovernanceError::NoVoteInProgress); if self.env().get_block_time() &lt; finish_time { self.env().revert(GovernanceError::VoteNotYetEnded); } // Count the votes let mut yes_votes = U256::zero(); let mut no_votes = U256::zero(); let contract = self.env().self_address(); while let Some(vote) = self.votes.pop() { if vote.choice { yes_votes += vote.amount; } else { no_votes += vote.amount; } // Transfer back the voting tokens to the voter. self.token.raw_transfer(&amp;contract, &amp;vote.voter, &amp;vote.amount); } // Perform the action if the vote has passed. if yes_votes &gt; no_votes { let (account, amount) = self .proposed_mint .get_or_revert_with(GovernanceError::NoVoteInProgress); self.token.raw_mint(&amp;account, &amp;amount); } // Close the vote. self.is_vote_open.set(false); }  Notice how we used raw_transfer from the Cep18 module. We used it to set the sender, so the contract's balance will be used, instead of the caller's. Additonally, we used raw_mint to mint the tokens, skipping the security checks. We have no modality for minting, but even if we had, we don't have anyone with permissions! The Contract needs to mint the tokens itself. ","version":"2.3.1","tagName":"h3"},{"title":"Testing​","type":1,"pageTitle":"CEP-18","url":"/docs/tutorials/cep18#testing","content":"Now, we will put our implementation to the test. One unit test, that we can run both on OdraVM and on the CasperVM. src/token.rs #[test] fn it_works() { let env = odra_test::env(); let init_args = OurTokenInitArgs { name: &quot;OurToken&quot;.to_string(), symbol: &quot;OT&quot;.to_string(), decimals: 0, initial_supply: U256::from(1_000u64), }; let mut token = OurToken::deploy(&amp;env, init_args); // The deployer, as the only token holder, // starts a new voting to mint 1000 tokens to account 1. // There is only 1 token holder, so there is one Ballot cast. token.propose_new_mint(env.get_account(1), U256::from(2000)); token.vote(true, U256::from(1000)); // The tokens should now be staked. assert_eq!(token.balance_of(&amp;env.get_account(0)), U256::zero()); // Wait for the vote to end. env.advance_block_time(60 * 11 * 1000); // Finish the vote. token.tally(); // The tokens should now be minted. assert_eq!(token.balance_of(&amp;env.get_account(1)), U256::from(2000)); assert_eq!(token.total_supply(), 3000.into()); // The stake should be returned. assert_eq!(token.balance_of(&amp;env.get_account(0)), U256::from(1000)); // Now account 1 can mint new tokens with their voting power... env.set_caller(env.get_account(1)); token.propose_new_mint(env.get_account(1), U256::from(2000)); token.vote(true, U256::from(2000)); // ...Even if the deployer votes against it. env.set_caller(env.get_account(0)); token.vote(false, U256::from(1000)); env.advance_block_time(60 * 11 * 1000); token.tally(); // The power of community governance! assert_eq!(token.balance_of(&amp;env.get_account(1)), U256::from(4000)); }  We can run the test using both methods: cargo odra test cargo odra test -b casper  It is all nice and green, but it would be really nice to see it in action. How about deploying it on the Casper network? ","version":"2.3.1","tagName":"h3"},{"title":"What's next​","type":1,"pageTitle":"CEP-18","url":"/docs/tutorials/cep18#whats-next","content":"We will se our token in action, by deploying it on the Casper network, and using tools from the Casper Ecosystem to interact with it. ","version":"2.3.1","tagName":"h2"},{"title":"Complete code​","type":1,"pageTitle":"CEP-18","url":"/docs/tutorials/cep18#complete-code","content":"Here is the complete code of the OurToken module: src/token.rs use odra::{casper_types::U256, prelude::*}; use odra_modules::cep18_token::Cep18; /// A ballot cast by a voter. #[odra::odra_type] struct Ballot { voter: Address, choice: bool, amount: U256, } /// Errors for the governed token. #[odra::odra_error] pub enum GovernanceError { /// The vote is already in progress. VoteAlreadyOpen = 0, /// No vote is in progress. NoVoteInProgress = 1, /// Cannot tally votes yet. VoteNotYetEnded = 2, /// Vote ended VoteEnded = 3, /// Only the token holders can propose a new mint. OnlyTokenHoldersCanPropose = 4, } /// A module definition. Each module struct consists of Vars and Mappings /// or/and other modules. #[odra::module(errors = GovernanceError)] pub struct OurToken { /// A submodule that implements the CEP-18 token standard. token: SubModule&lt;Cep18&gt;, /// The proposed mint. proposed_mint: Var&lt;(Address, U256)&gt;, /// The list of votes cast in the current vote. votes: List&lt;Ballot&gt;, /// Whether a vote is open. is_vote_open: Var&lt;bool&gt;, /// The time when the vote ends. vote_end_time: Var&lt;u64&gt;, } /// Module implementation. /// /// To generate entrypoints, /// an implementation block must be marked as #[odra::module]. #[odra::module] impl OurToken { /// Initializes the contract with the given metadata and initial supply. pub fn init(&amp;mut self, name: String, symbol: String, decimals: u8, initial_supply: U256) { // We put the token address as an admin, so it can govern itself. Self-governing token! self.token.init(symbol, name, decimals, initial_supply); } // Delegate all Cep18 functions to the token submodule. delegate! { to self.token { /// Returns the name of the token. fn name(&amp;self) -&gt; String; /// Returns the symbol of the token. fn symbol(&amp;self) -&gt; String; /// Returns the number of decimals the token uses. fn decimals(&amp;self) -&gt; u8; /// Returns the total supply of the token. fn total_supply(&amp;self) -&gt; U256; /// Returns the balance of the given address. fn balance_of(&amp;self, address: &amp;Address) -&gt; U256; /// Returns the amount of tokens the owner has allowed the spender to spend. fn allowance(&amp;self, owner: &amp;Address, spender: &amp;Address) -&gt; U256; /// Approves the spender to spend the given amount of tokens on behalf of the caller. fn approve(&amp;mut self, spender: &amp;Address, amount: &amp;U256); /// Decreases the allowance of the spender by the given amount. fn decrease_allowance(&amp;mut self, spender: &amp;Address, decr_by: &amp;U256); /// Increases the allowance of the spender by the given amount. fn increase_allowance(&amp;mut self, spender: &amp;Address, inc_by: &amp;U256); /// Transfers tokens from the caller to the recipient. fn transfer(&amp;mut self, recipient: &amp;Address, amount: &amp;U256); /// Transfers tokens from the owner to the recipient using the spender's allowance. fn transfer_from(&amp;mut self, owner: &amp;Address, recipient: &amp;Address, amount: &amp;U256); } } /// Burns the given amount of tokens from the given address. pub fn burn(&amp;mut self, owner: &amp;Address, amount: &amp;U256) { self.token.assert_caller(owner); // Burn the tokens. self.token.raw_burn(owner, amount); } /// Proposes a new mint for the contract. pub fn propose_new_mint(&amp;mut self, account: Address, amount: U256) { // Only allow proposing a new mint if there is no vote in progress. if self.is_vote_open.get_or_default() { self.env().revert(GovernanceError::VoteAlreadyOpen); } // Only the token holders can propose a new mint. if self.balance_of(&amp;self.env().caller()) == U256::zero() { self.env() .revert(GovernanceError::OnlyTokenHoldersCanPropose); } // Set the proposed mint. self.proposed_mint.set((account, amount)); // Open a vote. self.is_vote_open.set(true); // Set the vote end time to 10 minutes from now. self.vote_end_time .set(self.env().get_block_time() + 10 * 60 * 1000); } /// Votes on the proposed mint. pub fn vote(&amp;mut self, choice: bool, amount: U256) { // Only allow voting if there is a vote in progress. self.assert_vote_in_progress(); let voter = self.env().caller(); let contract = self.env().self_address(); // Transfer the voting tokens from the voter to the contract. self.token.transfer(&amp;contract, &amp;amount); // Add the vote to the list. self.votes.push(Ballot { voter, choice, amount, }); } /// Count the votes and perform the action pub fn tally(&amp;mut self) { // Only allow tallying the votes once. if !self.is_vote_open.get_or_default() { self.env().revert(GovernanceError::NoVoteInProgress); } // Only allow tallying the votes after the vote has ended. let finish_time = self .vote_end_time .get_or_revert_with(GovernanceError::NoVoteInProgress); if self.env().get_block_time() &lt; finish_time { self.env().revert(GovernanceError::VoteNotYetEnded); } // Count the votes let mut yes_votes = U256::zero(); let mut no_votes = U256::zero(); let contract = self.env().self_address(); while let Some(vote) = self.votes.pop() { if vote.choice { yes_votes += vote.amount; } else { no_votes += vote.amount; } // Transfer back the voting tokens to the voter. self.token .raw_transfer(&amp;contract, &amp;vote.voter, &amp;vote.amount); } // Perform the action if the vote has passed. if yes_votes &gt; no_votes { let (account, amount) = self .proposed_mint .get_or_revert_with(GovernanceError::NoVoteInProgress); self.token.raw_mint(&amp;account, &amp;amount); } // Close the vote. self.is_vote_open.set(false); } fn assert_vote_in_progress(&amp;self) { if !self.is_vote_open.get_or_default() { self.env().revert(GovernanceError::NoVoteInProgress); } let finish_time = self .vote_end_time .get_or_revert_with(GovernanceError::NoVoteInProgress); if self.env().get_block_time() &gt; finish_time { self.env().revert(GovernanceError::VoteEnded); } } } #[cfg(test)] mod tests { use super::*; use odra::host::Deployer; #[test] fn it_works() { let env = odra_test::env(); let init_args = OurTokenInitArgs { name: &quot;OurToken&quot;.to_string(), symbol: &quot;OT&quot;.to_string(), decimals: 0, initial_supply: U256::from(1_000u64), }; let mut token = OurToken::deploy(&amp;env, init_args); // The deployer, as the only token holder, // starts a new voting to mint 1000 tokens to account 1. // There is only 1 token holder, so there is one Ballot cast. token.propose_new_mint(env.get_account(1), U256::from(2000)); token.vote(true, U256::from(1000)); // The tokens should now be staked. assert_eq!(token.balance_of(&amp;env.get_account(0)), U256::zero()); // Wait for the vote to end. env.advance_block_time(60 * 11 * 1000); // Finish the vote. token.tally(); // The tokens should now be minted. assert_eq!(token.balance_of(&amp;env.get_account(1)), U256::from(2000)); assert_eq!(token.total_supply(), 3000.into()); // The stake should be returned. assert_eq!(token.balance_of(&amp;env.get_account(0)), U256::from(1000)); // Now account 1 can mint new tokens with their voting power... env.set_caller(env.get_account(1)); token.propose_new_mint(env.get_account(1), U256::from(2000)); token.vote(true, U256::from(2000)); // ...Even if the deployer votes against it. env.set_caller(env.get_account(0)); token.vote(false, U256::from(1000)); env.advance_block_time(60 * 11 * 1000); token.tally(); // The power of community governance! assert_eq!(token.balance_of(&amp;env.get_account(1)), U256::from(4000)); } }  ","version":"2.3.1","tagName":"h2"},{"title":"Migration guide to v0.8.0","type":0,"sectionRef":"#","url":"/docs/migrations/to-0.8.0","content":"","keywords":"","version":"2.3.1"},{"title":"1. Prerequisites​","type":1,"pageTitle":"Migration guide to v0.8.0","url":"/docs/migrations/to-0.8.0#1-prerequisites","content":"","version":"2.3.1","tagName":"h2"},{"title":"1.1. Update cargo-odra​","type":1,"pageTitle":"Migration guide to v0.8.0","url":"/docs/migrations/to-0.8.0#11-update-cargo-odra","content":"Before you begin the migration process, make sure you installed the latest version of the Cargo Odra toolchain. You can install it by running the following command: cargo install cargo-odra --force --locked  ","version":"2.3.1","tagName":"h3"},{"title":"1.2. Review the Changelog​","type":1,"pageTitle":"Migration guide to v0.8.0","url":"/docs/migrations/to-0.8.0#12-review-the-changelog","content":"Before you move to changing your code, start by reviewing the Changelog to understand the changes introduced in v0.8.0. ","version":"2.3.1","tagName":"h3"},{"title":"2. Migration Steps​","type":1,"pageTitle":"Migration guide to v0.8.0","url":"/docs/migrations/to-0.8.0#2-migration-steps","content":"","version":"2.3.1","tagName":"h2"},{"title":"2.1 Add bin directory​","type":1,"pageTitle":"Migration guide to v0.8.0","url":"/docs/migrations/to-0.8.0#21-add-bin-directory","content":"Odra 0.8.0 introduces a new way to build smart contracts. The .builder_casper directory is no longer used. Instead, you should create a new directory called bin in the root of your project and add the build_contract.rs and build_schema.rs files to the bin directory. You can find the build_contract.rs and build_schema.rs files in templates directory in the Odra main repository. You can choose whatever template you want to use and copy the files to your project. In both files, you should replace {{project-name}} with the name of your project. ","version":"2.3.1","tagName":"h3"},{"title":"2.2. Update Cargo.toml​","type":1,"pageTitle":"Migration guide to v0.8.0","url":"/docs/migrations/to-0.8.0#22-update-cargotoml","content":"There a bunch of changes in the Cargo.toml file. You don't have to specify the features anymore - remove the features section and default-features flag from the odra dependency.Register bins you added in the previous step.Add dev-dependencies section with odra-test crate.Add recommended profiles for release and dev to optimize the build process. Below you can compare the Cargo.toml file after and before the migration to v0.8.0: 0.8.0Prev [package] name = &quot;my_project&quot; version = &quot;0.1.0&quot; edition = &quot;2021&quot; [dependencies] odra = &quot;0.8.0&quot; [dev-dependencies] odra-test = &quot;0.8.0&quot; [[bin]] name = &quot;my_project_build_contract&quot; path = &quot;bin/build_contract.rs&quot; test = false [[bin]] name = &quot;my_project_build_schema&quot; path = &quot;bin/build_schema.rs&quot; test = false [profile.release] codegen-units = 1 lto = true [profile.dev.package.&quot;*&quot;] opt-level = 3  ","version":"2.3.1","tagName":"h3"},{"title":"2.2. Update Odra.toml​","type":1,"pageTitle":"Migration guide to v0.8.0","url":"/docs/migrations/to-0.8.0#22-update-odratoml","content":"Due to the changes in cargo-odra, the Odra.toml file has been simplified. The name property is no longer required. 0.8.0Prev [[contracts]] fqn = &quot;my_project::Flipper&quot;  ","version":"2.3.1","tagName":"h3"},{"title":"2.3. Update Smart Contracts​","type":1,"pageTitle":"Migration guide to v0.8.0","url":"/docs/migrations/to-0.8.0#23-update-smart-contracts","content":"The smart contracts themselves will need to be updated to work with the new version of the framework. The changes will depend on the specific features and APIs used in the contracts. Here are some common changes you might need to make: 2.3.1. Update the use statements to reflect the new module structure.​ Big integer types are now located in the odra::casper_types module.odra::types::Address is now odra::Address.Variable is now Var.Remove odra::contract_env.Remove odra::types::event::OdraEvent.Remove odra::types::OdraType as it is no longer required.Change odra::types::casper_types::*; to odra::casper_types::*;. 2.3.2. Some type aliases are no longer in use.​ Balance - use odra::casper_types::U512.BlockTime - use u64.EventData - use odra::casper_types::bytesrepr::Bytes. 2.3.3. Consider import odra::prelude::* in your module files.​ 2.3.4. Flatten nested Mappings.​ // Before #[odra::module(events = [Approval, Transfer])] pub struct Erc20 { ... allowances: Mapping&lt;Address, Mapping&lt;Address, U256&gt;&gt; } // After #[odra::module(events = [Approval, Transfer])] pub struct Erc20 { ... allowances: Mapping&lt;(Address, Address), U256&gt; }  2.3.5. Update errors definitions.​ execution_error! macro has been replace with OdraError derive macro. 0.8.0Prev use odra::OdraError; #[derive(OdraError)] pub enum Error { InsufficientBalance = 30_000, InsufficientAllowance = 30_001, NameNotSet = 30_002, SymbolNotSet = 30_003, DecimalsNotSet = 30_004 }  2.3.6. Update events definitions.​ 0.8.0Prev use odra::prelude::*; use odra::Event; #[derive(Event, Eq, PartialEq, Debug)] pub struct Transfer { pub from: Option&lt;Address&gt;, pub to: Option&lt;Address&gt;, pub amount: U256 } // Emitting the event self.env().emit_event(Transfer { from: None, to: Some(*address), amount: *amount });  2.3.7. Replace contract_env with self.env() in your modules.​ self.env() is a new way to access the contract environment, returns a reference to ContractEnv. The API is similar to the previous contract_env but with some changes. fn get_var&lt;T: FromBytes&gt;(key: &amp;[u8]) -&gt; Option&lt;T&gt; is now fn get_value&lt;T: FromBytes&gt;(&amp;self, key: &amp;[u8]) -&gt; Option&lt;T&gt;.fn set_var&lt;T: CLTyped + ToBytes&gt;(key: &amp;[u8], value: T) is now fn set_value&lt;T: ToBytes + CLTyped&gt;(&amp;self, key: &amp;[u8], value: T).set_dict_value() and get_dict_value() has been removed. All the dictionary operations should be performed using Mapping type, internally using set_var() and get_var() functions. fn hash&lt;T: AsRef&lt;[u8]&gt;&gt;(input: T) -&gt; Vec&lt;u8&gt; is now fn hash&lt;T: ToBytes&gt;(&amp;self, value: T) -&gt; [u8; 32].fn revert&lt;E: Into&lt;ExecutionError&gt;&gt;(error: E) -&gt; ! is now fn revert&lt;E: Into&lt;OdraError&gt;&gt;(&amp;self, error: E) -&gt; !.fn emit_event&lt;T: ToBytes + OdraEvent&gt;(event: T) is now fn emit_event&lt;T: ToBytes&gt;(&amp;self, event: T).fn call_contract&lt;T: CLTyped + FromBytes&gt;(address: Address, entrypoint: &amp;str, args: &amp;RuntimeArgs, amount: Option&lt;U512&gt;) -&gt; T is now fn call_contract&lt;T: FromBytes&gt;(&amp;self, address: Address, call: CallDef) -&gt; T.functions native_token_metadata() and one_token() have been removed. 2.3.8. Wrap submodules of your module with odra::SubModule&lt;T&gt;.​ 0.8.0Prev #[odra::module(events = [Transfer])] pub struct Erc721Token { core: SubModule&lt;Erc721Base&gt;, metadata: SubModule&lt;Erc721MetadataExtension&gt;, ownable: SubModule&lt;Ownable&gt; }  2.3.9. Update external contract calls.​ However the definition of an external contract remains the same, the way you call it has changed. A reference to an external contract is named {{ModuleName}}ContractRef (former {{ModuleName}}Ref) and you can call it using {{ModuleName}}ContractRef::new(env, address) (former {{ModuleName}}Ref::at()). 0.8.0Prev #[odra::external_contract] pub trait Token { fn balance_of(&amp;self, owner: &amp;Address) -&gt; U256; } // Usage TokenContractRef::new(env, token).balance_of(account)  2.3.10. Update constructors.​ Remove the #[odra::init] attribute from the constructor and ensure that the constructor function is named init. 2.3.11. Update UnwrapOrRevert calls.​ The functions unwrap_or_revert and unwrap_or_revert_with now require &amp;HostEnv as the first parameter. 2.3.12. Remove #[odra(using)] attribute from your module definition.​ Sharing the same instance of a module is no longer supported. A redesign of the module structure might be required. ","version":"2.3.1","tagName":"h3"},{"title":"2.4. Update Tests​","type":1,"pageTitle":"Migration guide to v0.8.0","url":"/docs/migrations/to-0.8.0#24-update-tests","content":"Once you've updated your smart contracts, you'll need to update your tests to reflect the changes. The changes will depend on the specific features and APIs used in the tests. Here are some common changes you might need to make: 2.4.1. Contract deployment.​ The way you deploy a contract has changed: You should use {{ModuleName}}HostRef::deploy(&amp;env, args) instead of {{ModuleName}}Deployer::init(). The {{ModuleName}}HostRef implements odra::host::Deployer.Instantiate the HostEnv using odra_test::env(), required by the odra::host::Deployer::deploy() function.If the contract doesn't have init args, you should use odra::host::NoArgs as the second argument of the deploy function.If the contract has init args, you should pass the autogenerated {{ModuleName}}InitArgs as the second argument of the deploy function. 0.8.0Prev // A contract without init args use super::OwnableHostRef; use odra::host::{Deployer, HostEnv, HostRef, NoArgs}; let env: HostEnv = odra_test::env(); let ownable = OwnableHostRef::deploy(&amp;env, NoArgs) // A contract with init args use super::{Erc20HostRef, Erc20InitArgs}; use odra::host::{Deployer, HostEnv}; let env: HostEnv = odra_test::env(); let init_args = Erc20InitArgs { symbol: SYMBOL.to_string(), name: NAME.to_string(), decimals: DECIMALS, initial_supply: Some(INITIAL_SUPPLY.into()) }; let erc20 = Erc20HostRef::deploy(&amp;env, init_args);  2.4.2. Host interactions.​ Replace odra::test_env with odra_test::env().The API of odra::test_env and odra_test::env() are similar, but there are some differences: test_env::advance_block_time_by(BlockTime) is now env.advance_block_time(u64).test_env::token_balance(Address) is now env.balance_of(&amp;Address).functions test_env::last_call_contract_gas_cost(), test_env::last_call_contract_gas_used(), test_env::total_gas_used(Address), test_env::gas_report() have been removed. You should use HostRef::last_call() and extract the data from a odra::ContractCallResult instance. HostRef is a trait implemented by {{ModuleName}}HostRef. 2.4.3. Testing failing scenarios.​ test_env::assert_exception() has been removed. You should use the try_ prefix to call the function and then assert the result.try_ prefix is a new way to call a function that might fail. It returns a OdraResult type, which you can then assert using the standard Rust assert_eq! macro. 0.8.0Prev #[test] fn transfer_from_error() { let (env, mut erc20) = setup(); let (owner, spender, recipient) = (env.get_account(0), env.get_account(1), env.get_account(2)); let amount = 1_000.into(); env.set_caller(spender); assert_eq!( erc20.try_transfer_from(owner, recipient, amount), Err(Error::InsufficientAllowance.into()) ); }  2.4.4. Testing events.​ assert_events! macro has been removed. You should use HostEnv::emitted_event() to assert the emitted events. The new API doesn't allow to assert multiple events at once, but adds alternative ways to assert the emitted events. Check the HostEnv documentation to explore the available options. 0.8.0Prev let env: HostEnv = odra_test::env(); let erc20 = Erc20HostRef::deploy(&amp;env, init_args); ... assert!(env.emitted_event( erc20.address(), &amp;Approval { owner, spender, value: approved_amount - transfer_amount } )); assert!(env.emitted_event( erc20.address(), &amp;Transfer { from: Some(owner), to: Some(recipient), amount: transfer_amount } ));  ","version":"2.3.1","tagName":"h3"},{"title":"3. Code Examples​","type":1,"pageTitle":"Migration guide to v0.8.0","url":"/docs/migrations/to-0.8.0#3-code-examples","content":"Here is a complete example of a smart contract after and before the migration to v0.8.0. 0.8.0Prev src/erc20.rs use crate::erc20::errors::Error::*; use crate::erc20::events::*; use odra::prelude::*; use odra::{casper_types::U256, Address, Mapping, Var}; #[odra::module(events = [Approval, Transfer])] pub struct Erc20 { decimals: Var&lt;u8&gt;, symbol: Var&lt;String&gt;, name: Var&lt;String&gt;, total_supply: Var&lt;U256&gt;, balances: Mapping&lt;Address, U256&gt;, allowances: Mapping&lt;(Address, Address), U256&gt; } #[odra::module] impl Erc20 { pub fn init( &amp;mut self, symbol: String, name: String, decimals: u8, initial_supply: Option&lt;U256&gt; ) { let caller = self.env().caller(); self.symbol.set(symbol); self.name.set(name); self.decimals.set(decimals); if let Some(initial_supply) = initial_supply { self.total_supply.set(initial_supply); self.balances.set(&amp;caller, initial_supply); if !initial_supply.is_zero() { self.env().emit_event(Transfer { from: None, to: Some(caller), amount: initial_supply }); } } } pub fn transfer(&amp;mut self, recipient: &amp;Address, amount: &amp;U256) { let caller = self.env().caller(); self.raw_transfer(&amp;caller, recipient, amount); } pub fn transfer_from(&amp;mut self, owner: &amp;Address, recipient: &amp;Address, amount: &amp;U256) { let spender = self.env().caller(); self.spend_allowance(owner, &amp;spender, amount); self.raw_transfer(owner, recipient, amount); } pub fn approve(&amp;mut self, spender: &amp;Address, amount: &amp;U256) { let owner = self.env().caller(); self.allowances.set(&amp;(owner, *spender), *amount); self.env().emit_event(Approval { owner, spender: *spender, value: *amount }); } pub fn name(&amp;self) -&gt; String { self.name.get_or_revert_with(NameNotSet) } // Other getter functions... pub fn allowance(&amp;self, owner: &amp;Address, spender: &amp;Address) -&gt; U256 { self.allowances.get_or_default(&amp;(*owner, *spender)) } pub fn mint(&amp;mut self, address: &amp;Address, amount: &amp;U256) { self.total_supply.add(*amount); self.balances.add(address, *amount); self.env().emit_event(Transfer { from: None, to: Some(*address), amount: *amount }); } pub fn burn(&amp;mut self, address: &amp;Address, amount: &amp;U256) { if self.balance_of(address) &lt; *amount { self.env().revert(InsufficientBalance); } self.total_supply.subtract(*amount); self.balances.subtract(address, *amount); self.env().emit_event(Transfer { from: Some(*address), to: None, amount: *amount }); } } impl Erc20 { fn raw_transfer(&amp;mut self, owner: &amp;Address, recipient: &amp;Address, amount: &amp;U256) { if *amount &gt; self.balances.get_or_default(owner) { self.env().revert(InsufficientBalance) } self.balances.subtract(owner, *amount); self.balances.add(recipient, *amount); self.env().emit_event(Transfer { from: Some(*owner), to: Some(*recipient), amount: *amount }); } fn spend_allowance(&amp;mut self, owner: &amp;Address, spender: &amp;Address, amount: &amp;U256) { let allowance = self.allowances.get_or_default(&amp;(*owner, *spender)); if allowance &lt; *amount { self.env().revert(InsufficientAllowance) } self.allowances.subtract(&amp;(*owner, *spender), *amount); self.env().emit_event(Approval { owner: *owner, spender: *spender, value: allowance - *amount }); } } pub mod events { use odra::prelude::*; use odra::{casper_types::U256, Address, Event}; #[derive(Event, Eq, PartialEq, Debug)] pub struct Transfer { pub from: Option&lt;Address&gt;, pub to: Option&lt;Address&gt;, pub amount: U256 } #[derive(Event, Eq, PartialEq, Debug)] pub struct Approval { pub owner: Address, pub spender: Address, pub value: U256 } } pub mod errors { use odra::OdraError; #[derive(OdraError)] pub enum Error { InsufficientBalance = 30_000, InsufficientAllowance = 30_001, NameNotSet = 30_002, SymbolNotSet = 30_003, DecimalsNotSet = 30_004 } } #[cfg(test)] mod tests { use super::{ errors::Error, events::{Approval, Transfer}, Erc20HostRef, Erc20InitArgs }; use odra::{ casper_types::U256, host::{Deployer, HostEnv, HostRef}, prelude::* }; const NAME: &amp;str = &quot;Plascoin&quot;; const SYMBOL: &amp;str = &quot;PLS&quot;; const DECIMALS: u8 = 10; const INITIAL_SUPPLY: u32 = 10_000; fn setup() -&gt; (HostEnv, Erc20HostRef) { let env = odra_test::env(); ( env.clone(), Erc20HostRef::deploy( &amp;env, Erc20InitArgs { symbol: SYMBOL.to_string(), name: NAME.to_string(), decimals: DECIMALS, initial_supply: Some(INITIAL_SUPPLY.into()) } ) ) } #[test] fn initialization() { // When deploy a contract with the initial supply. let (env, erc20) = setup(); // Then the contract has the metadata set. assert_eq!(erc20.symbol(), SYMBOL.to_string()); assert_eq!(erc20.name(), NAME.to_string()); assert_eq!(erc20.decimals(), DECIMALS); // Then the total supply is updated. assert_eq!(erc20.total_supply(), INITIAL_SUPPLY.into()); // Then a Transfer event was emitted. assert!(env.emitted_event( erc20.address(), &amp;Transfer { from: None, to: Some(env.get_account(0)), amount: INITIAL_SUPPLY.into() } )); } #[test] fn transfer_works() { // Given a new contract. let (env, mut erc20) = setup(); // When transfer tokens to a recipient. let sender = env.get_account(0); let recipient = env.get_account(1); let amount = 1_000.into(); erc20.transfer(&amp;recipient, &amp;amount); // Then the sender balance is deducted. assert_eq!( erc20.balance_of(&amp;sender), U256::from(INITIAL_SUPPLY) - amount ); // Then the recipient balance is updated. assert_eq!(erc20.balance_of(&amp;recipient), amount); // Then Transfer event was emitted. assert!(env.emitted_event( erc20.address(), &amp;Transfer { from: Some(sender), to: Some(recipient), amount } )); } #[test] fn transfer_error() { // Given a new contract. let (env, mut erc20) = setup(); // When the transfer amount exceeds the sender balance. let recipient = env.get_account(1); let amount = U256::from(INITIAL_SUPPLY) + U256::one(); // Then an error occurs. assert!(erc20.try_transfer(&amp;recipient, &amp;amount).is_err()); } // Other tests... }  ","version":"2.3.1","tagName":"h2"},{"title":"4. Troubleshooting​","type":1,"pageTitle":"Migration guide to v0.8.0","url":"/docs/migrations/to-0.8.0#4-troubleshooting","content":"If you encounter any further issues after completing the migration steps, please don't hesitate to reach out to us on Discord or explore the other sections this documentation. You can also refer to the technical documentation for more detailed information. Additionally, our examples repository offers a wide range of examples to assist you in understanding the new features and APIs. Be sure to carefully review any compilation errors and warnings, as they may provide valuable insights into the necessary adjustments. ","version":"2.3.1","tagName":"h2"},{"title":"5. References​","type":1,"pageTitle":"Migration guide to v0.8.0","url":"/docs/migrations/to-0.8.0#5-references","content":"ChangelogOdra DocumentationDocs.rsExamples ","version":"2.3.1","tagName":"h2"},{"title":"ERC-20","type":0,"sectionRef":"#","url":"/docs/tutorials/erc20","content":"","keywords":"","version":"2.3.1"},{"title":"Framework features​","type":1,"pageTitle":"ERC-20","url":"/docs/tutorials/erc20#framework-features","content":"A module we will write in a minute, will help you master a few Odra features: Advanced storage using key-value pairs,Odra types such as Address,Advanced event assertion. ","version":"2.3.1","tagName":"h2"},{"title":"Code​","type":1,"pageTitle":"ERC-20","url":"/docs/tutorials/erc20#code","content":"Our module features a considerably more complex storage layout compared to the previous example. It is designed to store the following data: Immutable metadata - name, symbol, and decimals.Total supply.Balances of individual users.Allowances, essentially indicating who is permitted to spend tokens on behalf of another user. ","version":"2.3.1","tagName":"h2"},{"title":"Module definition​","type":1,"pageTitle":"ERC-20","url":"/docs/tutorials/erc20#module-definition","content":"erc20.rs use odra::prelude::*; use odra::casper_types::U256; #[odra::module(events = [Transfer, Approval], errors = Error)] pub struct Erc20 { decimals: Var&lt;u8&gt;, symbol: Var&lt;String&gt;, name: Var&lt;String&gt;, total_supply: Var&lt;U256&gt;, balances: Mapping&lt;Address, U256&gt;, allowances: Mapping&lt;(Address, Address), U256&gt; }  L10 - For the first time, we need to store key-value pairs. In order to do that, we use Mapping. The name is taken after Solidity's native type mapping.L11 - Odra does not allows nested Mappings as Solidity does. Instead, you can create a compound key using a tuple of keys. ","version":"2.3.1","tagName":"h2"},{"title":"Metadata​","type":1,"pageTitle":"ERC-20","url":"/docs/tutorials/erc20#metadata","content":"erc20.rs #[odra::module] impl Erc20 { pub fn init(&amp;mut self, name: String, symbol: String, decimals: u8, initial_supply: U256) { let caller = self.env().caller(); self.name.set(name); self.symbol.set(symbol); self.decimals.set(decimals); self.mint(&amp;caller, &amp;initial_supply); } pub fn name(&amp;self) -&gt; String { self.name.get_or_default() } pub fn symbol(&amp;self) -&gt; String { self.symbol.get_or_default() } pub fn decimals(&amp;self) -&gt; u8 { self.decimals.get_or_default() } pub fn total_supply(&amp;self) -&gt; U256 { self.total_supply.get_or_default() } } impl Erc20 { pub fn mint(&amp;mut self, address: &amp;Address, amount: &amp;U256) { self.balances.add(address, *amount); self.total_supply.add(*amount); self.env().emit_event(Transfer { from: None, to: Some(*address), amount: *amount }); } } #[odra::event] pub struct Transfer { pub from: Option&lt;Address&gt;, pub to: Option&lt;Address&gt;, pub amount: U256 }  L1 - The first impl block, marked as a module, contains functions defined in the ERC-20 standard.L3-L9 - A constructor sets the token metadata and mints the initial supply.L28 - The second impl is not an Odra module; in other words, these functions will not be part of the contract's public interface.L29-L38 - The mint function is public, so, like in regular Rust code, it will be accessible from the outside. mint() uses the notation self.balances.add(address, *amount);, which is syntactic sugar for: let current_balance = self.balances.get(address).unwrap_or_default(); let new_balance = &lt;U256 as OverflowingAdd&gt;::overflowing_add(current_balance, current_balance).unwrap_or_revert(&amp;self.env()); self.balances.set(address, new_balance);  ","version":"2.3.1","tagName":"h3"},{"title":"Core​","type":1,"pageTitle":"ERC-20","url":"/docs/tutorials/erc20#core","content":"To ensure comprehensive functionality, let's implement the remaining features such as transfer, transfer_from, and approve. Since they do not introduce any new concepts, we will present them without additional remarks. erc20.rs #[odra::module] impl Erc20 { ... pub fn transfer(&amp;mut self, recipient: &amp;Address, amount: &amp;U256) { let caller = self.env().caller(); self.raw_transfer(&amp;caller, recipient, amount); } pub fn transfer_from(&amp;mut self, owner: &amp;Address, recipient: &amp;Address, amount: &amp;U256) { let spender = self.env().caller(); self.spend_allowance(owner, &amp;spender, amount); self.raw_transfer(owner, recipient, amount); } pub fn approve(&amp;mut self, spender: &amp;Address, amount: &amp;U256) { let owner = self.env().caller(); self.allowances.set(&amp;(owner, *spender), *amount); self.env().emit_event(Approval { owner, spender: *spender, value: *amount }); } pub fn balance_of(&amp;self, address: &amp;Address) -&gt; U256 { self.balances.get_or_default(&amp;address) } pub fn allowance(&amp;self, owner: &amp;Address, spender: &amp;Address) -&gt; U256 { self.allowances.get_or_default(&amp;(*owner, *spender)) } } impl Erc20 { ... fn raw_transfer(&amp;mut self, owner: &amp;Address, recipient: &amp;Address, amount: &amp;U256) { let owner_balance = self.balances.get_or_default(&amp;owner); if *amount &gt; owner_balance { self.env().revert(Error::InsufficientBalance) } self.balances.set(owner, owner_balance - *amount); self.balances.add(recipient, *amount); self.env().emit_event(Transfer { from: Some(*owner), to: Some(*recipient), amount: *amount }); } fn spend_allowance(&amp;mut self, owner: &amp;Address, spender: &amp;Address, amount: &amp;U256) { let allowance = self.allowance(owner, spender); if allowance &lt; *amount { self.env().revert(Error::InsufficientAllowance) } let new_allowance = allowance - *amount; self.allowances .set(&amp;(*owner, *spender), new_allowance); self.env().emit_event(Approval { owner: *owner, spender: *spender, value: allowance - *amount }); } } #[odra::event] pub struct Approval { pub owner: Address, pub spender: Address, pub value: U256 } #[odra::odra_error] pub enum Error { InsufficientBalance = 1, InsufficientAllowance = 2, }  Now, compare the code we have written, with Open Zeppelin code. Out of 10, how Solidity-ish is our implementation? ","version":"2.3.1","tagName":"h3"},{"title":"Test​","type":1,"pageTitle":"ERC-20","url":"/docs/tutorials/erc20#test","content":"erc20.rs #[cfg(test)] pub mod tests { use super::*; use odra::{ casper_types::U256, host::{Deployer, HostEnv}, prelude::* }; const NAME: &amp;str = &quot;Plascoin&quot;; const SYMBOL: &amp;str = &quot;PLS&quot;; const DECIMALS: u8 = 10; const INITIAL_SUPPLY: u32 = 10_000; fn setup() -&gt; (HostEnv, Erc20HostRef) { let env = odra_test::env(); ( env.clone(), Erc20::deploy( &amp;env, Erc20InitArgs { symbol: SYMBOL.to_string(), name: NAME.to_string(), decimals: DECIMALS, initial_supply: INITIAL_SUPPLY.into() } ) ) } #[test] fn initialization() { // When deploy a contract with the initial supply. let (env, erc20) = setup(); // Then the contract has the metadata set. assert_eq!(erc20.symbol(), SYMBOL.to_string()); assert_eq!(erc20.name(), NAME.to_string()); assert_eq!(erc20.decimals(), DECIMALS); // Then the total supply is updated. assert_eq!(erc20.total_supply(), INITIAL_SUPPLY.into()); // Then a Transfer event was emitted. assert!(env.emitted_event( &amp;erc20, &amp;Transfer { from: None, to: Some(env.get_account(0)), amount: INITIAL_SUPPLY.into() } )); } #[test] fn transfer_works() { // Given a new contract. let (env, mut erc20) = setup(); // When transfer tokens to a recipient. let sender = env.get_account(0); let recipient = env.get_account(1); let amount = 1_000.into(); erc20.transfer(&amp;recipient, &amp;amount); // Then the sender balance is deducted. assert_eq!( erc20.balance_of(&amp;sender), U256::from(INITIAL_SUPPLY) - amount ); // Then the recipient balance is updated. assert_eq!(erc20.balance_of(&amp;recipient), amount); // Then Transfer event was emitted. assert!(env.emitted_event( &amp;erc20, &amp;Transfer { from: Some(sender), to: Some(recipient), amount } )); } #[test] fn transfer_error() { // Given a new contract. let (env, mut erc20) = setup(); // When the transfer amount exceeds the sender balance. let recipient = env.get_account(1); let amount = U256::from(INITIAL_SUPPLY) + U256::one(); // Then an error occurs. assert!(erc20.try_transfer(&amp;recipient, &amp;amount).is_err()); } #[test] fn transfer_from_and_approval_work() { let (env, mut erc20) = setup(); let (owner, recipient, spender) = (env.get_account(0), env.get_account(1), env.get_account(2)); let approved_amount = 3_000.into(); let transfer_amount = 1_000.into(); assert_eq!(erc20.balance_of(&amp;owner), U256::from(INITIAL_SUPPLY)); // Owner approves Spender. erc20.approve(&amp;spender, &amp;approved_amount); // Allowance was recorded. assert_eq!(erc20.allowance(&amp;owner, &amp;spender), approved_amount); assert!(env.emitted_event( &amp;erc20, Approval { owner, spender, value: approved_amount } )); // Spender transfers tokens from Owner to Recipient. env.set_caller(spender); erc20.transfer_from(&amp;owner, &amp;recipient, &amp;transfer_amount); // Tokens are transferred and allowance decremented. assert_eq!( erc20.balance_of(&amp;owner), U256::from(INITIAL_SUPPLY) - transfer_amount ); assert_eq!(erc20.balance_of(&amp;recipient), transfer_amount); assert!(env.emitted_event( &amp;erc20, Approval { owner, spender, value: approved_amount - transfer_amount } )); assert!(env.emitted_event( &amp;erc20, Transfer { from: Some(owner), to: Some(recipient), amount: transfer_amount } )); // assert!(env.emitted(&amp;erc20, &quot;Transfer&quot;)); } #[test] fn transfer_from_error() { // Given a new instance. let (env, mut erc20) = setup(); // When the spender's allowance is zero. let (owner, spender, recipient) = (env.get_account(0), env.get_account(1), env.get_account(2)); let amount = 1_000.into(); env.set_caller(spender); // Then transfer fails. assert_eq!( erc20.try_transfer_from(&amp;owner, &amp;recipient, &amp;amount), Err(Error::InsufficientAllowance.into()) ); } }  L146 - Alternatively, if you don't want to check the entire event, you may assert only its type. ","version":"2.3.1","tagName":"h3"},{"title":"What's next​","type":1,"pageTitle":"ERC-20","url":"/docs/tutorials/erc20#whats-next","content":"Having two modules: Ownable and Erc20, let's combine them, and create an ERC-20 on steroids. ","version":"2.3.1","tagName":"h2"},{"title":"Ticketing System","type":0,"sectionRef":"#","url":"/docs/tutorials/nft","content":"","keywords":"","version":"2.3.1"},{"title":"Ticket Office Contract​","type":1,"pageTitle":"Ticketing System","url":"/docs/tutorials/nft#ticket-office-contract","content":"Our TicketOffice contract will include the following features: Compliance with the CEP-78 standard.Ownership functionality.Only the owner can issue new event tickets.Users can purchase tickets for events.Tickets are limited to a one-time sale.Public access to view the total income of the TicketOffice. ","version":"2.3.1","tagName":"h2"},{"title":"Setup the project​","type":1,"pageTitle":"Ticketing System","url":"/docs/tutorials/nft#setup-the-project","content":"Creating a new NFT token with Odra is straightforward. Use the cargo odra new command to create a new project with the CEP-95 template: cargo odra new --name ticket-office --template cep95  ","version":"2.3.1","tagName":"h2"},{"title":"Contract implementation​","type":1,"pageTitle":"Ticketing System","url":"/docs/tutorials/nft#contract-implementation","content":"Let's start implementing the TicketOffice contract by modify the code generated from the template. src/token.rs use odra::{casper_types::{U256, U512}, prelude::*}; use odra_modules::access::Ownable; use odra_modules::cep95::{CEP95Interface, Cep95}; pub type TicketId = U256; #[odra::odra_type] pub enum TicketStatus { Available, Sold, } #[odra::odra_type] pub struct TicketInfo { event_name: String, price: U512, status: TicketStatus, } #[odra::event] pub struct OnTicketIssue { ticket_id: TicketId, event_name: String, price: U512, } #[odra::event] pub struct OnTicketSell { ticket_id: TicketId, buyer: Address, } #[odra::odra_error] pub enum Error { TicketNotAvailableForSale = 200, InsufficientFunds = 201, InvalidTicketId = 202, TicketDoesNotExist = 203, } #[odra::module( events = [OnTicketIssue, OnTicketSell], errors = Error )] pub struct TicketOffice { token: SubModule&lt;Cep95&gt;, ownable: SubModule&lt;Ownable&gt;, tickets: Mapping&lt;TicketId, TicketInfo&gt;, token_id_counter: Var&lt;TicketId&gt;, total_supply: Var&lt;u64&gt;, } #[odra::module] impl TicketOffice { pub fn init(&amp;mut self, collection_name: String, collection_symbol: String, total_supply: u64) { let caller = self.env().caller(); self.ownable.init(caller); self.token.init(collection_name, collection_symbol); } pub fn issue_ticket(&amp;mut self, event_name: String, price: U512) { let env = self.env(); let caller = env.caller(); self.ownable.assert_owner(&amp;caller); // mint a new token let ticket_id = self.token_id_counter.get_or_default(); self.token.mint(caller, ticket_id, Default::default()); // store ticket info self.tickets.set( &amp;ticket_id, TicketInfo { event_name: event_name.clone(), price, status: TicketStatus::Available, }, ); self.token_id_counter.set(ticket_id + 1); // emit an event env.emit_event(OnTicketIssue { ticket_id, event_name, price, }); } #[odra(payable)] pub fn buy_ticket(&amp;mut self, ticket_id: TicketId) { let env = self.env(); let owner = self.ownable.get_owner(); let buyer = env.caller(); let value = env.attached_value(); // only tokens owned by the owner can be sold if self.token.owner_of(ticket_id) != Some(owner) { env.revert(Error::TicketNotAvailableForSale); } let mut ticket = self .tickets .get(&amp;ticket_id) .unwrap_or_revert_with(&amp;env, Error::TicketDoesNotExist); // only available tickets can be sold if ticket.status != TicketStatus::Available { env.revert(Error::TicketNotAvailableForSale); } // check if the buyer sends enough funds if value &lt; ticket.price { env.revert(Error::InsufficientFunds); } // transfer csprs to the owner env.transfer_tokens(&amp;owner, &amp;value); // transfer the ticket to the buyer self.token.transfer_from(owner, buyer, ticket_id); ticket.status = TicketStatus::Sold; self.tickets.set(&amp;ticket_id, ticket); env.emit_event(OnTicketSell { ticket_id, buyer }); } pub fn balance_of(&amp;self) -&gt; U512 { self.env().self_balance() } }  L7-L39 - We define structures and enums that will be used in our contract. TicketStatus enum represents the status of a ticket, TicketInfo struct contains information about a ticket that is written to the storage, TicketId is a type alias for u64. OnTicketIssue and OnTicketSell are events that will be emitted when a ticket is issued or sold.L41-L44 - Register errors and events that will be used in our contract, required to produce a complete contract schema.L45-L51 - TicketOffice module definition. The module contains a Cep95 token, an Ownable module, a Mapping that stores information about tickets and Vars token_id_counter and total_supply to keep track of the total number of tickets issued.L55-L59 - The init function has been generated from the template and there is no need to modify it, except the Ownable module initialization.L61-L84 - The issue_ticket function allows the owner to issue a new ticket. The function mints a new token, stores information about the ticket, and emits an OnTicketIssue event.L86 - The payable attribute indicates that the buy_ticket function can receive funds.L87-L116 - The buy_ticket function checks if the ticket is available for sale, if the buyer sends enough funds, and transfers the ticket to the buyer. Finally, the function updates the ticket status and emits an OnTicketSell event. Lets test the contract. The test scenario will be as follows: Deploy the contract.Issue two tickets.Try to buy a ticket with insufficient funds.Buy tickets.Try to buy the same ticket again.Check the balance of the contract. src/tests.rs use odra::{ casper_types::U512, host::{Deployer, HostRef}, }; use crate::token::{Error, TicketOfficeHostRef, TicketOfficeInitArgs}; #[test] fn it_works() { let env = odra_test::env(); let init_args = TicketOfficeInitArgs { collection_name: &quot;Ticket&quot;.to_string(), collection_symbol: &quot;T&quot;.to_string(), total_supply: 100, }; let mut contract = TicketOffice::deploy(&amp;env, init_args); contract.issue_ticket(&quot;Ev&quot;.to_string(), U512::from(100)); contract.issue_ticket(&quot;Ev&quot;.to_string(), U512::from(50)); let buyer = env.get_account(1); env.set_caller(buyer); assert_eq!( contract .with_tokens(U512::from(50)) .try_buy_ticket(0.into()), Err(Error::InsufficientFunds.into()) ); assert_eq!( contract .with_tokens(U512::from(100)) .try_buy_ticket(0.into()), Ok(()) ); assert_eq!( contract .with_tokens(U512::from(50)) .try_buy_ticket(1.into()), Ok(()) ); assert_eq!( contract .with_tokens(U512::from(100)) .try_buy_ticket(0.into()), Err(Error::TicketNotAvailableForSale.into()) ); }  Unfortunately, the test failed. The first assertion succeeds because the buyer sends insufficient funds to buy the ticket. However, the second assertion fails even though the buyer sends enough funds to purchase the ticket. The buy_ticket function reverts with CEP-95 Error::NotAnOwnerOrApproved because the buyer attempts to transfer a token that they do not own, are not approved for, or are not an operator of. odra/modules/src/cep95.rs fn transfer_from(&amp;mut self, from: Address, to: Address, token_id: U256) { self.assert_exists(&amp;token_id); let caller = self.env().caller(); let owner = self .owner_of(token_id) .unwrap_or_revert_with(self, Error::ValueNotSet); // Only the owner or an approved spender can transfer the token. if (owner != from || owner != caller) &amp;&amp; !self.is_approved_for_all(from, caller) { if let Some(approved) = self.approved_for(token_id) { if approved != caller { self.env().revert(Error::NotAnOwnerOrApproved); } } else { self.env().revert(Error::NotAnOwnerOrApproved); } } ... }  Let's fix it by redesigning our little system. ","version":"2.3.1","tagName":"h2"},{"title":"Redesign​","type":1,"pageTitle":"Ticketing System","url":"/docs/tutorials/nft#redesign","content":"Since a buyer cannot purchase a ticket directly, we need to introduce an intermediary — an operator who will be responsible for buying tickets on behalf of the buyer. The operator will be approved by the ticket office to transfer tickets. The sequence diagram below illustrates the new flow: ","version":"2.3.1","tagName":"h2"},{"title":"Ticket Operator Contract​","type":1,"pageTitle":"Ticketing System","url":"/docs/tutorials/nft#ticket-operator-contract","content":"As shown in the sequence diagram, a new contract will act as an operator for the ticket office. To create this new contract, use the cargo odra generate command. cargo odra generate -c ticket_operator  src/ticket_operator.rs use crate::token::{TicketId, TicketOfficeContractRef}; use odra::{casper_types::{U256, U512}, ContractRef, prelude::*}; #[odra::odra_error] pub enum Error { UnknownTicketOffice = 300, } #[odra::module(errors = Error)] pub struct TicketOperator { ticket_office_address: Var&lt;Address&gt;, } #[odra::module] impl TicketOperator { pub fn register(&amp;mut self, ticket_office_address: Address) { self.ticket_office_address.set(ticket_office_address); } // now the operator's `buy_ticket` receives funds. #[odra(payable)] pub fn buy_ticket(&amp;mut self, ticket_id: TicketId) { let env = self.env(); let buyer = env.caller(); let value = env.attached_value(); let center = self .ticket_office_address .get() .unwrap_or_revert_with(&amp;env, Error::UnknownTicketOffice); let mut ticket_contract = TicketOfficeContractRef::new(env, center); // now and approved entity - the operator - buys the ticket on behalf of the buyer ticket_contract.buy_ticket(ticket_id, buyer, value); } pub fn balance_of(&amp;self) -&gt; U512 { self.env().self_balance() } }  L4-L7 - Define errors that will be used in the contract.L9-L13 - Define the TicketOperator module that stores the address of the ticketing office.L16-L18 - The register function sets the address of the ticketing office.L20-L32 - The buy_ticket function buys a ticket on behalf of the buyer using the ticket office address. The function forwards the call to the ticketing office contract. We simply create a TicketOfficeContractRef to interact we the TicketOffice contract. Note that, the operator's buy_ticket now receives funds. Now we need to adjust the TicketOffice contract to use the TicketOperator contract to buy tickets. src/token.rs #[odra::odra_error] pub enum Error { ... MissingOperator = 204, Unauthorized = 205, } #[odra::module] pub struct TicketOffice { ... operator: Var&lt;Address&gt;, } #[odra::module] impl TicketOffice { ... pub fn register_operator(&amp;mut self, operator: Address) { // only the owner can register an operator let caller = self.env().caller(); self.ownable.assert_owner(&amp;caller); // store the ticketing center address in the operator contract TicketOperatorContractRef::new(self.env(), operator).register(self.env().self_address()); self.operator.set(operator); } pub fn issue_ticket(&amp;mut self, event_name: String, price: U512) { // minting logic remains the same... ... // approve the operator to transfer the ticket let operator = self.operator(); self.token.approve(operator, ticket_id); // emit an event ... } pub fn buy_ticket(&amp;mut self, ticket_id: TicketId, buyer: Address, value: U512) { let env = self.env(); let owner = self.ownable.get_owner(); let caller = env.caller(); // make sure the caller is the operator if !self.is_operator(caller) { env.revert(Error::Unauthorized); } ... // the logic remains the same, except for the csprs transfer // it is now handled by the operator contract. // env.transfer_tokens(&amp;owner, &amp;value); } #[inline] fn is_operator(&amp;self, caller: Address) -&gt; bool { Some(caller) == self.operator.get() } #[inline] fn operator(&amp;self) -&gt; Address { self.operator .get() .unwrap_or_revert_with(&amp;self.env(), Error::MissingOperator) } }  L11 - the contract stores the operator address.L18-L25 - a new function register_operator allows the owner to register an operator. Also calls the register entry point on the operator contract.L32-36 - modify the issue_ticket function: once a new token is minted, approves the operator to transfer the ticket later.L40-L53 - modify the buy_ticket function: check if the caller is the operator, do not transfer cspr to the contract - now the operator collect funds.We also added two helper functions: is_operator and operator to check if the caller is the operator and get the operator address. Two new errors were added: MissingOperator and Unauthorized. Now we need to update our tests to create a scenario we presented in the sequence diagram. src/tests.rs use odra::{ casper_types::U512, host::{Deployer, HostRef, NoArgs}, prelude::* }; use crate::{ ticket_operator::TicketOperatorHostRef, token::{Error, TicketId, TicketOfficeContractRef, TicketOfficeInitArgs}, }; #[test] fn it_works() { let env = odra_test::env(); let init_args = TicketOfficeInitArgs { collection_name: &quot;Ticket&quot;.to_string(), collection_symbol: &quot;T&quot;.to_string(), total_supply: 100, }; let operator = TicketOperator::deploy(&amp;env, NoArgs); let mut ticket_office = TicketOfficeContractRef::deploy(&amp;env, init_args); ticket_office.register_operator(operator.address().clone()); ticket_office.issue_ticket(&quot;Ev&quot;.to_string(), U512::from(100)); ticket_office.issue_ticket(&quot;Ev&quot;.to_string(), U512::from(50)); let buyer = env.get_account(1); env.set_caller(buyer); assert_eq!( buy_ticket(&amp;operator, 0.into(), 50), Err(Error::InsufficientFunds.into()) ); assert_eq!(buy_ticket(&amp;operator, 0.into(), 100), Ok(())); assert_eq!(buy_ticket(&amp;operator, 1.into(), 50), Ok(())); assert_eq!( buy_ticket(&amp;operator, 0.into(), 100), Err(Error::TicketNotAvailableForSale.into()) ); assert_eq!(operator.balance_of(), U512::from(150)); } fn buy_ticket(operator: &amp;TicketOperatorHostRef, id: TicketId, price: u64) -&gt; OdraResult&lt;()&gt; { operator.with_tokens(U512::from(price)).try_buy_ticket(id) }  ","version":"2.3.1","tagName":"h3"},{"title":"Conclusion​","type":1,"pageTitle":"Ticketing System","url":"/docs/tutorials/nft#conclusion","content":"In this tutorial, we created a simple ticketing system using the CEP-95 standard. This guide demonstrates how to combine various Odra features, including modules, events, errors, payable functions, and cross-contract calls. ","version":"2.3.1","tagName":"h2"},{"title":"Odra CLI","type":0,"sectionRef":"#","url":"/docs/tutorials/odra-cli","content":"","keywords":"","version":"2.3.1"},{"title":"Example​","type":1,"pageTitle":"Odra CLI","url":"/docs/tutorials/odra-cli#example","content":"Let's go through an example available in the odra repository to see how to use the Odra CLI library. It creates a CLI tool for a useful DogContract. ","version":"2.3.1","tagName":"h2"},{"title":"Cargo.toml​","type":1,"pageTitle":"Odra CLI","url":"/docs/tutorials/odra-cli#cargotoml","content":"To use the Odra CLI library in your project, you need to add odra-cli to your Cargo.toml file, alongside a new binary: [dependencies] ... odra-cli = &quot;2&quot; ... [[bin]] name = &quot;odra-cli&quot; path = &quot;bin/odra-cli.rs&quot;  Then, create an empty file in the bin directory named odra-cli.rs. ","version":"2.3.1","tagName":"h3"},{"title":"Deploy script​","type":1,"pageTitle":"Odra CLI","url":"/docs/tutorials/odra-cli#deploy-script","content":"The first type of script we can create is a deploy script. It is used to deploy the contract to the network and store the address of the deployed contract in a container for later use. Only one deploy script can be used in a single CLI tool, and it is executed when the user runs the deploy command. bin/odra-cli.rs use odra::host::HostEnv; use odra_cli::{ deploy::DeployScript, DeployerExt, DeployedContractsContainer, }; use odra_examples::features::storage::variable::{DogContract, DogContractInitArgs}; /// Deploys the `DogContract` and adds it to the container. pub struct DeployDogScript; impl DeployScript for DeployDogScript { fn deploy( &amp;self, env: &amp;HostEnv, container: &amp;mut DeployedContractsContainer ) -&gt; Result&lt;(), odra_cli::deploy::Error&gt; { env.set_gas(350_000_000_000); let dog_contract = DogContract::try_deploy( env, DogContractInitArgs { barks: true, weight: 10, name: &quot;Mantus&quot;.to_string() } )?; container.add_contract(&amp;dog_contract)?; // By default, a contract is non-upgradeable, you can change it by passing `InstallConfig` _ = DogContract::try_deploy_with_cfg( env, DogContractInitArgs { barks: true, weight: 10, name: &quot;Mantus&quot;.to_string() }, InstallConfig::upgradable::&lt;DogContract&gt;(), )?; // Alternatively, you can use the `DeployerExt` trait to deploy the contract: _ = DogContract::load_or_deploy( env, DogContractInitArgs { barks: true, weight: 10, name: &quot;Mantus&quot;.to_string() }, container, 350_000_000_000 )?; // You can use `load_or_deploy_with_cfg` to deploy the contract with a custom configuration _ = DogContract::load_or_deploy_with_cfg( env, DogContractInitArgs { barks: true, weight: 10, name: &quot;Mantus&quot;.to_string() }, InstallConfig::upgradable::&lt;DogContract&gt;(), container, 350_000_000_000 )?; Ok(()) } }  In the example above, we see a few alternative implementations of a simple DeployScript for our DogContract. All of them set the gas limit, deploy the contract and adds it to a container. DogContract::try_deploy method, which deploys the contract every time the script is run. DogContract::try_deploy_with_cfg also deploys a contract everytime, but passes InstallConfig instance to configure the deployment using a factory method InstallConfig::upgradable.Utilizes the DeployerExt trait, which checks if the contract is already deployed and returns the existing instance if it is, or deploys it if it is not. It is a convenient way to ensure that the contract is deployed only once. It is useful when you want to add more contracts to the script in the future and avoid redeploying previously deployed contracts. The last option is to use DeployerExt::load_or_deploy_with_cfg that works like the previous one, but accepts a custom configuration. The address of the deployed contract is stored in a TOML file in the resources directory, which is created automatically by the Odra CLI library. ","version":"2.3.1","tagName":"h3"},{"title":"Scenarios​","type":1,"pageTitle":"Odra CLI","url":"/docs/tutorials/odra-cli#scenarios","content":"Scenarios are a way to run multiple calls one after another, and can be used to test the contract or perform complex operations like setting up the dependencies between contracts. To create a scenario, you need to implement the Scenario trait and add it to the OdraCli instance in the main function. A scenario also implements the ScenarioMetadata trait, which provides metadata about the scenario, such as its name and description. You can use this metadata to display the scenario in the CLI tool and provide a description of what it does. bin/odra-cli.rs use odra_cli::{ scenario::{Args, Error, Scenario, ScenarioMetadata}, CommandArg, ContractProvider, DeployedContractsContainer, }; use std::vec; pub struct DogCheckScenario; impl Scenario for DogCheckScenario { fn args(&amp;self) -&gt; Vec&lt;CommandArg&gt; { vec![CommandArg::new( &quot;name&quot;, &quot;The name of the dog&quot;, NamedCLType::String, ).required()] } fn run( &amp;self, env: &amp;HostEnv, container: &amp;DeployedContractsContainer, args: Args ) -&gt; Result&lt;(), Error&gt; { let dog_contract = container.contract_ref::&lt;DogContract&gt;(env)?; let test_name = args.get_single::&lt;String&gt;(&quot;name&quot;)?; env.set_gas(50_000_000); let actual_name = dog_contract.try_name()?; assert_eq!(test_name, actual_name, &quot;Dog name mismatch&quot;); Ok(()) } } impl ScenarioMetadata for DogCheckScenario { const NAME: &amp;'static str = &quot;check&quot;; const DESCRIPTION: &amp;'static str = &quot;Checks if the name of the deployed dog matches the provided name&quot;; }  A scenario must implement the Scenario trait, which requires defining the args and run methods. The args method returns a vector of CommandArg that defines the arguments that the scenario accepts. In this case, we define a single argument name of type String, which is required - the program will fail at parse time if the argument is not provided. The run method is where the scenario logic is implemented. It receives the HostEnv, a container with deployed contracts, and the arguments passed to the scenario. To load the contract, we use the ContractProvider trait, which allows us to get a reference to the contract by its type. The trait is implemented for the DeployedContractsContainer, which is passed to the run method. To read the arguments, we use the Args type, which provides two methods: get_single and get_many. In this case, we use get_single to get the value of the name argument. If we want to get multiple values for an argument, we must define the argument as CommandArg::new(&quot;name&quot;, &quot;The name of the dog&quot;, NamedCLType::String).list(), where list() indicates that the argument can be provided multiple times. The example above performs a simple check on the return value of one of the methods. Of course, there is no limit to how complex a scenario can be. ","version":"2.3.1","tagName":"h3"},{"title":"Contract methods​","type":1,"pageTitle":"Odra CLI","url":"/docs/tutorials/odra-cli#contract-methods","content":"To interact with the contract methods, we can use the contract command. The Odra CLI automatically generates commands for each contract method, allowing us to call them directly by name. But first, we need to register the contract in the OdraCli instance. ","version":"2.3.1","tagName":"h3"},{"title":"Builder​","type":1,"pageTitle":"Odra CLI","url":"/docs/tutorials/odra-cli#builder","content":"Now, let's put everything together in the main function. We will use the OdraCli builder to create a CLI tool that can deploy the contract, call its methods, and run scenarios. bin/odra-cli.rs use odra_cli::OdraCli; /// Main function to run the CLI tool. pub fn main() { OdraCli::new() .about(&quot;Dog contract cli tool&quot;) .deploy(DeployDogScript) .contract::&lt;DogContract&gt;() .scenario(DogCheckScenario) .build() .run(); }  This code creates a new OdraCli instance, sets the description of the tool, adds the deploy script, registers the DogContract, and adds the scenario. Finally, it builds the CLI tool and runs it. ","version":"2.3.1","tagName":"h3"},{"title":"How to use it​","type":1,"pageTitle":"Odra CLI","url":"/docs/tutorials/odra-cli#how-to-use-it","content":"Assuming the correct livenet environment is set up, you can run the CLI tool using the following command: cargo run --bin odra-cli  This will display all of our options: Dog contract cli tool Usage: odra_cli [OPTIONS] &lt;COMMAND&gt; Commands: deploy Runs the deploy script contract Commands for interacting with contracts scenario Commands for interacting with scenarios print-events Prints the most recent events emitted by a contract help Print this message or the help of the given subcommand(s) Options: -c, --contracts-toml &lt;PathBuf&gt; The path to the file with the deployed contracts. Relative to the project root. -h, --help Print help  By default, contracts are written/read to/from the contracts.toml file, which is located in the resources directory, but you can specify a different path using the -c or --contracts-toml option. ","version":"2.3.1","tagName":"h2"},{"title":"Deploy command​","type":1,"pageTitle":"Odra CLI","url":"/docs/tutorials/odra-cli#deploy-command","content":"First, we need to deploy the contract: cargo run --bin odra_cli deploy  This gives us the following output: cargo run --bin odra_cli -- deploy Compiling odra-examples v2.1.0 (/home/kuba/Projekty/odra/odra/examples) Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.65s Running `../target/debug/odra_cli deploy` 💁 INFO : Found wasm under &quot;wasm/DogContract.wasm&quot;. 💁 INFO : Deploying &quot;DogContract&quot;. 🙄 WAIT : Waiting 10 for V1(TransactionV1Hash(4230d5ca3113d87190e4136cefe097bd08fea03c841ce5e4df73a049e10208f1)). 💁 INFO : Transaction &quot;4230d5ca3113d87190e4136cefe097bd08fea03c841ce5e4df73a049e10208f1&quot; successfully executed. 🔗 LINK : 💁 INFO : Contract &quot;contract-package-53b3486180b2a9506fbb0523ed159b1908cec628d091b19cbe74e057e7ebbc8b&quot; deployed. 💁 INFO : Command executed successfully  This will run the deploy script and create a new file in the resources directory named contracts.toml: last_updated = &quot;2025-07-03T10:33:55Z&quot; [[contracts]] name = &quot;DogContract&quot; package_hash = &quot;hash-53b3486180b2a9506fbb0523ed159b1908cec628d091b19cbe74e057e7ebbc8b&quot;  All the calls to the contract will be made using this package hash, unless you specify a different one using the -c or --contracts-toml option. ","version":"2.3.1","tagName":"h3"},{"title":"Contract command​","type":1,"pageTitle":"Odra CLI","url":"/docs/tutorials/odra-cli#contract-command","content":"To call a contract method, we need to use the contract command. The command itself will display all the available contracts: cargo run --bin odra_cli -- contract  This outputs: Commands for interacting with contracts Usage: odra_cli contract &lt;COMMAND&gt; Commands: DogContract Commands for interacting with the DogContract contract help Print this message or the help of the given subcommand(s)  And when a contract is selected, it will show us the available methods: cargo run --bin odra_cli -- contract DogContract  Commands for interacting with the DogContract contract Usage: odra_cli contract DogContract &lt;COMMAND&gt; Commands: barks Returns true if the dog barks. weight Returns the dog's weight. name Returns the dog's name. walks_amount Adds a walk to the dog's walks. walks_total_length Returns the total length of the dog's walks. help Print this message or the help of the given subcommand(s)  To run a command, compose a command like this: cargo run --bin odra_cli -- contract DogContract barks  This will result in: 💁 INFO : Call result: true 💁 INFO : Command executed successfully  If you run a command that requires arguments, it will display an error message: cargo run --bin odra_cli -- contract DogContract rename error: the following required arguments were not provided: --new_name &lt;String&gt; --gas &lt;U64&gt; Usage: odra_cli contract DogContract rename --new_name &lt;String&gt; --gas &lt;U64&gt; For more information, try '--help'.  The error message above indicates that the rename method requires two arguments: new_name and gas. In the code, the rename method is mutable and takes a single argument new_name of type String. As the entry point is mutable and requires a real transaction, the gas argument is also required to specify how much gas to use for the call. The gas amount is denominated in motes. Let's run the command with the required arguments: cargo run --bin odra_cli -- contract DogContract rename --new_name &quot;Doggy&quot; --gas 200000000 error: invalid value '200000000' for '--gas &lt;U64&gt;': 200000000 is not in 2500000000..18446744073709551615  As the minimum gas amount for a transaction is 2.5 CSPRs, we need to increase the gas amount to at least that value: cargo run --bin odra_cli -- contract DogContract rename --new_name &quot;Doggy&quot; --gas 2500000000 💁 INFO : Calling &quot;contract-package-0eda9544d667775d8e5503543dd8ba0996d439fd9ded79cfe28454d07f42df3a&quot; directly with entrypoint &quot;rename&quot;. 🙄 WAIT : Waiting 10 for V1(TransactionV1Hash(e9d2e7f9d7d832cbf64e6e9eb09404423757e354a1ed7420c0398d851fea3a40)). 💁 INFO : Transaction &quot;e9d2e7f9d7d832cbf64e6e9eb09404423757e354a1ed7420c0398d851fea3a40&quot; successfully executed. 🔗 LINK : 💁 INFO : Call executed successfully, but no result was returned. 💁 INFO : Command executed successfully # Verifying the name change cargo run --bin odra_cli -- contract DogContract name 💁 INFO : Call result: Doggy 💁 INFO : Command executed successfully  There are more options available for the contract command that we can discover by running the help command: cargo run --bin odra_cli -- contract DogContract rename --help It is uncommon but you can change the dog's name. Usage: odra_cli contract DogContract rename [OPTIONS] --new_name &lt;String&gt; --gas &lt;U64&gt; Options: --new_name &lt;String&gt; --attached_value &lt;U512&gt; The amount of CSPRs attached to the call --gas &lt;U64&gt; The amount of gas to attach to the call -p, --print-events Print events emitted by the contract -h, --help  If you want to print the events emitted by the contract, you can use the --print-events option. This will print all the events emitted by the contract during the call. cargo run --bin odra_cli -- contract DogContract rename --new_name &quot;Doggy&quot; --gas 2500000000 --print-events 💁 INFO : Syncing events for the call... 💁 INFO : Calling &quot;contract-package-0eda9544d667775d8e5503543dd8ba0996d439fd9ded79cfe28454d07f42df3a&quot; directly with entrypoint &quot;rename&quot;. 🙄 WAIT : Waiting 10 for V1(TransactionV1Hash(f2f473d46b59c136052f687539ab76e5fbb3af958c483e3a382b5a0e498227c4)). 💁 INFO : Transaction &quot;f2f473d46b59c136052f687539ab76e5fbb3af958c483e3a382b5a0e498227c4&quot; successfully executed. 🔗 LINK : 💁 INFO : Captured 1 events for contract 'DogContract' 💁 INFO : Event 1: 'NamedChanged': 'old_name': Mantus 'new_name': Doggy 💁 INFO : Call executed successfully, but no result was returned. 💁 INFO : Command executed successfully  For a payable method, you can use the --attached_value option to specify the amount of CSPRs to attach to the call. The value is denominated in motes. ","version":"2.3.1","tagName":"h3"},{"title":"Print-events command​","type":1,"pageTitle":"Odra CLI","url":"/docs/tutorials/odra-cli#print-events-command","content":"The print-events command allows you to print the most recent events emitted by a contract. It is useful for debugging and understanding what is happening in the contract. You can run it like this: cargo run --bin odra_cli -- print-events DogContract --help Print events of the DogContract contract Usage: odra_cli print-events DogContract [OPTIONS] Options: -n, --number &lt;N&gt; Number of events to print [default: 10] -h, --help Print help cargo run --bin odra_cli -- print-events DogContract -n 2 💁 INFO : Printing 4 the most recent events for contract 'DogContract' 💁 INFO : Event 1: 'NamedChanged': 'old_name': Mantus 'new_name': Doggy 💁 INFO : Event 2: 'NamedChanged': 'old_name': Rex 'new_name': Mantus 💁 INFO : Command executed successfully  By default, it prints the last 10 events, but you can specify a different number using the -n or --number option. ","version":"2.3.1","tagName":"h3"},{"title":"Scenario command​","type":1,"pageTitle":"Odra CLI","url":"/docs/tutorials/odra-cli#scenario-command","content":"Scenarios registered in the OdraCli instance can be run using the scenario command. It displays all the available scenarios: cargo run --bin odra_cli -- scenario  This will output: Commands for running user-defined scenarios Usage: odra_cli scenario &lt;COMMAND&gt; Commands: check Checks if the name of the deployed dog matches the provided name help Print this message or the help of the given subcommand(s)  It can be run like this: cargo run --bin odra_cli -- scenario check --name Doggy  This will output: thread 'main' panicked at examples/bin/odra_cli.rs:59:9: assertion `left == right` failed: Dog name mismatch left: &quot;Doggy&quot; right: &quot;Mantus&quot; ## Conclusion The Odra CLI library provides a powerful and convenient way to create command-line tools for your Odra contracts. It simplifies the process of deploying, interacting with, and testing your contracts, allowing you to focus on the business logic of your application. By following the examples in this tutorial, you can create your own CLI tools and streamline your development workflow.  ","version":"2.3.1","tagName":"h3"},{"title":"Ownable","type":0,"sectionRef":"#","url":"/docs/tutorials/ownable","content":"","keywords":"","version":"2.3.1"},{"title":"Framework features​","type":1,"pageTitle":"Ownable","url":"/docs/tutorials/ownable#framework-features","content":"A module we will write in a minute, will help you master a few Odra features: storing a single value,defining a constructor,error handling,defining and emitting events.registering a contact in a test environment,interactions with the test environment,assertions (value, events, errors assertions). ","version":"2.3.1","tagName":"h2"},{"title":"Code​","type":1,"pageTitle":"Ownable","url":"/docs/tutorials/ownable#code","content":"Before we write any code, we define functionalities we would like to implement. Module has an initializer that should be called once. Only the current owner can set a new owner.Read the current owner.A function that fails if called by a non-owner account. ","version":"2.3.1","tagName":"h2"},{"title":"Define a module​","type":1,"pageTitle":"Ownable","url":"/docs/tutorials/ownable#define-a-module","content":"ownable.rs use odra::prelude::*; #[odra::module(events = [OwnershipChanged])] pub struct Ownable { owner: Var&lt;Option&lt;Address&gt;&gt; }  That was easy, but it is crucial to understand the basics before we move on. L3 - Firstly, we need to create a struct called Ownable and apply #[odra::module(events = [OwnershipChanged])] attribute to it. The events attribute is optional but informs the Odra toolchain about the events that will be emitted by the module and includes them in the contract's metadata. OwnershipChanged is a type that will be defined later.L5 - Then we can define the layout of our module. It is extremely simple - just a single state value. What is most important is that you can never leave a raw type; you must always wrap it with Var. ","version":"2.3.1","tagName":"h3"},{"title":"Init the module​","type":1,"pageTitle":"Ownable","url":"/docs/tutorials/ownable#init-the-module","content":"ownable.rs #[odra::module] impl Ownable { pub fn init(&amp;mut self, owner: Address) { if self.owner.get_or_default().is_some() { self.env().revert(Error::OwnerIsAlreadyInitialized) } self.owner.set(Some(owner)); self.env().emit_event(OwnershipChanged { prev_owner: None, new_owner: owner }); } } #[odra::odra_error] pub enum Error { OwnerIsAlreadyInitialized = 1, } #[odra::event] pub struct OwnershipChanged { pub prev_owner: Option&lt;Address&gt;, pub new_owner: Address }  Ok, we have done a couple of things, let's analyze them one by one: L1 - The impl should be an Odra module, so add #[odra::module].L3 - The init function is a constructor. This matters if we would like to deploy the Ownable module as a standalone contract.L17-L20 - Before we set a new owner, we must assert there was no owner before and raise an error otherwise. For that purpose, we defined an Error enum. Notice that the #[odra::odra_error] attribute is applied to the enum. It generates, among others, the required Into&lt;odra::OdraError&gt; binding.L4-L6 - If the owner has been set already, we call ContractEnv::revert() function with an Error::OwnerIsAlreadyInitialized argument. L8 - Then we write the owner passed as an argument to the storage. To do so, we call the set() on Var.L22-L26 - Once the owner is set, we would like to inform the outside world. The first step is to define an event struct. The struct annotated with #[odra::event] attribute.L10 - Finally, call ContractEnv::emit_event() passing the OwnershipChanged instance to the function. Hence, we set the first owner, we set the prev_owner value to None.  ","version":"2.3.1","tagName":"h3"},{"title":"Features implementation​","type":1,"pageTitle":"Ownable","url":"/docs/tutorials/ownable#features-implementation","content":"ownable.rs #[odra::module] impl Ownable { ... pub fn ensure_ownership(&amp;self, address: &amp;Address) { if Some(address) != self.owner.get_or_default().as_ref() { self.env().revert(Error::NotOwner) } } pub fn change_ownership(&amp;mut self, new_owner: &amp;Address) { self.ensure_ownership(&amp;self.env().caller()); let current_owner = self.get_owner(); self.owner.set(Some(*new_owner)); self.env().emit_event(OwnershipChanged { prev_owner: Some(current_owner), new_owner: *new_owner }); } pub fn get_owner(&amp;self) -&gt; Address { match self.owner.get_or_default() { Some(owner) =&gt; owner, None =&gt; self.env().revert(Error::OwnerIsNotInitialized) } } } #[odra::odra_error] pub enum Error { NotOwner = 1, OwnerIsAlreadyInitialized = 2, OwnerIsNotInitialized = 3, }  The above implementation relies on the concepts we have already used in this tutorial, so it should be easy for you to get along. L7,L31 - ensure_ownership() reads the current owner and reverts if it does not match the input Address. Also, we need to update our Error enum by adding a new variant NotOwner.L11 - The function defined above can be reused in the change_ownership() implementation. We pass to it the current caller, using the ContractEnv::caller() function. Then we update the state and emit OwnershipChanged.L21,L33 - Lastly, a getter function. Read the owner from storage, if the getter is called on an uninitialized module, it should revert with a new Error variant OwnerIsNotInitialized. There is one worth-mentioning subtlety: Var::get() function returns Option&lt;T&gt;. If the type implements the Default trait, you can call the get_or_default() function, and the contract does not fail even if the value is not initialized. As the owner is of type Option&lt;Address&gt; the Var::get() would return Option&lt;Option&lt;Address&gt;&gt;, we use Var::get_or_default() instead. ","version":"2.3.1","tagName":"h3"},{"title":"Test​","type":1,"pageTitle":"Ownable","url":"/docs/tutorials/ownable#test","content":"ownable.rs #[cfg(test)] mod tests { use super::*; use odra::host::{Deployer, HostEnv}; fn setup() -&gt; (OwnableHostRef, HostEnv, Address) { let env: HostEnv = odra_test::env(); let init_args = OwnableInitArgs { owner: env.get_account(0) }; (Ownable::deploy(&amp;env, init_args), env.clone(), env.get_account(0)) } #[test] fn initialization_works() { let (ownable, env, owner) = setup(); assert_eq!(ownable.get_owner(), owner); env.emitted_event( &amp;ownable, OwnershipChanged { prev_owner: None, new_owner: owner } ); } #[test] fn owner_can_change_ownership() { let (mut ownable, env, owner) = setup(); let new_owner = env.get_account(1); env.set_caller(owner); ownable.change_ownership(&amp;new_owner); assert_eq!(ownable.get_owner(), new_owner); env.emitted_event( &amp;ownable, OwnershipChanged { prev_owner: Some(owner), new_owner } ); } #[test] fn non_owner_cannot_change_ownership() { let (mut ownable, env, _) = setup(); let new_owner = env.get_account(1); ownable.change_ownership(&amp;new_owner); assert_eq!( ownable.try_change_ownership(&amp;new_owner), Err(Error::NotOwner.into()) ); } }  L6 - Each test case starts with the same initialization process, so for convenience, we have defined the setup() function, which we call in the first statement of each test. Take a look at the signature: fn setup() -&gt; (OwnableHostRef, HostEnv, Address). OwnableHostRef is a contract reference generated by Odra. This reference allows us to call all the defined entrypoints, namely: ensure_ownership(), change_ownership(), get_owner(), but not init(), which is a constructor.L7-L11 - The starting point of every test is getting an instance of HostEnv by calling odra_test::env(). Our function returns a triple: a contract ref, an env, and an address (the initial owner). Odra's #[odra::module] attribute implements a odra::host::Deployer for Ownable, and OwnableInitArgs that we pass as the second argument of the odra::host::Deployer::deploy() function. Lastly, the module needs an owner. The easiest way is to take one from the HostEnv. We choose the address of first account (which is the default one). L14 - It is time to define the first test. As you see, it is a regular Rust test.L16-17 - Using the setup() function, we get the owner and a reference (in this test, we don't use the env, so we ignore it). We make a standard assertion, comparing the owner we know with the value returned from the contract. note You may have noticed, we use here the term module interchangeably with contract. The reason is once we deploy our module onto a virtual blockchain it may be considered a contract. L19-25 - On the contract, only the init() function has been called, so we expect one event to have been emitted. To assert that, let's use HostEnv. To get the env, we call env() on the contract, then call HostEnv::emitted_event. As the first argument, pass the contract you want to read events from, followed by an event as you expect it to have occurred.L31 - Because we know the initial owner is the 0th account, we must select a different account. It could be any index from 1 to 19 - the HostEnv predefines 20 accounts.L33 - As mentioned, the default is the 0th account, if you want to change the executor, call the HostEnv::set_caller() function. note The caller switch applies only the next contract interaction, the second call will be done as the default account. L46-55 - If a non-owner account tries to change ownership, we expect it to fail. To capture the error, call HostEnv::try_change_ownership() instead of HostEnv::change_ownership(). HostEnv provides try_ functions for each contract's entrypoint. The try functions return OdraResult (an alias for Result&lt;T, OdraError&gt;) instead of panicking and halting the execution. In our case, we expect the contract to revert with the Error::NotOwner error. To compare the error, we use the Error::into() function, which converts the error into the OdraError type. ","version":"2.3.1","tagName":"h3"},{"title":"Summary​","type":1,"pageTitle":"Ownable","url":"/docs/tutorials/ownable#summary","content":"The Ownable module is ready, and we can test it against any defined backend. Theoretically it can be deployed as a standalone contract, but in upcoming tutorials you will see how to use it to compose a more complex contract. ","version":"2.3.1","tagName":"h2"},{"title":"What's next​","type":1,"pageTitle":"Ownable","url":"/docs/tutorials/ownable#whats-next","content":"In the next tutorial we will implement a ERC20 standard. ","version":"2.3.1","tagName":"h2"},{"title":"OwnedToken","type":0,"sectionRef":"#","url":"/docs/tutorials/owned-token","content":"","keywords":"","version":"2.3.1"},{"title":"Code​","type":1,"pageTitle":"OwnedToken","url":"/docs/tutorials/owned-token#code","content":"What should our module be capable of? Conform the Erc20 interface.Allow only the module owner to mint tokens.Enable the current owner to designate a new owner. ","version":"2.3.1","tagName":"h2"},{"title":"Module definition​","type":1,"pageTitle":"OwnedToken","url":"/docs/tutorials/owned-token#module-definition","content":"Let's define a module called OwnedToken that is a composition of Ownable and Erc20 modules. owned_token.rs use crate::{erc20::Erc20, ownable::Ownable}; use odra::prelude::*; #[odra::module] pub struct OwnedToken { ownable: SubModule&lt;Ownable&gt;, erc20: SubModule&lt;Erc20&gt; }  As you can see, we do not need any storage definition - we just take advantage of the already-defined modules! ","version":"2.3.1","tagName":"h3"},{"title":"Delegation​","type":1,"pageTitle":"OwnedToken","url":"/docs/tutorials/owned-token#delegation","content":"owned_token.rs ... use odra::casper_types::U256; ... #[odra::module] impl OwnedToken { pub fn init(&amp;mut self, name: String, symbol: String, decimals: u8, initial_supply: U256) { let deployer = self.env().caller(); self.ownable.init(deployer); self.erc20.init(name, symbol, decimals, initial_supply); } pub fn name(&amp;self) -&gt; String { self.erc20.name() } pub fn symbol(&amp;self) -&gt; String { self.erc20.symbol() } pub fn decimals(&amp;self) -&gt; u8 { self.erc20.decimals() } pub fn total_supply(&amp;self) -&gt; U256 { self.erc20.total_supply() } pub fn balance_of(&amp;self, address: &amp;Address) -&gt; U256 { self.erc20.balance_of(address) } pub fn allowance(&amp;self, owner: &amp;Address, spender: &amp;Address) -&gt; U256 { self.erc20.allowance(owner, spender) } pub fn transfer(&amp;mut self, recipient: &amp;Address, amount: &amp;U256) { self.erc20.transfer(recipient, amount); } pub fn transfer_from(&amp;mut self, owner: &amp;Address, recipient: &amp;Address, amount: &amp;U256) { self.erc20.transfer_from(owner, recipient, amount); } pub fn approve(&amp;mut self, spender: &amp;Address, amount: &amp;U256) { self.erc20.approve(spender, amount); } pub fn get_owner(&amp;self) -&gt; Address { self.ownable.get_owner() } pub fn change_ownership(&amp;mut self, new_owner: &amp;Address) { self.ownable.change_ownership(new_owner); } pub fn mint(&amp;mut self, address: &amp;Address, amount: &amp;U256) { self.ownable.ensure_ownership(&amp;self.env().caller()); self.erc20.mint(address, amount); } }  Easy. However, there are a few worth mentioning subtleness: L9-L10 - A constructor is an excellent place to initialize both modules at once.L13-L15 - Most of the entrypoints do not need any modification, so we simply delegate them to the erc20 module.L49-L51 - The same is done with the ownable module.L57-L60 - Minting should not be unconditional, we need some control over it. First, using ownable we make sure the caller really is indeed the owner. ","version":"2.3.1","tagName":"h3"},{"title":"Summary​","type":1,"pageTitle":"OwnedToken","url":"/docs/tutorials/owned-token#summary","content":"The Odra Framework encourages a modularized design of your smart contracts. You can encapsulate features in smaller units and test them in isolation, ensuring your project is easy to maintain. Finally, unleash their full potential by combining modules. You do not need any magic bindings for that. ","version":"2.3.1","tagName":"h2"},{"title":"Pausable","type":0,"sectionRef":"#","url":"/docs/tutorials/pauseable","content":"","keywords":"","version":"2.3.1"},{"title":"Code​","type":1,"pageTitle":"Pausable","url":"/docs/tutorials/pauseable#code","content":"As always, we will start with defining functionalities of our module. Check the state - is it paused or not.State guards - a contract should stop execution if is in a state we don't expect.Switch the state. ","version":"2.3.1","tagName":"h2"},{"title":"Events and Error​","type":1,"pageTitle":"Pausable","url":"/docs/tutorials/pauseable#events-and-error","content":"There just two errors that may occur: PausedRequired, UnpausedRequired. We define them in a standard Odra way. Events definition is highly uncomplicated: Paused and Unpaused events holds only the address of the pauser. pauseable.rs use odra::prelude::*; #[odra::odra_error] pub enum Error { PausedRequired = 1_000, UnpausedRequired = 1_001, } #[odra::event] pub struct Paused { pub account: Address } #[odra::event] pub struct Unpaused { pub account: Address }  ","version":"2.3.1","tagName":"h3"},{"title":"Module definition​","type":1,"pageTitle":"Pausable","url":"/docs/tutorials/pauseable#module-definition","content":"The module storage is extremely simple - has a single Var of type bool, that indicates if a contract is paused. pauseable.rs #[odra::module(events = [Paused, Unpaused], errors = Error)] pub struct Pausable { is_paused: Var&lt;bool&gt; }  ","version":"2.3.1","tagName":"h3"},{"title":"Checks and guards​","type":1,"pageTitle":"Pausable","url":"/docs/tutorials/pauseable#checks-and-guards","content":"Now, let's move to state checks and guards. pauseable.rs impl Pausable { pub fn is_paused(&amp;self) -&gt; bool { self.is_paused.get_or_default() } pub fn require_not_paused(&amp;self) { if self.is_paused() { self.env().revert(Error::UnpausedRequired); } } pub fn require_paused(&amp;self) { if !self.is_paused() { self.env().revert(Error::PausedRequired); } } }  L1 - as mentioned in the intro, the module is not intended to be a standalone contract, so the only impl block is not annotated with odra::module and hence does not expose any entrypoint.L2 - is_paused() checks the contract state, if the Var is_paused has not been initialized, the default value (false) is returned.L6 - to guarantee the code is executed when the contract is not paused, require_not_paused() function reads the state and reverts if the contract is paused. L12 - require_paused() is a mirror function - stops the contract execution if the contract is not paused. ","version":"2.3.1","tagName":"h3"},{"title":"Actions​","type":1,"pageTitle":"Pausable","url":"/docs/tutorials/pauseable#actions","content":"Finally, we will add the ability to switch the module state. pauseable.rs impl Pausable { pub fn pause(&amp;mut self) { self.require_not_paused(); self.is_paused.set(true); self.env().emit_event(Paused { account: self.env().caller() }); } pub fn unpause(&amp;mut self) { self.require_paused(); self.is_paused.set(false); self.env().emit_event(Unpaused { account: self.env().caller() }); } }  pause() and unpause() functions do three things: ensure the contract is the right state (unpaused for pause(), not paused for unpause()), updates the state, and finally emits events (Paused/Unpaused). ","version":"2.3.1","tagName":"h3"},{"title":"Pausable counter​","type":1,"pageTitle":"Pausable","url":"/docs/tutorials/pauseable#pausable-counter","content":"In the end, let's use the module in a contract. For this purpose, we will implement a mock contract called PausableCounter. The contract consists of a Var value and a Pausable module. The counter can only be incremented if the contract is in a normal state (is not paused). pauseable.rs ... #[odra::module] pub struct PausableCounter { value: Var&lt;u32&gt;, pauseable: SubModule&lt;Pausable&gt; } #[odra::module] impl PausableCounter { pub fn increment(&amp;mut self) { self.pauseable.require_not_paused(); let new_value = self.value.get_or_default() + 1; self.value.set(new_value); } pub fn pause(&amp;mut self) { self.pauseable.pause(); } pub fn unpause(&amp;mut self) { self.pauseable.unpause(); } pub fn get_value(&amp;self) -&gt; u32 { self.value.get_or_default() } } #[cfg(test)] mod test { use super::*; use odra::host::{Deployer, NoArgs}; #[test] fn increment_only_if_unpaused() { let test_env = odra_test::env(); let mut contract = PausableCounter::deploy(&amp;test_env, NoArgs); contract.increment(); contract.pause(); assert_eq!( contract.try_increment().unwrap_err(), Error::UnpausedRequired.into() ); assert_eq!(contract.get_value(), 1); } }  As we see in the test, in a simple way, using a single function call we can turn off the counter for a while and freeze the counter. Any time we want we can turn it back on. Easy! ","version":"2.3.1","tagName":"h2"},{"title":"Upgrading Contracts","type":0,"sectionRef":"#","url":"/docs/tutorials/upgrades","content":"","keywords":"","version":"2.3.1"},{"title":"Livenet Example​","type":1,"pageTitle":"Upgrading Contracts","url":"/docs/tutorials/upgrades#livenet-example","content":"In this example, we will deploy a simple counter contract and then upgrade it to a new version with additional features. We will skip the details of the contract implementation and focus on the deployment and upgrade process. Our example deploys a simple counter contract making it upgradable and then upgrades it twice: first to CounterV2, and then back to CounterV1. examples/bin/upgrades_on_livenet.rs //! This example demonstrates how to deploy and upgrade a contract on the Livenet environment. use odra::casper_types::U256; use odra::host::{Deployer, HostRef, InstallConfig, NoArgs}; use odra_examples::features::upgrade::{CounterV1, CounterV2, CounterV2UpgradeArgs}; fn main() { let env = odra_casper_livenet_env::env(); env.set_gas(500_000_000_000u64); // Contracts can be upgraded let mut counter = CounterV1::deploy_with_cfg(&amp;env, NoArgs, InstallConfig::upgradable::&lt;CounterV1&gt;()); env.set_gas(50_000_000_000u64); counter.increment(); assert_eq!(counter.get(), 1); env.set_gas(500_000_000_000u64); let mut counter2 = CounterV2::try_upgrade( &amp;env, counter.contract_address(), CounterV2UpgradeArgs { new_start: None } ) .unwrap(); env.set_gas(50_000_000_000u64); counter2.increment(); assert_eq!(counter2.get(), U256::from(2)); env.set_gas(500_000_000_000u64); let mut counter3 = CounterV1::try_upgrade(&amp;env, counter.contract_address(), NoArgs).unwrap(); env.set_gas(50_000_000_000u64); counter3.increment(); assert_eq!(counter3.get(), 2); }  The Deployer trait has two functions that allow upgrading contracts: try_upgrade: upgrades a contract to a new version. It takes the environment, the address of the contract to be upgraded, and the arguments for the new version of the contract. The function try_upgrade_with_cfg: same as try_upgrade, but allows specifying a custom upgrade configuration. Let's take a quick look at the CounterV2 implementation: #[odra::module] impl CounterV2 { pub fn init(&amp;mut self, start_from: Option&lt;U256&gt;) { if let Some(start) = start_from { self.new_counter.set(start); } else { self.new_counter.set(U256::from(0)); } } pub fn upgrade(&amp;mut self, new_start: Option&lt;U256&gt;) { if let Some(start) = new_start { self.new_counter.set(start); } else { // If no new value is provided, we keep the current value self.new_counter.set(self.counter.get_or_default().into()); } } ... }  The contract implements the upgrade function, which allows executing the upgrade logic for the contract. When upgrading to a new version, the upgrade function is called with the new initialization parameters. We call the try_upgrade function with CounterV2UpgradeArgs - a struct automatically generated by the Odra framework. It is a mirror feature of the contract's initialization parameters. ","version":"2.3.1","tagName":"h2"},{"title":"Run the example​","type":1,"pageTitle":"Upgrading Contracts","url":"/docs/tutorials/upgrades#run-the-example","content":"Now, let's see the code in action! cargo run --bin our_token_livenet --features livenet  A sample output of the program might look like this:  Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.11s Running `../target/debug/upgrade_on_livenet` 💁 INFO : Found wasm under &quot;/Users/kpob/workspace/odra/examples/wasm/CounterV1.wasm&quot;. 💁 INFO : Deploying &quot;CounterV1&quot;. 🙄 WAIT : Waiting 10 for V1(TransactionV1Hash(301469239d731d7b7ca9aef7a42dcb1473a1388d59e1bac619a008e7b555aa0d)). 💁 INFO : Transaction &quot;301469239d731d7b7ca9aef7a42dcb1473a1388d59e1bac619a008e7b555aa0d&quot; successfully executed. 🔗 LINK : https://testnet.cspr.live/transaction/301469239d731d7b7ca9aef7a42dcb1473a1388d59e1bac619a008e7b555aa0d 💁 INFO : Contract &quot;contract-package-b8b5003fe3ba05b4cae2e8acaeb777520e025958e12bd15394bf42e96f3f7b12&quot; deployed. 💁 INFO : Calling &quot;contract-package-b8b5003fe3ba05b4cae2e8acaeb777520e025958e12bd15394bf42e96f3f7b12&quot; directly with entrypoint &quot;increment&quot;. 🙄 WAIT : Waiting 10 for V1(TransactionV1Hash(a0fb180018063702094cdd66bdda1a3eda6f90c2e726334f202d77cddd88e649)). 🙄 WAIT : Waiting 10 for V1(TransactionV1Hash(a0fb180018063702094cdd66bdda1a3eda6f90c2e726334f202d77cddd88e649)). 💁 INFO : Transaction &quot;a0fb180018063702094cdd66bdda1a3eda6f90c2e726334f202d77cddd88e649&quot; successfully executed. 🔗 LINK : https://testnet.cspr.live/transaction/a0fb180018063702094cdd66bdda1a3eda6f90c2e726334f202d77cddd88e649 💁 INFO : Found wasm under &quot;/Users/kpob/workspace/odra/examples/wasm/CounterV2.wasm&quot;. 💁 INFO : Deploying &quot;CounterV2&quot;. 🙄 WAIT : Waiting 10 for V1(TransactionV1Hash(ec4518f51a2b3ed19886d6cd2d67e138aeb24834362d8fad8adb4af45fa36f21)). 💁 INFO : Transaction &quot;ec4518f51a2b3ed19886d6cd2d67e138aeb24834362d8fad8adb4af45fa36f21&quot; successfully executed. 🔗 LINK : https://testnet.cspr.live/transaction/ec4518f51a2b3ed19886d6cd2d67e138aeb24834362d8fad8adb4af45fa36f21 💁 INFO : Contract &quot;contract-package-b8b5003fe3ba05b4cae2e8acaeb777520e025958e12bd15394bf42e96f3f7b12&quot; deployed. 💁 INFO : Calling &quot;contract-package-b8b5003fe3ba05b4cae2e8acaeb777520e025958e12bd15394bf42e96f3f7b12&quot; directly with entrypoint &quot;increment&quot;. 🙄 WAIT : Waiting 10 for V1(TransactionV1Hash(cc694727bf166c55e2080578fcf6dc944e2d9b931b8301fe5208c8e29e8c599a)). 🙄 WAIT : Waiting 10 for V1(TransactionV1Hash(cc694727bf166c55e2080578fcf6dc944e2d9b931b8301fe5208c8e29e8c599a)). 💁 INFO : Transaction &quot;cc694727bf166c55e2080578fcf6dc944e2d9b931b8301fe5208c8e29e8c599a&quot; successfully executed. 🔗 LINK : https://testnet.cspr.live/transaction/cc694727bf166c55e2080578fcf6dc944e2d9b931b8301fe5208c8e29e8c599a 💁 INFO : Found wasm under &quot;/Users/kpob/workspace/odra/examples/wasm/CounterV1.wasm&quot;. 💁 INFO : Deploying &quot;CounterV1&quot;. 🙄 WAIT : Waiting 10 for V1(TransactionV1Hash(58453efdf683f2271f558a22e406631edccff2771867069c2cbefb3386fc8833)). 💁 INFO : Transaction &quot;58453efdf683f2271f558a22e406631edccff2771867069c2cbefb3386fc8833&quot; successfully executed. 🔗 LINK : https://testnet.cspr.live/transaction/58453efdf683f2271f558a22e406631edccff2771867069c2cbefb3386fc8833 💁 INFO : Contract &quot;contract-package-b8b5003fe3ba05b4cae2e8acaeb777520e025958e12bd15394bf42e96f3f7b12&quot; deployed. 💁 INFO : Calling &quot;contract-package-b8b5003fe3ba05b4cae2e8acaeb777520e025958e12bd15394bf42e96f3f7b12&quot; directly with entrypoint &quot;increment&quot;. 🙄 WAIT : Waiting 10 for V1(TransactionV1Hash(5cd3920e6b7cab505e074eb5684cc1b191841d2f24a889079d9fb1a92167fd4f)). 🙄 WAIT : Waiting 10 for V1(TransactionV1Hash(5cd3920e6b7cab505e074eb5684cc1b191841d2f24a889079d9fb1a92167fd4f)). 💁 INFO : Transaction &quot;5cd3920e6b7cab505e074eb5684cc1b191841d2f24a889079d9fb1a92167fd4f&quot; successfully executed. 🔗 LINK : https://testnet.cspr.live/transaction/5cd3920e6b7cab505e074eb5684cc1b191841d2f24a889079d9fb1a92167fd4f  ","version":"2.3.1","tagName":"h2"},{"title":"Cspr.live​","type":1,"pageTitle":"Upgrading Contracts","url":"/docs/tutorials/upgrades#csprlive","content":"Let's take a look at cspr.live: https://testnet.cspr.live/contract-package/b8b5003fe3ba05b4cae2e8acaeb777520e025958e12bd15394bf42e96f3f7b12 It works! Now our contracts has three versions deployed:  ","version":"2.3.1","tagName":"h2"},{"title":"Conclusion​","type":1,"pageTitle":"Upgrading Contracts","url":"/docs/tutorials/upgrades#conclusion","content":"In this tutorial, we learned how to upgrade a smart contract on the blockchain using the Odra framework. We deployed a simple counter contract, made it upgradable, and then upgraded it twice: first to CounterV2, and then back to CounterV1. We also explored the testnet to verify our contract deployments. ","version":"2.3.1","tagName":"h2"},{"title":"Using Proxy Caller","type":0,"sectionRef":"#","url":"/docs/tutorials/using-proxy-caller","content":"","keywords":"","version":"2.3.1"},{"title":"Contract​","type":1,"pageTitle":"Using Proxy Caller","url":"/docs/tutorials/using-proxy-caller#contract","content":"For this tutorial, we will use the TimeLockWallet contract from our examples. examples/src/contracts/tlw.rs use odra::prelude::*; use odra::casper_types::U512; #[odra::module(errors = Error, events = [Deposit, Withdrawal])] pub struct TimeLockWallet { balances: Mapping&lt;Address, U512&gt;, lock_expiration_map: Mapping&lt;Address, u64&gt;, lock_duration: Var&lt;u64&gt; } #[odra::module] impl TimeLockWallet { /// Initializes the contract with the lock duration. pub fn init(&amp;mut self, lock_duration: u64) { self.lock_duration.set(lock_duration); } /// Deposits the tokens into the contract. #[odra(payable)] pub fn deposit(&amp;mut self) { // Extract values let caller: Address = self.env().caller(); let amount: U512 = self.env().attached_value(); let current_block_time: u64 = self.env().get_block_time(); // Multiple lock check if self.balances.get(&amp;caller).is_some() { self.env().revert(Error::CannotLockTwice) } // Update state, emit event self.balances.set(&amp;caller, amount); self.lock_expiration_map .set(&amp;caller, current_block_time + self.lock_duration()); self.env().emit_event(Deposit { address: caller, amount }); } /// Withdraws the tokens from the contract. pub fn withdraw(&amp;mut self, amount: &amp;U512) { // code omitted for brevity } /// Returns the balance of the given account. pub fn get_balance(&amp;self, address: &amp;Address) -&gt; U512 { // code omitted for brevity } /// Returns the lock duration. pub fn lock_duration(&amp;self) -&gt; u64 { // code omitted for brevity } } /// Errors that may occur during the contract execution. #[odra::odra_error] pub enum Error { LockIsNotOver = 1, CannotLockTwice = 2, InsufficientBalance = 3 } /// Deposit event. #[odra::event] pub struct Deposit { pub address: Address, pub amount: U512 } /// Withdrawal event. #[odra::event] pub struct Withdrawal { pub address: Address, pub amount: U512 }  Full code can be found in our Github repo. ","version":"2.3.1","tagName":"h2"},{"title":"Client​","type":1,"pageTitle":"Using Proxy Caller","url":"/docs/tutorials/using-proxy-caller#client","content":"Before we can interact with the node, we need to set it up. We will use the casper-nctl-docker image. docker run --rm -it --name mynctl -d -p 11101:11101 -p 14101:14101 -p 18101:18101 makesoftware/casper-nctl  Make sure you have the contract's wasm file and the secret key. # Build the contract cargo odra build -c TimeLockWallet # Extract secret key docker exec mynctl /bin/bash -c &quot;cat /home/casper/casper-node/utils/nctl/assets/net-1/users/user-1/secret_key.pem&quot; &gt; your/path/secret_key.pem  RustTypeScript To interact with the contract, we use the livenet backend. It allows to write the code in the same manner as the test code, but it interacts with the live network (a local node in our case). Cargo.toml [package] name = &quot;odra-examples&quot; version = &quot;2.2.0&quot; edition = &quot;2021&quot; [dependencies] odra = { path = &quot;../odra&quot;, default-features = false } ... # other dependencies odra-casper-livenet-env = { version = &quot;2.2.0&quot;, optional = true } ... # other sections [features] default = [] livenet = [&quot;odra-casper-livenet-env&quot;] ... # other sections [[bin]] name = &quot;tlw_on_livenet&quot; path = &quot;bin/tlw_on_livenet.rs&quot; required-features = [&quot;livenet&quot;] test = false ... # other sections examples/bin/tlw_on_livenet.rs //! Deploys an [odra_examples::contracts::tlw::TimeLockWallet] contract, then deposits and withdraw some CSPRs. use odra::casper_types::{AsymmetricType, PublicKey, U512}; use odra::host::{Deployer, HostRef}; use odra::prelude::*; use odra_examples::contracts::tlw::{TimeLockWallet, TimeLockWalletInitArgs}; const DEPOSIT: u64 = 100; const WITHDRAWAL: u64 = 99; const GAS: u64 = 20u64.pow(9); fn main() { let env = odra_casper_livenet_env::env(); let caller = env.get_account(0); env.set_caller(caller); env.set_gas(GAS); let mut contract = TimeLockWallet::deploy( &amp;env, TimeLockWalletInitArgs { lock_duration: 60 * 60 } ); // Send 100 CSPRs to the contract. contract .with_tokens(U512::from(DEPOSIT)) .deposit(); println!(&quot;Caller's balance: {:?}&quot;, contract.get_balance(&amp;caller)); // Withdraw 99 CSPRs from the contract. contract.withdraw(&amp;U512::from(WITHDRAWAL)); println!(&quot;Remaining balance: {:?}&quot;, contract.get_balance(&amp;caller)); } To run the code, execute the following command: ODRA_CASPER_LIVENET_SECRET_KEY_PATH=path/to/secret_key.pem \\ ODRA_CASPER_LIVENET_NODE_ADDRESS=[NODE_ADDRESS] \\ ODRA_CASPER_LIVENET_CHAIN_NAME=casper-test \\ ODRA_CASPER_LIVENET_EVENTS_URL=[EVENTS_STREAM_ADDRESS] \\ cargo run --bin tlw_on_livenet --features=livenet Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.09s Running `../target/debug/tlw_on_livenet` 💁 INFO : Found wasm under &quot;/Users/kpob/workspace/odra/examples/wasm/TimeLockWallet.wasm&quot;. 💁 INFO : Deploying &quot;TimeLockWallet&quot;. 🙄 WAIT : Waiting 10 for V1(TransactionV1Hash(5ab45ba29c9e7b9a91c4b5a5fbd2ba31735f03f99f94dce542d3584c8776ce8a)). 🙄 WAIT : Waiting 10 for V1(TransactionV1Hash(5ab45ba29c9e7b9a91c4b5a5fbd2ba31735f03f99f94dce542d3584c8776ce8a)). 💁 INFO : Transaction &quot;5ab45ba29c9e7b9a91c4b5a5fbd2ba31735f03f99f94dce542d3584c8776ce8a&quot; successfully executed. 🔗 LINK : https://testnet.cspr.live/transaction/5ab45ba29c9e7b9a91c4b5a5fbd2ba31735f03f99f94dce542d3584c8776ce8a 💁 INFO : Contract &quot;contract-package-fe69f4dd63445cda6cdc3b4c066760227208a752857950af6bda8a41600781ea&quot; deployed. 💁 INFO : Calling &quot;contract-package-fe69f4dd63445cda6cdc3b4c066760227208a752857950af6bda8a41600781ea&quot; with entrypoint &quot;deposit&quot; through proxy. 🙄 WAIT : Waiting 10 for V1(TransactionV1Hash(86d07f72dc9383f46144b5fdfd912ddf15c7be539cf2c34e43f1214244da25b3)). 💁 INFO : Transaction &quot;86d07f72dc9383f46144b5fdfd912ddf15c7be539cf2c34e43f1214244da25b3&quot; successfully executed. 🔗 LINK : https://testnet.cspr.live/transaction/86d07f72dc9383f46144b5fdfd912ddf15c7be539cf2c34e43f1214244da25b3 Owner's balance: 100 💁 INFO : Calling &quot;contract-package-fe69f4dd63445cda6cdc3b4c066760227208a752857950af6bda8a41600781ea&quot; directly with entrypoint &quot;withdraw&quot;. 🙄 WAIT : Waiting 10 for V1(TransactionV1Hash(cbdedd1d5f528754904feb23a0e2087a53ed6f6ed27298367a98bc2accc5792f)). 💁 INFO : Transaction &quot;cbdedd1d5f528754904feb23a0e2087a53ed6f6ed27298367a98bc2accc5792f&quot; successfully executed. 🔗 LINK : https://testnet.cspr.live/transaction/cbdedd1d5f528754904feb23a0e2087a53ed6f6ed27298367a98bc2accc5792f Remaining balance: 1 As observed, the contract was successfully deployed, and the Caller deposited tokens. Subsequently, the caller withdrew 99 CSPRs from the contract, leaving the contract's balance at 1 CSPR. The logs display deploy hashes, the contract's hash, and even indicate if the call was made through the proxy, providing a comprehensive overview of the on-chain activity. ","version":"2.3.1","tagName":"h2"},{"title":"Conclusion​","type":1,"pageTitle":"Using Proxy Caller","url":"/docs/tutorials/using-proxy-caller#conclusion","content":"In this tutorial, we learned how to use the proxy_caller wasm to make a payable function call. We deployed the TimeLockWallet contract, deposited tokens using the proxy_caller with attached CSPRs, and withdrew them. You got to try it out in both Rust and TypeScript, so you can choose whichever you prefer. Rust code seemed simpler, thanks to the Odra livenet backend making chain interactions easier to handle. ","version":"2.3.1","tagName":"h2"},{"title":"Odra for Solidity developers","type":0,"sectionRef":"#","url":"/docs/tutorials/odra-solidity","content":"","keywords":"","version":"2.3.1"},{"title":"Introduction​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/tutorials/odra-solidity#introduction","content":"Hi, stranger Solidity developer! If you are looking to expand your horizons into Rust-based smart contract development, you've come to the right place. Odra is a high-level framework designed to simplify the development of smart contracts for the Casper Network. This tutorial will guide you through the basics of transitioning from Solidity to Odra, highlighting key differences and providing practical examples. Before we delve into the details, we have great news for you. From the very beginning, we have been thinking of you. Our main goal was to design the framework in a way that flattens the learning curve, especially for Solidity developers. ","version":"2.3.1","tagName":"h2"},{"title":"Prerequisites​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/tutorials/odra-solidity#prerequisites","content":"To follow this guide, you should have: Knowledge of Solidity.Familiarity with Ethereum and smart contract concepts.Basic understanding of Rust, as Odra is based on it. ","version":"2.3.1","tagName":"h2"},{"title":"Hello World​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/tutorials/odra-solidity#hello-world","content":"Let's start with a simple &quot;Hello World&quot; contract in Odra. The following code snippet demonstrates a basic smart contract that stores a greeting message. OdraSolidity use odra::prelude::*; #[odra::module] pub struct HelloWorld { greet: Var&lt;String&gt;, } #[odra::module] impl HelloWorld { pub fn init(&amp;mut self, message: String) { self.greet.set(message); } pub fn get(&amp;self) -&gt; String { self.greet.get_or_default() } }  As you may have noticed, the Odra code is slightly more verbose than the Solidity code. To define a contract in Odra, you need to create a struct and implement a module for it, both annotated with the odra::module attribute. The struct contains the contract's state variables, while the module defines the contract's functions. In this example, the HelloWorld struct has a single state variable greet, which stores the greeting message. The module contains two functions: init to set the greeting message and get to retrieve it. Two key differences are: Odra does not generate getters for public state variables automatically, so you need to define them explicitly.To initialize values, you must do it in the init function, which is the contract constructor. You can't assign defaults outside the constructor. ","version":"2.3.1","tagName":"h2"},{"title":"Variable Storage and State Management​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/tutorials/odra-solidity#variable-storage-and-state-management","content":"","version":"2.3.1","tagName":"h2"},{"title":"Data Types​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/tutorials/odra-solidity#data-types","content":"OdraSolidity use core::str::FromStr; use odra::{casper_types::{bytesrepr::Bytes, U256}, prelude::*}; #[odra::module] pub struct Primitives { boo: Var&lt;bool&gt;, u: Var&lt;u8&gt;, // u8 is the smallest unsigned integer type u2: Var&lt;U256&gt;, // U256 is the biggest unsigned integer type i: Var&lt;i32&gt;, // i32 is the smallest signed integer type i2: Var&lt;i64&gt;, // i64 is the biggest signed integer type address: Var&lt;Address&gt;, bytes: Var&lt;Bytes&gt;, default_boo: Var&lt;bool&gt;, default_uint: Var&lt;U256&gt;, default_int: Var&lt;i64&gt;, default_addr: Var&lt;Address&gt;, } #[odra::module] impl Primitives { pub fn init(&amp;mut self) { self.boo.set(true); self.u.set(1); self.u2.set(U256::from(456)); self.i.set(-1); self.i2.set(456); self.address.set( Address::from_str( &quot;hash-d4b8fa492d55ac7a515c0c6043d72ba43c49cd120e7ba7eec8c0a330dedab3fb&quot;, ) .unwrap_or_revert(&amp;self.env()), ); self.bytes.set(Bytes::from(vec![0xb5])); let _min_int = U256::zero(); let _max_int = U256::MAX; } // For the types that have default values, we can use the get_or_default method pub fn get_default_boo(&amp;self) -&gt; bool { self.default_boo.get_or_default() } pub fn get_default_uint(&amp;self) -&gt; U256 { self.default_uint.get_or_default() } pub fn get_default_int(&amp;self) -&gt; i64 { self.default_int.get_or_default() } // Does not compile - Address does not have the default value pub fn get_default_addr(&amp;self) -&gt; Address { self.default_addr.get_or_default() } }  The range of integer types in Odra is slightly different from Solidity. Odra provides a wide range of integer types: u8, u16, u32, u64, U128, and U256 for unsigned integers, and i32 and i64 for signed integers. The Address type in Odra is used to represent account and contract addresses. In Odra, there is no default/zero value for the Address type; the workaround is to use Option&lt;Address&gt;. The Bytes type is used to store byte arrays. Values are stored in units called Named Keys and Dictionaries. Additionally, local variables are available within the entry points and can be used to perform necessary actions or computations within the scope of each entry point. ","version":"2.3.1","tagName":"h3"},{"title":"Constants and Immutability​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/tutorials/odra-solidity#constants-and-immutability","content":"OdraSolidity use odra::{casper_types::{account::AccountHash, U256}, prelude::*}; #[odra::module] pub struct Constants; #[odra::module] impl Constants { pub const MY_UINT: U256 = U256([123, 0, 0, 0]); pub const MY_ADDRESS: Address = Address::Account( AccountHash([0u8; 32]) ); }  In Odra, you can define constants using the const keyword. Constants are immutable and can be of any type, including custom types. In addition to constants, Solidity also supports the immutable keyword, which is used to set the value of a variable once, in the constructor. Further attempts to alter this value result in a compile error. Odra/Rust does not have an equivalent to Solidity's immutable keyword. ","version":"2.3.1","tagName":"h3"},{"title":"Variables​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/tutorials/odra-solidity#variables","content":"OdraSolidity use odra::{casper_types::U256, prelude::*}; #[odra::module] pub struct Variables { text: Var&lt;String&gt;, my_uint: Var&lt;U256&gt;, } #[odra::module] impl Variables { pub fn init(&amp;mut self) { self.text.set(&quot;Hello&quot;.to_string()); self.my_uint.set(U256::from(123)); } pub fn do_something(&amp;self) { // Local variables let i = 456; // Env variables let timestamp = self.env().get_block_time(); let sender = self.env().caller(); } }  In Solidity there are three types of variables: state variables, local variables, and global variables. State variables are stored on the blockchain and are accessible by all functions within the contract. Local variables are not stored on the blockchain and are only available within the function in which they are declared. Global variables provide information about the blockchain. Odra uses very similar concepts, but with some differences. In Odra, state variables are a part of a module definition, and local variables are available within the entry points and can be used to perform necessary actions or computations within the scope of each entry point. Global variables are accessed using an instance of ContractEnv retrieved using the env() function. ","version":"2.3.1","tagName":"h3"},{"title":"Arrays and Mappings​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/tutorials/odra-solidity#arrays-and-mappings","content":"OdraSolidity use odra::{casper_types::U256, prelude::*}; #[odra::module] pub struct MappingContract { my_map: Mapping&lt;Address, Option&lt;U256&gt;&gt; } #[odra::module] impl MappingContract { pub fn get(&amp;self, addr: Address) -&gt; U256 { // self.my_map.get(&amp;addr) would return Option&lt;Option&lt;U256&gt;&gt; // so we use get_or_default instead and unwrap the inner Option self.my_map.get_or_default(&amp;addr).unwrap_or_default() } pub fn set(&amp;mut self, addr: Address, i: U256) { self.my_map.set(&amp;addr, Some(i)); } pub fn remove(&amp;mut self, addr: Address) { self.my_map.set(&amp;addr, None); } } #[odra::module] pub struct NestedMapping { my_map: Mapping&lt;(Address, U256), Option&lt;bool&gt;&gt; } #[odra::module] impl NestedMapping { pub fn get(&amp;self, addr: Address, i: U256) -&gt; bool { self.my_map.get_or_default(&amp;(addr, i)).unwrap_or_default() } pub fn set(&amp;mut self, addr: Address, i: U256, boo: bool) { self.my_map.set(&amp;(addr, i), Some(boo)); } pub fn remove(&amp;mut self, addr: Address, i: U256) { self.my_map.set(&amp;(addr, i), None); } }  OdraSolidity use odra::prelude::*; #[odra::module] pub struct Array { // the size of the array must be known at compile time arr: Var&lt;[u8; 10]&gt;, vec: Var&lt;Vec&lt;u32&gt;&gt;, } #[odra::module] impl Array { pub fn init(&amp;mut self) { self.arr.set([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]); self.vec.set(vec![1, 2, 3, 4, 5]); } pub fn get_arr(&amp;self) -&gt; [u8; 10] { self.arr.get_or_default() } pub fn push_vec(&amp;mut self, value: u32) { let mut vec = self.vec.get_or_default(); vec.push(value); self.vec.set(vec); } pub fn pop_vec(&amp;mut self) { let mut vec = self.vec.get_or_default(); vec.pop(); self.vec.set(vec); } pub fn update_arr(&amp;mut self, index: u8, value: u8) { let mut arr = self.arr.get_or_default(); arr[index as usize] = value; self.arr.set(arr); } }  For storing a collection of data as a single unit, Odra uses the Vec type for dynamic arrays and fixed-size arrays, both wrapped with the Var container. As in Solidity, you must be aware that reading the entire array in one go can be expensive, so it's better to avoid it for large arrays. In many cases, you can use a Mapping or List instead of an array or vector to store data. ","version":"2.3.1","tagName":"h3"},{"title":"Custom types​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/tutorials/odra-solidity#custom-types","content":"OdraSolidity use odra::prelude::*; #[odra::odra_type] #[derive(Default)] pub enum Status { #[default] Pending, Shipped, Accepted, Rejected, Canceled, } #[odra::module] pub struct Enum { status: Var&lt;Status&gt;, } #[odra::module] impl Enum { pub fn get(&amp;self) -&gt; Status { self.status.get_or_default() } pub fn set(&amp;mut self, status: Status) { self.status.set(status); } pub fn cancel(&amp;mut self) { self.status.set(Status::Canceled); } pub fn reset(&amp;mut self) { self.status.set(Default::default()); } }  In Odra, custom types are defined using the #[odra::odra_type] attribute. The enum can have a default value specified using the #[default] attribute if derived from the Default trait. The enum can be used as a state variable in a contract, and its value can be set and retrieved using the set and get functions. The value cannot be deleted; however, it can be set using the Default::default() function. OdraSolidity use odra::prelude::*; #[odra::odra_type] pub struct Todo { text: String, completed: bool, } #[odra::module] pub struct Enum { // You could also use Var&lt;Vec&lt;Todo&gt;&gt; instead of List&lt;Todo&gt;, // but List is more efficient for large arrays, // it loads items lazily. todos: List&lt;Todo&gt;, } #[odra::module] impl Enum { pub fn create(&amp;mut self, text: String) { self.todos.push(Todo { text, completed: false, }); } pub fn update_text(&amp;mut self, index: u32, text: String) { if let Some(mut todo) = self.todos.get(index) { todo.text = text; self.todos.replace(index, todo); } } pub fn toggle_complete(&amp;mut self, index: u32) { if let Some(mut todo) = self.todos.get(index) { todo.completed = !todo.completed; self.todos.replace(index, todo); } } // Odra does not create getters by default pub fn get(&amp;self, index: u32) -&gt; Option&lt;Todo&gt; { self.todos.get(index) } }  Similarly to enums, custom structs are defined using the #[odra::odra_type] attribute. The struct can be used to define a list of items in a contract. The list can be created using the List type, which is more efficient for large arrays as it loads items lazily. ","version":"2.3.1","tagName":"h3"},{"title":"Data Location​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/tutorials/odra-solidity#data-location","content":"In Solidity, data location is an important concept that determines where the data is stored and how it can be accessed. The data location can be memory, storage, or calldata. In Odra, data location is not explicitly defined, but whenever interacting with storage primitives (e.g., Var, Mapping, List), the data is stored in the contract's storage. ","version":"2.3.1","tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/tutorials/odra-solidity#functions","content":"Odra contracts define their entry point and internal functions within the impl block. Here's an example of a transfer function: impl Erc20 { pub fn transfer(&amp;mut self, recipient: &amp;Address, amount: &amp;U256) { self.internal_transfer(&amp;self.env().caller(), recipient, amount); // Transfer logic goes here } fn internal_transfer(&amp;mut self, sender: &amp;Address, recipient: &amp;Address, amount: &amp;U256) { // Internal transfer logic goes here } }  Functions can modify contract state and emit events using the ContractEnv function. ","version":"2.3.1","tagName":"h2"},{"title":"View and Pure​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/tutorials/odra-solidity#view-and-pure","content":"OdraSolidity use odra::prelude::*; #[odra::module] pub struct ViewAndPure { x: Var&lt;u32&gt; } #[odra::module] impl ViewAndPure { pub fn add_to_x(&amp;self, y: u32) -&gt; u32 { self.x.get_or_default() + y } } pub fn add(i: u32, j: u32) -&gt; u32 { i + j }  In Odra, you don't need to specify view or pure functions explicitly. All functions are considered view functions by default, meaning they can read contract state but not modify it. To modify the state, the first parameter (called the receiver parameter) should be &amp;mut self. If you want to create a pure function that doesn't read or modify state, you can define it as a regular Rust function without any side effects. ","version":"2.3.1","tagName":"h3"},{"title":"Modifiers​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/tutorials/odra-solidity#modifiers","content":"OdraSolidity use odra::prelude::*; #[odra::module] pub struct FunctionModifier { x: Var&lt;u32&gt;, locked: Var&lt;bool&gt;, } #[odra::module] impl FunctionModifier { pub fn decrement(&amp;mut self, i: u32) { self.lock(); self.x.set(self.x.get_or_default() - i); if i &gt; 1 { self.decrement(i - 1); } self.unlock(); } #[inline] fn lock(&amp;mut self) { if self.locked.get_or_default() { self.env().revert(Error::NoReentrancy); } self.locked.set(true); } #[inline] fn unlock(&amp;mut self) { self.locked.set(false); } } #[odra::odra_error] pub enum Error { NoReentrancy = 1, }  In Odra, there is no direct equivalent to Solidity's function modifiers. Instead, you can define functions that perform certain actions before or after the main function logic. In the example above, the lock and unlock functions are called before and after the decrement function, respectively, but they must be called explicitly. As often as practicable, developers should inline functions by including the body of the function within their code using the #[inline] attribute. In the context of coding for Casper blockchain purposes, this reduces the overhead of executed Wasm and prevents unexpected errors due to exceeding resource tolerances. ","version":"2.3.1","tagName":"h3"},{"title":"Visibility​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/tutorials/odra-solidity#visibility","content":"Functions and state variables have to declare whether they are accessible by other contracts. Functions can be declared as: OdraSolidity `pub` inside `#[odra::module]` impl block - any contract/submodule and account can call. `pub` inside a regular impl block - any submodule can call. `default/no modifier/private` - only inside the contract that defines the function.  ","version":"2.3.1","tagName":"h3"},{"title":"Payable​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/tutorials/odra-solidity#payable","content":"OdraSolidity use odra::{casper_types::U512, prelude::*}; #[odra::module] pub struct Payable { owner: Var&lt;Address&gt;, } #[odra::module] impl Payable { pub fn init(&amp;mut self) { self.owner.set(self.env().caller()); } #[odra(payable)] pub fn deposit(&amp;self) { } pub fn not_payable(&amp;self) { } pub fn withdraw(&amp;self) { let amount = self.env().self_balance(); self.env().transfer_tokens(&amp;self.owner.get_or_revert_with(ExecutionError::UnwrapError), &amp;amount); } pub fn transfer(&amp;self, to: Address, amount: U512) { self.env().transfer_tokens(&amp;to, &amp;amount); } }  In Odra, you can define a function with the #[odra(payable)] attribute to indicate that the function can receive CSPRs. In Solidity, the payable keyword is used to define functions that can receive Ether. ","version":"2.3.1","tagName":"h3"},{"title":"Selectors​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/tutorials/odra-solidity#selectors","content":"In Solidity, when a function is called, the first 4 bytes of calldata specify which function to call. This is called a function selector. contract_addr.call( abi.encodeWithSignature(&quot;transfer(address,uint256)&quot;, address, 1234) )  Odra does not support such a mechanism. You must have access to the contract interface to call a function. ","version":"2.3.1","tagName":"h3"},{"title":"Events and Logging​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/tutorials/odra-solidity#events-and-logging","content":"OdraSolidity use odra::prelude::*; #[odra::event] pub struct Log { sender: Address, message: String, } #[odra::event] pub struct AnotherLog {} #[odra::module] struct Event; #[odra::module] impl Event { pub fn test(&amp;self) { let env = self.env(); env.emit_event(Log { sender: env.caller(), message: &quot;Hello World!&quot;.to_string(), }); env.emit_event(Log { sender: env.caller(), message: &quot;Hello Casper!&quot;.to_string(), }); env.emit_event(AnotherLog {}); } }  In Odra, events are regular structs defined using the #[odra::event] attribute. The event struct can contain multiple fields, which can be of any type (primitive or custom Odra type). To emit an event, use the env's emit_event() function, passing the event struct as an argument. note Events in Solidity are used to emit logs that off-chain services can capture. However, Casper does not support events natively. Odra mimics this feature. Read more about it in the Basics section. ","version":"2.3.1","tagName":"h2"},{"title":"Error Handling​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/tutorials/odra-solidity#error-handling","content":"OdraSolidity use odra::{prelude::*, casper_types::{U256, U512}}; #[odra::odra_error] pub enum CustomError { InsufficientBalance = 1, InputLowerThanTen = 2, } #[odra::module] pub struct Error; #[odra::module] impl Error { pub fn test_require(&amp;mut self, i: U256) { if i &lt;= 10.into() { self.env().revert(CustomError::InputLowerThanTen); } } pub fn execute_external_call(&amp;self, withdraw_amount: U512) { let balance = self.env().self_balance(); if balance &lt; withdraw_amount { self.env().revert(CustomError::InsufficientBalance); } } }  In Solidity, there are four ways to handle errors: require, revert, assert, and custom errors. In Odra, there is only one way to revert the execution of a function - by using the env().revert() function. The function takes an error type as an argument and stops the execution of the function. You define an error type using the #[odra::odra_error] attribute. On Casper, an error is only a number, so you can't pass a message with the error. ","version":"2.3.1","tagName":"h2"},{"title":"Composition vs. Inheritance​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/tutorials/odra-solidity#composition-vs-inheritance","content":"In Solidity, developers often use inheritance to reuse code and establish relationships between contracts. However, Odra and Rust follow a different paradigm known as composition. Instead of inheriting behavior from parent contracts, Odra encourages the composition of contracts by embedding one contract within another. Let's take a look at the difference between inheritance in Solidity and composition in Odra. OdraSolidity use odra::prelude::*; #[odra::module] pub struct A; #[odra::module] impl A { pub fn foo(&amp;self) -&gt; String { &quot;A&quot;.to_string() } } #[odra::module] pub struct B { a: SubModule&lt;A&gt; } #[odra::module] impl B { pub fn foo(&amp;self) -&gt; String { &quot;B&quot;.to_string() } } #[odra::module] pub struct C { a: SubModule&lt;A&gt; } #[odra::module] impl C { pub fn foo(&amp;self) -&gt; String { &quot;C&quot;.to_string() } } #[odra::module] pub struct D { b: SubModule&lt;B&gt;, c: SubModule&lt;C&gt; } #[odra::module] impl D { pub fn foo(&amp;self) -&gt; String { self.c.foo() } } #[odra::module] pub struct E { b: SubModule&lt;B&gt;, c: SubModule&lt;C&gt; } #[odra::module] impl E { pub fn foo(&amp;self) -&gt; String { self.b.foo() } } #[odra::module] pub struct F { a: SubModule&lt;A&gt;, b: SubModule&lt;B&gt;, } #[odra::module] impl F { pub fn foo(&amp;self) -&gt; String { self.a.foo() } }  Solidity supports both single and multiple inheritance. This means a contract can inherit from one or more contracts. Solidity uses a technique called &quot;C3 linearization&quot; to resolve the order in which base contracts are inherited in the case of multiple inheritance. This helps to ensure a consistent method resolution order. However, multiple inheritance can lead to complex code and potential issues, especially for inexperienced developers. In contrast, Rust does not have a direct equivalent to the inheritance model, but it achieves similar goals through composition. Each contract is defined as a struct, and contracts can be composed by embedding one struct within another. This approach provides a more flexible and modular way to reuse code and establish relationships between contracts. ","version":"2.3.1","tagName":"h2"},{"title":"Libraries and Utility​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/tutorials/odra-solidity#libraries-and-utility","content":"OdraSolidity use odra::{casper_types::U256, prelude::*}; mod math { use odra::casper_types::U256; pub fn sqrt(y: U256) -&gt; U256 { let mut z = y; if y &gt; 3.into() { let mut x = y / 2 + 1; while x &lt; z { z = x; x = (y / x + x) / 2; } } else if y != U256::zero() { z = U256::one(); } z } } #[odra::module] struct TestMath; #[odra::module] impl TestMath { pub fn test_square_root(&amp;self, x: U256) -&gt; U256 { math::sqrt(x) } } #[odra::odra_error] enum Error { EmptyArray = 100, } trait Removable { fn remove(&amp;mut self, index: usize); } impl Removable for Var&lt;Vec&lt;U256&gt;&gt; { fn remove(&amp;mut self, index: usize) { let env = self.env(); let mut vec = self.get_or_default(); if vec.is_empty() { env.revert(Error::EmptyArray); } vec[index] = vec.pop().unwrap_or_revert(&amp;env); self.set(vec); } } #[odra::module] struct TestArray { arr: Var&lt;Vec&lt;U256&gt;&gt;, } #[odra::module] impl TestArray { pub fn test_array_remove(&amp;mut self) { let mut arr = self.arr.get_or_default(); for i in 0..3 { arr.push(i.into()); } self.arr.set(arr); self.arr.remove(1); let arr = self.arr.get_or_default(); assert_eq!(arr.len(), 2); assert_eq!(arr[0], 0.into()); assert_eq!(arr[1], 2.into()); } }  In Solidity, libraries are similar to contracts but can't declare any state variables and can't receive Ether. In the sample code above, the Math library contains a square root function, while the Array library provides a function to remove an element from an array. Both libraries are consumed in different ways: the TestMath contract calls the sqrt function directly, while the TestArray contract uses the using keyword, which extends the type uint256[] by adding the remove function. In Odra, you use language-level features: modules and traits. The mod keyword defines a module, which is similar to a library in Solidity. Modules can contain functions, types, and other items that can be reused across multiple contracts. Traits are similar to interfaces in other programming languages, defining a set of functions that a type must implement. Implementing the Removable trait for the Var&lt;Vec&lt;U256&gt;&gt; type allows the remove function to be called on a variable that stores a vector of U256 values. ","version":"2.3.1","tagName":"h2"},{"title":"Fallback and Receive Functions​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/tutorials/odra-solidity#fallback-and-receive-functions","content":"In Solidity, a contract receiving Ether must implement a receive() and/or fallback() function. The receive() function is called when Ether is sent to the contract with no data, while the fallback() function is called when the contract receives Ether with data or when a function that does not exist is called. Odra does not have a direct equivalent to the receive() and fallback() functions. Instead, you can define a function with the #[odra(payable)] attribute to indicate that the function can receive CSPRs. ","version":"2.3.1","tagName":"h2"},{"title":"Miscellaneous​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/tutorials/odra-solidity#miscellaneous","content":"","version":"2.3.1","tagName":"h2"},{"title":"Hashing​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/tutorials/odra-solidity#hashing","content":"OdraSolidity use odra::{casper_types::{bytesrepr::ToBytes, U256}, prelude::*}; #[odra::module] pub struct HashFunction; #[odra::module] impl HashFunction { pub fn hash(&amp;self, text: String, num: U256, addr: Address) -&gt; [u8; 32] { let env = self.env(); let mut data = Vec::new(); data.extend(text.to_bytes().unwrap_or_revert(&amp;env)); data.extend(num.to_bytes().unwrap_or_revert(&amp;env)); data.extend(addr.to_bytes().unwrap_or_revert(&amp;env)); env.hash(data) } } #[odra::module] pub struct GuessTheMagicWord { answer: Var&lt;[u8; 32]&gt;, } #[odra::module] impl GuessTheMagicWord { /// Initializes the contract with the magic word hash. pub fn init(&amp;mut self) { self.answer.set([ 0x86, 0x67, 0x15, 0xbb, 0x0b, 0x96, 0xf1, 0x06, 0xe0, 0x68, 0x07, 0x89, 0x22, 0x84, 0x42, 0x81, 0x19, 0x6b, 0x1e, 0x61, 0x45, 0x50, 0xa5, 0x70, 0x4a, 0xb0, 0xa7, 0x55, 0xbe, 0xd7, 0x56, 0x08, ]); } /// Checks if the `word` is the magic word. pub fn guess(&amp;self, word: String) -&gt; bool { let env = self.env(); let hash = env.hash(word.to_bytes().unwrap_or_revert(&amp;env)); hash == self.answer.get_or_default() } }  The key difference between the two is that in Solidity, the keccak256 function is used to hash data, while in Odra, the env.hash() function is used, which implements the blake2b algorithm. Both functions take a byte array as input and return a 32-byte hash. ","version":"2.3.1","tagName":"h3"},{"title":"Try-catch​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/tutorials/odra-solidity#try-catch","content":"OdraSolidity use odra::prelude::*; #[odra::module] pub struct Example { other_contract: External&lt;OtherContractContractRef&gt;, } #[odra::module] impl Example { pub fn init(&amp;mut self, other_contract: Address) { self.other_contract.set(other_contract); } pub fn execute_external_call(&amp;self) { let result = self.other_contract.some_function(); match result { Ok(success) =&gt; { // Code to execute if the external call was successful } Err(reason) =&gt; { // Code to execute if the external call failed } } } } #[odra::module] pub struct OtherContract; #[odra::module] impl OtherContract { pub fn some_function(&amp;self) -&gt; Result&lt;bool, ()&gt; { Ok(true) } }  In Solidity, try/catch is a feature that allows developers to handle exceptions and errors more gracefully. The try/catch statement allows developers to catch and handle exceptions that occur during external function calls and contract creation. In Odra, there is no direct equivalent to the try/catch statement in Solidity. However, you can use the Result type to handle errors in a similar way. The Result type is an enum that represents either success (Ok) or failure (Err). You can use the match statement to handle the Result type and execute different code based on the result. However, if an unexpected error occurs on the way, the whole transaction reverts. ","version":"2.3.1","tagName":"h3"},{"title":"Conclusion​","type":1,"pageTitle":"Odra for Solidity developers","url":"/docs/tutorials/odra-solidity#conclusion","content":"Congratulations! You've now learned the main differences in writing smart contracts with the Odra Framework. By understanding the structure, initialization, error handling, and the composition pattern in Odra, you can effectively transition from Solidity to Odra for Casper blockchain development. Experiment with the provided code samples, explore more advanced features, and unleash the full potential of the Odra Framework. Read more about the Odra Framework in the Basics and Advanced sections. Learn by example with our Tutorial series, you will find there a contract you likely familiar with - the Erc20 standard implementation. If you have any further questions or need clarification on specific topics, feel free to join our Discord! ","version":"2.3.1","tagName":"h2"}],"options":{"excludeRoutes":["docs/0.2.0/**/*","docs/0.3.0/**/*","docs/0.3.1/**/*","docs/0.4.0/**/*","docs/0.5.0/**/*","docs/0.6.0/**/*","docs/0.7.0/**/*","docs/0.8.0/**/*","docs/0.9.0/**/*","docs/0.9.1/**/*"],"id":"default"}}